{"path":"COMDIS/bibliografía/BItacoras.pdf","text":"BITÁCORAS COMPUTACIÓN DISTRIBUÍDA 2021-2022 3º curso – 1º cuadrimestre Os seguintes apuntamentos foron recollidos en forma de bitácoras durante cada clase do curso polas seguintes persoas: Adriana Aurora Rodríguez Oreiro, Adrián Vidal Lorenzo, Andrea Solla Alfonsín, Diana Mascareñas Sande, Elena Segade Martínez, Hugo Vázquez Docampo, Javier Beiro Piñón, Manuel Cid Domínguez, Martín Campos Zamora, Nerea Freiría Alonso, Nicolás Vilela Pérez, Pablo Gil Pérez, Pablo Martínez González, Roberto de la Iglesia, Teresa Gutiérrez Blanco Non son apuntamentos recollidos de forma 100% formal e pode haber erros nalgúns datos ou fallos de formato. A pesar disto, pensamos que poden ser de gran axuda para os vindeiros cursos :) Grao en Enxeñaría Informática 3º curso – 1º cuadrimestre Computación Distribuída 08-09-2021 Pablo Gil Pérez, Adrián Vidal Lorenzo, Nicolás Vilela Pérez Clase 01 Temas traballados: 0. Presentación da materia 1. Paradigmas da computación distribuída 1. Presentación da materia 2 Índice 1. Presentación da materia ........................................................................................................... 3 a) Titorías ............................................................................................................................... 3 b) Índice de contidos ............................................................................................................. 3 c) Avaliación .......................................................................................................................... 3 d) Plan de continxencia ......................................................................................................... 4 e) Bibliografía ........................................................................................................................ 4 2. Paradigmas da computación distribuída ................................................................................... 5 a) Paradigmas para aplicacións distribuídas ......................................................................... 5 b) Abstraccións ...................................................................................................................... 5 c) O paradigma do envío de mensaxes ................................................................................. 6 d) Paradigma cliente-servidor ............................................................................................... 7 e) Arquitectura de igual a igual (peer-to-peer) ..................................................................... 7 f) Paradigma do sistema de mensaxes ................................................................................. 9 1. Presentación da materia 3 1. Presentación da materia a) Titorías Existe un horario oficial de titorías: - Luns de 16:00 a 18:00 - Martes e xoves de 9:00 a 11:00 Tamén se indica que non habería problema en ter titorías fóra do horario de titorías sempre que o profesor estea dispoñible. As titorías terían lugar no despacho D109 do CiTIUS, mais destácase que preferiblemente sexan online a través de MS Teams con cita previa. b) Índice de contidos - Paradigmas de computación distribuída - O modelo de paso de mensaxes - O modelo cliente/servidor - Aplicacións colaborativas - Obxectos distribuídos - Arquitecturas baseadas en pares - Arquitecturas orientadas a mensaxes - Sistemas multiaxente - Servizos de rede - Espazos de obxectos c) Avaliación • Prácticas: A asistencia e realización das prácticas é un requisito obrigatorio. (Di que non pasa lista normalmente). Hai cuestións que se tratarán exclusivamente en clase de prácticas e non nas de teoría, polo que se recomenda a asistencia. Para a corrección das prácticas, o profesor fará na clase unha serie de preguntas sobre ela e haberá que respondelas (estilo CoGa). Hai que aprobar todas as prácticas obrigatorias para aprobar a materia. • Prácticas voluntarias: Non son voluntarias porque hai que facelas perfectas para chegar ó 10. • Teoría: Farase un exame de teoría ó final do cuadrimestre. • Nota final: Calcúlase como a media xeométrica da nota de prácticas e da de teoría. Se algunha está suspensa, a nota final é a nota mínima entre prácticas e teoría. • Non presentado: Para que a cualificación sexa de non presentado, o alumno non pode presentarse ó exame final nin presentar máis do 25% das prácticas. • Recuperación: Se se suspende a primeira oportunidade, poderanse volver a presentar as prácticas e tamén volver a presentarse ó exame de teoría. A cualificación que se asumirá é a da última avaliación nos dous casos. • Repetidores: Non se gardan prácticas nin teoría dun ano para outro. Comézase de 0. 1. Presentación da materia 4 d) Plan de continxencia • En caso de escenario 2: Expositivas a través de MS Teams/vídeos gravados. Interactivas presenciais e exame final presencial. • En caso de escenario 3: Expositivas e interactivas a través de MS Teams/vídeos gravados. Non habería exame final, se non unha serie de traballos sobre a parte teórica da materia que puntúan un 25% da nota final. O 75% restante sería o resultado das notas de prácticas. e) Bibliografía [Libro principal da materia] M.L. Liu. “Computación distribuida: fundamentos y aplicaciones”. Addison Wesley 2004. ISBN 84-7829-066-4. George Coulouris, Jean Dollimore y Tim Kindberg. \"Sistemas Distribuidos: conceptos y diseño\". 3ª edición. Addisson Wesley 2001. ISBN 84-7829-049-4 Andrew S. Tanenbaum y Maarten van Steen. \"Distributed systems: principles and paradigms\". Prentice-Hall 2002. ISBN 0-13-088893-1 W. Richard Stevens. \"Unix Network Programming. Volumen 1: Networking APIs - Sockets and XTI\". Prentice-Hall 1997. ISBN 013490012X. W. Richard Stevens. \"Unix Network Programming. Volumen 2: Interprocess Communications\". Prentice-Hall 1998. ISBN 0130810819. Cay S. Horstmann y Gary Cornell. \"Core Java. Volumen 2: Advanced Features\". Prentice-Hall 1999. ISBN 0130819344. Elliotte Rusty Harold. “Java Network Programming”. 3ª edición. O'Reilly 2004. ISBN 0-596- 00721-3. Levent Erdogan. “Java Message Service (JMS) for J2EE”. Que 2002. ISBN 0-7357-1255-7. David Chappell, Richard Monson-Haefel. “Java Message Service”. O'Reilly 2000. ISBN 0596000685. Eric Freeman, Susanne Hupfer, Ken Arnold. “JavaSpaces: Principles, paterns and practice”. Prentice-Hall Java Series 1999. ISBN 9780201309553. Keith Edwards. “Core Jini”. Prentice-Hall Java Series 2000. ISBN 0130894087. Fabio Bellifemine, Giovanni Caire, Dominic Greenwood. “Developing multi-agent systems with JADE”. Wiley series in agent technology. ISBN 978-0-470-05747-6. Link: https://drive.google.com/drive/folders/1adVncMxVL8qXV5J_IsMOdH5-B3nkkB9O 2. Paradigmas da computación distribuída 5 2. Paradigmas da computación distribuída a) Paradigmas para aplicacións distribuídas Paradigma significa “patrón, exemplo, modelo”, e é que estes consisten na base dunha materia mediante a que se clasifican todos os elementos desta. En computación é unha simplificación de como funciona un determinado software. As características que distinguen unha aplicación distribuída dunha convencional son as seguintes: - Comunicación entre procesos: unha aplicación distribuída necesita a participación de dúas ou máis entidades independentes (procesos) que teñan a capacidade de intercambiar información. - Sincronización de eventos: nunha aplicación distribuída, o envío e recepción de datos entre os distintos participantes deben estar sincronizado. Unha comunicación é efectiva cando un proceso está emitindo e outro recibindo, ademais de ter que facerse nunha determinada orde (xeralmente o proceso que recibe debe activarse antes). b) Abstraccións A abstracción é un dos conceptos máis fundamentais da computación e ten que ver con esconder os detalles. En Enxeñaría do software, a abstracción conséguese mediante ferramentas que permitan construír software sen necesidade de que o programador coñeza todos os detalles da complexidade do sistema. - Middleware: Módulo/capa software que proporciona abstracción. A nivel de distintos paradigmas de computación, atopamos diferentes niveis de abstracción. Van dende o máis baixo nivel ata chegar o espazo de obxectos, que posiblemente sexa o paradigma de maior alto nivel de abstracción. Cando se traballa con un middleware estase traballando nun dos distintos niveis. Por exemplo, traballando coa API de sockets, estase traballando o nivel de paso de mensaxes. Pódense encadear distintas capas de middleware, como pode ser o API de sockets que proporciona unha determinada abstracción e sobre este desenvolver outro middleware que aumente máis o nivel de abstracción, como pode ser a chamada de a servizos remotos. 2. Paradigmas da computación distribuída 6 c) O paradigma do envío de mensaxes Proporciona o nivel de abstracción máis baixo. Trátase do paradigma máis importante para a construción de aplicacións distribuídas. • Un proceso envía unha mensaxe que representa unha petición. • A mensaxe é entregada o receptor que procesa a petición e envía unha mensaxe de resposta. • Como consecuencia, a resposta pode disparar novas peticións que poden levar a novas respostas. No seguinte esquema vese unha representación do envío de mensaxes entre dous procesos (A e B). En primeiro lugar o proceso A comeza o diálogo enviando un paquete de datos o proceso B, este último responde co envío doutro paquete de datos e así sucesivamente. Para a implementación do paradigma de envío de mensaxes as operacións básicas necesarias para dar soporte son “envía” e “recibe”. Se se trata dunha comunicación orientada a conexión, tamén son necesarias as operacións “conecta” e “desconecta”. Para este tipo de comunicación necesitase realizar unha apertura dun canal de comunicación (operación “conecta”) no cal se especifica quen é o destinatario. Neste caso, cando se envía e comeza a comunicación xa non é necesario especificar o destinatario porque a canle de comunicación xa está aberta, a diferenza do método non orientado a conexión que habería que facelo de todas formas en cada envío. Con este modelo de abstracción, os procesos realizan operacións de entrada/saída entre eles de forma similar a como se realizaría con un arquivo. As operacións de entrada/saída encapsulan os detalles da comunicación de rede a nivel de sistema operativo. Descritor: Número identificativo en Linux que representa unha estrutura á que se poden enviar bytes de información ou da que pode lelos. Nunha API de sockets, un socket non é máis que un descritor a nivel de sistema operativo UNIX. Un descritor permite acceder tanto a un socket como a un arquivo. As mesmas operacións utilizadas para os descritores pódense utilizar para a xestión dun canal de comunicación ou do envío de datos dun arquivo. 2. Paradigmas da computación distribuída 7 d) Paradigma cliente-servidor Segue sendo o paradigma do envío de mensaxes pero cunha diferencia: no paradigma do pase de mensaxes non se especifica a orde na cal se vai establecer a comunicación e, polo tanto, non temos resolta a sincronización de eventos, a cal é unha característica chave das aplicacións distribuídas. Este paradigma asigna roles asimétricos aos dous procesos que colaboran: - Proceso servidor: xoga o papel de provedor do servizo, esperando de forma pasiva a chegada de peticións. Está en estado de recepción. - Proceso cliente: envía peticións específicas ao servidor, esperando a súa resposta. O modelo cliente-servidor proporciona unha abstracción eficiente para a provisión de servicios de rede. As operacións requiridas polo servidor son “esperar” e “aceptar peticións” e, polo cliente, “emitir peticións” e “aceptar respostas”. Ao asignar roles asimétricos, a sincronización de eventos simplifícase xa que o servidor espera peticións e o cliente envía respostas. Moitos servicios de Internet son aplicacións cliente-servidor: HTTP, FTP, DNS, finger, gopher, etc. Hai que distinguir entre o paradigma e o protocolo. O paradigma é como iniciamos o diálogo (Cliente inicia e servidor espera). Unha vez iniciado o diálogo pode haber multitude de intercambios de información, o cal compón o protocolo, que describe como se intercambian os distintos paquetes de información en cada momento concreto. Os protocolos poden ser públicos ou privados. Un lugar para atopar información sobre distintos protocolos son os Request for Comments. Estes son documentos ASCII que describen protocolos, métodos, programas... e) Arquitectura de igual a igual (peer-to-peer) É unha arquitectura onde se intercambian de forma directa recursos e servizos entre ordenadores. Entre estes servizos e recursos compartidos inclúese o intercambio de información, ciclos de procesamento, almacenamento, etc. 2. Paradigmas da computación distribuída 8 Neste tipo de arquitecturas, os ordenadores que tradicionalmente se utilizaban como clientes comunícanse de forma directa entre eles e poden actuar o mesmo tempo como clientes e servidores en función de cal é o rol máis eficiente para a rede. Tamén poden actual como routers, de forma que, calquera nodo dunha arquitectura peer-to-peer pode actuar como cliente (facer unha petición), como servidor (resolver unha petición) ou como routers (transmitir a petición dun cliente a un terceiro). No paradigma peer-to-peer, os procesos participantes xogan roles iguais, con capacidades e responsabilidades equivalentes. Cada participante pode enviar unha petición a outro participante e recibir unha resposta. No seguinte esquema, obsérvase en primeiro lugar que o proceso 1 actúa como o servidor e o proceso 2 actúa como cliente. Cando o proceso dous envía a súa petición, o proceso 1 envía a resolución a petición. A continuación, cambian os roles, pasando a ser o proceso 1 o que actúa como cliente e o proceso 2 o que actúa como servidor. Non é viable a construción de un nodo dentro dunha arquitectura peer-to-peer se ese nodo non ten polo menos dous fíos de execución. Un deles xoga o rol de servidor e espera peticións e o outro xoga o rol de cliente e envíaas. O paradigma cliente-servidor é ideal para un servizo de rede centralizado, onde se ten un servizo único o cal acceden múltiples clientes. Por outro lado, o modelo peer-to-peer é máis apropiado para aplicacións menos centralizadas tales como a mensaxería instantánea, a transferencia de arquivos de igual a igual, etc. Existe a posibilidade dunha aplicación que use ambos modelos de computación. Un exemplo de aplicación que faga uso de ambos paradigmas é Napster.com, sendo esta unha das primeiras aplicacións comerciais peer-to-peer proporcionando acceso a arquivos de música. O funcionamento de Napster pódese explicar facendo uso do paradigma cliente-servidor e do paradigma peer-to-peer. Napster posuía un servidor central que coordinaba o resto dos nodos. O diálogo entre os nodos e o servidor era un diálogo cliente-servidor. Cando un cliente quería descargar un arquivo, realizaba unha consulta no servidor, o cal respondía co envío das direccións IP das máquinas que posuían ese arquivo. En ese instante, a comunicación pasa a ser de cliente a cliente (peer-to-peer). 2. Paradigmas da computación distribuída 9 f) Paradigma do sistema de mensaxes O sistema de mensaxes ou Message-Oriented-Middleware (MOM) é unha sofisticación do paradigma de paso de mensaxes. Este paradigma intenta resolver o problema de sincronización. Para a resolución deste problema introdúcese un terceiro que actuará como intermediario entre dous procesos independientes. En este caso será o servidor. O sistema de mensaxes actúa como un conmutador de mensaxes a través do cal os procesos intercambian mensaxes de forma asíncrona dunha maneira desacoplada. O sistema de mensaxes sempre se atopa a escoita, o emisor deposita a súa mensaxe no sistema de mensaxes, que a súa vez a deposita nunha cola de mensaxes asociada a cada receptor. Existen dous tipos de modelos de mensaxes: • O modelo Punto-a-Punto: Neste modelo, o sistema de mensaxes (servidor) reenvía a mensaxe do emisor a cola de mensaxes do receptor. Isto permite que o emisor se poida desacoplar do receptor. Este modelo proporciona un maior nivel de abstracción para operacións asíncronas que o proporcionado polo modelo de paso de mensaxes. Para conseguir o mesmo resultado, no paradigma de paso de mensaxes o programador tería que facer uso de threads ou procesos fillo. • Modelo publica/subscribe: Neste modelo, cada mensaxe ten asociado un evento específico. Unha aplicación pode subscribirse a ese evento, e cando un emisor envía unha mensaxe, o sistema de mensaxe distribúe a mensaxe a todos os receptores que están interesados. Este sistema proporciona unha abstracción moi forte para comunicacións multicast, e a comunicación lévase a cabo mediante as operacións “publish” e “subscribe”. Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 13-09-2021 Andrea Solla Alfonsín, Hugo Vázquez Docampo Clase 01 Temas trabajados: 1. Paradigmas de la computación distribuida 1. Sistema de mensajes o Message-Oriented Middleware 2 Índice 1. Sistema de mensajes o Message-Oriented Middleware ........................................................... 3 a) Modelo punto a punto ....................................................................................................... 3 b) Modelo Publica/Suscribe ................................................................................................... 3 c) Ejemplo .............................................................................................................................. 3 2. Remote Procedure Call (RPC) ..................................................................................................... 4 d) Diferencia con respecto a pase de mensajes ..................................................................... 4 3. Paradigma de Objetos Distribuidos ........................................................................................... 5 e) Remote Method Invocation (RMI) ..................................................................................... 5 f) Paradigma de los servicios de red...................................................................................... 5 g) Object request broker ........................................................................................................ 6 i. Corba .............................................................................................................................. 6 1. Sistema de mensajes o Message-Oriented Middleware 3 1. Sistema de mensajes o Message-Oriented Middleware Es un sistema que se interpone entre el emisor y el receptor. Es un proceso que está permanentemente escuchando posibles conexiones de emisores. Cuando un emisor se pone en contacto mandando un mensaje indica a quién va destinado el mensaje, entonces el sistema de mensajes deposita una copia de los datos recibidos en la cola correspondiente al receptor. Hay una cola por cada uno de los posibles receptores, cada uno de los cuales acudirá cuando lo considere oportuno a leer un mensaje u otro según el orden establecido. Con esto se consigue un completo desacoplamiento entre emisor y receptor. Es decir, el emisor no debe preocuparse de que haya un receptor activo en el momento del envío y el receptor no tiene que preocuparse de si el emisor le ha enviado o no un mensaje. El sistema de mensajes consta de dos submodelos: a) Modelo punto a punto Un módulo software receptor en una máquina concreta actúa como punto de interconexión entre emisor y receptor. Esto amplía enormemente a nivel de abstracción en el paradigma del pase de mensajes. b) Modelo Publica/Suscribe En este caso habrá suscriptores que se suscriban a un determinado evento. El emisor sería el creador de eventos. Para cada evento habrá una única cola de forma que cuando se detecta que se ha producido ese evento, el sistema de mensajes se pone en contacto con cada uno de los suscriptores normalmente de forma secuencia; es decir, uno a uno. c) Ejemplo Supongamos un sistema de documentación meteorológica que informa sobre la temperatura actual. Para recibir esa información se podrían usar múltiples opciones: • Una de ellas, pero no la más óptima es mediante un sondeo; acudir al servidor para conocer la información. • Otra forma consiste en tener en cuenta que la temperatura no cambia de forma muy frecuente. Así, en la parte del servidor podría establecerse un proceso que estuviese continuamente monitorizando el estado de un termómetro y, mientras la temperatura no cambie, no se produce ningún evento. Sin embargo, si se produce un cambio de temperatura, automáticamente se depositará un mensaje en el sistema de mensajes indicando la variación de temperatura. Los clientes, se suscribirán ante un determinado evento; en este caso el cambio de la temperatura. 2. Remote Procedure Call (RPC) 4 2. Remote Procedure Call (RPC) Es otro paradigma de la computación distribuida. Conforme las aplicaciones aumentan de complejidad, es deseable tener paradigmas que permitan programar software distribuido de manera similar a las aplicaciones que se ejecutan en un único procesador. EL modelo RPC se basa en invocar a métodos que residen en una máquina remota. Se le pasarán una serie de argumentos y el método que se va a ejecutar y se obtendrá una respuesta. d) Diferencia con respecto a pase de mensajes En el paradigma de pase de mensajes, a la hora de dialogar con otro proceso, se debe pensar a nivel de paquetes de datos que se intercambian con su cabecera y en cómo construirlo, leer la cabecera… Sin embargo, si existen muchos tipos distintos de paquetes a intercambiar, la cosa se complica porque en el switch de selección (hablando a nivel de programación) existirían muchísimas opciones y cometer un error ahí podría resultar terrible ya que analizar por que el receptor de un mensaje falla puede resultar muy complejo. En cambio, a nivel de llamada de procedimientos remotos no se piensa en la construcción de paquetes sino a que procedimiento se va a llamar ya que su nombre indica para que sirve y lo que va a continuación. Si se comete un error y se invoca a un método erróneo, el compilador resolverá el trabajo identificando que esa firma que se emplea es incorrecta. Existen dos procesos que buscan intercambiar información de la siguiente manera: Existe un intercambio de eventos implícito en el sentido de que no se construye el paquete de datos; simplemente se invoca al procedimiento pasando una lista de argumentos. RPC permite a los programadores construir aplicaciones de red usando construcciones similares a las utilizadas en la invocación local de métodos, proporcionando una abstracción de la comunicación entre procesos y su sincronización. Hay dos APIs de RPC fundamentales: • The Open Network Computing Remote Procedure Call, que ha evolucionado del API RPC de Sun Microsystems. (Es el más usado hoy en día). • The Open Group Distributed Computing Environment (DCE) RPC. Cualquiera de las dos utiliza una herramienta llamada rpcgen que permite transformar invocaciones remotas a llamadas a procedimientos locales pertenecientes al denominado Stub (proxy). Es decir, es lo que generará automáticamente código. 3. Paradigma de Objetos Distribuidos 5 En realidad el funcionamiento se basa en llamar a un procedimiento local el cual encapsula los datos. 3. Paradigma de Objetos Distribuidos La idea es que un objeto perteneciente a un conjunto de objetos pueda invocar un método de otro objeto que reside en una máquina remota. Implica un cambio sustancial con respecto a la programación orientada a objetos a la que estamos habituados. En general, un programa como los que solemos trabajar termina su ejecución cuando el método main termina. Sin embargo, cuando se aborda el paradigma de objetos distribuidos, existirán objetos servidores y objetos clientes. Una de las características de los servidores es que se mantendrá a la espera por los objetos clientes. Existirán en este paradigma un mínimo de dos hilos de ejecución (en una o varias maquinas), de forma que el objeto cliente invocara a un método de un objeto servidor para obtener un servicio, obtener un resultado y consumirlo. El paradigma de objetos distribuidos incluye: • Remote Method Invocation (RMI) • Network services • Object request broker • Object spaces e) Remote Method Invocation (RMI) Es el equivalente orientado a objetos de la invocación remota de métodos. En este modelo, un proceso invoca a métodos de un objeto que podrá residir en otra máquina. Al igual que con RPC, se pueden pasar argumentos en la invocación. f) Paradigma de los servicios de red En este paradigma, los proveedores de servicios se registran en servidores de directorio en una red. Un proceso que desea un servicio en particular contacta con el servidor de directorio en tiempo real y, si el servicio está disponible, obtendrá una referencia a dicho servicio. Usando dicha referencia el proceso interactúa con el servicio. Este paradigma es esencialmente una extensión del paradigma de la invocación remota de métodos pero, a diferencia del anterior, en este caso no es necesario tener conocimiento de la dirección IP, los objetos que proporcionan el servicio están registrados en un servicio global de directorio, permitiendo que sean localizados y accedidos por otros procesos en una red. La tecnología Jini es un ejemplo de este paradigma. 3. Paradigma de Objetos Distribuidos 6 g) Object request broker (ORB) Es parecido a los anteriores pero con una salvedad. Mientras en los anteriores hablábamos de implementaciones para lenguajes de programación concretos, en este caso se trata de un protocolo que especifica cómo tiene que intercambiarse la información para implementar un sistema de objetos distribuidos, de modo que cualquiera que se adhiera a este protocolo va a ser compatible. Lo que se busca con esto es solucionar el problema actual de la programación distribuída: la integracionabilidad. Esto significa que, si tenemos una aplicación desarrollada en un lenguaje determinado, esa aplicación pueda dialogar con aplicaciones desarrolladas en distintos lenguajes. Una aplicación envía una petición a un object request broker (ORB), que redirige dicha petición al objeto apropiado que proporciona el servicio deseado. Funciona como un middleware que permite a una aplicación acceder a múltiples objetos remotos (o locales), como un mediador entre objetos heterogéneos que permite la interacción entre objetos implementados utilizando diferentes APIs y/o ejecutándose en diferentes plataformas. i. CORBA Es una iniciativa de OMG (unión de múltiples empresas de software) que es un estándar (una serie de protocolos) que hacen que las aplicaciones sean más genéricas, es decir, que estén afectadas por menos restricciones. Ejemplos de herramientas que utilizan esta arquitectura: • MicroFocus Visibroker o https://www.microfocus.com/es-es/products/corba/visibroker/# • Java’s Interface Development Language (Java IDL) o http://docs.oracle.com/javase/7/docs/technotes/guides/idl/ • MicroFocus Orbix o https://www.microfocus.com/es-es/products/corba/orbix/ Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 20-09-2021 Pablo Martínez González, Roberto de la Iglesia Rodríguez Clase 3 Temas trabajados: 1. Paradigmas de la computación distribuida (continuación) 2. Tema 3: Objetos distribuidos 1. Paradigmas de la computación distribuida (continuación) 2 Índice 1. Paradigmas de la computación distribuida (continuación) ...................................................3 1.1 Espacio de Objetos ......................................................................................................3 1.2 Tecnologías basadas en Componentes .........................................................................3 1.3 Paradigma de Agentes Móviles ....................................................................................4 1.4 Paradigma de Aplicaciones Colaborativas .....................................................................4 2. Tema 3: Objetos Distribuidos ............................................................................................5 2.1 Paso de Mensajes frente a Objetos Distribuidos ............................................................5 2.2 Paradigma de Objetos distribuidos ...............................................................................5 Arquitectura de objetos distribuidos ..............................................................................6 1. Paradigmas de la computación distribuida (continuación) 3 1. Paradigmas de la computación distribuida (continuación) 1.1 Espacio de Objetos Consiste en un paradigma orientado a objetos más abstracto. En él, se asume la existencia de entidades lógicas, las cuales se denominan “espacios de objetos”. Los participantes de una aplicación convergen en un espacio de objetos común, funcionando de manera similar a lo que sería una zona de memoria compartida, pero en la red. El proveedor de servicios distribuye los objetos a modo de entradas en el espacio de objetos, y los procesos que pretenden usar dichos servicios se suscribe a dicho espacio, pudiendo acceder a las entradas y métodos de dichos servicios. El paradigma de espacio de objetos ofrece un espacio virtual entre los proveedores y los clientes de recursos de red. Lo que realiza este nivel de abstracción, es ocultar los detalles de los objetos, como la invocación remota de métodos, el ORB o los servicios de red. Un ejemplo de uso de este paradigma es JavaSpaces 1.2 Tecnologías basadas en Componentes También están basadas en paradigmas de la computación distribuida, debido a que un componente es un objeto encapsulado según un protocolo, el cual tiene una interfaz para comunicarse con el exterior que es común con otros objetos, que interaccionan unos con otros. Los servidores de aplicaciones son softwares con unos servicios por defecto, que tienen fines empresariales. Se trata de Middlewares que proporcionan el acceso a objetos y componentes. Estas tecnologías, suelen tener incluidos diversos servicios, así como bases de datos, sistemas de control y mantenimiento... 1. Paradigmas de la computación distribuida (continuación) 4 1.3 Paradigma de Agentes Móviles Un agente móvil se trata de un objeto o programa el cual es transportable. Se lanza un agente desde un ordenador en particular, el cual viaja de maquina en maquina siguiendo un itinerario. En cada parada el agente accede a los recursos y servicios necesarios y realiza las tareas necesarias. Este paradigma ofrece una abstracción que permite tener objetos o programas transportables, ya que, en lugar de intercambiar mensajes, los datos son transportados por el agente móvil a medida que viaja entre máquinas. 1.4 Paradigma de Aplicaciones Colaborativas En este modelo, cada participante participa en una sesión colaborativa como grupo. Cada proceso participante puede contribuir a la entrada de parte o la totalidad del grupo. Realizan esta acción utilizando dos métodos: - Multicasting: se envian datos a todos los nodos presentes en la red o a parte del grupo. - Pizarras virtuales: “zonas de memoria compartida” en la cual cada participante puede leer y escribir datos. 2. Tema 3: Objetos Distribuidos 5 2. Tema 3: Objetos Distribuidos 2.1 Paso de Mensajes frente a Objetos Distribuidos El paso de mensajes es el modelo más natural para la computación distribuida, ya que simula la comunicación humana. Se trata de un paradigma apropiado para servicios de red donde los procesos interactúan entre ellos a través del intercambio de mensajes. Sin embargo, la abstracción no cumple las necesidades de computación complejas, debido a problemas como el gran volumen de datos por mensaje o posibles errores de programación. Además, requiere que los participantes se encuentren fuertemente acoplados. Los procesos deben comunicarse directamente entre ellos, y si se pierde la comunicación, esta falla. El paradigma de paso de mensajes está orientado a datos, debido a que cada mensaje contiene datos con un formato mutuamente acordado y se interpreta como una petición o respuesta de acuerdo con el protocolo. Por otro lado, el paradigma de objetos distribuidos proporciona una mayor abstracción que el modelo de paso de mensajes, ya que está basado en objetos existentes sobre un sistema distribuido. Está basado en un lenguaje de programación orientado a objetos, como java, donde los objetos se utilizan para la representación de las entidades significativas de la aplicación. Cada objeto encapsula: - El estado (o datos de la entidad): los datos se encuentran en variables de instancia de cada objeto. - Las operaciones de la entidad, mediante las cuales se puede acceder o modificar el estado de la entidad. Existen dos tipos de objetos: Objetos locales Son objetos cuyos métodos solo se pueden invocar por un proceso local, es decir, un proceso que se ejecuta en el mismo computador en el que está el objeto. Objetos distribuidos Son aquellos en los que los métodos pueden invocarse por un proceso remoto. DE esta manera un proceso que se ejecuta en un computador conectado a través de una red puede invocar los métodos de un objeto de otro computador, también conectado. 2.2 Paradigma de Objetos distribuidos En este paradigma, los recursos se representan como objetos distribuidos. Al solicitar un servicio, un proceso invoca uno de sus métodos u operaciones, pasando los datos como parámetros al método. Este método se ejecuta en la maquina remota y la respuesta es enviada al proceso solicitante como un valor de salida. 2. Tema 3: Objetos Distribuidos 6 La principal diferencia entre el paradigma de paso de mensajes y el paradigma de objetos distribuidos consiste en que, el primero, está orientado a los datos, mientras que el de objetos distribuidos está orientado a acciones. Esto se debe a que hace hincapié en las operaciones, tratando los datos de forma secundaria. Arquitectura de objetos distribuidos En el camino lógico, que sería el que piensa el programador (representado en azul), el objeto cliente localizaría el objeto servidor mediante la referencia que le da el registro de objetos. Una vez encontrado se invocaría al método del cliente servidor. Sin embargo, el camino físico es distinto. El objeto cliente no invoca directamente al objeto servidor. Una vez obtenida la referencia, el objeto cliente invoca al proxy del cliente, el cual recibe la información y la pasa al runtime support, que encapsula la información creando paquetes de datos. A continuación, el soporte de red inyecta estos paquetes en la red los cuales son recibidos por el soporte de red del servidor. En el runtime support del servidor, se des encapsulan los paquetes de información y se pasan al proxy del servidor, que prepara la información para invocar al método del objeto servidor. Una vez obtenida una respuesta, esta realiza el mismo camino, pero en sentido contrario hasta llegar al objeto cliente. El proxy se podría decir que funciona como una copia local del cliente o del servidor. El programador se abstrae de la programación de los niveles inferiores al proxy, ya que se trata de un código autogenerado a partir de una serie de especificaciones. Cabe destacar que el objeto cliente tiene un método main, mientras que el objeto servidor no. El main del objeto servidor se encuentra en su proxy. Es un software que arranca la aplicación y se mantiene a la espera de recibir solicitudes de invocación de sus métodos. Este main, des encapsula la información e invoca al método correspondiente A un objeto distribuido proporcionado o exportado por un proceso se le denomina objeto servidor. Existe un registro de objetos el cual registra los distintos objetos distribuidos. Para acceder a un objeto distribuido, un proceso (el objeto cliente) busca en el registro de 2. Tema 3: Objetos Distribuidos 7 objetos para encontrar la referencia al objeto. Una vez encontrada, el objeto cliente la utiliza para realizar llamadas a los métodos del objeto remoto. El objeto cliente realiza una llamada directamente al método remoto. Sin embargo, el componente del software que se encarga de gestionar esta llamada es el proxy del cliente, que interactúa con el software de la máquina del cliente con el fin de proporcionar soporte en tiempo de ejecución para el sistema de objetos distribuidos. El runtime support (soporte en tiempo de ejecución) realiza la comunicación entre procesos necesaria para transmitir la llamada a la maquina remota, empaquetando los argumentos que se van a transmitir El proxy del servidor es el software que recibe la llamada a los componentes del objeto servidor. Este invoca al método local del objeto distribuido que se pretenda, pasándole los argumentos desempaquetados Para la implementación del paradigma de objetos distribuidos se han empleado distintas soluciones, entre las que destacan: - Java Remote Method Invocation (RMI) - Common Object Request Broker Arquitecture (CORBA) - Distributed COmponent Object Model (DCOM) - Herramientas y APIs para el Simple Object Access Protocol (SOAP) Sin embargo, la más sencilla de todas ellas es Java RMI Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Asignatura: Computación Distribuida 22-09-2021 Nerea Freiría Alonso, Adriana Aurora Rodríguez Oreiro Temas trabajados: Tema 3 1. Remote Procedure Call frente a Remote Method Invocation 2 Índice 1. Remote Procedure Call frente a Remote Method Invocation .................................................... 3 a) Remote Procedure Calls(RPC) .......................................................................................... 3 i. Llamada local ................................................................................................................ 4 ii. Llamada remota ............................................................................................................. 4 b) Java Remote Method Invocation ....................................................................................... 5 i. Arquitectura de Java RMI ............................................................................................. 5 ii. Registro de los objetos .................................................................................................. 6 iii. Interacción entre el stub y el skeleton ........................................................................... 6 iv. El API de Java RMI ...................................................................................................... 7 v. La interfaz remota ......................................................................................................... 7 vi. Ejemplo de interfaz remota Java ................................................................................... 7 vii. Software de la parte servidora ................................................................................... 8 viii. Implementación de la interfaz remota ....................................................................... 8 ix. Diagrama UML para la clase SomeImpl ..................................................................... 10 x. Generación del Stub y el Skeleton .............................................................................. 10 xi. El fichero stub para el objeto ....................................................................................... 11 xii. Servidor de objetos .................................................................................................. 11 1. Remote Procedure Call frente a Remote Method Invocation 3 1. Remote Procedure Call frente a Remote Method Invocation a) Remote Procedure Calls(RPC) El Remote Method Invocation (RMI) tiene su origen en el paradigma denominado Llamada a Procedimientos Remotos. En el modelo de la llamada a procedimientos remotos, un proceso realiza una llamada a procedimientos de otro proceso, pasándole los datos a través de argumentos. Cuando un proceso recibe una llamada, se ejecuta la acción codificada en el procedimiento. A continuación, se notifica la finalización de la llamada al proceso que invoca la llamada y, si existe un valor de retorno se le encía a este último proceso desde el proceso invocado. El programador tiene la sensación de lo siguiente: En realidad, lo que ocurre cuando se realiza una llamada a una función remota es lo representado en esta figura: 1. Remote Procedure Call frente a Remote Method Invocation 4 i. Llamada local En una llamada local, tenemos un procedimiento 1 que se ejecuta secuencialmente, llegado a un punto, a nivel de lenguaje ensamblador, existe una llamada a una subrutina. Esta lo que hace es depositar el contador del programa en la pila del sistema y carga un nuevo valor. Como consecuencia de eso, el flujo de ejecución salta a un procedimiento que está almacenado en esa nueva dirección y se ejecutará nuevamente el programa de forma secuencial. Cuando el procedimiento termina, envía un valor de retorno de subrutina, que lo que hace es extraer el valor dato almacenado en la pila del sistema y lo carga en el contador del programa de forma que se recupera la dirección anterior. ii. Llamada remota En una llamada remota lo que ocurre es que el procedimiento 1, de forma secuencial ejecuta las funciones hasta la llamada a la subrutina. En este caso el código de la subrutina estará guardado en el proxi. En esa subrutina se realizan una serie de acciones en las que se encuentra encapsular los elementos de entrada según un determinado protocolo y transmitirlo a través de la red. En el otro extremo hay otro procedimiento, procedimiento 2, que tiene un proxi que permanentemente está escuchando, dentro del proxi hay una rutina en la que se está ejecutando el código. En el momento en el que se recibe un mensaje del procedimiento 1 se desbloquea (está bloqueado, esperando una lectura de un dato). Después se desempaqueta la información que se ha recibido á través de la red y se hace la llamada propiamente dicha a la subrutina. Cuando termina el procedimiento devuelve los datos, el proxi del servidor encapsula la información, la envía a través de la red, la recibe el proxi del cliente el cual desempaqueta el dato. Desde su introducción a principios de los años 80, el modelo RPC se ha utilizado ampliamente en las aplicaciones de red y existen dos grandes APIs que lo implementan: - El API Open Network Computing Remote Procedure Call: es una evolución del API de RPC que desarrolló originalmente Sun Microsystms a principios de los años 80. - EL API Open Group Distributed Computing Environment (DCE) RPC, este es el menos utilizados. 1. Remote Procedure Call frente a Remote Method Invocation 5 En ambos casos existe una herramienta (rpcgen), esta hace que en base a unas especificaciones que declaran como es nuestro servidor, como es el procedimiento que voy a invocar de forma remota, va a generar de forma automática los proxis, tanto del cliente como del servidor. En el caso del cliente, el código contiene una función que se llama igual que la función que se va a llamar de forma remota, en el caso del servidor el código que genera contiene el método main, porque lo único que se programa en el servidor es el proceso que va a ser invocado. b) Java Remote Method Invocation Java RMI es una implementación orientada a objetos del modelo RPC. Se trata de una API exclusiva para programas Java. En RMI, un servidor de objetos exporta un objeto remoto y lo registra en un servicio de directorio. El objeto proporciona métodos remotos, que pueden invocar los programas cliente. En java RMI lo que vamos a tener es, lo que denominamos un servidor de objetos, esto es un código que va a instanciar el objeto servidor, el objeto que tiene los métodos que son accesibles de forma remota, y posteriormente lo va a publicar en un directorio para que sea accesible; de tal forma que el cliente cuando quiera hacer uso del objeto servidor deberá acudir a ese directorio y obtener la referencia remota. Sintácticamente tenemos lo siguiente: - Un objeto remoto se declara como una interfaz remota: es similar a una interfaz en java, pero con algunas diferencias. - El objeto servidor implementa la interfaz remota - Un objeto cliente accede al objeto mediante la invocación remota de sus métodos utilizando una sintaxis similar a las invocaciones de los métodos locales. i. Arquitectura de Java RMI 1. Remote Procedure Call frente a Remote Method Invocation 6 Como se puede ver es muy similar a la arquitectura general de un objeto distribuido. Aquí tenemos un objeto cliente y un objeto servidor, además tenemos un camino lógico (flechas azules) y un camino físico (flechas rojas). En lugar de hablar de proxis se llaman stub (a proxi de cliente) y skeleton(a proxi de servidor). El funcionamiento es similar al explicado para RPC. ii. Registro de los objetos - El API de RMI hace posible el uso de diferentes servicios de directorios para registrar un objeto distribuido. Uno de estos servicios de directorios es la interfaz e nombrado y directorios de Java (JNDI), que es más general que el registro RMI, en el sentido de que lo pueden utilizar aplicaciones que no usan el API RMI. - Nosotros usuraremos un servicio de directorio llamado registro RMI, rmiregistry, proporcionado por el Java Software Development Kit (SDK). El registro RMI es un servicio cuyo servidor, cuando está activo, se ejecuta en la máquina del servidor del objeto. Por convención utiliza el puerto TCP 1099 por defecto. Nosotros usaremos el rmiregistry por que es el más sencillo de utilizar. No tenemos que instalar nada y se trata de un demonio que cuando lo activamos esta permanentemente escuchando un puerto. Este registro (en el que está escuchando de forma permanente) tiene que estar ubicado en la máquina en la que se encuentra el objeto servidor y el servidor de objetos. iii. Interacción entre el stub y el skeleton Un diagrama de eventos temporal describiendo la interacción entre el stub y el skeleton: Esto es entre el proxi del cliente y entre el proxi del servidor. Asumimos que el tiempo transcurre hacia abajo, entonces lo que ocurre es que cuando se produce la llamada el stub encapsula la información de los argumentos, se transmite al servidor y en el servidor se desencapsula la información. Acto seguido se invoca al método remoto, cuando este concluye 1. Remote Procedure Call frente a Remote Method Invocation 7 devuelve un resultado. Este resultado se encapsula por el skeleton, se transmite a través de la red y se desencapsula cuando llega al stub. iv. El API de Java RMI A la hora de desarrollar una aplicación en Java, nosotros tenemos que hacer una serie de cosas: 1. Construir nuestra interfaz remota: declara como va a ser nuestro objeto servidor, qué métodos son accesibles, como se llaman, número de argumentos de entrada, de salida…. 2. Desarrollo del software en la parte del servidor: a. Creamos un objeto que implemente la interfaz remota b. Generar de forma automática el Stub y el Skeleton c. El Servidor de Objetos: Elaborar el código que se encarga de instanciar en memoria el objeto servidor y registrarlo en los registros de Java RMI 3. Desarrollo del software en la parte del cliente Aunque se podría hacer todo en una misma clase, se recomienda que la implementación de la interfaz remota, del objeto servidor, y la funcionalidad del servidor de objetos residan en clases diferentes, se recomienda que el servidor sea una clase y que el objeto servidor sea una clase distinta. v. La interfaz remota Una interfaz Java es una clase que se utiliza como plantilla para otras clases: contiene las declaraciones de los métodos (denominados métodos abstractos) que deben implementar las clases que utilizan dicha interfaz. Una interfaz remota Java es una interfaz que hereda de la clase Java Remote, que permite implementar la interfaz utilizando sintaxis RMI. Aparte de la extensión que se hace de la clase Remote y de que todas las declaraciones de los métodos deben especificar la excepción RemoteException, una interfaz remota utiliza la misma sintaxis que una interfaz Java local. Permite declara como es nuestro objeto servidor utilizando java RMI. vi. Ejemplo de interfaz remota Java // file: SomeInterface.java // to be implemented by a Java RMI server class. import java.rmi.* public interface SomeInterface extends Remote { // signature of first remote method 1. Remote Procedure Call frente a Remote Method Invocation 8 public String someMethod1( ) throws java.rmi.RemoteException; // signature of second remote method public int someMethod2( float ) throws java.rmi.RemoteException; // signature of other remote methods may follow } // end interface - Esto es la estructura típica de una interfaz remota. - Cada uno de los métodos tiene que poder lanzar la excepción de RemoteException. - Cada declaración de un método debe especificar la excepción java.rmi.Remote en la sentencia throws. - Cuando ocurre un error durante el procesamiento de la innovación del método remoto, se lanza una excepción de este tipo, que debe ser gestionada en el programa del método que lo invoca. - Las causas que origina este tipo de excepción incluyen los errores que pueden ocurrir durante la comunicación entre los procesos, tal como fallos de acceso y conexión, así como problemas asociados exclusivamente a la invocación de métodos remotos, como por ejemplo no encontrar el objeto, el stub o el skeleton. vii. Software de la parte servidora Un objeto servidor es un objeto que proporciona los métodos y la interfaz de un objeto distribuido. Cada objeto servidor debe implementar cada uno de los métodos remotos especificados en la interfaz y registrar en un servicio de directorios un objeto que contiene la implementación. Se recomienda que las dos partes se realicen en clases separadas (la segunda parte la realizaría el servidor de objetos). viii. Implementación de la interfaz remota Se debe crear una clase que implemente la interfaz remota. La sintaxis es similar a una clase que implementa la interfaz local. import java.rmi.*; import java.rmi.server.*; /** * This class implements the remote interface SomeInterface. */ public class SomeImpl extends UnicastRemoteObject 1. Remote Procedure Call frente a Remote Method Invocation 9 implements SomeInterface { public SomeImpl() throws RemoteException { super( ); } public String someMethod1( ) throws RemoteException { // code to be supplied } public int someMethod2( ) throws RemoteException { // code to be supplied } } // end class Esta clase tiene que heredar de forma obligatoria de la clase UnicastRemoteObject. Este objeto hace referencia a como es el mecanismo de llamada. Si yo tengo un objeto remoto y lo invoco desde un cliente, puede haber varios tipos de llamada. Para ello hay varias estrategias: - Invocar al método una vez, si se pierde la llamada se continúa. - Garantizar que la llamada se ejecuta una vez por invocación en el cliente. - Invocar al servidor y esperar un tiempo, si no se obtiene respuesta se vuelve a invocar. Java RMI puede usar en la capa de transporte tanto TCP como UDP, entonces hay posibilidad de pérdida de datos por esto, la estrategia utilizada por RMI es la tercera. Esta interfaz: - No puede tener elementos de tipo estático. - No puede tener dependencias con datos almacenados en disco. - Solo depende de los argumentos de entrada. La única forma de asegurar que todo esté bien es haciendo uso de una base de datos relacional. 1. Remote Procedure Call frente a Remote Method Invocation 10 ix. Diagrama UML para la clase SomeImpl Hay una implementación con una serie de métodos, que hereda de una interfaz y a la vez propiedades de un remoteobject. x. Generación del Stub y el Skeleton En RMI, un objeto distribuido requiere un proxy por cada uno de los servidores y clientes de objeto, conocidos como skeleton y stub respectivamente. Estos proxies se generan a partir de la implementación de una interfaz remota utilizando una herramienta del SDK de Java: el compilador RMI rmic. rmic <nombre de la clase de la implementación de la interfaz remota > Por ejemplo: rmic SomeImpl Como resultado de la compilación se generan dos ficheros proxy, cada uno de ellos con el prefijo correspondiente al nombre de la clase de la implementación: SomeImpl_skel.class SomeImpl_stub.class. Una vez que tenemos todo esto, hay que generar los proxies (proxy cliente y proxy servidor). Para esto se hace uso del comando RMI. A diferencia de RPCG, el RMI no genera código fuente. En java todo es la misma máquina virtual, todo interpreta el mismo pilecode. “¿Por qué generaría código fuente cuando ya genero código binario correspondientes a los proxies?” (pregunta irónica). “Me ahorro un paso”. El comando RMI genera proxies y los genera en base al conocimiento de la implementación de la interfaz remota. Lo que le debemos pasar al comando RMI es el objeto servidor compilado. En base a esto, nos va a generar: SomeImpl_skel.class y SomeImpl_stub.class. Esta es la forma tradicional, lo que se us aplicaciones java rmic. Java rmic tiene soporte de generación dinámica de proxies. Es decir, yo genero los códigos binarios correspondientes al servidor y al cliente y cuando los ejecuto, el propio código de ambos en tiempo de ejecución generan los proxies y los instalan adecuadamente. 1. Remote Procedure Call frente a Remote Method Invocation 11 Nota: “si trabajo con java rmic pues me olvido de este paso”. El profesor los va a explicar explícitamente para que notemos la existencia de dichos proxies. Así que, los ejemplos de línea de comando generará los proxies. xi. El fichero stub para el objeto - El fichero de stub para el objeto, así como el fichero de la interfaz remota deben compartirse con cada cliente de objeto – estos ficheros son imprescindibles para que el programa cliente pueda compilar correctamente. - Una copia de cada fichero debe colocarse manualmente en la parte del cliente. Adicionalmente, Java RMI dispone de una característica denominada “stub downloading” que consiste en que el cliente obtiene de forma dinámica el stub. Problema: yo tengo el proxy del cliente y el proxy del servidor; y una aplicación cliente- servidor donde yo tengo un cliente que conectándose con el servidor consume un determinado recurso y proporciona una información. Suponiendo que el programador de la aplicación decide modificar algo en el servidor, añadirle alguna funcionalidad. Pero esta modificación no implica añadir ni quitar ningún método, por lo que el cliente no se ve modificado. Simplemente por hacer eso, luego de generar el nuevo código del servidor y compilarlo; hay que volver a generar los proxies (imaginando que hay un montón de clientes, habría que ir a instalarle el código a cada uno de ellos). La solución: stub downloading. Stub Downloading consiste en un objeto servidor que reside en una máquina. Esta máquina servidora además tiene un servidor web instalado; en este servidor tiene en un sitio concreto depositado un fichero lstub. El cliente al ejecutarse hará algo parecido a cuando se descarga una página web. Primero, hace una consulta viendo el documento. Si el documento que está almacenado coincide en fecha y hora con el documento que está en la red no lo descarga, está en caché. Pero, si hay alguna diferencia en eso procede a la descarga. Esto es una forma de actualizar el cliente de forma transparente. xii. Servidor de objetos La clase del servidor de objetos instancia y exporta un objeto que implementa la interfaz remota. El siguiente código muestra una plantilla para la clase del servidor de objetos. Se encarga de instanciar en memoria el objeto servidor y registrar en el registro de java rmi. ¿Cómo lo hace? Primer paso: ¿dónde está el objeto en memoria?. Segundo paso: arrancar el registro de java rmi. De forma automática o manual 1. Remote Procedure Call frente a Remote Method Invocation 12 Nota: es como si se hubiera realizado a mano el comando rmiregistry. Diferencia en el código: “en el código se asume que el usuario es torpe y se olvida”. En ese caso, va a descubrir que el registro no está activo y lo va a activar él mismo, el programa, de forma automática. Nota: en java si se acaba el main NO tiene por qué haberse acabado el programa pues puede quedar un thread trabajando. Nota: rebind crea un thread que constantemente esté en escucha para poder recibir otro cliente. Si ya existía una entrada, borra la entrada anterior e inserta una nueva. También existe bind que hace lo mismo pero sin borrar la entrada anterior. Por lo que, si hubiera una entrada previamente generaría una excepción. - Cuando se ejecuta un servidor de objetos, la exportación de los objetos distribuidos provoca que el proceso servidor comience a escuchar por el puerto y espere a que los clientes se conecten y soliciten el servicio del objeto. - Un objeto servidor RMI es un servidor concurrente: cada solicitud de un objeto cliente se procesa a través de un hilo independiente del servidor. Dado que las invocaciones de los métodos remotos se pueden ejecutar de forma concurrente, es importante que la implementación de un objeto remoto sea thread-safe Si yo tengo un método remoto dentro de un objeto, y este por la razón que sea tarda mucho tiempo en ejecutarse. Entre medias, antes de concluir un segundo cliente invoca el mismo método. ¿Qué ocurre? Java rmi en este caso no hace que el segundo cliente tenga que esperar al primero, cada ejecución remota despliega un hilo para su ejecución. Por lo que cada invocación implica la creación de un hilo que nosotros no creamos, lo hace java rmi. Tenemos que garantizar que las cosas funcionan correctamente cuando tenemos múltiples hilos generando el mismo código. Nota: hay que tener en consideración uso de candados, carreras críticas... para evitar problemas. Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Asignatura 27-09-2021 Elena Segade Martínez, Teresa Gutiérrez Blanco Clase 06 Temas trabajados: Tema 3. El API de Java RMI. Principio Tema 4. 1. El API de Java RMI 2 Índice 1. El API de Java RMI ................................................................................................................. 3 2. La interfaz remota ................................................................................................................. 3 3. Software de la parte servidora .............................................................................................. 3 4. El software de la parte cliente............................................................................................... 5 5. Pasos para construir una aplicación RMI .............................................................................. 6 6. Colocación de los ficheros en una aplicación RMI ................................................................ 7 7. Pruebas y depuración de una aplicación RMI ....................................................................... 8 8. Comparación entre RMI y el API de sockets ......................................................................... 8 9. El ejemplo HelloWorld .......................................................................................................... 9 10. Tema 4: RMI Avanzado ....................................................................................................... 10 1. El API de Java RMI 3 1. El API de Java RMI Estábamos viendo objetos distribuidos: Java RMI, en concreto. Habíamos comentado las cosas que teníamos que hacer para desarrollar el software de la parte del servidor: 1. Primero crear una interfaz remota 2. Implementar dicha interfaz, es decir, el objeto servidor que implementa dicha interfaz. 3. Generamos los proxys: el Stub y el Skeleton. 4. Después creamos el servidor de objetos. Todo esto (puntos 2, 3 y 4) por parte del software del servidor, más adelante hablaremos del software del cliente. 2. La interfaz remota Una interfaz remota Java es una interfaz que hereda de la clase Java Remote, que permite implementar la interfaz utilizando sintaxis RMI. Aparte de la extensión que se hace de la clase Remote y de que todas las declaraciones de los métodos deben especificar la excepción RemoteException, una interfaz remota utiliza la misma sintaxis que una interfaz Java local. Esta interfaz RemoteException encapsula todas las fallos de comunicación que se puedan dar en el proceso de llamada desde el cliente, a la hora de llamar a un método remoto hay que rodearlo de un try catch para capturar estas excepciones. Esto es lo que nos puede dar la pista de que estamos ante un código que se ejecuta de manera remota, sino no hay nada que distinga esta invocación de una local. Por lo tanto: • Cada declaración de un método debe especificar la excepción java.rmi.Remote en la sentencia throws. • Cuando ocurre un error durante el procesamiento de la invocación del método remoto, se lanza una excepción de este tipo, que debe ser gestionada en el programa del método que lo invoca. • Las causas que origina este tipo de excepción incluyen los errores que pueden ocurrir durante la comunicación entre los procesos, tal como fallos de acceso y conexión, así como problemas asociados exclusivamente a la invocación de métodos remotos, como por ejemplo no encontrar el objeto, el stub o el skeleton. 3. Software de la parte servidora Un objeto servidor es un objeto que proporciona los métodos y la interfaz de un objeto distribuido. Cada objeto servidor debe • implementar cada uno de los métodos remotos especificados en la interfaz y heredar de UnicastRemoteObject • registrar en un servicio de directorio un objeto que contiene la implementación. Se recomienda que las dos partes se realicen en clases separadas (la segunda parte la realizaría el servidor de objetos). a) Implementación de la interfaz Heredar de UnicastRemoteObject implica cómo es el procedimiento de la llamada, esto es, si yo invoco y no obtengo un resultado vuelvo a invocar hasta que el servidor me proporcione el resultado. así funciona Java RMI e implica que dentro del código del objeto servidor no puede haber métodos que hagan uso de 3. Software de la parte servidora 4 variables estáticas, ya que esto haría que el comportamiento no fuese predecible, porque si modificamos esta variable estática cada vez que invocamos, no sabemos cuantas veces vamos a invocar una función ante una llamada de un cliente, no hay correspondencia de 1 a 1. Una vez compilado el objeto servidor generamos los proxys de stub y skeleton. b) Generación del Stub y el Skeleton En RMI, un objeto distribuido requiere un proxy por cada uno de los servidores y clientes del objeto, conocidos como skeleton y stub, respectivamente. Estos proxies se generan a partir de la implementación de una interfaz remota utilizando una herramienta del SDK de Java: el compilador RMI rmic. Comando rmic <nombre de la clase de la implementación de la interfaz remota>. Equivalente a rpcg de RemoteProcedureCall. Genera de manera automática el código de los proxys, el programador no se tiene que preocupar por esto. Por ejemplo: rmic SomeImpl Como resultado de la compilación se generan dos ficheros proxy, cada uno de ellos con el prefijo correspondiente al nombre de la clase de la implementación: SomeImpl_skel.class SomeImpl_stub.class. c) El fichero de stub para el objeto El fichero de stub para el objeto, así como el fichero de la interfaz remota deben compartirse con cada cliente de objeto – estos ficheros son imprescindibles para que el programa cliente pueda compilar correctamente. Una copia de cada fichero debe colocarse manualmente en la parte del cliente. Adicionalmente, Java RMI dispone de una característica denominada “stub downloading” que consiste en que el cliente obtiene de forma dinámica el stub. De esta manera cuando el cliente se conecta al servidor, lo primero que hace es comprobar si tiene la ultima versión de este fichero y realiza una descarga de una copia si no tiene esta ultima versión. Para esta descarga utiliza el protocolo http. d) El servidor de objetos La clase del servidor de objetos instancia y exporta un objeto que implementa la interfaz remota, registrándolo en el registro de java RMI. El siguiente código muestra una plantilla para la clase del servidor de objetos. import java.rmi.*; ...... public class SomeServer { public static void main(String args[]) { try{ // code for port number value to be supplied SomeImpl exportedObj = new SomeImpl(); startRegistry(RMIPortNum); // register the object under the name “some” registryURL = \"rmi://localhost:\" + portNum + \"/some\"; Naming.rebind(registryURL, exportedObj); System.out.println(\"Some Server ready.\"); }// end try } // end main 4. El software de la parte cliente 5 La función startRegistry verifica que el registro esté activo y una vez nos aseguramos de esto, creamos una url (es obligatorio usar localhost cuando estamos registrando el servidor) y con esta y el objeto instanciado en memoria, lo registramos en el registro RMI. Al hacer este registro se despliega un hilo de carácter bloqueante, esto es, está permanentemente bloqueado esperando conexiones de posibles clientes. Aunque termine el código del servidor de objetos no termina el programa debido a este hilo que tenemos activo. Cada vez que ese hilo recibe una conexión de un cliente, se deriva a un nuevo hilo que ejecutará el código, porque en java RMI cada vez que ejecutamos un método remoto se despliega un hilo para la ejecución de dicho método, por eso todo el código que creemos en Java RMI tiene que ser thread-safe (no usar variables estáticas, ni usar nada que mantenga el estado entre llamadas (almacenamiento en disco...)), las funciones en Java RMI deben ser funciones que atienden única y exclusivamente a los parámetros de entrada. Muchas veces el programador, sea conscientemente o no, no tiene esto en cuenta al 100%, a veces tenemos bases de datos que almacenan el estado, etc, pero debemos ser conscientes de las limitaciones que impone Java RMI y que, si el código no funciona bien, puede deberse a esto. En resumen: • Cuando se ejecuta un servidor de objetos, la exportación de los objetos distribuidos provoca que el proceso servidor comience a escuchar por el puerto y espere a que los clientes se conecten y soliciten el servicio del objeto. • Un objeto servidor RMI es un servidor concurrente: cada solicitud de un objeto cliente se procesa a través de un hilo independiente del servidor. Dado que las invocaciones de los métodos remotos se pueden ejecutar de forma concurrente, es importante que la implementación de un objeto remoto sea thread-safe Alternativamente, se puede activar un registro RMI manualmente utilizando el comando rmiregistry, que se encuentra en el SDK, a través de la ejecución del siguiente mandato en el intérprete de comandos: rmiregistry <número puerto> , donde el número de puerto es un número de puerto TCP (>1023, para evitar conflictos con otros servicios). Si no se especifica ningún puerto, se utiliza el puerto por defecto 1099. El registro se ejecutará de forma continua hasta que se solicite su terminación (a través de CTRL-C, por ejemplo) 4. El software de la parte cliente La clase cliente es como cualquier otra clase Java. La sintaxis necesaria para hacer uso de RMI supone: • localizar el registro RMI en el nodo servidor, • buscar la referencia remota para el servidor de objeto; a continuación se realizará un cast de la referencia a la clase de la interfaz remota y se invocarán los métodos remotos. Las llamadas a métodos remotos no se diferencian en nada a una llamada local excepto que están rodeadas del try-catch del que hablamos previamente. import java.rmi.*; .... public class SomeClient { public static void main(String args[]) { 5. Pasos para construir una aplicación RMI 6 try { String registryURL = \"rmi://localhost:\" + portNum + \"/some\"; SomeInterface h = (SomeInterface)Naming.lookup(registryURL); // invoke the remote method(s) String message = h.method1(); System.out.println(message); // method2 can be invoked similarly } // end try catch (Exception e) { System.out.println(\"Exception in SomeClient: \" + e); } } //end main // Definition for other methods of the class, if any. }//end class Primero creamos una url que se corresponde al objeto al que nos queremos conectar. En el ejemplo usamos localhost pero no tiene porque ser así porque el servidor puede estar ubicado en otra maquina. Después ejecutamos el método lookup de la clase Naming, método estático por lo que no necesitamos instanciar Naming. Nos proporciona un objeto que ya sabemos de que tipo es, el de la interfaz remota. Solo puedo llamar de forma remota a métodos que estén declarados en la interfaz remota. Por lo tanto, no tiene sentido que declaremos (mediante un cast) la salida de lookup como el tipo del objeto servidor, la declaramos del tipo de la interfaz remota porque estamos restringiendo el posible uso de esa referencia: esa referencia solo puede utilizarse para invocar a los métodos declarados en la interfaz. A partir de ahí, hago uso de ese objeto como si fuera un objeto local, a través del uso de los métodos declarados en la interfaz. Tiene que haber un try catch para la RemoteException y nada mas. En resumen: • El método lookup de la clase Naming se utiliza para obtener la referencia del objeto, si existe, que previamente ha almacenado en el registro el servidor de objetos. Obsérvese que se debe hacer un cast de la referencia obtenida a la clase de la interfaz remota (no a su implementación). • Se utiliza la referencia a la interfaz remota para invocar cualquiera de los métodos de dicha interfaz. • Obsérvese que la sintaxis utilizada para la invocación de los métodos remotos es igual que la utilizada para invocar métodos locales. • Es un error común el hacer un cast del objeto obtenido del registro a la clase que implementa la interfaz o a la clase del servidor de objetos. El cast debe realizarse a la clase de la interfaz. 5. Pasos para construir una aplicación RMI a) Algoritmo para desarrollar el software en la parte del servidor i. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 6. Colocación de los ficheros en una aplicación RMI 7 ii. Especificar la interfaz remota del servidor en SomeInterface.java. Compilarla y revisarla hasta que no exista ningún error de sintaxis. iii. Implementar la interfaz en SomeImpl.java, compilarla y revisarla hasta que no exista ningún error de sintaxis. iv. Utilizar el compilador de RMI rmic para procesar la clase de la implementación y generar los ficheros stub y skeleton para el objeto remoto: rmic SomeImpl Los ficheros generados se encontrarán en el directorio como: SomeImpl_Skel.class y SomeImpl_Stub.class. Se deben repetir los pasos 3 y 4 cada vez que se realice un cambio a la implementación de la interfaz. v. Crear el programa del servidor de objetos SomeServer.java. Compilarlo y revisarlo hasta que no exista ningún error de sintaxis.Este servidor de objetos puede crear varios objetos, no hace falta tener un servidor de objetos por cada objeto. vi. Activar el servidor de objetos java SomeServer b) Algoritmo para desarrollar el software en la parte del cliente i. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. ii. Obtener una copia del fichero class de la interfaz remota. Alternativamente, obtener una copia del fichero fuente de la interfaz remota y compilarlo utilizando javac para generar el fichero class de la interfaz. Esto es necesario porque el cliente hace uso de esta interfaz en el lookup. iii. Obtener una copia del fichero stub para la implementación de la interfaz: SomeImpl_Stub.class. iv. Desarrollar el programa cliente SomeClient.java. Compilarlo y revisarlo hasta que no exista ningún error de sintaxis. v. Activar el cliente. java SomeClient 6. Colocación de los ficheros en una aplicación RMI Archivos estrictamente necesarios para el uso del cliente y servidor. Cuanta menos información se le da a cada una de las partes mejor, de nada sirve que el cliente conozca la implementación. Los ficheros creados en el entorno de desarrollo no son 7. Pruebas y depuración de una aplicación RMI 8 necesarios. Como vemos, es necesario tener la interfaz en ambas partes, pero la implementación solo la tenemos en el servidor. 7. Pruebas y depuración de una aplicación RMI i. Construir una plantilla para un programa RMI básico. Empezar con una interfaz remota que sólo contenga la declaración de un método, su implementación utilizando un stub, un programa servidor que exporte el objeto y un programa cliente con código que sólo invoque al método remoto. Probar la plantilla en una máquina hasta que se pueda ejecutar correctamente el método remoto. ii. Añadir una declaración cada vez a la interfaz. Con cada adición, modificar el programa cliente para que invoque al método que se ha añadido. iii. Rellenar la definición de cada método remoto uno a uno. Probar y depurar de forma detallada cada método añadido antes de incluir el siguiente. iv. Después de que todos los métodos remotos se han probado detalladamente, crear la aplicación cliente utilizando una técnica incremental. Con cada incremento, probar y depurar los programas. v. Distribuir los programas en máquinas separadas. Probarlos y depurarlo No es bueno intentar desarrollar una aplicación distribuida compleja de un tirón, no podemos pretender desarrollar el servidor con 10 métodos accesibles de forma remota y luego programar el cliente para probarlo todo junto ya que es muy probable que algo falle y encontrarlo será muy complejo. Hay que ir desarrollando método a método y probándolos en el cliente, verificando los parámetros de diseño y viendo que se proporcionan los resultados esperados, luego ya iremos añadiendo nuevas funcionalidades. Hacer todo de un golpe es la mejor forma de fracasar y que la aplicación no funcione. 8. Comparación entre RMI y el API de sockets El API de RMI es una herramienta eficiente y eficaz para construir aplicaciones de red. Puede utilizarse en lugar del API de sockets para construir una aplicación de red rápidamente. Sin embargo, esta opción tiene pros y contras: • El API de sockets está más cercano al sistema operativo, por lo que tiene menos sobrecarga de ejecución, es más rápido. Mayor cantidad de información en menos tiempo. Para aplicaciones que requieran un alto rendimiento, el API de sockets puede ser la única solución viable. Además, podemos elegir entre TCP y UDP, UDP siendo más rápido por ser más simple. • El API de RMI proporciona la abstracción necesaria para facilitar el desarrollo de software. Los programas desarrollados con un nivel más alto de abstracción son más comprensibles y, por lo tanto, más sencillos de depurar. Al usar el paradigma de llamadas a métodos remotos, los fallos en las llamadas (argumentos de distinto tipo o en distinto número...) son verificados por el compilador. Aunque sea un método remoto, si lo invoco mal desde el cliente el compilador se dará cuenta. Ya no es cuestión del programador. Desarrollar aplicaciones más complejas en menos tiempo gracias a la alta abstraccion. 9. El ejemplo HelloWorld 9 9. El ejemplo HelloWorld Esta en el cv como hello.zip, lo descargamos y extraemos. Contiene 4 ficheros. Para obtener un .class de una interfaz de java, se utiliza el comando javac interfaz.java. Para la ejecución de un programa servidor-cliente, se deben generar los proxys. Los proxys se pueden generar de forma dinámica con la ejecución. Si se ejecuta el código en teoría debería funcionar. También se pueden generar de forma estática, existiendo dos formas: una es generando un único fichero que contiene los dos proxys y que se pueden usar indistintamente en el servidor y en el cliente y la otra opción es generar 2 ficheros separados, uno específicamente para el cliente y otra para el servidor. El comando rmic para la generación de proxys, por defecto genera un único fichero. Si se desea crear los dos archivos por separado se debe poner la opción -v1.1, que indica el protocolo que se utilizará para encapsular la información de los proxys. Al comando rmic se le pasa la implementación sin extensión. Ejemplo: rmic -v1.1 implementación Como consecuencia del comando anterior, aparecen 2 ficheros, el implementacio_Skell.class y el implementacion_Stub.class que son el skelleton y el stub respectivamente, esto es, el proxy del servidor y el proxy del cliente. La generación estática se encuentra en desuso por la existencia de la dinámica. El protocolo por defecto en el rmic es el 1.2, el cuál genera un único archivo. Para ejecutar el programa, se debe realizar el comando javac fichero.java, siendo fichero.java el fichero en el cuál se encuentra la función main de la aplicación. El cliente puede estar en una máquina y el servidor en otra diferente. Con respecto a los archivos que necesitan servidor y cliente: • La interfaz debería estar en ambos. • La implementación es exclusiva del servidor. • El skel debería ir en el servidor y el stub en el cliente. • El servidor de objetos tiene que ir en el servidor y el cliente.class en el cliente. Para activar el servidor, se utiliza el comando java Server.java. El comando netstat muestra las conexiones de red. Si ejecutamos netstat -a tras ejecutar el programa servidor, aparece una entrada en el puerto 1099 con nombre rmiregistry pero, ¿cómo sabe que es el rmiregistry? Porque en unix existe un fichero denominado /etc/services que mira el nombre de cada uno de los servicios correspondiente a un puerto específico y si se mira el puerto 1099 aparece rmiregistry. Si se ejecutase el comando rmiregistry antes de la ejecución del servidor, la aplicación no localizaría el puerto debido a que ya estaría activo. 10. Tema 4: RMI Avanzado 10 Al ejecutar el servidor y el cliente pueden existir problemas que hacen que no se ejecuten correctamente. Esto es debido a la configuración de la máquina, la cuál normalmente responde a 2 direcciones ip por defecto: la dirección ip declarada y la dirección loopback(127.0.0.1). A veces ocurre que cuándo se pregunta por la dirección ip de la máquina, el sistema operativo devuelve la dirección de loopback. El servidor de objetos cuando publica el objeto servidor publica el puerto en el cuál está accesible el servicio y la dirección ip, información que obtiene el cliente cuándo dialoga con el registro de Java RMI. Pero, resulta que en este proceso puede ocurrir que el servidor de objetos obtenga como dirección ip la loopback en lugar de la real, entonces el cliente cuando intenta conectarse con el servidor, se intenta conectar consigo mismo, fallando la conexión. Esto se soluciona cambiando una de las propiedades de la aplicación. Esto se puede hacer o bien desde el propio código o mediante una opción cuando se invoca el programa. Básicamente lo que se debe hacer es cambiar la propiedad java.rmi.server.hostname a la dirección ip real de la máquina, de forma que en el código una de las primeras líneas debe ser: System.setProperty(“Java.rmi.server.hostname”, <<direccion ip>>). La otra forma sería pasar en la línea de comandos la opción: -D java.rmi.server.hostname=<<direccion ip>>. Cualquiera de las opciones es válida. 10. Tema 4: RMI Avanzado El API de Java RMI tiene múltiples funcionalidades. Aquí analizaremos algunas de las características avanzadas de RMI más interesantes, a saber: • stub downloading: Logra que el proceso descargue de forma dinámica el stub en ejecución • Security manager: Forma de proteger el código ante el código malicioso. Fijarse que cuando se realiza el stub downloading se descarga un proxy, es código ejecutable que no se sabe que contiene. Puede ocurrir que ese código accede al disco duro y borre archivos o cosas por el estilo. Security manager sirve para prohibir determinadas acciones al código. • Client callback: Mecanismo por el cual una vez que se habla con el servidor, este puede invocar un método del cliente. El cliente tiene métodos que son accesibles de forma remota. Estos métodos son la base para realizar aplicaciones más complejas como puede ser el modelo publica-subscribe o peer to peer. • Serialización y envío de objetos: Imagine que se tiene un método accesible de forma remota que tiene una serie de argumentos. ¿Qué pasa cuando el argumento es un objeto?. Java tiene un mecanismo por el cuál un objeto se puede transformar en una cadena alfanumérica de caracteres que representa en binario al objeto instanciado en memoria y, esa cadena, se puede transmitir a través de un canal de comunicaciones, almacenar en disco, recuperar… Al estar transmitiendo código 10. Tema 4: RMI Avanzado 11 en la serialización, es obligatorio el uso de un security manager para proteger al servidor de posible código malicioso enviado por el cliente. Aunque no se trata de características inherentes del paradigma de objetos distribuidos, se trata de mecanismos que pueden ser útiles para los desarrolladores de aplicaciones. Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 29-09-2021 Manuel Cid Domínguez, Diana Mascareñas Sande Clase 07 Temas trabajados: tema 4, RMI Avanzado 1. RMI – Cuestiones avanzadas 2 ÍNDICE 1. RMI – Cuestiones avanzadas .............................................................................................3 2. La arquitectura Java RMI ..................................................................................................3 3. Interacción Cliente Servidor en Java RMI ..........................................................................3 4. Stub downloading .............................................................................................................4 a) El fichero java.policy ....................................................................................................5 b) Colocación de los ficheros .............................................................................................5 5. RMI Security Manager......................................................................................................6 a) Algoritmo para construir una aplicación RMI .................................................................7 6. RMI Callbacks .................................................................................................................8 a) Introducción .................................................................................................................8 b) Polling vs. Callback ......................................................................................................8 c) Comunicaciones en ambos sentidos ................................................................................9 d) RMI Callbacks..............................................................................................................9 e) Interacciones Cliente-Servidor con Callback ................................................................. 10 f) Ficheros de una aplicación Callback ............................................................................. 11 g) Colocación de los ficheros en una RMI Callback........................................................... 12 h) La aplicación Hello con Callback ................................................................................. 13 1. RMI – Cuestiones avanzadas 3 1. RMI – Cuestiones avanzadas - El API de Java RMI tiene múltiples funcionalidades. - Aquí analizaremos algunas de las características avanzadas de RMI más interesantes, a saber: stub downloading (descarga dinámica del proxy del cliente), security manager (necesario en el cliente cuando hago stub downloading. Impone unas restricciones para impedir ciertas acciones), client callback (cuando ocurre un evento, el servidor puede notificar al cliente sin notificación previa), serialización y envío de objetos (qué pasa cuando invocamos a un método remoto y uno de sus argumentos es un objeto. En este caso el security manager debe proteger al servidor). - Aunque no se trata de características inherentes del paradigma de objetos distribuidos, se trata de mecanismos que pueden ser útiles para los desarrolladores de aplicaciones. 2. La arquitectura Java RMI 3. Interacción Cliente Servidor en Java RMI 4. Stub downloading 4 ¿Qué ocurre cuando hacemos stub downloading? (Explicación en la imagen y a continuación) 1. El cliente se pone en contacto con el registro de Java RMI para obtener una referencia del objeto remoto. 2. El registro de Java RMI le proporciona esa referencia. 3. El cliente intenta no paralizar el proxy (del cliente)/stub. Para ello se conectará, mediante el protocolo HTTP con la máquina que proporciona el stub. Si el stub que está depositado en esa máquina no coincide con el que tiene a nivel local, se produce la descarga de esa nueva copia y se instala. 4. Se produce la llamada a través del stub y del skeleton correspondiente. 4. Stub downloading - RMI se ha diseñado para permitir que los clientes obtengan dinámicamente el stub. Esto permite realizar cambios en los métodos remotos sin afectar al programa cliente. - El stub puede ser colocado en un servidor web y descargado usando el protocolo HTTP. - Es necesario establecer ciertas medidas de seguridad tanto en la parte del cliente como del servidor: o En concreto, es necesario un fichero que describa la política de seguridad. o Debe realizarse una instancia de un Java Security Manager tanto en el cliente como en el servidor. - Si el stub va a ser descargado de un servidor remoto, debe moverse la clase stub al directorio apropiado del servidor y asegurarse que tiene los permisos de acceso necesarios. - Cuando activamos el servidor, se debe especificar las siguientes opciones: java -Djava.rmi.serve.codebase = <URL>/ \\ -Djava.rmi.server.hostname= <server host name>\\ -Djava.security.policy=<full directory path to java policy file> Where <URL>/ is the URL for the stub class, e.g., http://www.csc.calpoly.edu/~mliu/class <server host name> is the name of the host on which the server runs, And <full directory path to java policy file> specifies where the security policy file for this application is to be found, e.g., java.security if you have a file by that name in the directory where the server class is. a). El fichero java.policy 5 a) El fichero java.policy Especificará qué se permite y qué no se permite hacer. - El gestor de seguridad de RMI no permite un acceso a la red. Las excepciones deben especificarse en un fichero java.policy. grant { →DEFINE TODO LO QUE SE PUEDE HACER (por defecto todo lo demás está prohibido) // permits socket access to all common TCP ports, including the default // RMI registry port (1099) – need for both the client and the server. permission java.net.SocketPermission \"*:1024-65535\", \"connect,accept,resolve\"; // permits socket access to port 80, the default HTTP port – needed // by client to contact an HTTP server for stub downloading permission java.net.SocketPermission \"*:80\", \"connect\"; }; - Este fichero puede colocarse en el mismo directorio del archivo class del servidor. - Cuando activamos el cliente, debemos especificar también un fichero java.policy: java -Djava.security.policy=java.policy SomeClient - Podría aparecer el bloque deny en lugar del grant, que definiría qué cosas están prohibidas (por defecto todo lo demás está permitido). b) Colocación de los ficheros Tanto en cliente como en servidor tenemos el java.policy. A través del fichero stub podremos descargar el proxy del cliente cuando invoque al servidor desde dicho cliente. 5. RMI Security Manager 6 5. RMI Security Manager El java policy no tiene ningún sentido sin un security manager. Este es la parte del programa que leerá el fichero de políticas de seguridad, interpretará lo que dice, y a partir de ello, aplicará una serie de restricciones. Es lo primero que debemos hacer. try { System.setSecurityManager(new RMISecurityManager()); } catch {…} - Puesto que RMI involucra el acceso desde/a una máquina remota y, posiblemente la descarga de objetos, es importante que tanto el servidor como el cliente se protejan ante accesos inadecuados o no permitidos. - RMISecurityManager es una clase de Java que puede ser instanciada tanto en el cliente como en el servidor para limitar los privilegios de acceso. - Es posible escribir nuestro propio gestor de seguridad, si lo deseamos (pero no tiene sentido reinventar la rueda). a). Algoritmo para construir una aplicación RMI 7 a) Algoritmo para construir una aplicación RMI LADO DEL SERVIDOR LADO DEL CLIENTE 1. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 2. Especificar la interfaz remota y compilarla para generar el archivo .class de la interfaz. 3.Construir el servidor remoto implementando la interfaz y compilarlo hasta que no haya ningún error. 4. Usar rmic para procesar la clase del servidor y generar un fichero .class de stub y un fichero .class de skeleton: rmic SomeServer 5. Si se desea stub downloading, copiar el fichero stub al directorio apropiado del servidor HTTP. 6. Activar el RMIRegistry en el caso de que no haya sido activado previamente. 7. Construir un fichero de políticas de seguridad para la aplicación llamado java.policy. 8. Activar el servidor especificando (i) el campo codebase si se utiliza stub downloading, (ii) el nombre del servidor y (iii) el fichero de políticas de seguridad. 1. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 2. Implementar el programa cliente o applet y compilarlo para generar la clase cliente. 3. Si no se puede usar stub downloading, copiar el fichero class de stub a mano. 4. Especificar el fichero de políticas de seguridad java.policy. 5. Activar el cliente especificando: (i) el nombre del servidor y (ii) el fichero con las políticas de seguridad. ´ 6. RMI Callbacks 8 6. RMI Callbacks ¿Cómo hacemos que el servidor pueda invocar a un método accesible de forma remota del cliente? a) Introducción - En el modelo cliente servidor, el servidor es pasivo: la comunicación IPC es iniciada por el cliente; el servidor espera por la llegada de las peticiones y proporciona las respuestas. - A veces, puede ser necesario obtener información lo más rápido posible de la ocurrencia donde ha terminado un evento. Dos soluciones: (i) hacer un sondeo (trabajar con el modelo cliente-servidor) para ver si la información ha cambiado o que, (ii) el servidor, cuando detecte cambios en ella, se conecte con el cliente sin que haya una petición previa. - Algunas aplicaciones necesitan que el servidor inicie la comunicación ante la ocurrencia de determinados eventos. Ejemplos de este tipo de aplicaciones las tenemos en: monitorización de procesos, juegos, subastas, trabajo colaborativo… b) Polling vs. Callback Si no disponemos de callback, un cliente tendrá que realizar un sondeo (polling) a un servidor pasivo repetidas veces si necesita ser notificado de que un evento ha ocurrido en el servidor. Polling Callback Nosotros intentamos evitar el sondeo, es decir, que un cliente a lo largo del tiempo esté continuamente haciendo consultas al servidor. Para ello: el cliente se conecta con el servidor en un momento dado, especificando en qué está interesado. A partir de ahí, no hay diálogo, este solo se produce cuando tiene lugar el evento en el que está interesado el cliente. Ahí el servidor enviará un mensaje al cliente. Se pueden recibir múltiples notificaciones ante una suscripción de un evento. c). Comunicaciones en ambos sentidos 9 c) Comunicaciones en ambos sentidos - Algunas aplicaciones necesitan que ambos lados puedan iniciar una comunicación IPC. - Si usamos sockets, se puede conseguir una comunicación duplex si utilizamos dos sockets en cada lado. - Con sockets orientados a conexión, cada lado actúa tanto como cliente como servidor. Para realizar todo esto, si empleáramos el API de sockets, tendríamos que crear múltiples sockets de forma que, si el proceso 1 quiere enviar algo al proceso 2, este hace una petición y obtiene una respuesta. Tendríamos un socket que está esperando conexiones, y otro que inicia el diálogo. Los sockets se van intercambiando los papeles si el diálogo va cambiando de sentido. Por tanto, se necesitarían múltiples sockets e hilos de ejecución (mínimo uno dedicado a enviar mensajes y otro a recibirlos). Todo esto, lo resuelve JavaRMI mediante el concepto de callback. Con JavaRMI no hace falta programar hilos (para lo que vamos a hacer, otra cosa es que, por exigencia de la aplicación necesitemos otros hilos), ya que los creará de forma inmediata nuestro Middleware. d) RMI Callbacks ¿En qué consiste? - Un cliente de un callback se registra en un servidor RMI (hace una petición). - En consecuencia, se invoca un método dentro del servidor, al que se le han pasado una serie de argumentos: información de conectividad (dónde me encuentro como cliente). Esta información se almacena en el servidor como una estructura de datos dinámica (arrayList, vector o mapa). - Ahora el servidor está monitorizando un determinado proceso, y cuando ocurre el evento que estamos esperando, cogerá la estructura dinámica, recorriéndola elemento a elemento, para notificar a cada uno de los clientes registrados la ocurrencia de dicho evento. Mientras el cliente esté suscrito, recibirá dichas notificaciones. Si el cliente quiere e). Interacciones Cliente-Servidor con Callback 10 dejar de recibirlas, se dialogará de nuevo con el servidor, y pasándole su información, pero esta vez, para que sea eliminada. e) Interacciones Cliente-Servidor con Callback Entonces, tendríamos algo así: 1. El cliente se conecta con el registro de JavaRMI para obtener la referencia remota del servidor. 2. Acto seguido, invoca a un método del servidor, pasándole información de conectividad (dónde está ubicado el cliente). 3. Para ello usa el proxy y el skeleton 4. El servidor, cuando detecte el evento, la llamada irá en sentido inverso por lo que debe haber otro proxy que represente al cliente, y un skeleton de modo que los papeles queden invertidos (“servidor hace de cliente” y “cliente hace de servidor”) • Con callback, el cliente no necesita un registro de JavaRMI, aquí solo hace falta en el servidor para poder empezar el diálogo. En el sentido contrario no es necesario ya que el servidor ya sabe dónde está el objeto cliente. f). Ficheros de una aplicación Callback 11 Explicación de los apuntes: 1. Client looks up the interface object in the RMIregistry on the server host. 2. The RMIRegistry returns a remote reference to the interface object. 3. Via the server stub, the client process invokes a remote method to register itself for callback passing a remote reference to itself to the server. The server saves the reference in its callback list. 4. Via the server stub, the client process interacts with the skeleton of the interface object to access the methods in the interface object. 5. When the anticipated event takes place, the server makes a callback to each registered client via the callback interface stub on the server side and the callback interface skeleton on the client side. **Pregunta de clase: ¿Cómo sabe el servidor qué método del cliente tiene que llamar? ¿Es un método genérico que se llama callback? El cliente va a tener uno o dos métodos descritos en una interfaz remota (propia del cliente). Es decir, tendremos dos interfaces remotas: la del objeto servidor y la del objeto cliente. El servidor usará una referencia remota del tipo de la interfaz remota del cliente pudiendo invocar únicamente los métodos que esta recoja. Y de los que están dentro de esa interfaz remota, ¿cómo sabe qué método invocar? Esa decisión es labor del programador. f) Ficheros de una aplicación Callback Ahora tenemos una interfaz del servidor (en el servidor), que también necesitaré en el cliente (el cliente tiene que saber cómo es el objeto servidor para invocarlo). A partir de esa interfaz crearemos un objeto servidor: ServerImpl.class (en el servidor). A partir de esa implementación, generaremos los proxy de cliente y servidor. El de cliente estará en el cliente, y el de servidor estará en el servidor. A mayores, necesitamos el objeto cliente, que va a ser la llamada al servidor. El cliente tendrá su interfaz remota (ClientInterface.class), y tendremos un objeto que implemente dicha interfaz (ClientImpl.class). Los métodos recogidos por esta serán los que puedan ser llamados por el servidor accediendo de forma remota. g). Colocación de los ficheros en una RMI Callback 12 A partir de esa implementación generamos el stub y skeleton de cliente y servidor. El skeleton lo ponemos en el cliente (porque en este caso hace la función de servidor) y el stub lo ponemos en la página del objeto servidor. **Por cada interfaz remota, siempre vamos a tener un stub y un skeleton, independientemente de la ubicación del objeto que implemente dicha interfaz remota. g) Colocación de los ficheros en una RMI Callback Si hubiera stub downloading: siempre se hace downloading al stub correspondiente al objeto servidor, nunca al del cliente. El objeto cliente cuanto menos se toque (varíe), mejor, lo que variaremos en nuestra aplicación distribuida será el objeto servidor (para añadir funcionalidades, por ejemplo). Colocaríamos el stub del servidor en un servidor web y ficheros de política de seguridad tanto en el servidor como en el cliente. h). La aplicación Hello con Callback 13 h) La aplicación Hello con Callback Veamos un ejemplo real: zip callback (campus virtual). El evento en cuestión será interno, y consiste en un registro. CallbackServerInterface: import java.rmi.*; /** * This is a remote interface for illustrating RMI * client callback. * @author M. L. Liu */ public interface CallbackServerInterface extends Remote { public String sayHello( ) throws java.rmi.RemoteException; // This remote method allows an object client to // register for callback // @param callbackClientObject is a reference to the // object of the client; to be used by the server // to make its callbacks. public void registerForCallback( h). La aplicación Hello con Callback 14 CallbackClientInterface callbackClientObject ) throws java.rmi.RemoteException; // This remote method allows an object client to // cancel its registration for callback public void unregisterForCallback( CallbackClientInterface callbackClientObject) throws java.rmi.RemoteException; } Vemos tres métodos: sayHello(), que devuelve un string; registerForCallback, que permite que un cliente se pueda registrar para recibir notificaciones. Le pasaremos una referencia remota del cliente, de tipo de la interfaz remota del cliente (CallbackClientInterface). El último método sirve para “desregistrar” al cliente. CallbackClientInterface: import java.rmi.*; /** * This is a remote interface for illustrating RMI * client callback. * @author M. L. Liu */ public interface CallbackClientInterface extends java.rmi.Remote{ // This remote method is invoked by a callback // server to make a callback to an client which // implements this interface. // @param message - a string containing information for the // client to process upon being called back. public String notifyMe(String message) throws java.rmi.RemoteException; } // end interface Tiene un método llamado notifyMe, que recibe un string con el que se presenta el mensaje por pantalla. Tenemos que empezar compilando estos dos archivos, primero el del cliente y luego el del servidor (el compilador de Java es lo suficientemente inteligente como para compilar antes el clientInterface si le pedimos que compile el serverInterface). h). La aplicación Hello con Callback 15 Ya tenemos los ficheros compilados (.class). Veamos la implementación del servidor: CallbackServerImpl import java.rmi.*; import java.rmi.server.*; import java.util.Vector; /** * This class implements the remote interface * CallbackServerInterface. * @author M. L. Liu */ public class CallbackServerImpl extends UnicastRemoteObject implements CallbackServerInterface { private Vector clientList; public CallbackServerImpl() throws RemoteException { super( ); clientList = new Vector(); } public String sayHello( ) throws java.rmi.RemoteException { return(\"hello\"); } public synchronized void registerForCallback( CallbackClientInterface callbackClientObject) throws java.rmi.RemoteException{ // store the callback object into the vector if (!(clientList.contains(callbackClientObject))) { clientList.addElement(callbackClientObject); System.out.println(\"Registered new client \"); doCallbacks(); } // end if } // This remote method allows an object client to // cancel its registration for callback // @param id is an ID for the client; to be used by // the server to uniquely identify the registered client. public synchronized void unregisterForCallback( CallbackClientInterface callbackClientObject) throws java.rmi.RemoteException{ if (clientList.removeElement(callbackClientObject)) { System.out.println(\"Unregistered client \"); } else { System.out.println( \"unregister: clientwasn't registered.\"); } } private synchronized void doCallbacks( ) throws java.rmi.RemoteException{ // make callback to each registered client System.out.println( \"**************************************\\n\" h). La aplicación Hello con Callback 16 + \"Callbacks initiated ---\"); for (int i = 0; i < clientList.size(); i++){ System.out.println(\"doing \"+ i +\"-th callback\\n\"); // convert the vector object to a callback object CallbackClientInterface nextClient = (CallbackClientInterface)clientList.elementAt(i); // invoke the callback method nextClient.notifyMe(\"Number of registered clients=\" + clientList.size()); }// end for System.out.println(\"********************************\\n\" + \"Server completed callbacks ---\"); } // doCallbacks }// end CallbackServerImpl class Implementa la interfaz remota, en el constructor invoca a esta clase madre y recibimos la estructura de datos dinámica donde se almacena la lista de clientes. Tenemos un método registerForCallback, que recibe la referencia remota del cliente, verifica si el lector ya tenía esa referencia: si no la tenía, la añade al vector, si ya la tenía, no hace nada. Acto seguido se produce el doCallbacks: el lugar donde notifico la ocurrencia del evento (que alguien se ha suscrito). En una situación normal, tendríamos un hilo que monitoriza un proceso y, cuando este genere el evento en cuestión, se invoca al método doCallbacks. El método doCallbacks recorre el vector de clientes y, elemento a elemento, extrayéndolos y almacenándolos (sabemos que estos serán de tipo CallbackClientInterface). Acto seguido invoca al método notifyMe, pasándole el tamaño del vector. ¿Por qué registerForCallback es synchronized? Si se diese la casualidad de que dos clientes acudieran a registrarse al mismo tiempo, habría un problema, porque podría ocurrir que estuviese realizando la operación de inserción de uno de los elementos, y no se hubiera completado, de forma que el vector estuviese corrupto. Lo mismo ocurre con doCallbacks. Mientras recorro el vector, no puedo permitir que nadie se suscriba. El método unregisterForCallback elimina el registro de un cliente, pasándole su referencia remota. También es synchronized. ¿Cuál es el recurso que no se puede compartir? El vector de clientes. No podemos estar en dos lugares distintos modificando el vector al mismo tiempo. ***El próximo día se verá el resto del ejemplo: la parte del cliente y la ejecución del programa. Grado en Ingeniería Informática 3º curso – 3º cuatrimestre Computación Distribuida 04-10-2021 Nerea Freiría Alonso, Adriana Aurora Rodríguez Oreiro Clase 08 Temas trabajados: Continuación Tema 4: RMI Avanzado Callback, Serialización y Envío de Objetos 1. Retomar última clase 2 Índice 1. Retomar última clase ................................................................................................................. 3 a) Habíamos visto: ................................................................................................................. 3 2. Notita ......................................................................................................................................... 3 3. Ejemplo archivos callback en cv ............................................................................................... 3 b) Interfaz remota Servidor .................................................................................................... 3 c) Interfaz remota cliente ....................................................................................................... 4 d) Implementación servidor ................................................................................................... 4 e) Implementación cliente ..................................................................................................... 7 f) Servidor objeto .................................................................................................................. 8 g) Cliente objeto .................................................................................................................... 9 h) ¿Alguien le ve algún problema a este código? (cliente objeto) ....................................... 12 i) Para compilar .................................................................................................................. 12 4. Ejecutar con ficheros de seguridad .......................................................................................... 14 5. Algoritmo para construir una aplicación RMI con callback ................................................... 15 j) Lado del servidor:............................................................................................................ 15 k) Lado del cliente ............................................................................................................... 16 6. Serialización y envío de objetos .............................................................................................. 16 l) Ejemplo: integración numérica ....................................................................................... 17 m) Código CV .................................................................................................................. 18 1. Retomar última clase 3 1. Retomar última clase a) Habíamos visto: - Ejemplos de callback - Distribución de archivos - Visto código que está en el campus virtual 2. Notita Esta bitácora es algo larga, pero hay mucho código ejemplo además del contenido en sí. Ánimo :) 3. Ejemplo archivos callback en cv b) Interfaz remota Servidor import java.rmi.*; /** * This is a remote interface for illustrating RMI * client callback. * @author M. L. Liu */ public interface CallbackServerInterface extends Remote { public String sayHello( ) throws java.rmi.RemoteException; // This remote method allows an object client to // register for callback // @param callbackClientObject is a reference to the // object of the client; to be used by the server // to make its callbacks. public void registerForCallback( CallbackClientInterface callbackClientObject ) throws java.rmi.RemoteException; // This remote method allows an object client to // cancel its registration for callback public void unregisterForCallback( CallbackClientInterface callbackClientObject) throws java.rmi.RemoteException; } Interfaz remota y proporciona tres funciones: 3. Ejemplo archivos callback en cv 4 - La primera no tiene mayor interés. - En las otras dos (registerForCallback y unregisterForCallback) el evento es de tipo académico para evitar complicar excesivamente la parte del servidor. Lo que realmente es interesante: el evento que hay que notificar es que alguien acaba de registrarse. Cuando un cliente se registra, lo que va a hacer es proporcionarle una referencia remota a su objeto que proporciona métodos accesibles de forma remota en el cliente. Recordar: una referencia remota no es más que un objeto de la interfaz remota. Por lo tanto, lo que le pasamos como argumento en la llamada a registerForCallback es la interfaz remota del cliente (idem para unregisterForCallback). c) Interfaz remota cliente import java.rmi.*; /** * This is a remote interface for illustrating RMI * client callback. * @author M. L. Liu */ public interface CallbackClientInterface extends java.rmi.Remote{ // This remote method is invoked by a callback // server to make a callback to an client which // implements this interface. // @param message - a string containing information for the // client to process upon being called back. public String notifyMe(String message) throws java.rmi.RemoteException; } // end interface El notifyMe en este caso lo único que va a hacer al notificar es imprimir por pantalla que se ha recibido una notificación. Esto se hace en un hilo, este es aparte del hilo principal del cliente. Es decir, el cliente estará haciendo cosas y cuando el servidor instancia al objeto de interfaz remota del cliente, tras ese momento, va a recibir llamadas del servidor. d) Implementación servidor import java.rmi.*; import java.rmi.server.*; import java.util.Vector; 3. Ejemplo archivos callback en cv 5 /** * This class implements the remote interface * CallbackServerInterface. * @author M. L. Liu */ public class CallbackServerImpl extends UnicastRemoteObject implements CallbackServerInterface { private Vector clientList; public CallbackServerImpl() throws RemoteException { super( ); clientList = new Vector(); } public String sayHello( ) throws java.rmi.RemoteException { return(\"hello\"); } public synchronized void registerForCallback( CallbackClientInterface callbackClientObject) throws java.rmi.RemoteException{ // store the callback object into the vector if (!(clientList.contains(callbackClientObject))) { clientList.addElement(callbackClientObject); System.out.println(\"Registered new client \"); doCallbacks(); } // end if } // This remote method allows an object client to // cancel its registration for callback // @param id is an ID for the client; to be used by // the server to uniquely identify the registered client. public synchronized void unregisterForCallback( CallbackClientInterface callbackClientObject) throws java.rmi.RemoteException{ if (clientList.removeElement(callbackClientObject)) { System.out.println(\"Unregistered client \"); 3. Ejemplo archivos callback en cv 6 } else { System.out.println( \"unregister: clientwasn't registered.\"); } } private synchronized void doCallbacks( ) throws java.rmi.RemoteException{ // make callback to each registered client System.out.println( \"**************************************\\n\" + \"Callbacks initiated ---\"); for (int i = 0; i < clientList.size(); i++){ System.out.println(\"doing \"+ i +\"-th callback\\n\"); // convert the vector object to a callback object CallbackClientInterface nextClient = (CallbackClientInterface)clientList.elementAt(i); // invoke the callback method nextClient.notifyMe(\"Number of registered clients=\" + clientList.size()); }// end for System.out.println(\"********************************\\n\" + \"Server completed callbacks ---\"); } // doCallbacks }// end CallbackServerImpl class Es una clase que hereda de UnicastRemoteObject y donde se encuentran los métodos de la interfaz remota. El constructor crea un objeto del tipo vector y lo almacena en clientList. En este caso se utiliza como estructura dinámica pero podría ser un ArrayList, HashMap y cualquier estructura de datos que puede aumentar o disminuir tamaño ejecutando. sayHellow solamente devuelve la frase “hello”. registerForCallback recibe la referencia remota del cliente y lo que hace es verificar que el cliente (el objeto) no esté ya en la estructura Vector, si no está lo añade como un elemento más. Nota: Vector almacena Objects, entonces da igual el tipo, en este caso son interfaces remotas de clientes. 3. Ejemplo archivos callback en cv 7 Como el cliente se registra, hay que avisar a los clientes que se ha registrado (doCallbacks). En este método se consulta cuál es el tamaño del Vector y lo va a recorrer elemento a elemento para acceder a cada uno de ellos. Vector devuelve Object porque no sabe qué tiene almacenado entonces es necesario realizar un cast. Acto seguido, se realiza la notificación con notifyMe para cada interfaz remota indicando la cantidad de clientes registrados. IMPORTANTE: registerForCallback, unregisterForCallback y doCallbacks son synchronized, y esto es para evitar que pueda haber otro cliente en el mismo momento registrándose (no haya carreras críticas, te queremos Rivera. Gracias por poner bajo el mar en clase :) ). Esto es un recurso que no puede ser compartido: Vector. unregisterForCallback recibe la interfaz remota del objeto y la elimina. Vector permite consultar por contenido así que elimina directamente el objeto. Nota: si se compila esto puede dar errores o warnings y es porque Vector es un tipo de dato que se desaconseja su uso. e) Implementación cliente import java.rmi.*; import java.rmi.server.*; /** * This class implements the remote interface * CallbackClientInterface. * @author M. L. Liu */ public class CallbackClientImpl extends UnicastRemoteObject implements CallbackClientInterface { public CallbackClientImpl() throws RemoteException { super( ); } public String notifyMe(String message){ String returnMessage = \"Call back received: \" + message; System.out.println(returnMessage); return returnMessage; } }// end CallbackClientImpl class Es un objeto remoto, de tipo servidor y tiene que implementar la interfaz remota correspondiente, en este caso CallbackClientInterface. notifyMe construye un mensaje, recibe el callback e imprime el mensaje. De igual forma, devuelve ese mensaje. Pero en el servidor no tengo en cuenta este valor de retorno. 3. Ejemplo archivos callback en cv 8 f) Servidor objeto import java.rmi.*; import java.rmi.server.*; import java.rmi.registry.Registry; import java.rmi.registry.LocateRegistry; import java.net.*; import java.io.*; /** * This class represents the object server for a distributed * object of class Callback, which implements the remote * interface CallbackInterface. * @author M. L. Liu */ public class CallbackServer { public static void main(String args[]) { InputStreamReader is = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(is); String portNum, registryURL; try{ System.out.println( \"Enter the RMIregistry port number:\"); portNum = (br.readLine()).trim(); int RMIPortNum = Integer.parseInt(portNum); startRegistry(RMIPortNum); CallbackServerImpl exportedObj = new CallbackServerImpl(); registryURL = \"rmi://localhost:\" + portNum + \"/callback\"; Naming.rebind(registryURL, exportedObj); System.out.println(\"Callback Server ready.\"); }// end try catch (Exception re) { System.out.println( \"Exception in HelloServer.main: \" + re); 3. Ejemplo archivos callback en cv 9 } // end catch } // end main //This method starts a RMI registry on the local host, if //it does not already exists at the specified port number. private static void startRegistry(int RMIPortNum) throws RemoteException{ try { Registry registry = LocateRegistry.getRegistry(RMIPortNum); registry.list( ); // This call will throw an exception // if the registry does not already exist } catch (RemoteException e) { // No valid registry at that port. Registry registry = LocateRegistry.createRegistry(RMIPortNum); } } // end startRegistry } // end class Declarar variables para poder leer por la terminal (bufferreader), preguntar número de puerto, crear instancia del objeto implementación de servidor, crear la URL correspondiente de callback y realizar rebind. StartRegistry es el código de siempre. g) Cliente objeto import java.io.*; import java.rmi.*; /** * This class represents the object client for a * distributed object of class CallbackServerImpl, * which implements the remote interface * CallbackServerInterface. It also accepts callback * from the server. * @author M. L. Liu 3. Ejemplo archivos callback en cv 10 */ public class CallbackClient { public static void main(String args[]) { try { int RMIPort; String hostName; InputStreamReader is = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(is); System.out.println( \"Enter the RMIRegistry host namer:\"); hostName = br.readLine(); System.out.println( \"Enter the RMIregistry port number:\"); String portNum = br.readLine(); RMIPort = Integer.parseInt(portNum); System.out.println( \"Enter how many seconds to stay registered:\"); String timeDuration = br.readLine(); int time = Integer.parseInt(timeDuration); String registryURL = \"rmi://localhost:\" + portNum + \"/callback\"; // find the remote object and cast it to an // interface object CallbackServerInterface h = (CallbackServerInterface)Naming.lookup(registryURL); System.out.println(\"Lookup completed \" ); System.out.println(\"Server said \" + h.sayHello()); CallbackClientInterface callbackObj = new CallbackClientImpl(); // register for callback h.registerForCallback(callbackObj); System.out.println(\"Registered for callback.\"); try { Thread.sleep(time * 1000); 3. Ejemplo archivos callback en cv 11 } catch (InterruptedException ex){ // sleep over } h.unregisterForCallback(callbackObj); System.out.println(\"Unregistered for callback.\"); } // end try catch (Exception e) { System.out.println( \"Exception in CallbackClient: \" + e); } // end catch } //end main }//end class Nuevamente, aparecen las variables necesarias para leer por pantalla, se le debe indicar el host (dónde está el objeto servidor), el número de puerto y a continuación pregunta cuánto tiempo va a estar registrado. Es decir, el cliente se registra y al pasar X segundos se va a desregistrar. Acto seguido, crear la URL para conectarse, hace Naming.lookup para obtener interfaz de servidor y crea una instancia de implementación de cliente. Esta variable es la que se le pasa al registerForCallback del servidor. Nota: se puede realizar de otra forma menos elegante y no recomendable. Esta consiste en pasarle el objeto tal cual, y si el servidor quiere invocar al método del cliente tendría que dialogar con un registro de java RMI ubicado en la máquina del cliente para invocar su método. Pero, si se hace de esta forma no es necesario un registro de java RMI en la máquina del cliente (sí, suena así de lioso. Te explico ahora, a ver si entiendes mejor). Esto es porque ya le estoy proporcionando una referencia remota (quédate con esta frase que en ratito explico qué es), es decir; le proporciono la misma información que obtendría si estuviera dialogando con un registro de java RMI. ¿Qué le proporciono? Pues el callbackObj. Lo cual es un objeto de implementación de cliente que a su vez implementa una interfaz remota y hereda de UnicastObject (lo que automáticamente convertiría al objeto en uno remoto o de servidor). Es decir, es una referencia remota (ya que se crea como Interfaz variable = new Implementación()); (Aquí el profesor dijo su muy mítico “¿me seguís?” seguido de un “¿voy demasiado rápido?” y nadie se atrevió a decirle que sí). Desde el registerForCallback(callbackObj) ahora el servidor puede realizar el notifyMe sin ningún tipo de problema. La ✨magia ✨está en que el CallbackImpl herede de UnicastRemoteObject. Si no heredara de esto, nada funcionaría; sus propiedades son muy importantes. Todos los objetos son objetos servidores en todos los efectos accesibles de forma remota. 3. Ejemplo archivos callback en cv 12 h) ¿Alguien le ve algún problema a este código? (cliente objeto) Alguien: cando metes a URL do registro RMI metes o localhost e non metes o *host domain* (aquí no estoy segura de si dijo esas palabras exactamente). Nota: se refieren a esto en CallbackClient.java: String registryURL = \"rmi://localhost:\" + portNum + \"/callback\"; Profesor: sí, este código tal cual solo serviría si ejecutas cliente y servidor en la misma máquina. Debería ser: String registryURL = \"rmi://\"+ hostname+ \":\" + portNum + \"/callback\"; i) Para compilar Nota: en la explicación no está compilando las interfaces remotas y hay que hacerlo. $ javac CallbackServerImpl.java $ rmic -v1.1 CallbackServerImpl.java /*esto es para crear el stub y el skeleton*/ $ javac CallbackServer.java $ javac CallbackClientImpl.java $ rmic -v1.1 CallbackClientImpl.java /*esto es para crear el stub y el skeleton*/ $ javac CallbackClient.java Ahora se van a crear dos ficheros de la forma: $ mkdir servidor $ mkdir cliente /*es necesaria la interfaz en ambas carpetas ya que ambos usuarios (si se les puede llamar de esta forma) hacen uso de ella*/ $ cp CallbackServerInterface.class servidor $ cp CallbackServerInterface.class cliente $ cp CallbackClientInterface.class servidor $ cp CallbackClientInterface.class cliente $ cp CallbackServerImpl.class servidor $ cp CallbackServerImpl_Skel.class servidor 3. Ejemplo archivos callback en cv 13 $ cp CallbackServerImpl_Stub.class cliente $ cp CallbackServer.class servidor $ cp CallbackClientImpl.class cliente $ cp CallbackClientImpl_Skeleton.class cliente /*en este caso el cliente hace de servidor*/ $ cp CallbackClientImpl_Stub.class servidor $ cp CallbackClient.class cliente Al llegar aqui servidor y cliente deben tener seis archivos cada uno. Estos se corresponden con: 4. Ejecutar con ficheros de seguridad 14 4. Ejecutar con ficheros de seguridad En el siguiente caso habría que añadir en cada sistema un fichero de políticas de seguridad, tanto en el cliente como en el servidor; de java.policy. Y, habría que añadir el stub en una máquina que tenga un servidor web. En el ejemplo del CV, aparece un java.policy: grant { permission java.net.SocketPermission \"*:1099\", \"connect, accept, resolve\"; // This allows RMI clients to contact the RMIRegistry of any host permission java.net.SocketPermission \"*:1024-65535\", \"connect, accept, resolve\"; // This allows RMI clients to make network connections to the public // ports on any host // If you start the RMIregistry on a port in this range, this will help // to get around the resolve access violation. permission java.net.SocketPermission \"localhost:1099\", \"connect, resolve\"; permission java.net.SocketPermission \"129.65.242.5:1024-\", 5. Algoritmo para construir una aplicación RMI con callback 15 \"connect, accept\"; // For some reason it is necessary for some people to have the above // statements to explicitly allow connection to/from falcon. permission java.net.SocketPermission \"*:80\", \"connect\"; // This allows connection to the default web server on any host - // needed for stub downloading, among other things. }; También, hay dos scripts: uno para ejecutar al servidor y otro para ejecutar al cliente. (runClient y runServer). runClient: java -Djava.security.policy=java.policy - Djava.rmi.server.codebase=http://www.csc.calpoly.edu/~mliu/stubs / CallbackClient runServer: java -Djava.security.policy=java.policy - Djava.rmi.server.codebase=http://www.csc.calpoly.edu/~mliu/stubs / CallbackServer Aquí, aparece la dirección del stub en http://www.csc.calpoly.edu/~mliu/stubs. Nota: no tiene por qué estar ahora. 5. Algoritmo para construir una aplicación RMI con callback j) Lado del servidor: - Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. - Especificar la interfaz remota de servidor y compilarla para generar el fichero .class de la interfaz. 6. Serialización y envío de objetos 16 - Construir la clase remota del servidor implementando el interfaz y compilarla hasta que no exista ningún error de sintaxis. - Utilizar rmic para procesar la clase del servidor y generar un fichero .class de stub y otro fichero .class de skeleton - Si se requiere stub downloading, copiar el fichero stub al directorio apropiado del servidor HTTP. - Activar el registro de RMI, si no estaba previamente activo. - Establecer la política de seguridad en el archivo java.policy. - Activar el servidor especificando (i) el codebase si se requiere stub downloading, (ii) el nombre del servidor y (iii) el fichero con la política de seguridad. - Obtener el CallbackInterface. Compilarlo con javac y usar rmic para generar el fichero de stub para la callback. k) Lado del cliente - Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. - Implementar el programa cliente o applet y compilarlo para generar la clase cliente. - Si no está activo el stub downloading, copiar el fichero .class del stub correspondiente al interfaz del servidor a mano. - Implementar la interfaz de callback. Compilarla usando javac, y usando rmic generar los ficheros .class correspondientes al stub y el skeleton. - Establecer la política de seguridad en el fichero java.policy. - Activar el cliente especificando (i) el nombre del servidor y (ii) el fichero con la política de seguridad. 6. Serialización y envío de objetos Java RMI no pone restricción sobre qué se puede pasar como argumento a un objeto remoto. No solo son tipos de datos básicos, lo que se puede transmitir como argumento. A veces, es necesario pasar como argumento un objeto y es posible en java RMI gracias al concepto de serialización. La serialización se utiliza para muchas cosas, (no solo esto) consiste en tener un objeto instanciado en memoria y luego les hace una fotografía a nivel binario y se transforma en una array alfanumérico que representa esos valores binarios. Este array es susceptible de almacenarse en un archivo, base de datos, transmitirse sobre la red, etc. Nota: nosotros haremos uso de transmitirlo en la red. · A veces resulta necesario el pasar como argumento a un método de un objeto remoto tipos de datos complejos como, por ejemplo, objetos que hayamos creado nosotros. · En Java con RMI es posible gracias al concepto de serialización, que consiste en encapsular el contenido de un objeto (código + datos) en una cadena de caracteres susceptible de poder ser enviada a través de la red. · La máquina virtual Java nos garantiza que la reconstrucción del objeto recibido en la parte remota será correcta y que el objeto funcionará sin problemas. Nota: ningún objeto de tipo deprecate (no aconsejable el uso) puede ser serializado. 6. Serialización y envío de objetos 17 - ¿Alguien sabe la razón? + No La razón: los creadores de java decidieron añadir las características estimadas necesarias, pero si “nos equivocamos” en algo vamos a tener un mecanismo del cual podemos ir “para atrás” y eliminar ese error (actualizando JDK). Si se permite serializar, se podría almacenar en una base de datos y si dentro de 20 años intenta acceder a ese registro y extraer el objeto quizás ya no soporta a ese objeto. l) Ejemplo: integración numérica Nota: en el CV hay un tar.gz con los códigos para resolver el programa. Ya están compilados y creados los ficheros servidor y cliente. Regla del punto medio: dividir en segmentos y quedarse con la altura del punto medio (respecto a f(x)). Mientras más segmentos, la integración es más exacta. ¿Problema?: Imagina que hay programado un servidor que sea capaz de integrar cualquier función. Yo le paso el valor inicial, final y número de segmentos que tiene que realizar; además de la función que hay que integrar. ¿Cómo le paso la función?: se lo puedo pasar como un objeto que represente a la función. 6. Serialización y envío de objetos 18 No puedo dejar implementada la función en el servidor porque yo quiero que pueda resolver cualquier función. m) Código CV Hay una interfaz remota RemoteIntegral y tiene un método integrate que hay que pasarle un comienzo, un final, un número de pasos y el objteto que representa al objeto. En este caso este tipo de objeto es Evaluatable, dentro de esta interfaz existe una función que devuelve el valor de f(x) de un x dado. Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 06-10-2021 Andrea Solla Alfonsín, Hugo Vázquez Docampo Clase 09 Temas trabajados: 4. RMI avanzado 5. Arquitecturas orientadas a servicios 1. RMIIntegral 2 Índice 1. .................................................................................................................................... RMIIntegral ........................................................................................................................................................ 3 a).......................................................................................... La interfaz remota, RemoteIntegral .................................................................................................................................................... 3 b) ............................................. La implementación de la interfaz remota, RemoteIntegralImpl .................................................................................................................................................... 3 c) .......................................................................... El servidor de objetos, RemoteintegralServer .................................................................................................................................................... 3 d) ........................................................................................................... El cliente, RemoteClient .................................................................................................................................................... 3 e) .................................................................................................... El objeto seno, la clase seno .................................................................................................................................................... 3 f) ................................................................................................................................. Directorios .................................................................................................................................................... 4 2. ............................................................................... Tema 5: Arquitecturas orientadas a servicios ........................................................................................................................................................ 4 g)......................................................................................................... Descripción del problema .................................................................................................................................................... 4 h) ........................................................................................................................................... RPC .................................................................................................................................................... 5 i. ..................................................................................................................................... DCOM ................................................................................................................................................ 5 ii. ................................................................................................................................... CORBA ................................................................................................................................................ 6 iii. ....................................................................................................................................... RMI ................................................................................................................................................ 6 i)....................................................................................................................................... Servlets .................................................................................................................................................... 7 iv. ................................................................................................................... Funcionamiento ................................................................................................................................................ 7 j) ..................................................................................................................... Arquitecturas SOA .................................................................................................................................................... 7 1. RMIIntegral 3 1. RMIIntegral En esta clase se realizó la explicación del código RMIIntegral que se encuentra disponible en el campus virtual. a) La interfaz remota, RemoteIntegral En la clase RemoteIntegral se menciona la existencia de un método de tipo evaluatable, si accedemos a la clase Evaluatable incorporada en el zip, observaremos que la clase Evaluatable.java no es más que una interface que incorpora el método evaluate que representa funciones de tipo y=f(x). Realizamos la incorporación de la interfaz Evaluatable como uno de los argumentos de la interfaz RemoteIntegral para que sea de la forma más genérica posible, es decir, para que la función de integración funcione con cualquier objeto que represente una función. La función Integrate, incorporada en la interfaz RemoteIntegral realiza la operación de integración haciendo uso de la regla del punto medio. A continuación, se explica como compilar esta parte del programa 1.- Se compila la interfaz evaluatable de la siguiente forma: javac Evaluatable.java esto genera el archivo Evaluatable.class. 2.- Se compila la interfaz remota: javac RemoteIntegral.java, esto genera el archivo RemoteIntegral.class. b) La implementación de la interfaz remota, RemoteIntegralImpl Como es una implementación de la interfaz remota, debe implementar el método integrate. En esta función, como nos interesa calcular la altura del segmento justo en la mitad, no vamos a empezar en el extremo, es decir, en start, vamos a empezar en (start+tamaño del paso) /2. Lo que interesa es la suma de las alturas, que las va a calcular la función sum. El área del segmento es el paso por la suma de las alturas. A continuación, compilamos la implementación de la interfaz remota con: javac RemoteIntegralImpl.java, con lo que obtenemos RemoteIntregalImpl.class. Una vez hecho esto, generamos el stub y el skeleton: rmic –v1.1 RemoteIntegralImpl. c) El servidor de objetos, RemoteintegralServer Vamos ahora con el servidor de objetos (clase RemoteintegralServer). Esto sigue el mismo procedimiento ya visto para los servidores de objetos típicos. Compilamos el servidor: javac - Xlint RemoteIntegralServer.java (esto dará un warning debido a que hay que meter un security manager y un fichero de políticas de privacidad porque se va a recibir un objeto de tipo evaluatable, pero no pasa nada). d) El cliente, RemoteClient Pasamos al cliente. El cliente es sencillo, los pasos a seguir son los de un cliente de objetos corriente con algunas variaciones, tras hacer el naming.lookUp hacemos una llamada al método Integrate de la interfaz remota desde 0 hasta pi, de un objeto de tipo Sin(). Esta llamada está definida con un paso de 10 hasta 10000 con paso 10, es decir, se prueba la integración con 10 pasos, con 100 pasos... así hasta 10000. Después, se presentará el resultado correcto. e) El objeto seno, la clase seno Esta clase implementa la interfaz Evaluatable y, por tanto, incorpora el método evaluate, que básicamente devuelve una invocación al método estático sin de la clase Math. Debe 2. Tema 5: Arquitecturas orientadas a servicios 4 implementar la interfaz Serializable para que se pueda transmitir a través de la red al objeto servidor. Es muy recomendable para los objetos serializables añadir el método toString, ya que puede darse el caso de que ese método esté almacenado en una base de datos, por ejemplo, y cuando se quiera recuperar no sepamos lo que es, de este modo podemos identificarlo haciendo un System-out-println (que llama al metodo toString). f) Directorios Para ejecutar el programa, es buena práctica separar en dos directorios los archivos, un directorio para el servidor y otro para el cliente. La interfaz remota debe estar en ambos directorios, ya que la necesitan tanto el cliente como el servidor, al igual que la interfaz Evaluatable y el objeto seno. La implementación de la interfaz remota, el skeleton y el servidor de objetos van en el servidor, mientras que el stub y el cliente van en el cliente. Esto lo podemos ver mejor en la siguiente tabla: SERVIDOR CLIENTE Remote Integral → Interfaz remota Remote Integral → por el Naming LookUp Interfaz evaluatable → implica un objeto evaluatable Interfaz evaluatable → el objeto Sin implementa esa interfaz Remote integral implementation Stub class Skeleton class cliente Servidor de objetos Seno (función) Sin.class → explicado debajo Al ejecutar “java RemoteIntegralServer”, observamos una excepción si no incluimos el fichero de políticas de seguridad en el servidor. Comando: Java –D java.security.policy = java.policy remoteIntegral... + Nº de puerto (para RMI = 1099). Si se intenta ejecutar nuevamente una vez incluidas las políticas de seguridad sin incluir el objeto seno (Sin.class) en el directorio del servidor, no funcionará tampoco porque el objeto cliente no está. Esto se debe a que los creadores de javaRMI estaban obsesionados con la seguridad. Su idea principal consistía en: coger el objeto, serializarlo, transmitirlo por internet y trabajar con él de forma remota. Los creadores decidieron serializar el estado del fichero.class (el valor de sus variables) y no el código. Por ello introdujeron redundancia cíclica y solo se transmiten los datos. Así, es necesario introducir una “copia” del Sin.class en el servidor para que así el programa pueda coger el código de ahí y los datos de forma remota. 2. Tema 5: Arquitecturas orientadas a servicios El problema sigue siendo que un objeto invoca a un método de otro objeto para conseguir un servicio. g) Descripción del problema • ¿Qué ocurre si las dos clases no están en la misma máquina? • ¿Dónde están las clases? ¿Cómo se pueden localizar o descubrir las clases con la funcionalidad que se necesita? 2. Tema 5: Arquitecturas orientadas a servicios 5 • ¿De qué modo se envía información entre clases? ¿Cómo se \"entienden\" las clases entre sí y qué protocolo de comunicación siguen? • ¿Qué sucede si no se encuentra ninguna clase con la funcionalidad necesaria? ¿Se puede combinar la funcionalidad de varias clases? Esto se puede solucionar mediante llamadas a procedimientos remotos (RPC) o utilizando la web como una capa software adicional. h) RPC En javaRMI la descripción del servicio es dependiente del lenguaje porque todo es Java. Si se utilizasen varios lenguajes, esta descripción no podría estar en java; sería necesaria una herramienta que, a partir del archivo IDL genere el skell / stub en el lenguaje correspondiente. Para ello son necesarias las correspondencias entre lenguaje IDL y local. A través de un compilador se genera automáticamente el código del cliente y del servidor que facilita la invocación entre los métodos. – Operaciones de codificación y decodificación de parámetros (marshalling / unmarshalling). – El método del cliente hace una invocación de un método que está implementado en un servidor. Los métodos se dan de alta en un registro en el que se les asigna una dirección IP y un puerto. – Los clientes generalmente conocen de antemano la definición del método (parámetros de entrada/salida y nombre). Esto no es siempre así, por ejemplo, CORBA permite la invocación dinámica de servicios, que consiste en construir en tiempo de ejecución cómo es la llamada. i. DCOM 2. Tema 5: Arquitecturas orientadas a servicios 6 ii. CORBA iii. RMI En Java RMI el protocolo por defecto es JRMP pero se puede usar IIOP y hacer la aplicación compatible con implementaciones en CORBA. En resumen, los RPC tienen las siguientes características: Por el contrario, presentan los siguientes problemas: • Estas tecnologías no interoperan entre sí. Aunque JavaRMI y CORBA sí que tienen una cierta interoperabilidad, es con un añadido de JavaRMI. • Es necesaria una arquitectura independiente del lenguaje, de la plataforma, de las características de los objetos, y del mecanismo de llamada. 2. Tema 5: Arquitecturas orientadas a servicios 7 i) Servlets Es uno de los servicios web más sencillos que hay, consiste en añadir una capa de web a las soluciones basadas en RPC. El resultado se construye en una página de respuesta que contiene la información solicitada. El principal problema de esta estrategia es que no hay tipos de datos, todo se encapsula en cadenas de texto en las que se codifican parámetros de entrada, y la respuesta se elabora en html. iv. Funcionamiento Típicamente se accede a una página web que tiene un formulario y, como consecuencia de pinchar en algún elemento de este formulario, se genera una petición que puede ser de tipo get o post. Como consecuencia el servlet ejecuta el código correspondiente y este elabora una respuesta, es decir, una página html que contiene la respuesta. Esto es un modo bastante ineficiente de realizar lo que ya hacíamos con JavaRMI. Por este motivo vamos a tender a soluciones basadas en arquitecturas SOA. j) Arquitecturas SOA Las arquitecturas orientadas a servicios no están ligadas a ninguna tecnología concreta, por lo que no necesariamente tiene que estar implementada con un servicio web. Lo que caracteriza a una arquitectura orientada a servicios es que sus componentes están bajamente acoplados, por lo que podrían ser reutilizados por otros componentes de la misma arquitectura (son independientes) y se pueden combinar entre si para proporcionar las funcionalidades requeridas por los clientes. Un servicio puede acudir a otro servicio para resolver un problema. Grao en Enxeñaría Informática 3º curso – 1º cuadrimestre Computación Distribuída 11-10-2021 Pablo Gil Pérez, Adrián Vidal Lorenzo, Nicolás Vilela Pérez Clase 10 Temas traballados: 5. Arquitecturas orientadas a servizos. Introdución ás Arquitecturas Orientadas a Servizos 1. Arquitectura SOA 2 Índice 1. Arquitectura SOA ....................................................................................................................... 3 a) Elementos dunha SOA ....................................................................................................... 3 b) Servizos web ...................................................................................................................... 3 2. Práctica da arquitectura SOA .................................................................................................... 7 a) IDE con Java Enterprise Edition ......................................................................................... 7 a) Apache CXF ........................................................................................................................ 9 1. Arquitectura SOA 3 1. Arquitectura SOA O termo “Arquitectura Orientada a Servizo” (SOA polas súas siglas en inglés) non está ligado a ningunha tecnoloxía ou a linguaxes de descrición de protocolos de interacción e de compoñentes. Unha arquitectura SOA non ten por que estar implementada como servizos web xa que non todo servizo é un servizo web. a) Elementos dunha SOA • Servizos: compoñentes software baixamente acoplados polo que poderían ser reutilizados por outros compoñentes da mesma arquitectura (independentes) e/ou combinados entre si para proporcionar funcionalidades requiridas polos clientes (orquestración). • Provedor: compoñente que ofrece un conxunto de servizos cunha funcionalidade dada. Os servizos son directamente accesibles a través de Internet (están expostos a través de URLs). Utiliza unha linguaxe de descrición estándar de servizos. • Consumidor: compoñente que invoca ou consome a funcionalidade dos servizos ofrecidos polo provedor. Utiliza un protocolo de invocación. • Rexistro: compoñente que contén os servizos ofrecidos polo provedor así como unha descrición dos mesmos. Non é obrigatorio en parte porque non está estandarizado polo consorcio W3C. b) Servizos web Os servizos web son interfaces que describen as características dunha colección de operacións ou métodos, as cales son accesibles a través da rede usando protocolos web estandarizados que están baseados en formatos XML (invocación) e cuxas propiedades están representadas usando unha linguaxe estándar baseada nun formato XML (descrición). Os formatos XML describen a estrutura dos protocolos de invocación e da descrición dos servizos. A institución que se encarga de estandarizar as linguaxes e protocolos na web é o Consorcio W3C. Na tecnoloxía de servicios web faise uso dos seguintes estándares que están representados en XML: - Protocolo de comunicacións: HTTP (https://www.w3.org/Protocols/) - Formato da mensaxe: SOAP (https://www.w3.org/TR/soap/) - Descrición dos servizos: WSDL (https://www.w3.org/TR/wsdl/) - Protocolo e rexistro: UDDI (http://uddi.xml.org/uddi-org) Os tres primeiros son estándares do Consorcio W3C. Entrar en detalle en como están formateadas as mensaxes a como están descritos os servizos non merece a pena. Centrarémonos en exemplos prácticos. A arquitectura SOA “recorda” ás solucións baseadas en tecnoloxía RPC (Remote Procedure Call). As principais diferenzas atópanse na estandarización de protocolos e no énfase na composición de servizos. 1. Arquitectura SOA 4 O provedor desprega o conxunto de operacións que desexa facer accesibles a través de internet. • Son accesibles como direccións URL que apuntan a recursos descritos na linguaxe WSDL. (ficheiros XML) • Con WSDL soamente se describen as capacidades funcionais de cada unha das operacións. É dicir: o WSDL contén as interfaces nas que se indica o nome, as entradas, e as saídas das operacións. o Tamén indica de que modo se invocarán as operacións. • Son estas operacións realmente accesibles por parte do programa cliente? o Si, serán accesibles se o cliente coñece as URLs. A través do ficheiro WSDL xa se pode construír a invocación remota. O provedor publica a través do protocolo UDDI as características dos servizos nun rexistro que podo ser consultado por os clientes (rexistro UDDI): • No rexistro indícanse as características non funcionais dos servizos tales como a descrición da empresa que os ofrece, categoría a que pertencen, etc. Poderanse realizar consultas seguindo tanto as características funcionais como as non funcionais. 1. Arquitectura SOA 5 • No rexistro tamén se indica a URL correspondente o ficheiro WSDL que contén as características funcionais do servizo desexado por o cliente. • Para acceder o rexistro UDDI utilízanse un conxunto de APIs que permiten dar de alta e de baixa os servizos que ofrece o provedor. Pódese dicir que un rexistro UDDI é ós servizos web o que un DNS ás direccións web. O consumidor busca os servizos no rexistro UDDI tendo en conta as características desexadas: • A busca realizase indicando palabras clave que fan referencia ás características funcionais e non funcionais dos servizos. • Pódense indicar as entradas e saídas que deben ter os servizos (TModel). Por exemplo, un servizo que proporcione un obxecto que representa un documento PDF, entón so se proporcionará os rexistro que devolvan como saída ese obxecto. • Como resultado da busca devolvese unha URL apuntando o ficheiro WSDL que contén a descrición das operacións e a forma na que poden ser invocadas. UDDI non é un estándar do Consorcio W3C polo que é unha das compoñentes de menor implantación no mercado. 1. Arquitectura SOA 6 O consumidor obtén o ficheiro WSDL e xera automaticamente o código necesario para realizar a invocación das operacións descritas. Os proxies son xerados de forma automática e transparente en base o coñecemento do arquivo WSDL. • Son xeradas as clases que representan os tipos de datos dos parámetros de entrada/saída. • Son xeradas as clases que codifican e decodifican os parámetros de entrada/saída das operacións. O consumidor usa o protocolo SOAP para invocar a execución de unha das operacións definidas no ficheiro WSDL que foi localizada no rexistro UDDI. O uso de formatos XML para describir e invocar as operacións permite a integración de aplicacións que: • Están implementadas en linguaxes de programación diferentes (tradución do formato XML a linguaxe de programación). • Utilizan modelos de datos diferentes (tradución do modelo representado no formato XML o modelo da aplicación). O uso de servizos como compoñentes baixamente acoplados permite ós consumidores: • Reutilizar as operacións en diferentes aplicacións. • Combinar as operacións entre sí para obter novas funcionalidades. 2. Práctica da arquitectura SOA 7 2. Práctica da arquitectura SOA Propóñense dúas maneiras de usar este tipo de arquitectura á hora de facer as prácticas: a) IDE con Java Enterprise Edition É a forma máis sinxela. Desenvolveríase tanto o produtor como o consumidor a través do IDE e este a través de GlassFish ou de Apache proporcionaríanos os servizos a través da rede. No campus virtual hai un executable de NetBeans 8 con todo xa instalado para non ter que configurar os módulos por separado, pero isto poderíase facer en calquera IDE. A versión de NetBeans só funciona correctamente con Java 1.8 ou inferior e no Campus Virtual só está a versión de Linux. Para despregar os servizos web están os pasos indicados no campus virtual. Debemos comezar no apartado “Creación y despliegue de servicios Web en NetBeans (I)”. Os primeiros pasos non hai que seguilos se instalamos o executable do CV, comézase en “Creating a Web Service”. Pasos: 1. New Project → Java Web → Web Application 2. Poñer nome e esas cousas. 3. En Server seleccionamos o GlassFish e en versión escollemos a versión desexada. 4. Finalizamos a creación do proxecto. 5. Botón dereito sobre o nome do proxecto no menú da esquerda → new → Web Service. 6. Poñémoslle nome ó servizo, paquete... e seleccionamos a casilla de Implementar o servizo web dende unha sesión sen estado. 7. Dámoslle a finalizar e o servizo web estaría creado. Por defecto trae o servizo Hello creado. Se unha vez creado o servizo web lle damos a Design, podemos modificar os parámetros dos servizos, crear novas operacións, borralas... Se pulsamos botón dereito sobre o nome do proxecto e pulsamos en Deploy, despregarase o noso servidor. Para comprobar que todo está ben podemos pulsar botón do servizo indicado na seguinte imaxe e levaranos a unha páxina web no navegador cuxa utilidade é probar o servizo en cuestión. Ademais da saída tamén se nos mostrarán os ficheiros XML intercambiados. Isto móstranos a sobrecarga computacional deste método, pois o intercambio deste tipo de documentos é ineficiente. 2. Práctica da arquitectura SOA 8 Para facer a proba tamén podemos crear un cliente que faga uso do servizo. Para facelo creamos un novo proxecto e facémolo da maneira da que estamos acostumados, sen escoller ningunha opción extraña, pois trátase simplemente dun proxecto no que utilizaremos o servizo. Unha vez creado o proxecto hai que crear o cliente do servizo web. Para facelo prememos botón dereito sobre o nome do proxecto do cliente → new → Web Service Client. Especificamos o documento WSDL. Se non coñecemos a URL do servidor, dámoslle a Browse (coa casilla de Project seleccionada) e xa nos busca automaticamente os nosos servizos activos. Dentro destes podemos buscar un servizo en concreto, seleccionámolo e xa se completa o campo da URL automaticamente. Se metemos a URL no navegador lévanos a unha páxina na que se describe o servizo. Se pulsamos en finalizar xa estaría o servizo dentro do cliente. Se queremos utilizalo tan só temos que premer en add no seguinte menú (no que aparecerán os servizos activos no noso proxecto) e arrastralo ata a zona do código. Crearase un método na clase que encapsulará a chamada ó servizo web. Unha vez feito isto xa podemos facer uso do servizo. Como se poden producir excepcións na chamada ó método, esta debe estar dentro dunha estrutura try-catch. Cabe destacar que o servizo podería ser usado dende calquera linguaxe de programación. 2. Práctica da arquitectura SOA 9 a) Apache CXF Isto que acabamos de ver tamén pode ser levado a cabo mediante o framework Apache CFX, sen necesidade de usar o NetBeans. Entraremos en detalle en prácticas sobre como se utiliza e as súas particularidades. Debemos escoller se utilizar este framework ou utilizar o método antes visto en NetBeans para a realización da práctica. Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 13-10-2021 Manuel Cid Domínguez, Diana Mascareñas Sande Clase 11 Temas trabajados: Introducción a los sistemas P2P (Peer-to-Peer Networks) 1. Agenda 2 ÍNDICE 1. AGENDA .............................................................................................................................3 2. ARQUITECTURA CLIENTE/SERVIDOR ...........................................................................................3 3. LIMITACIONES DE LA ARQUITECTURA CLIENTE/SERVIDOR .................................................................3 4. LA COMPUTACIÓN P2P ..........................................................................................................4 5. LA ARQUITECTURA P2P ..........................................................................................................4 6. CARACTERÍSTICAS DE LAS REDES P2P ..........................................................................................4 7. BENEFICIOS DE LAS REDES P2P .................................................................................................5 8. APLICACIONES P2P ...............................................................................................................5 9. SISTEMAS P2P POPULARES ......................................................................................................6 A) NAPSTER: ....................................................................................................................6 B) GNUTELLA ...................................................................................................................7 C) KAZAA ........................................................................................................................8 D) FREE RIDING.................................................................................................................9 E) ANONIMATO ................................................................................................................9 F) FREENET ................................................................................................................... 10 10. P2P ESTRUCTURADO ......................................................................................................... 11 A) DHT: DISTRIBUTED HASH TABLES .................................................................................... 11 B) INTERFAZ GENÉRICA DHT .............................................................................................. 12 C) APLICACIONES DHT ..................................................................................................... 12 D) PROPIEDADES ATRACTIVAS DE DHT .................................................................................. 12 E) PROTOCOLOS DE ENRUTAMIENTO DE DHT ......................................................................... 13 F) CHORD API ............................................................................................................... 13 G) CÍRCULO IDENTIFICADOR DE CHORD ................................................................................. 14 1. Agenda 3 1. AGENDA - Descripción general de P2P: características y beneficios - Sistemas P2P no estructurados: Napster (Centralizado), Gnutella (Distribuido), Kazaa/Fasttrack (Súper-pares) - Sistemas P2P estructurados (DHTs): Chord, Pastry, CAN - Conclusiones 2. ARQUITECTURA CLIENTE/SERVIDOR Nosotros estamos acostumbrados a trabajar siguiendo el modelo Cliente/Servidor, que es conocido, potente, fiable y exitoso. Lo que tenemos en él es una clasificación de los elementos que participan en la comunicación ya sea como clientes o como servidores. A su vez, hay que tener en cuenta que el servidor espera las conexiones y el cliente el que las inicia. Se ha implementado este modelo en numerosos protocolos de Internet: WWW (HTTP), FTP, servicios web… 3. LIMITACIONES DE LA ARQUITECTURA CLIENTE/SERVIDOR Este modelo posee una serie de hándicaps: - La escalabilidad es difícil de lograr: a medida que el número de clientes crece, nos vemos obligados a aumentar la potencia del servidor, pudiendo ocurrir que, llegado un punto, no tuviéramos un servidor capaz de atender a todos los clientes. - Presenta un único punto de fallo: si el servidor falla o desaparece, el servicio dejaría de proporcionarse automáticamente. - Requiere administración: es necesario que alguien lleve periódicamente la gestión de dicho servidor para que opere correctamente. - Recursos no utilizados en la red. Los clientes muchas veces tienen potencia de cálculo que no se está utilizando. Los sistemas P2P intentan abordar estas limitaciones 4. La computación P2P 4 4. LA COMPUTACIÓN P2P - Es el intercambio de recursos informáticos y servicios por intercambio directo entre sistemas. - Estos recursos y servicios incluyen el intercambio de información, ciclos de procesamiento, almacenamiento en caché y almacenamiento en disco de archivos. Nosotros estamos acostumbrados a que intercambien archivos, pero, por ejemplo, un sistema grid podría ser entendido como un sistema P2P que reparte la CPU entre múltiples sistemas. - La computación P2P se aprovecha de los recursos de los clientes: capacidad de cálculo, alimentación, almacenamiento y conectividad de red, permitiendo a los usuarios aprovechar su poder colectivo para el \"beneficio\" de todos y aumentar la escalabilidad total del sistema. 5. LA ARQUITECTURA P2P - Todos los nodos son ambos clientes y servidores al mismo tiempo. Además, son routers, es decir: cualquier nodo dentro de un sistema P2P puede recibir información de otro nodo y redirigirla a un tercero. - Proporcionar y consumir datos - Cualquier nodo puede iniciar un diálogo - Sin datos fuente centralizados : \"La forma definitiva de democracia en Internet\", \"La máxima amenaza para protección de derechos de autor en Internet\" 6. CARACTERÍSTICAS DE LAS REDES P2P - Los clientes también son servidores y routers o Los nodos aportan contenido, almacenamiento, memoria, CPU - Los nodos son autónomos (no hay administración, nadie se encarga de que los nodos operen correctamente, se reconfiguran automáticamente) - La red es dinámica: los nodos entran y salen del red en cualquier momento, sin que el sistema se vea alterado - Los nodos colaboran directamente entre sí (no a través de conocidos servidores) - Los nodos tienen capacidades muy diversas (no todos la misma potencia de cálculo, capacidad de almacenamiento… pero pueden colaborar entre ellos). 7. Beneficios de las redes P2P 5 7. BENEFICIOS DE LAS REDES P2P - Uso eficiente de recursos o Ancho de banda no utilizado, almacenamiento, potencia de procesamiento en el borde de la red - Escalabilidad o Los consumidores de recursos también donan recursos o Los recursos agregados crecen naturalmente con la utilización - Fiabilidad o Réplicas: se puede recuperar la información perdida o Distribución geográfica o No hay un punto único de fallo - Facilidad de administración o Los nodos se autoorganizan o No es necesario implementar servidores para satisfacer la demanda (confrontar escalabilidad) o Tolerancia a fallos, replicación y equilibrio de carga integrados 8. APLICACIONES P2P Podríamos preguntarnos si los siguientes ejemplos son sistemas P2P: - Compartición de archivos (Napster, Gnutella, Kazaa) → lo son, sin ninguna duda. - Juegos multijugador (Unreal Tournament, DOOM) → lo son, cuando se juega con la PlayStation en un juego de carreras de coches, la instancia de juego de un jugador actúa con un nodo P2P, y va a dialogar con otros nodos equivalentes de la red (no tiene por qué ser a través de un servidor). Dependerá de la implementación que sea P2P o basado en Cliente/Servidor. - Aplicaciones colaborativas (ICQ, shared whiteboard) → podrían ser sistemas P2P, dependerá de la implementación. Otra opción sería la comunicación multicast. - Computación distribuida (Seti@home) → presento un problema muy grande que hay que resolver y propongo a un grupo de usuarios que compartan tiempo de CPU conmigo para resolverlo. Tengo un servidor que subdivide ese problema en otros más pequeños y se los va dando a los clientes. Cuando estos terminan, proporcionan el resultado. Para garantizar que todo va bien, se suele dar el mismo trozo de problema a dos o más ordenadores, y solo se acepta el resultado cuando todos los ordenadores coinciden en este. Seti@home utiliza esta estrategia para analizar la totalidad del espectro electromagnético en astronomía con la idea de buscar señales de vida inteligente. A esto NO le llamaríamos 9. Sistemas P2P populares 6 P2P, porque realmente tenemos un modelo cliente-servidor. Tenemos un servidor que divide el trabajo a cada cliente y estos van al servidor a reclamar más carga de trabajo y, a medida que terminan, van enviando el resultado al servidor. No hay un diálogo entre clientes propiamente. - Redes ad-hoc 9. SISTEMAS P2P POPULARES Como ya hemos dicho, existen infinidad de sistemas conocidos para P2P. La mayoría han surgido para el intercambio de archivos (vídeos, música…): es el caso de Napster, Gnutella, Kazaa, Freenet. Napster fue el primero de los sistemas “comerciales” masivamente adoptado por el público. - Intercambio de archivos a gran escala. o El usuario A tiene archivos (música, video, etc.) que quiere compartir con otros usuarios, así que se conecta al sistema P2P o El usuario B se conecta a la red, busca archivos (veremos cómo) y descarga archivos directamente del usuario A . Si el archivo es muy grande, se particiona y se pide que cada trozo lo haga uno de los posibles clientes que tenga esa copia del archivo, y agilizar la carga de este. - Problemas de infracción de derechos de autor a) NAPSTER: - Una forma de compartir archivos de música con otros - P2P no estructurado. P2P porque los nodos dialogan entre sí para buscar información, pero puede haber un nodo especial que es el servidor. - Los usuarios cargan su lista de archivos a Servidor de Napster. Cada usuario tiene una carpeta con los archivos que quiere compartir. Si me quisiera conectar, lo haría con el servidor, diciendo “soy a, mi dirección IP es b, y mi lista de archivos a compartir es c”. Generalmente lo que mandaría es el nombre de los archivos y un código de redundancia cíclica que identifica al archivo. - Envías consultas a Napster servidor para archivos de interés - Búsqueda de palabras clave (artista, canción, álbum, tasa de bits, etc.) 9. Sistemas P2P populares 7 - El servidor Napster responde con dirección IP de usuarios con coincidencia archivos. Identifica claramente todas las máquinas que contienen dicho archivo. - Te conectas directamente al usuario que contenga dicho archivo para descargarlo. - Napster tuvo muchos problemas legales porque se compartía mucha información que tenía derechos de autor, por lo que llegó un momento en el que un juez en EEUU dijo que Napster tenía que acabarse: apagaron el servidor, desapareciendo la red como consecuencia. A día de hoy, Napster sigue funcionando, pero de forma legal, como un suministrador de archivos multimedia, pero los clientes pagan una cuota mensual para utilizarla. Por un lado, la presencia del servidor de Napster nos garantiza que los archivos que obtenemos son los correctos. Tiene cuellos de botella debido a la escalabilidad: si aumenta el número de clientes indefinidamente, el servidor debe crecer. No es una parte demasiad crítica ya que las labores del servidor no son demasiado complejas. Tiene un único punto de fallo. Es susceptible a ataques de denegación de servicios: yo podría crear uno o más clientes que atacaran al servidor, que yo estuviera realizando peticiones, y mientras atiende a las mías, no atiende a las del resto. La búsqueda es centralizada, pero el intercambio de archivos es P2P. Este es un ejemplo clarísimo de una aplicación que se rige por varios modelos de computación distribuida: por un lado el cliente-servidor, cuando los clientes dialogan con el servidor para hacer una petición de ciertos archivos, y por otro lado es P2P, para explicar el intercambio de información entre los distintos nodos cliente. b) GNUTELLA - Comparte cualquier tipo de archivos (no solo música) - Búsqueda descentralizada a diferencia de Napster - Le preguntas a tus vecinos para archivos de interés - Los vecinos preguntan a sus vecinos, etc. (Función de router) Si se encuentra el archivo, la máquina que lo contiene dialoga directamente con la máquina que lo buscaba. 9. Sistemas P2P populares 8 o Para evitar profundizar demasiado en el árbol de búsqueda, habrá un TTL (Time To Live) de límite, de forma que si pasa ese tiempo sin encontrar el archivo, se abandona la búsqueda. - Si se apaga uno de los nodos, sea el que sea, la red sigue funcionando: impidiendo que nadie pueda echar abajo la red. - Principal hándicap: tengo que tener conocimiento a priori de otras máquinas que pertenezcan a la red Gnutella es descentralizado, al contrario que Napster: no tiene un único punto de fallo, no es tan susceptible a ataques de denegación de servicio como Napster, pero no puede garantizar que los resultados sean correctos: cualquiera en la red podría decir que tiene el archivo, siendo uno distinto al que buscaba la máquina . Además, se debe tener un conocimiento previo de quiénes son los vecinos. Por otra parte, son susceptibles al desbordamiento de búsquedas: yo podría estar emitiendo búsquedas con un TTL muy grande buscando cosas que no existen, por ejemplo. Si se hacen muchas búsquedas así, se vuelca a muchos nodos de la red en este proceso, sin que se vaya a obtener ningún resultado. c) KAZAA - Híbrido de Napster centralizado y Gnutella descentralizado. Se intenta buscar “lo mejor de ambos mundos” - Los súper-peers actúan como centros de búsqueda locales o Cada súper-peer es similar a un servidor Napster para una pequeña parte de la red. Contienen un registro con todos los archivos y qué máquinas contienen esos archivos. Son responsables de una zona geográfica. Para poder estar enlazado a la red de Kazaa, necesito conocer al menos uno de los servidores. Me conecto al servidor, hago las peticiones necesarias y recibo mi respuesta. o El sistema elige automáticamente a los supercompañeros en función de sus capacidades (almacenamiento, ancho de banda, etc.) y disponibilidad (tiempo de conexión). Si tengo una máquina conectada las 24 horas del día los 7 días de la semana, los 365 días del año, y estoy conectado a través de fibra óptica, con un buen ancho de banda… es muy probable que mi máquina, en poco tiempo, termine siendo un súper-peer. Cuando una máquina progresa a súper-peer, automáticamente avisa al resto de los servidores de su nueva situación, y se intercambian su base de datos (todos los servidores tienen la misma copia de la base de datos). - Los usuarios cargan su lista de archivos a un súper-peer 9. Sistemas P2P populares 9 - Los súper-peers intercambian listas de archivos periódicamente - Envía consultas a un súper-peer para obtener archivos de interés Se persigue, por un lado, el funcionamiento de Napster, que es intuitivo y funciona muy bien, y por otro lado, que no se pueda echar la red abajo, mediante la existencia de múltiples servidores (solo ocurriría apagando todos los servidores a la vez). d) FREE RIDING *****El profesor ignora la diapositiva diciendo literalmente “esto nada”****** - Las redes de intercambio de archivos dependen de que los usuarios compartan datos - Dos tipos de conducción libre o Descargar, pero no compartir ningún dato o No compartir ningún dato interesante - En Gnutella o 15% de los usuarios contribuyen con el 94% del contenido o el 63% de los usuarios nunca respondió a una consulta ▪ No tenía datos \"interesantes\" e) ANONIMATO Estar conectado a una red P2P no significa tener anonimato. La mayor parte de las soluciones basados en este sistema, no proporcionan anonimato. - Napster, Gnutella, Kazaa no proporcionan anonimato o Los usuarios saben de quién están descargando o Otros saben quién envió una consulta Las fuerzas de seguridad cuando persiguen, por ejemplo, pornografía infantil o cosas por el estilo, lo hacen de una forma muy sencilla pero efectiva: cogen un archivo que saben que es muy interesante para un determinado público, lo meten en uno de sus servidores y lo ofrecen (pudiendo ser como un súper-peer). Así, recibirán consultas, identificando fecha y hora de estas y dirección IP. Con esta dirección, pueden acceder al suministrador de acceso a internet y solicitar la dirección física (en España, el suministrador de acceso a internet está obligado a mantener el registro de los últimos 6 meses). - Freenet: garantiza el anonimato o Diseñado para proporcionar anonimato entre otras características 9. Sistemas P2P populares 10 f) FREENET Garantiza el anonimato haciendo que las consultas se enruten a través de los distintos nodos. Es decir, no se hace la consulta directamente sobre el nodo del que quiero obtener la información, sino que la hago sobre un nodo determinado y dicho nodo hace una consulta en mi nombre a un tercer nodo, y así sucesivamente. Así, cuando yo recibo una consulta, no sé si es el nodo que la creó inicialmente, o uno intermedio. Los flujos de datos circulan en la ruta inversa de la consulta: - Imposible saber si un usuario está iniciando o reenviando una consulta - Imposible saber si un usuario está consumiendo o reenviando la información Consultas “inteligentes” - Las consultas se encaminan hacia el peer correcto mediante el descubrimiento incremental - Un ejemplo lo vemos a continuación: - Suponemos que el nodo a quiere pedir una determinada información que tiene el nodo d. - Primero, el nodo a hace una consulta al nodo b. - El nodo b tiene conexión con los nodos c, e y f. - Primero, el nodo b hace la petición en nombre del nodo a al nodo c, y este le responde que no tiene dicha información. - Después, el nodo c hace la petición en nombre del nodo a al nodo e, el cual está conectado con f y con d. - El nodo d redirige la petición al nodo f, que conectará con el nodo b, pero detectará la producción de un ciclo, por lo que se rechaza la consulta. - Así, vuelve al nodo e a realizar la consulta, el cual va hasta el nodo d, que sí contiene la información buscada. - Del nodo d, la información va hasta a, pasando por e y por b. 10. P2P Estructurado 11 10. P2P ESTRUCTURADO Es la segunda generación de sistemas P2P. Realmente se usa fundamentalmente a nivel de investigación e industrial, pero a nivel personal prácticamente no se utiliza. En este tipo de redes lo que se busca es que sean autoorganizadas, que tengan un balance de carga (importante, en todas las redes que hemos visto hasta ahora no está garantizada esta cualidad) y que sean tolerantes a fallos. Serán redes escalables, ya que se garantiza que, ante un determinado número de saltos, se encontrará la respuesta (la mayor diferencia con los P2P no estructurados, donde no hay garantías de tiempo de ejecución de una consulta). Estos sistemas están basados en una tabla hash distribuida. Esta es una memoria subjetiva que se consulta por contenido, pero tiene una característica a destacar: su base de datos no está ubicada en un único nodo, sino que está distribuida entre varios. De esta forma, el sistema P2P es un conjunto de nodos que ofrecen un API que nos permite acceder a esa tabla hash distribuida y, cuando busco información en el sistema P2P, lo haré contra esa tabla hash distribuida. Buscaré el archivo por un nombre, mediante el cual accederé a su contenido. a) DHT: DISTRIBUTED HASH TABLES Es la versión estructurada de una estructura de datos de una tabla hash. Tendremos pares de elementos de tipo (clave, valor), donde normalmente la clave será el nombre del fichero, y el valor su contenido. El objetivo de estos sistemas es realizar las operaciones de inserción, búsqueda y borrado de pares de la forma más eficiente posible. De esta forma, cada nodo de la red, será responsable de un subconjunto total de posibles pares clave-valor. Cuando se dice que hay un balanceo de carga, es porque ese subconjunto de pares clave-valor asignados a un determinado nodo, será más o menos el mismo para todos los nodos, ya que todos serán responsables de un mismo número (aproximado) de entradas dentro de la tabla hash. La operación que nosotros buscamos es encontrar el nodo responsable para una determinada clave que uso para buscar el archivo. El sistema me dirá en qué nodo se encuentra el valor correspondiente a la clave, realizando un mapeo entre la clave y el nodo e forma que se consigue más eficiencia en las operaciones. 10. P2P Estructurado 12 b) INTERFAZ GENÉRICA DHT Identificador de nodo: secuencia de m-bits (en función de cuántos nodo tenga necesitaré más o menos bits) que será equivalente a una IP. Clave: secuencia de bytes que representa el nombre del fichero Valor: secuencia de bytes que representa el contenido del fichero Habrá dos operaciones: - Inserción: put (key, value). Almacena dicha pareja clave-valor en el nodo correspondiente responsable de la clave, según un determinado algoritmo. - Obtención del valor: value = get (key). Dada una clave devuelve su valor asociado desde el nodo correspondiente. c) APLICACIONES DHT Muchos servicios pueden ser construidos sobre una interfaz DHT - Compartición de archivos - Almacenamiento de archivos - Bases de datos - Nombramiento, descubrimiento de servicios - Servicio de chat - Comunicación basada en rendezvous (reunión) - Publica-suscribe d) PROPIEDADES ATRACTIVAS DE DHT Una de las características que busco es que la proyección de las claves sobre los nodos sea lo más equitativa posible (los nodos tienen más o menos el mismo número de claves). Cada nodo solo tiene información al respecto de unos pocos nodos, es decir, ningún nodo contiene toda la información de toda la red. Los mensajes podrán ser enrutados a un nodo de forma eficiente. Si quiero insertar una clave, dialogaré con un nodo, pero si este no es el responsable de dicha clave, buscará otro nodo dentro de sus nodos conocidos para ver si alguno es el responsable de realizar dicha operación, y así sucesivamente hasta encontrar el nodo adecuado. La inserción/eliminación de nodos debe afectar a muy pocos nodos. 10. P2P Estructurado 13 e) PROTOCOLOS DE ENRUTAMIENTO DE DHT DHT es una interfaz genérica, de la cual hay muchas implementaciones posibles (la mayoría de carácter experimental, a nivel académico): - Chord [MIT] - Pastry [Microsoft Research UK, Rice University] - Tapestry [UC Berkeley] - Content Addressable Network (CAN) [UC Berkeley] - SkipNet [Microsoft Research US, Univ. of Washington] - Kademlia [New York University] - Viceroy [Israel, UC Berkeley] - P-Grid [EPFL Switzerland] - Freenet [Ian Clarke] Estos sistemas son conocidos como sustratos de enrutamiento P2P, es decir, son soportes de aplicaciones más complejas. f) CHORD API Sistema DHT más simple Identificador de nodo: secuencia de m-bits (hash que depende de un identificador único de la máquina, como la IP) (misma longitud que el id de la clave) Clave: secuencia de bytes que representa el nombre del fichero (misma longitud que el id del nodo) Valor: secuencia de bytes que representa el contenido del fichero API - Insert (key, value). Almacena la pareja en el nodo correspondiente - Lookup (key). Localiza una clave dentro de la red. - Update(key, newval). Actualiza esa pareja en un nodo que ya contiene la clave - Join (n). Une un nodo. Si soy un nodo, le paso mi identificador (n) y me uno a la red. - Leave(). Sacar un nodo de la red. 10. P2P Estructurado 14 g) CÍRCULO IDENTIFICADOR DE CHORD Chord se organiza de forma circular. Los nodos tienen sus identificadores. Cada nodo tendrá una tabla que representa a sus nodos posteriores. Función hash asegura incluso la distribución de los nodos y claves en el círculo. Tamaño de la tabla: O (logN) Si yo estoy hablando del nodo 8 por ejemplo, iré incrementando el valor de la clave en potencias de 2. Estoy en 8 y le sumo 20 = 9. 9 en este caso no existe, así que habrá que ir al nodo posterior: el 14. 8 + 2 = 10, y 8 + 4 = 12, también delegamos en n14. 8 + 8 = 16, supera 14, por lo que pasa al siguiente nodo que, en este caso, es n21. Haríamos esto sucesivamente. Si quisiéramos hacer 8 + 64, se saldría del rango en este caso particular, es decir, no habría nodos para representarlo. Cada uno de los nodos va a tener su tabla. Cuando hago una consulta de la clave 54, por ejemplo, tengo que buscar primero, el nodo más grande que no supere el 54, en este caso iría desde el nodo 8 al 42. Este nodo tiene su tabla, de modo que, si estoy consultando el nodo 54, saltará al nodo 51. La única entrada que tiene este nodo sin superar el valor de 54 es 51 + 1 = 52, por lo que nos iríamos a n56. Por ello, el nodo 56 tiene que ser, necesariamente, el encargado de la clave 54. Es ahí cuando se detiene el proceso. El número de saltos realizados está limitado. La complejidad de este algoritmo es de O(log2 N), por lo que es bastante eficiente. En muy pocos saltos, se recorrerá una gran cantidad de nodos. Grado en Ingeniería Informática 3º curso – 3º cuatrimestre Asignatura 18-10-2021 Pablo Martínez González, Roberto de la Iglesia Rodríguez Clase 12 Temas trabajados: Continuación sistemas P2P y Sistemas de Mensajes 1. Chord 2 Índice 1. ......................................................................................................................................... ￼Chord ........................................................................................................................................................ 3 2. ............................................................................................................................................. Pastry ........................................................................................................................................................ 3 3. ................................................................................................................................................. Can ........................................................................................................................................................ 3 4. .................................................................................................................................... P2P Review ........................................................................................................................................................ 4 5. ..................................................................................................................................Conclusiones ........................................................................................................................................................ 4 6. ..................................................................................................... Tema 7. Sistemas de mensajes ........................................................................................................................................................ 4 1. Chord 3 1. Chord Chord Finger Table- Key Location Saltaremos a aquel nodo que sea igual o menor al de la clave que quiero buscar. Por ejemplo, si quiero buscar el nodo 54, busco el nodo más grade inferior a 54, en este caso sería el 42 al cual se produce el salto. A partir de las tablas del 42, obtenemos que el nodo más cercano es el 51. Este tiene solo una entrada, 51+1 por lo que nos iríamos al 56. El único sitio donde puede estar esta clave es en el nodo 56. Chord Properties - En un sistema de n nodos y k claves, con alta probabilidad: - cada nodo recibe n/k claves. - Cada nodo mantiene información de (logN) otros nodos. - Las búsquedas son de logN saltos. - No garantiza respuesta. - Puede no haber consistencia entre replicas. - Localidad espacial muy pobre. De un nodo al siguiente no hay ninguna relación ni garantía de que este próximo físicamente. 2. Pastry - Tiene una interfaz similar a chord. - Facilita localidad espacial. - Los saltos entre nodos siempre se van a producir. - Cambios en un único bit indican que los nodos están próximos físicamente - Cada salto siempre implica el cambio de un bit, y por eso tienen localidad espacial 3. Can - Busca proximidad a un sistema de coordenadas d-dimensional. - Cada nodo pertenece a una zona en el espacio. - Las claves se corresponden a un punto en el espacio. Los nodos frontera conocen los nodos frontera de otras zonas. 4. P2P Review 4 4. P2P Review Son sistemas estructurados y no estructurados, además de centralizados. Las dos funciones claves de P2P son: - Sharing content. Compartir información. - Finding content. Encontrar información Ambas de la forma más sencilla posible. Sharing content - Transferencia directa entre peers - Estrucuturado y no estructurado. - Réplica automática de los datos Finding content - Centralizado (Napster) - Descentralizado (Gnutella) - Garantías probables (DHTs) 5. Conclusiones - P2P conecta dispositivos por internet. - Solo se utilizan a nivel experimental o a nivel industrial. - Otras aplicaciones diferentes a la compartición de archivos están siendo desarrolladas. 6. Tema 7. Sistemas de mensajes → Contexto histórico. 6. Tema 7. Sistemas de mensajes 5 - A partir de los 60, se produce la incorporación de mainframes para operaciones críticas. - Las opciones de entrada eran reducidas. - La interconectividad era inexistente. - No es posible un procesamiento paralelo - En los años 70, se permite el acceso a través de terminales a diferentes usuarios. - Se permite acceso concurrente. - Se posibilitará la comunicación entre los mainframes a través de redes. - En los 80, aparecieron las interfaces gráficas, los PC y la emulación de terminales se hizo frecuente. - La necesidad de acceder a los mainframes se vuelve creciente. - La conexión fuente y destino no era nada sencillo. - Cada hardware, protocolo y formato de datos requería un tipo diferente de adaptador. - A mayor lista de adaptadores, mayor número de versiones. - Dificultades de mantenimiento y no escalable. - Todo esto hizo que surgiera la mensajería empresarial. La mensajería empresarial persigue poder transmitir información entre sistemas heterogéneos mediante el envío de mensajes entre un sistema y otro. Esta incluye diversas tecnologías: - Llamadas a procedimientos remotos que hacen funciones de middleware (COM y CORBA) - Notificación de eventos, comunicación entre procesos y colas de mensajes, incluidos en los sistemas operativos - Categoría de middleware que ofrece un mecanismo de mensajería fiable y asíncrono, como RabbitMQ Debido a la necesidad de comunicación y transferencia de datos entre sistemas diversos surgen los MOM (Message-Oriente Middleware). Sistemas de mensajes Los sistemas de mensajes son un método de comunicación entre componentes software o aplicaciones. - Sólo es necesaria la conexión a un MOM. - Esto permite una comunicación distribuida débilmente acoplada. - Emisor y receptor no tienen que estar disponibles al mismo tiempo (asíncrono). - Emisor y receptor no necesitan saber nada uno del otro. Solo es necesario conocer formato del mensaje y destino. RabbitMQ RabbitMQ es un middleware de mensajería concebido en 2007 que permite la transmisión de mensajes soportando múltiples protocolos, como pueden ser AMQP 0-9-1, STOMP o incluso HTTP. 6. Tema 7. Sistemas de mensajes 6 El protocolo AMQP (Advanced Message Queuing Protocol) es un protocolo asíncrono que permite un envío de mensajes fiable, almacenándose estos en colas seguras hasta que el receptor se conecte o se cumpla cierto criterio y pueda recibir los mismos. Un ejemplo habitual en el que se utilice el protocolo AMQP va a contener los siguientes elementos: 1. Un mensaje que se desea enviar, el cual contiene dos partes: Por un lado, la clave, que va a contener un valor que permita al controlador que va a tratar con el mensaje conocer a que cola enviarlo y, por otro lado, el contenido en sí del mensaje. 2. Productor: Encargado de crear el mensaje y que desea enviarlo al consumidor. 3. Consumidor: El receptor del mensaje que desea enviar el productor. 4. Cola: Estructura personal de cada consumidor en el que se almacenan los mensajes de forma segura, hasta que se cumplan los criterios para consumirlos. 5. Exchange (Intercambio): Se encarga de redirigir los mensajes enviados por un productor a la cola de un receptor adecuada en base a ciertas condiciones. El productor coge el mensaje y lo manda al exchange. Al colocar todos los elementos nos queda lo siguiente: Exchange(intercambio): redirige los mensajes enviados por un productor a la cola de un receptor adecuada en base a ciertas condiciones. Coge el mensaje y lo manda a otras colas. El exchange en base a ciertos criterios decide reenviar a una o varias colas de consumidores. 1. Fanout: El mensaje se envía a todas las colas conectadas. 2. Directo: El mensaje se envía a una cola conectada, si la clave del mensaje y la clave de la conexión son exactamente iguales. 3. Topic c o Tema: Muy similar al directo, pero se admite que la clave del mensaje y la clave de la conexión sean parcialmente iguales. 4. Header o Cabecera: En lugar de comparar la clave del mensaje con la clave de la conexión, compara el valor de la cabecera del mensaje con la clave de la conexión. 5. Default o nameless: En lugar de comparar la clave del mensaje con la clave de la conexión, compara el valor de la clave del mensaje con el nombre de la cola. 6. Tema 7. Sistemas de mensajes 7 6. Tema 7. Sistemas de mensajes 8 A continuación, en esta clase, se mostraron los comandos de Instalación y de añadir dependencias con RabbitMQ que se pueden encontrar en las diapositivas del tema. Grao en Enxeñaría Informática 3º curso – 1º cuadrimestre Computación Distribuída 27-10-2021 Pablo Gil Pérez, Adrián Vidal Lorenzo, Nicolás Vilela Pérez Clase 15 Temas traballados: Tema 8: Introdución ós Sistemas Multiaxente 1. Introdución 2 Índice 1. Introdución ................................................................................................................................ 3 2. Ubicuidade ................................................................................................................................ 3 3. Interconexión ............................................................................................................................ 3 4. Intelixencia ................................................................................................................................ 3 5. Delegación ................................................................................................................................. 3 1. Introdución 3 1. Introdución (Nesta clase só se deron 10 minutos porque o resto foi parte do seminario) Os sistemas multiaxente son aqueles que teñen a capacidade de comunicarse e interactuar eles. Fai uns anos estabamos moi lonxe de poder aplicar este tipo de tecnoloxía a problemas reais, mais unha serie de feitos en base a distintas tendencias fixérono posible. Existen cinco grandes tendencias que marcaron a historia da computación: • Ubicuidade • Interconexión • Intelixencia • Delegación • Orientado a humanos 2. Ubicuidade A continua redución no custo de computación fixo posible introducir capacidade de procesamento en sitios e dispositivos que fai pouco tempo resultaría prohibitivo economicamente. Conforme a capacidade de procesamento se fai máis accesible, a complexidade (e intelixencia dalgún tipo) vólvese ubicua. Hoxe en día é posible pensar en cales serían os beneficios de integrar un procesador nun dispositivo do mundo da automoción, electrodomésticos, wearables... 3. Interconexión Os sistemas de computación de hoxe xa non se atopan sós, senón que están conectados en rede formando grandes sistemas distribuídos. Internet é un exemplo obvio, pero a interconexión entre equipos está medrando fóra dese ámbito. Desde que os sistemas distribuídos e concorrentes se converteron en norma, algúns investigadores están poñendo o acento na investigación de modelos teóricos nos que a computación se transforma nun proceso de interacción. 4. Intelixencia A complexidade das tarefas que somos capaces de automatizar ou delegar en sistemas de computación creceu continuamente. Se esta posible definición de intelixencia non é satisfactoria é, posiblemente, porque somos humanos. En xeral, pódese entender intelixencia como sinónimo de complexidade. 5. Delegación Os ordenadores están realizando cada vez máis por nós sen a nosa intervención. Estamos dándolle o control aos ordenadores, incluso en tarefas críticas. Por exemplo: aeronáutica fly-by-wire, onde o xuízo dunha máquina pode ser de maior confianza ca un piloto experto Posibles exemplos de delegación no futuro: coches fly-by-wire, sistemas intelixentes de freado, control de cruceiro que mantén a distancia respecto ao vehículo de en fronte... Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 03-11-2021 Manuel Cid Domínguez, Diana Mascareñas Sande Clase 17 Temas trabajados: Tema 8: Introducción a los sistemas multiagente 1. Introducción 2 ÍNDICE 1. Introducción .....................................................................................................................3 a) Progreso de la programación ......................................................................................4 b) Computación global ..................................................................................................5 c) ¿Hacia dónde nos lleva todo esto? ..............................................................................5 d) Interconexión y distribución .......................................................................................5 e) Ciencias de la Computación .......................................................................................5 f) Una posible definición de agentes...............................................................................6 2. Sistemas multiagente ........................................................................................................6 a) Diseño de agentes y sociedades ..................................................................................6 b) Sistemas multiagente .................................................................................................6 c) Control de vehículos espaciales ..................................................................................7 d) Agentes autónomos para tareas especializadas.............................................................7 e) Control de tráfico aéreo .............................................................................................8 f) Agentes de internet ....................................................................................................8 g) Cuestiones de investigación .......................................................................................9 h) Los sistemas multiagente es un campo multidisciplinario .............................................9 i) Algunos puntos de vista sobre el campo .................................................................... 10 j) Objeciones a los MAS ............................................................................................. 10 k) Sistemas MultiAgente (SMA) .................................................................................. 11 1. Introducción 3 1. Introducción Existen cinco grandes tendencias que han marcado la historia de la computación: ubicuidad, interconexión, inteligencia, delegación y orientado a humanos. Ubicuidad - La continua reducción en el coste de computación ha hecho posible introducir capacidad de procesamiento en sitios y dispositivos que hace poco tiempo resultaría prohibitivo económicamente. - Conforme la capacidad de procesamiento se hace más accesible, la complejidad (e inteligencia de algún tipo) se vuelve ubicua. - Hoy en día es posible pensar en cuales serían los beneficios de integrar un procesador en un dispositivo como … (automoción, electrodomésticos, dispositivos vestibles, etc.) Hace años la única forma que teníamos de identificar un producto era con un código de barras (era un dispositivo pasivo). Ahora las etiquetas RFID llevan un solenoide que se activa remotamente como consecuencia de una señal electromagnética. Dicho solenoide genera una señal de energía eléctrica para alimentar a un procesador durante un tiempo limitado y llevar a cabo un tipo de acción. Normalmente se utiliza para identificar productos, pero también se podría usar para una firma digital, entre otros. Interconexión Han surgido numerosos estándares de comunicación (física e inalámbrica) de forma que cada vez es más fácil interconectar los equipos. Un ejemplo es la domótica. - Los sistemas de computación de hoy ya no se encuentran solos, sino que están conectados en red formando grandes sistemas distribuidos. - Internet es un ejemplo obvio, pero la interconexión entre equipos está creciendo fuera de este ámbito. - Desde que los sistemas distribuidos y concurrentes se han convertido en norma, algunos investigadores están poniendo el acento en la investigación de modelos teóricos en los que la computación se transforma en un proceso de interacción. Inteligencia Hace años, se incluía un microcontrolador de 8 bits en un chip. Hoy en día, por el mismo precio o incluso inferior, se puede obtener uno de 16 o 32 bits. 1. Introducción 4 - La complejidad de las tareas que somos capaces de automatizar o delegar en sistemas de computación ha crecido continuamente. - Si esta posible definición de inteligencia no es satisfactoria es, posiblemente, porque somos humanos. En general, se puede entender inteligencia como sinónimo de complejidad. Delegación Hoy en día, siempre que es posible se realizan controles electrónicos. La mayor parte de los sistemas informáticos que se venden a lo largo del año, son equipos que interaccionan con el mundo real (con sensores…). - Los ordenadores están realizando cada vez más por nosotros sin nuestra intervención. - Estamos dando el control a los ordenadores, incluso en tareas críticas. - Un ejemplo: aeronáutica fly-by-wire, donde el juicio de una máquina puede ser de mayor confianza que un piloto experto - Posibles ejemplos de delegación en el futuro: coches fly-by-wire, sistemas inteligentes de frenado, control de crucero que mantiene la distancia con respecto al vehículo de enfrente… Orientado a humanos Estos sistemas cada vez más, están pensados para interactuar con seres humanos (por voz u otros medios). - Esta es una tendencia que pretende alejarnos de formas de programar orientadas a las máquinas mediante conceptos y metáforas que reflejan más fielmente la forma en la que vemos y entendemos el mundo. - Los programadores (y usuarios) se relacionan con las máquinas de manera diferente. - Los programadores conceptualizan e implementan software en términos de abstracciones de más alto nivel más orientadas a los humanos. a) Progreso de la programación La programación ha progresado a través de los siguientes hitos: código máquina→ lenguaje ensamblador→ lenguajes de programación independientes de la máquina→ subrutinas→ procedimientos y funciones→ tipos de datos abstractos→ objetos; hacia agentes. Con Jade (entorno que vamos a utilizar) cambia un poco el paradigma de la programación. Cambiará la forma de plantear el desarrollo de la aplicación. 1. Introducción 5 b) Computación global - ¿Qué tipos de técnicas podemos necesitar para gestionar sistemas compuestos de 1010 procesadores? “Hace 50 años WhatsApp era ciencia ficción”. - ¡Ojo! Este escenario no es ciencia ficción. - Cientos de millones de personas conectados a través de e-mail un día pareció “ciencia ficción”… - Asumamos que los modelos actuales de desarrollo de software no pueden gestionar esto… c) ¿Hacia dónde nos lleva todo esto? - La delegación e inteligencia implican la necesidad de construir sistemas de computación que puedan actuar efectivamente en lugar de nosotros y que van a luchar por nuestros intereses, que pueden estar en conflicto con los intereses de otros usuarios de otro sistema. - Esto implica: o La capacidad de los sistemas de cómputo de actuar de forma independiente o La capacidad de los sistemas de cómputo de actuar de una forma que defienda mejor nuestros intereses cuando interactúa con otros humanos o sistemas De alguna forma, nuestro módulo software va a tener que competir por unos recursos que otros módulos de características similares (como hacemos los humanos cuando dialogamos entre nosotros). Por tanto, tiene que haber una forma de coordinarse. d) Interconexión y distribución - La interconexión y distribución se han convertido en elementos clave de las ciencias de la computación e inteligencia artificial - Pero la interconexión y distribución, unida a la necesidad de que los sistemas representen nuestros intereses, implica sistemas que puedan cooperar y llegar a acuerdos (o incluso competir) con otros sistemas que tienen diferentes intereses (de forma similar a lo que hacemos nosotros con otras personas) e) Ciencias de la Computación - Este tipo de cuestiones no eran estudiadas en seminarios de Ciencias de la Computación hasta recientemente - Todas estas tendencias han dado lugar a un nuevo campo en las Ciencias de la Computación: sistemas multiagente 2. Sistemas multiagente 6 f) Una posible definición de agentes Un agente es un sistema de computación capaz de realizar una acción de forma independiente a favor de su dueño. Esto significa que solo dialogan con el usuario para recibir pautas de comportamiento y para dar un resultado. Dialoga con otros agentes por sí mismo. 2. Sistemas multiagente Un sistema multiagente es un sistema que consta de un número de agentes que interactúan entre sí. En el caso más general, esto agentes actuarán representado a usuarios con diferentes objetivos y motivaciones. Para que interactúen de forma apropiada, necesitan la habilidad de cooperar, coordinarse, y negociar entre ellos, de forma similar a como lo hace la gente. Los expertos dicen que la capacidad de diálogo propio de agentes es su característica más destacada. a) Diseño de agentes y sociedades Surgen las siguientes cuestiones: - ¿Cómo podemos construir agentes capaces de tomar acciones de forma independiente y autónoma, para que puedan llevar a cabo con éxito las tareas que hemos delegado en ellos? - ¿Cómo podemos construir agentes que sean capaces de interactuar (cooperar, coordinarse, negociar) con otros agentes de forma que puedan llevar a cabo las tareas que hemos delegado en ellos, sobre todo cuando hay otros agentes que no comparten los mismos intereses y/u objetivos? - El primer problema es el del diseño de agentes, y el segundo el del diseño de sociedades. b) Sistemas multiagente Debemos tener en cuenta lo siguiente: - ¿Cómo surge la cooperación en sociedades de agentes que tienen sus propios intereses? Una de las técnicas más reconocidas a la hora de llegar a un acuerdo entre agentes es la subasta. - ¿Qué tipo de lenguajes pueden los agentes utilizar para comunicarse? - ¿Cómo pueden los agentes reconocer un conflicto y, en cualquier caso, llegar a un acuerdo? (Podríamos acudir a la subasta de nuevo) - ¿Cómo pueden agentes autónomos coordinar sus actividades de forma que alcancen metas de forma cooperativa? 2. Sistemas multiagente 7 A pesar de que todas estas cuestiones son analizadas en parte por otras disciplinas (economía y ciencias sociales), lo que hace diferente al campo de los sistemas multiagente es el hecho de que se enfatiza que los agentes son entidades computacionales, capaces de procesar información. c) Control de vehículos espaciales Ejemplos de soluciones reales basadas en sistemas multiagente que fueron pioneras en su momento: - Cuando una nave espacial no tripulada realiza un largo viaje desde la tierra a planetas lejanos, normalmente se necesita una gran cantidad de personas para vigilar su progreso y decidir qué hacer en el caso de que surjan eventos inesperados. Esta forma de trabajar solo es viable en el momento del despegue (porque la señal tarda milisegundos en llegar), pero a medida que el cohete se aleja, esta se vuelve más costosa y, si las decisiones deben ser tomadas rápidamente, simplemente no es práctico. Por esas razones, organizaciones como la NASA están investigando la posibilidad de construir naves espaciales más autónomas, proporcionándoles mayores capacidades y responsabilidades. - Este es el caso de la misión Deep Space 1(objetivo: acercarse a un asteroide y obtener información del mismo. Era un proyecto de investigación de bajo coste, de modo que aprovecharon la ocasión para probar nuevas tecnologías (no les suponía un gran problema si el cohete se perdía, por ejemplo). Una de las medidas que tomaron fue compartimentar la sonda en múltiples subsistemas, donde cada uno se comportaba como un agente. De esta forma, si uno de estos fallaba, la sonda era capaz de reconfigurarse de forma autónoma para continuar con su trabajo. Explicación del profesor: a día de hoy, muchos procesos se siguen realizando manualmente (p.e: los primeros rovers de marte). Sin embargo, los sistemas de navegación autónoma se están introduciendo cada vez más (los rovers de ahora pueden detectar obstáculos, tomar decisiones… permitiendo moverse más metros en menos tiempo). d) Agentes autónomos para tareas especializadas El DS1 es un ejemplo de tipo general. Los agentes (y su implementación física en la forma de robots) juegan un papel importante en situaciones de alto riesgo imposibles para humanos. El Deep Space 1 salió de Cabo Cañaveral el 24 de octubre de 1998. Durante su misión, ha verificado 12 tecnologías avanzadas y de alto riesgo en el espacio. En su misión se encontró con el cometa Borrelly y envió las mejores imágenes hasta el momento que tenemos de un comenta. La nave fue retirada el 18 de diciembre de 2001. Su página web es: http://nmp.jpl.nasa.gov/ds1/ 2. Sistemas multiagente 8 grado de autonomía difiere dependiendo de la situación (el control remoto humano puede ser una alternativa, pero no siempre). Cada vez más se están introduciendo sistemas de navegación autónoma. e) Control de tráfico aéreo - Un sistema de control de tráfico de repente falla, dejando a los vuelos en la vecindad del aeropuerto que controla sin soporte. Un sistema de control autónomo del tráfico aéreo reconocería el fallo de uno de sus vecinos y cooperaría para gestionar los vuelos afectados. - En este caso los sistemas toman la iniciativa. - Los agentes cooperan para solucionar un problema más allá de las capacidades de cualquier agente individual. Explicación del profesor: los controladores aéreos deben ser capaces de tener en mente la situación actual del cuadrante del que es responsable. De modo que, si de repente, hay un fallo y desaparece el sistema de control, por radio podrá conectarse con cada uno de los aviones y dar indicaciones para que no se choquen, guiando a cada uno. Supongamos la siguiente situación: tenemos el aeropuerto de Santiago, de Coruña y de Vigo. Cada uno tiene su zona de radar, y posiblemente se solapen parcialmente entre ellas. Supongamos que, por un momento dado, desaparece el control aéreo de Santiago. Se plantea: los sistemas de control tanto de Coruña como de Vigo, funcionan como agentes, dialoguen entre ellos y se repartan de forma automática los vuelos. Así, un determinado control se hará cargo de un conjunto de vuelos: Coruña → de Santiago hacia el norte; Vigo → de Santiago hacia el sur. Esto a día de hoy no es viable, tiene que haber una persona humana que se haga cargo de los vuelos. f) Agentes de internet La búsqueda en Internet de la respuesta a una pregunta concreta puede ser un proceso largo y tedioso. ¿Por qué no permitir a un programa –un agente- que realice búsquedas por nosotros? El agente recibiría una pregunta que necesitaría unir diversas piezas de información procedentes de varios sitios en Internet. Se producirá un fallo cuando una fuente de información no está disponible (posiblemente debido a un fallo en la red) o cuando no se pueden obtener resultados - Los agentes de Internet no se circunscriben a realizar búsquedas - Pueden hacer planes, gestionar, comprar, negociar y llevar a cabo todo tipo de arreglos que haría un humano - Conforme más cosas se pueden hacer de forma electrónica, los agentes software tienen mayor acceso a sistemas que modifican el mundo real 2. Sistemas multiagente 9 Explicación del profesor: a día de hoy, si queremos buscar un viaje, buscamos el avión, el hotel… ¿Por qué no pensar en un agente que dialogue con otros agentes, y que haya uno encargado del vuelo, otro del hotel…? Yo le diría a mi agente a dónde quiero ir, qué días, precio máximo… Ese agente dialogando con otros, me busca la alternativa más viable. Esto hoy en día no existe tampoco, pero no sería muy descabellado de realizar. Amadeus es una compañía de gestión de recursos de ocio que posee una ventaja: además de proporcionar una interfaz de texto, también proporciona un API de programación. Tú puedes desarrollar tu aplicación dialogando con Amadeus como quieras. Otros actores importantes en este campo como Booking, podrían proporcionar APIs de programación que permitan acceder a su información. Una vez se tiene esto, desarrollar un agente es muy sencillo, solo se necesita un middleware que facilite la construcción de dicho agente. Este middleware ya existe, nosotros vamos a ver uno de ellos: Jade. g) Cuestiones de investigación - ¿Cómo le damos nuestras preferencias o restricciones a un agente? - ¿Cómo puede un agente comparar entre diversas ofertas de varios vendedores? ¿Qué ocurre cuando hay muchos parámetros? - ¿Qué algoritmos puede usar un agente para negociar con otros agentes (con el objetivo de asegurar que tenemos una buena oferta)? - Este tipo de software puede ser utilizado por agencias gubernamentales (licitación de obras, compra de materiales, etc.). Explicación del profesor: por ejemplo, una de las primeras implementaciones de la subasta en línea fue debida a General Motors (principios de los 90). Este fabricante (así como el resto) estaba acostumbrado a, cuando proponía un nuevo modelo, ponerse en contacto con los distintos suministradores físicamente y negociar antes de comenzar la fabricación. Llegado un momento General Motors decidió que, en vez de ponerse ellos en contacto con los suministradores, los suministradores se pondrían en contacto con ellos. Para conseguir esto, pondrían en una página los objetos que necesitan y mediante una subasta los distintos proveedores podrían participar y los que proporcionaran el material a menor coste ganarían. h) Los sistemas multiagente es un campo multidisciplinario Este campo está influenciado e inspirado por otros campos: - Economía - Filosofía - Teoría de juegos: cómo diseñar estrategias en las que pienso en mi movimiento teniendo en cuenta el de mi contrincante. En función de eso, tendré un árbol de decisión que puede ser muy grande, en el que buscaré un nodo que represente que yo gano. 2. Sistemas multiagente 10 - Lógica - Ecología - Ciencias sociales Esto es en general beneficioso (se aprovecha de metodologías ya desarrolladas para otros problemas). Existen numerosas analogías con el campo de la inteligencia artificial. i) Algunos puntos de vista sobre el campo - Agentes como paradigma para la ingeniería del software: Los ingenieros de software cada vez entienden mejor las características de la complejidad del software. La interacción es probablemente la característica más importante de un software complejo. - En las últimas dos décadas, uno de los temas de investigación más importantes en Ciencias de la Computación es el desarrollo de herramientas y técnicas para modelar, comprender e implementar sistemas en los que la interacción es habitual. - Agentes como herramienta para entender a las sociedades humanas: Los sistemas multiagente proporcionan una nueva herramienta para simular sociedades. - Guarda ciertas analogías con las “teorías de la mente” exploradas por algunos investigadores del campo de la Inteligencia Artificial. El juego de la vida: simular el comportamiento de la sociedad con un número muy elevado de individuos en el que, con una serie de normas muy sencillas, que deciden quién vive y quién muere en la próxima generación, podemos ver cómo evoluciona dicha población. - Sistemas multiagente como búsqueda de bases teóricas apropiadas: Queremos construir sistemas de agentes autónomos interaccionado, pero no sabemos todavía como deberían de ser dichos agentes. Aparecen comportamientos emergentes cuando el número de individuos es muy alto. - Este problema se puede ver desde el punto de vista teórico o de ingeniería. - Este punto de vista guarda también analogías con el campo de la inteligencia artificial. j) Objeciones a los MAS ¿No se trata sin más de sistemas concurrentes/distribuidos? - A los agentes se les supone autónomos, capaces de tomar decisiones de forma independiente, por lo que necesitan mecanismos para sincronizar y coordinar sus actividades en tiempo real. - Los agentes tienen sus propios intereses, por lo que sus interacciones son de carácter económico. 2. Sistemas multiagente 11 ¿No es simplemente Inteligencia Artificial? - No necesitamos resolver todos los problemas de la Inteligencia Artificial para construir agentes útiles. - La Inteligencia Artificial clásica ignoraba los aspectos sociales. Estos son partes importantes de la actividad inteligente en el mundo real. ¿No es simplemente economía/teoría de juegos? - Aunque la teoría de juegos nos proporciona conceptos, no nos proporciona siempre como obtener soluciones. A nosotros nos interesan los agentes computacionales con recursos limitados. - Algunas suposiciones en economía/teoría de juegos pueden no ser válidas o útiles para construir agentes artificiales. ¿No es simplemente ciencias sociales? - Podemos ver posibles soluciones estudiando las sociedades humanas, pero no hay ninguna razón particular para creer que las sociedades artificiales deban de construirse de la misma manera. k) Sistemas MultiAgente (SMA) Los problemas que tenemos son los siguientes: - ¿Qué son? - ¿Por qué otro paradigma? - ¿Otra moda tecnológica? - ¿Qué hay de nuevo? - ¿Para qué sirven? - ¿Cómo se construyen? Los agentes software tienen un conjunto de características que habrá que tener en cuenta para su desarrollo. Grado en Ingeniería Informática 3º curso – 3º cuatrimestre Computación Distribuida 08-11-2021 Roberto de la Iglesia, Pablo Martínez Clase 18 Temas trabajados: Sistemas MultiAgente, 1. Sistemas MultiAgente (SMA) 2 Índice 1. .................................................................................................... ￼Sistemas MultiAgente (SMA) ........................................................................................................................................................ 3 1. Sistemas MultiAgente (SMA) 3 1. Sistemas MultiAgente (SMA) Los agentes son entidades autónomas por lo que para poder ser considerado un sistema multiagente se tienen que cumplir las siguientes características: - Autonomía: Pueden trabajar sin la intervención directa del usuario y tienen cierto control sobre sus acciones y estado interno. - Reactividad: Pueden percibir su entorno (que puede ser el mundo físico, un usuario detrás de una interfaz gráfica o vocal, aplicaciones en la red, u otros agentes) y responder oportunamente a cambios que se produzcan en el mismo. - Iniciativa: El comportamiento de los agentes está determinado por los objetivos (metas) que persiguen y por tanto pueden producir acciones no sólo como respuesta al entorno. Podemos entender esto como que el agente es un agente de control. En la mayor parte de los dominios el agente sólo tendrá control parcial del entorno. Debe estar preparado para fallar, o para la incertidumbre de si ha tenido éxito o no. Un agente dispone de un repertorio de acciones disponibles con sus correspondientes precondiciones. Una misma acción realizada por el agente en diferentes ocasiones puede tener efectos muy distintos en general los entornos son no-deterministas. El principal problema al que se enfrenta un agente es decidir qué acción realizar para alcanzar sus objetivos de diseño y puede suceder que esa acción escogida no sea la mejor posible. Que en un momento determinado un agente realice una acción sólo quiere decir que ha cumplido su precondición. Un agente puede decidir: qué objetivo perseguir o a qué evento reaccionar, cómo actuar para conseguir un objetivo, o suspender o abandonar un objetivo para dedicarse a otro. El agente puede adaptarse progresivamente a cambios en entornos dinámicos mediante técnicas de aprendizaje. • Principio de la racionalidad: Si un agente conoce que una de sus acciones le lleva a cumplir sus objetivos, el agente elige esa acción. (No garantiza elegir la mejor opción). Los agentes no actúan sólos, si no que como sistemas multiagente. Esto proporciona una serie de ventajas: 1. Sistemas MultiAgente (SMA) 4 - Resolución de problemas mediante la estrategia divide y vencerás - Reparto de responsabilidades - Heterogeneidad - Concurrencia y Distribución o Flexibilidad, escalabilidad, tolerancia a fallos, gestión de recursos o Distribución del conocimiento IMPORTANTE: La diferencia entre P2P y MultiAgente es la hetererogeneidad,es decir, que los sistemas pueden ser diferentes. En un sistema P2P, todos los clientes son iguales, homogéneos. TEST DE HUHNS- SIGNGH Si un sistema teniendo varios agentes, al introducir un nuevo agente, debe cambiar sustancialmente. Tiene condiciones: - EL entorno del agente no es estático. - El entorno es observable suficientemente. - El tipo de agentes que se incorporan es alguno ya existente en el sistema. Los agentes tienen habilidad social, por lo que deben tener: - Interacción, dialogar entre ellos. - Delegación: asignación de tareas. - Cooperación: trabajo en común. - Coordinación. - Negociación: si hay dos agentes que compiten entre ellos, tiene que haber una negociación para ver cómo se soluciona. Existen lenguajes de comunicación entre agentes: - KQML - FIPA ACL Los agentes pueden tener movilidad, es decir, pueden migrar de un nodo a otro conservando su estado entre nodos. 1. Sistemas MultiAgente (SMA) 5 Nos saltamos una parte, saltamos a la diapositiva 54 ENTORNOS. Se pueden clasificar en diferentes categorías dependiendo de sus características. - Un entorno accesible es uno en el que el agente puede obtener información completa y exacta al respecto del estado de su entorno. - La mayoría de los entornos (incluyendo, por ejemplo, el mundo real e Internet) son inaccesibles. - Cuanto más accesible sea un entorno, más fácil resulta construir agentes que operen sobre él. Los entornos pueden ser determinísticos o no determinísticos. - Determinísticos: Cualquier acción tiene garantizado un único efecto. - No determinísticos: Al contrario. Presentan grandes problemas al desarrollador de agentes. El mundo real es no determinístico. Los entornos pueden ser episódicos o no episódicos: - En un entorno episódico, las prestaciones de un agente dependen de un número discreto de episodios, no dependiendo del escenario concreto. - Los entornos episódicos son más simples desde el punto de vista del desarrollador de agentes, pues el agente puede decidir qué acción tomar en base al conocimiento del episodio actual – no necesita razonar al respecto de posibles interacciones entre el episodio actual y futuros episodios. El entorno también puede ser estático o dinámico. 1. Sistemas MultiAgente (SMA) 6 - Estático: Aquel que permanece inalterado por las acciones que tome el agente. - Dinámico: El mundo real es dinámico. El entorno puede ser discreto o continuo. Un entorno es discreto si existe un número fijo y finito de acciones que puede percibir. Agentes como Sistemas de Intenciones Cuando explicamos la actividad humana, es a menudo útil realizar sentencias como las siguientes: - Ana cogió su paraguas porque creía que iba a llover. - Miguel trabajó duro porque quería leer su tesis. Este tipo de actitudes empleadas para describir acciones son conocidas como intenciones. El término sistemas de intenciones describe entidades “cuyo comportamiento puede ser predicho mediante la atribución de creencias y deseos”. Arquitectura de agentes: Metodologías para construir agentes: • 1º clasificación: Acceso a los sensores y actuadores de las capas de control. Cada una de las tareas elige qué es lo que hay que hacer en términos de lo que dice cada una de las tareas individuales. La ventaja es que se realizar de forma paralela, pero requiere un alto conocimiento y control para coordinar. 1. Sistemas MultiAgente (SMA) 7 • 2º Clasificación: Tipos de procesamiento: o Arquitecturas Basadas en lógica o Arquitecturas Deliberativas o Arquitecturas Reactivas o Arquitecturas Híbridas Arquitecturas Basadas en lógicas. Representan el estado interno según un conjunto de sentencias lógicas de primer orden. Reglas de deducción lógicas para tomar decisiones. Ventajas: - Representación clara y elegante Desventajas: - Complejidad temporal elevada - Difícil encontrar una representación simbólica para entidades y procesos del mundo real Sea - L, un conjunto de sentencias lógica de primero orden. - D, un conjunto de bases de datos de L. (D=P (L)). - d, elementos de D. - A, las posibles acciones de que el agente es capaz. - a, elementos de A. Entonces las funciones que forman un agente son: - Ver: S -> P - Próximo: D x P -> D - Acción: D -> A Arquitecturas deliberativas. Son aquellas arquitecturas que utilizan modelos de representación simbólica del conocimiento. Suelen estar basadas en la teoría clásica de planificación, donde existe un estado inicial de partida, un conjunto de planes y un estado objetivo a satisfacer. En estos sistemas parece aceptada la idea de que un agente contenga algún sistema de planificación que sea el encargado de determinar que paso debe de llevar a cabo para conseguir su objetivo. Por tanto, un agente deliberativo (o con una arquitectura deliberativa) es aquel que contiene un modelo simbólico del mundo, explícitamente representado, en donde las decisiones se toman utilizando mecanismos de razonamiento lógico basados en la concordancia de patrones y la manipulación simbólica. Un ejemplo sería la arquitectura B.D.I. Teniendo los conjuntos de creencias, deseos e intenciones ( BEl, Des, Int): 1. Sistemas MultiAgente (SMA) 8 Brf:P(Bel ) x P ->P(Bel ) Opciones:P(Bel) x P( Int) ->P(Des) Filtro:P(Bel) x P(Des) x P(Int) -> P( Int) Ejecutar: P( Int) -> A Diagrama de flujo: Ventajas: - Modelo intuitivo. Desventajas - Difícil de equilibrar una conducta del agente que tenga al mismo tiempo iniciativa y reactividad. Arquitecturas Reactivas. - No incluye un modelo del mundo simbólico - No usa razonamiento simbólico complejo. - Modelo Estímulo – Respuesta 1. Sistemas MultiAgente (SMA) 9 - Procesamiento Ascendente (bottom-up): - Patrones que se activan bajo ciertas condiciones de los sensores y tienen un efecto directo en los actuadores - Arquitecturas verticales - Estímulos externos procesados por capas especializadas que responden con acciones y pueden inhibir las capas inferiores Las arquitecturas reactivas, se caracterizan por no tener como elemento central de razonamiento un modelo simbólico y por no utilizar razonamiento simbólico complejo (Brooks, 1991). Un ejemplo típico de estas arquitecturas es la propuesta de Roodney Brooks, conocida como arquitectura de subsunción (Brooks, 1991). Esta arquitectura se basa en el hecho de que el comportamiento inteligente puede ser generado sin utilizar propuestas del modelo simbólico y en el hecho de que la inteligencia es una propiedad emergente de ciertos sistemas complejos. Las arquitecturas de subsunción manejan jerarquías de tareas que definen un comportamiento. Suelen estar organizados en jerarquías de capas, de menor a mayor nivel de abstracción Una o más capas superiores inhiban a las capas inferiores. Ejemplo: Quieres ir de A a B en línea recta. Puede haber obstáculos. Tienes una tarea para evitar obstáculos. Esa tarea está desactivada hasta que te encuentras un obstáculo, en ese momento inhibe las tareas inferiores y es la prioridad. Ventajas: - Respuesta inmediata del agente - No problema de la representación simbólica Inconvenientes: - Difícil diseñar agentes puramente reactivos que puedan aprender de la experiencia - Interacciones difíciles de entender en agentes con muchas conductas Ejemplo. 1. Sistemas MultiAgente (SMA) 10 Esta función opera sobre todas las posibles acciones, y devuelve aquella que no tenga ninguna percepción que la inhiba. Arquitecturas Híbridas. Incluye una mezcla de dos sistemas: Deliberativo: - Modelo del mundo simbólico - Determinar acciones a realizar para satisfacer los objetivos locales y cooperativos de los agentes Reactivo: - Procesar los estímulos que no necesitan deliberación Para la construcción de agentes no es del todo acertado utilizar una arquitectura totalmente deliberativa, o totalmente reactiva. Se han propuesto sistemas híbridos que pretenden combinar aspectos de ambos modelos. Agente compuesto de dos subsistemas: - uno deliberativo, que utilice un modelo simbólico y que genere planes en el sentido expuesto anteriormente, y - -otro reactivo centrado en reaccionar a los eventos que tengan lugar en el entorno y que no requiera un mecanismo de razonamiento complejo. Estructuración por capas: - Verticalmente, sólo una capa tiene acceso a los sensores y actuadores. - Horizontalmente, todas las capas tienen acceso a los sensores y a los actuadores. 1. Sistemas MultiAgente (SMA) 11 • Comunicación. 1. Hacer a otro partícipe de lo que uno tiene 2. Descubrir a alguno una cosa 3. Conversar 4. Consultar • Comunicación entre agentes. Basada en la teoría de los actos del habla. Consiste en una serie de elementos, nos vamos a centrar en las performativas. Clasificación de las ilocuciones. - Asertivas (informar) - Directivas (pedir y preguntar) - Comisivas (prometer) - Permisivas, prohibitivas y declarativas (causan eventos) - Expresivas (emociones y evaluaciones) Niveles de comunicación: Inferior, medio y superior. Los mensajes pueden ser: planificables, síncronos/asíncronos, direcciones físicas, unicast/Multicast/broadcast. Implementaciones: CORBA, RMI, DCOM. Lenguaje de comunicación. - Debe tener semántica bien definida - Semántica formal - Implementaciones: 1. Sistemas MultiAgente (SMA) 12 o KQML o FIPA ACL o Basada en XML Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 10-11-2021 Andrea Solla Alfonsín, Hugo Vázquez Docampo Clase 19 Temas trabajados: 8. Agentes 0. 2 Índice 1. Protocolos de comunicación 3 a) Problemas 3 b) Ontologías 3 c) FIPA ACL 3 i. Servicio de transporte 4 d) Requerimientos de los agentes 4 ii. Requerimiento nº 1 4 iii. Requerimiento nº 2 4 iv. Requerimiento nº 3 4 v. Requerimiento nº 4 5 vi. Requerimiento nº 5 5 e) Modelo de comunicaciones 5 vii. Ejemplo de mensaje FIPA 6 viii. Tipos de mensaje 6 f) Protocolos FIPA ACL 7 g) Protocolo FIPA-query 7 h) Protocolo FIPA-request 8 i) Protocolo FIPA-request-when 8 j) Protocolo FIPA-contract-net 8 k) FIPA-iterated-contract-net 9 l) FIPA-english-auction 9 m) FIPA-dutch-auction 10 0. 3 1. Protocolos de comunicación Se tiene un protocolo de comunicación como el equivalente a una clase, mientras que una conversación (el diálogo propiamente dicho) es una instancia del protocolo. Es decir, el protocolo define cómo es el funcionamiento a nivel general del diálogo entre dos elementos, mientras que la conversación es una instancia particular donde hay mensajes que se intercambian expresamente entre cada una de las partes. Los protocolos son patrones que modelan las posibles comunicaciones, un mismo protocolo puede explicar múltiples conversaciones distintas. Cualquier participante en una conversación debe reconocer el protocolo que se está utilizando para que la comunicación sea efectiva. El protocolo debe estar definido formalmente y tendrá que estar implementado en algún tipo de estándar. En nuestro caso usaremos FIPA ACL, que es posiblemente el estándar más utilizado en agentes para describir cómo son los protocolos de comunicación. a) Problemas Aunque se use el mismo protocolo, puede ocurrir que la comunicación no sea del todo efectiva, ya que se pueden presentar diversos problemas: ➢ Diferentes términos para un mismo concepto. ➢ El mismo término usado para diferentes conceptos. ➢ Diferentes sistemas de unidades. b) Ontologías En general, todos estos problemas se resuelven haciendo uso de lo que se conoce como una ontología. Una ontología, desde el punto de vista lingüístico es como una especie de diccionario que contiene todos los sinónimos de las palabras y, para cada palabra y su conjunto de sinónimos, nos da la palabra base o palabra de referencia. Para verlo de forma práctica, cuando queremos dialogar con otra persona y no entendemos algo porque la otra persona usa términos distintos, vamos a la ontología, buscamos la palabra base y ya sabemos de lo que nos están hablando. JADE tiene un soporte nativo bastante bueno para la confección de ontologías. El uso de ontologías aporta otras cosas a mayores como la verificación automática de que la sintaxis del mensaje es correcta tanto para el envío como para la recepción. Hay distintos estándares para la elaboración de ontologías, nosotros utilizaremos un estándar de la universidad de Stanford llamado Protege, que es una herramienta que permite exportar la ontología en un formato que es entendible por Java, por lo que podremos trabajar con ontologías sin ningún tipo de problema. c) FIPA ACL Las siglas son de Foundation for Inteligent Physical Agents - Agent Communication Language. Es un estándar para la construcción de protocolos de comunicación. Podemos ver la página web oficial de esta organización en este enlace, es una página que lleva muchos años sin cambiar ya que la mayoría de los protocolos se desarrollaron a principios de los 2000 y no han evolucionado mucho, pero siguen ahí. A día de hoy son estándar 25 protocolos. Los protocolos pasan por diferentes fases, empiezan por ser protocolos a nivel preliminar, luego pasan a experimental y finalmente, si son aceptados globalmente, pasan a ser estándar. 1. Protocolos de comunicación 4 i. Servicio de transporte FIPA ACL perfecciona muchas cosas, entre ellas el servicio de transporte, que es capaz de enviar un mensaje y codificarlo para su transmisión como una secuencia de bytes. En el caso más habitual el servicio será de confianza (los mensajes bien formados llegan a su destino), fiable (el mensaje se recibe tal y como se envía) y de carácter ordenado, a todos los efectos funciona básicamente como TCP-IP. Asociada a los mensajes puede haber metainformación, como el plazo máximo de respuesta, que no se codifica en el propio mensaje, sino en la interfaz proporcionada para el envío del mensaje, es decir, se especifica información al margen del mensaje propiamente dicho. El servicio de envío de mensajes va a detectar condiciones de error como mensajes mal formados o no enviables, agentes no alcanzables, etc. Todo agente tiene un nombre que va a permitir al servicio de envío de mensajes remitir el mensaje a la dirección correcta. EN JADE, además del nombre del agente, tendrá un nombre de plataforma, que se utiliza para dialogar con agentes de una plataforma distinta (si los dos agentes se encuentran en la misma plataforma solo es necesario el nombre del agente). El servicio de envío de mensajes debe ser capaz de determinar el mecanismo de transporte adecuado (TCP/IP, SMTP, HTTP, etc) y permitir cambios en la ubicación del agente de ser necesario, ya que el agente podría emigrar de un contenedor a otro, podría estar ejecutándose en una máquina y, en un determinado momento, cambiar a otra máquina, por lo que el sistema de transporte tiene que resolver el problema de cómo localizar dónde se encuentra el agente. Todos los mensajes que se intercambian entre agentes forman parte de lo que se conoce como acto del habla, cuyos objetivos son los siguientes: Completitud: cubrir un alto rango de situaciones de comunicación. Simplicidad: no sobredimensionar el diseño de agentes simples. Concisión: minimizar la redundancia y la ambigüedad para facilitar a los agentes la elección del acto comunicativo que deben emplear. d) Requerimientos de los agentes Cuando un agente dialoga con otros agentes, debe cumplir una serie de requerimientos: ii. Requerimiento nº 1 Los agentes deben enviar un mensaje not-understood si reciben un mensaje que no reconocen o cuyo contenido no son capaces de procesar y deben estar preparados para recibir y manejar adecuadamente un mensaje not-understood de otros agentes. iii. Requerimiento nº 2 Un agente ACL puede escoger implementar cualquier subconjunto de tipos de mensajes y protocolos predefinidos, no es obligatorio que un agente implemente todos los protocolos, solo un conjunto limitado. La implementación de estos mensajes debe ser correcta respecto a la definición semántica de los actos referenciados. iv. Requerimiento nº 3 Un agente ACL que utilice actos comunicativos cuyos nombres están definidos en esta especificación, debe implementarlos correctamente de acuerdo a su definición. 1. Protocolos de comunicación 5 v. Requerimiento nº 4 Los agentes pueden usar actos comunicativos con otros nombres, no definidos en el presente documento, y son responsables de asegurarse de que el agente receptor comprende el significado del acto. Sin embargo, los agentes no deben definir nuevos actos con un significado que coincida con alguno de los actos estándares predefinidos (no reinventar la rueda, si hay un protocolo ya existente que resuelve un determinado problema, no tiene sentido crear un nuevo protocolo con distinto nombre que implemente exactamente lo mismo). vi. Requerimiento nº 5 Un agente ACL debe ser capaz de generar mensajes sintácticamente bien formados en la forma de transporte que corresponde al mensaje que desea enviar. De la misma forma, debe ser capaz de traducir una secuencia de caracteres que esté bien formada en la sintaxis del mensaje correspondiente. Existen 2 niveles: el nivel de transporte que consiste en la forma en que codificamos los mensajes y los transmitimos a través de la red de comunicaciones y el nivel del agente, que consiste en la forma de manipular el mensaje dentro del propio agente. Ese proceso de traducción del mensaje desde el agente a un formato específico para su reenvío o al revés tiene que ser sintácticamente correcto. e) Modelo de comunicaciones Generalmente la estructura tiene los siguientes elementos: ➢ Agente iniciador: manda el mensaje ➢ Agente receptor ➢ Mensaje: acto comunicativo, tiene una serie de elementos que forman parte de su metainformación. o Tipo: el mensaje puede ser de tipo query, request, inform, subscribe, etc. o Emisor o Receptor o receptores o Contenido del mensaje propiamente dicho o Responder con o En respuesta a, sirven para formar hilos de conversación o Lenguaje: la forma en la que se codifica la información o Ontología o Protocolo o Conversación 1. Protocolos de comunicación 6 vii. Ejemplo de mensaje FIPA Los mensajes FIPA pueden ser de tipo ascii o modo binario. Normalmente se suele utilizar, salvo que haya problemas de eficiencia, el modo ascii porque es más legible, un agente que no implemente el protocolo FIPA podría intentar parsear el contenido del mensaje e intentar descubrir qué es lo que se está enviando. En este ejemplo vemos que el mensaje es de tipo request, el contenido está en un determinado lenguaje llamado SL0 que define esa sintaxis que vemos ahí. viii. Tipos de mensaje No hay un número muy elevado de tipos de mensaje, son los siguientes: 1. Protocolos de comunicación 7 f) Protocolos FIPA ACL Recordatorio de lo más importante • Terminología: Protocolo: Patrón fijos de intercambios de mensajes Conversación: una instancia particular de uno de estos diálogos • Los agentes deben conocer en todo momento qué protocolo se está utilizando. Un protocolo puede contener internamente instancias de otros protocolos, por lo que se hace más complicado. Veremos a continuación algunos de los protocolos más importantes. g) Protocolo FIPA-query Se emplea para solicitar a un agente que realice una acción de tipo inform. Ejemplo: + ¿Cúal es la temperatura del salón? - La temperatura del salón es de treinta grados Existen dos tipos: • Query-if: respuestas de tipo true/false. • Query-ref: respuestas más generales. FUNCIONAMIENTO: Se empieza con un query-if o con un query- ref. La respuesta a este puede ser rechazarlo (refuse) o demostrar conformidad (agree). Pasado un tiempo, tras consultar la información, puedo: avisar de que algo ha ido mal (failure), puedo informar (Inform) con un True o un False diciendo si es cierto o falso lo que se pide (Query-if) o también puedo enviar un inform- result (query-ref) para mostrar una respuesta más general y no de tipo true/false. En este protocolo, la respuesta del agree es opcional; debe funcionar a una velocidad establecida y se puede sustituir el agree por, directamente un inform. 1. Protocolos de comunicación 8 h) Protocolo FIPA-request Permite a un agente solicitar que otro agente realice una acción. El receptor debe llevarla a cabo o responder que no puede realizarla. FUNCIONAMIENTO: Se lleva a cabo una petición (request) que se puede rechazar (refuse), mostrar el acuerdo; nuevamente opcional (agree). Pasado cierto tiempo puede suceder un fallo (failure), puede informar de que ha realizado lo solicitado (inform-done) o puede informar mostrando un resultado (inform-result). i) Protocolo FIPA-request-when Es similar al request pero la acción que debe realizar el agente participante debe desarrollarse cuando se cumpla una determinada condición. FUNCIONAMIENTO: Se lleva a cabo la petición condicionada (request-when), la cual se puede rechazar o mostrar conformidad (refuse o agree). Pasado un tiempo, cuando se cumple la condición, se puede informar de un fallo (failure), de que se ha realizado (inform-done) o de que se ha hecho mostrando un resultado (inform-result). La principal diferencia con respecto al protocolo anterior es que el protocolo FIPA-request funciona de manera inmediata mientras que este solo se aplica en el momento en que se cumpla una determinada condición. j) Protocolo FIPA-contract-net Se trata de un protocolo en el cual un agente desea que se realice una acción y existen varios implicados. En este, se desea que se minimice una función que caracterice la tarea (función de coste). EJEMPLO: Un comprador y múltiples vendedores de libros. El comprador envía una petición con el libro que desea adquirir y los vendedores le responden conforme tengan o no el libro y el precio por el cual lo venden en caso de poseerlo. Entonces, el comprador selecciona al vendedor que le ofrezca el libro al menor precio. 1. Protocolos de comunicación 9 FUNCIONAMIENTO: Se empleará para su explicación el anterior ejemplo. En primer lugar, se envía el call for proposals (cfp), mediante el cual indica que se desea comprar un libro. Este se trata de un mensaje de 1 a m, siendo m el número de posibles vendedores. Al cabo de un cierto tiempo, habrá n agentes que desean participar en el diálogo (n no tiene por qué ser igual a m ya que, por ejemplo, alguno pudo haber perdido el mensaje). De esos n agentes, un número i (menor que n) decide, por el motivo que sea, rechazar (un ejemplo podría ser que no posea el libro). Así, n-i agentes deciden realizar la propuesta (propose) e informar de la disposición del libro a un precio determinado. El iniciador, en este caso el comprador, tras recibir todos los mensajes, tiene que decidir a quien le va a realizar la compra. Así, rechazará un número k (menor que j) de solicitudes mediante un reject proposal y aceptará al resto -acept proposal- (puede aceptar a varios, aunque lo normal es que se acepte solo uno y se rechace al resto). Pasado un tiempo, los que se aceptan pueden informar de un fallo, de la realización de la solicitud o de un resultado (failure, inform-done, inform-result). Un ejemplo donde puede ocurrir un fallo con este protocolo sería: Si existen múltiples compradores intentando comprar un mismo libro y recibo múltiples propuestas, en el trascurso hacia la aceptación, otro agente comprador pudo haberse comunicado con el vendedor y haber vendido ese ejemplar, quedándose sin stock de este. k) FIPA-iterated-contract-net Es igual que el anterior protocolo, pero introduciendo varias rondas. En caso de error, se repite la ronda hasta concluir con éxito. FUNCIONAMIENTO: el funcionamiento hasta la recepción del propose es igual a la del protocolo anterior. Sin embargo, una vez se reciba, se rechazan las propuestas no deseadas (reject proposal) y, en lugar de aceptar, ya que eso implicaría finalizar con el protocolo, se envía un cfp revisado; esto se repite una y otra vez (non-final iteration) hasta cumplir una determinada condición. En ese caso (final iteration), se rechazan todos menos uno, se acepta el elegido y se prosigue hasta el final. ACLARACIÓN: la existencia de un protocolo denominado propose demuestra que un protocolo si que puede incluir a otro. l) FIPA-english-auction Se trata de el método de subasta al alza. Este protocolo presenta un problema; se trata de un protocolo experimental (no estándar). La razón es que existen múltiples problemas asociados a este protocolo. 1. Protocolos de comunicación 10 El iniciador es el vendedor y los participantes son los posibles compradores. Así, el vendedor informa sobre el inicio de la subasta (mensaje de 1 a n, siendo n el número de personas en la sala de subastas; valor variable dependiente de las entradas y salidas). Sin embargo, este mensaje carece de sentido ya que si se entra más tarde a la subasta se pierde. Por ello, se puede suprimir. A continuación, se envía un CFP (de nuevo, un mensaje de 1 a n), que se podría identificar de forma muy próxima con un FIPA-iterated-contract-net. Para solucionar el problema de la variabilidad del valor n se introduce el concepto de páginas amarillas, que, de forma similar a las telefónicas, se consultarán de forma esporádica para seleccionar a los usuarios registrados (interesados en la subasta). A todos los efectos, podrían identificarse dichas páginas como la sala de subastas, asociando el registro y desregistro sobre estas con la entrada o salida de la sala. Tras consultar las páginas amarillas, se puede enviar el CFP. Tras recibirlo, los diferentes participantes pueden responder con un not- understood o bien con un propose. A continuación, el vendedor rechaza o acepta las diferentes propuestas emitiendo reject proposal y accept proposal. Es importante tener en cuenta que aceptar una propuesta de un posible comprador no implica que la subasta haya finalizado; esto simplemente demuestra la validez de la propuesta enviada. Esto desemboca en un proceso iterativo constituido por varias rondas en el que para cada una de estas se consulta el sistema de páginas amarillas y que finaliza cuando se satisfaga la condición de final de la subasta. En ese caso, se informa a todos los presentes de como ha terminado la subasta (inform) y se transmite un request al ganador. m) FIPA-dutch-auction Se trata también de un protocolo experimental. Se identifica con la subasta a la baja; la empleada en las lonjas gallegas para vender el pescado. Esta se basa en empezar la puja a un precio alto e ir bajándolo poco a poco hasta encontrar algún interesado. Debe establecerse un precio mínimo a partir del cual no se permite realizar la venta. Tanto en esta como en la anterior, se suele establecer un precio de partida. Grado en Ingeniería Informática 3º curso – 3º cuatrimestre Computación Distribuida 15-11-2021 Pablo Martínez, Roberto de la Iglesia Clase 20 Temas trabajados: Protocolos FIPA ACL, JADE 1. Protocolos FIPA ACL (continuación) 2 Índice 1. Protocolos FIPA ACL (continuación) ................................................................................3 FIPA- brokering ...............................................................................................................3 FIPA- recruiting ...............................................................................................................3 FIPA- suscribe .................................................................................................................4 FIPA- propose ..................................................................................................................5 2. JADE - Java Agent Development Framework .....................................................................5 Arquitectura JADE. ..........................................................................................................6 Cómo ejecutar jade ...........................................................................................................7 Herramientas graficas de JADE. ........................................................................................8 1) Remote Management Agente (RMA). .....................................................................8 2) Dummy agent. .......................................................................................................9 3) Sniffer agent..........................................................................................................9 4) Introspector agent ................................................................................................ 10 5) Log manager agent .............................................................................................. 10 6) DFGui ................................................................................................................ 11 Programación en JADE ................................................................................................... 11 1. Protocolos FIPA ACL (continuación) 3 1. Protocolos FIPA ACL (continuación) FIPA- brokering Protocolo de intermediación entre agentes. Este protocolo cuenta con un iniciador y el broker. El broker recibe las iniciaciones del iniciador y las delega a otros agentes. El dialogo entre el iniciador y el participante nunca se establece de manera directa, si no que se comunica intermediamente con el broker. FIPA- recruiting Se trata de un protocolo análogo a FIPA-brokering. El broker, que en este caso se llama recruiter envía la petición a un conjunto de agentes y son los agentes quienes envían las respuestas al iniciador directamente, sin tener que pasar por el recruiter. 1. Protocolos FIPA ACL (continuación) 4 FIPA- suscribe El iniciador solicita ser avisado cada vez que se cumpla la condición indicada a cada mensaje. 2. JADE - Java Agent Development Framework 5 FIPA- propose El emisor propone a los participantes la realización de una acción. Este emisor suele seguir la realización de la acción y la notificación al estado. FIPA ACL no es el único lenguaje de agentes. También existe KQML (no muy importante). 2. JADE - Java Agent Development Framework JADE se trata de un middleware para el desarrollo de agentes basado en java. Está basado en FIPA ACL. Es interoperable, por lo que es capaz de dialogar con agentes. Jade es una plataforma de agentes que implementa los servicios básicos y la infraestructura de una aplicación multiagente distribuida: • Ciclo de vida y movilidad del • Servicios de páginas amarillas y blancas • Transporte de mensajes • Seguridad del agente • Gestión de las tareas del agente • Conjunto de utilidades para la monitorización y depuración Además, JADE permite la interoperabilidad a través de FIPA. 2. JADE - Java Agent Development Framework 6 Arquitectura JADE. Una aplicación basada en jade está compuesta de una colección activos llamados agentes, donde cada agente tiene un nombre único. Los agentes forman parte de una aplicación P2P puesto que puede comunicarse de forma bidireccional con todos los demás agentes. Además, cada agente vive en un contenedor, el cual le proporciona su entorno de ejecución. En un sistema P2P todos los sistemas son homogéneos y todos colaboran. Sin embargo, en un sistema de agentes pueden ser heterogéneos y pueden competir entre sí. Los contenedores se agrupan en las plataformas, de los cuales hay un contenedor principal y el resto secundarios. Se tiene un conjunto de agentes que se comportan como si estuvieran dentro de una nube, comunicándose entre ellos. Para comunicarse con un agente dentro de una plataforma se utiliza el nombre del agente, que es único para cada sistema de agentes. Todo el entorno se encarga de gestionar como hacer llegar el mensaje a cada agente. Lo que diferencia a un contenedor principal del resto es que el principal tiene dos agentes especiales desplegados, que dan soporte a este entorno. Uno de ellos es el agente AMS y el otro DF. Agente AMS (Agent Management System): se encarga de la gestión de la plataforma (crear/matar agentes, destruir contenedores, …). Además, otros agentes pueden pedirle al agente AMS que realice esas acciones. Se puede obtener el AID a través del método getAMS(). Agente DF: Proporciona el servicio de páginas amarillas. Permite localizar a los agentes mediante sus propiedades. 2. JADE - Java Agent Development Framework 7 Para dialogar entre el agente A1 y el A4 basta con poner el nombre. Si se quiere dialogar entre el A4 y el A5, se tiene que incluir también el nombre de la plataforma, ya que están en distintas. Cómo ejecutar jade El contenedor se despliega mediante el comando java jade.Boot. Se trata de un paquete a través del cual se va a poder crear un contenedor. Sin embargo, si no se introducen opciones se crea solo el contenedor principal. Hay que especificar un host, que será donde se ubique el contenedor principal. Algunas opciones: • help • container (crea un contenedor y lo enlaza a la actual plataforma) • host (especifica el host de la plataforma con el que nos vamos a enlazar) • port (especifica el número de puerto) • gui (lanza el agente de monitorización remota) • nomtp / mtp (lista de MTPs) • conf (crea/carga un fichero de configuración) Especificadores de agente: • lista de agentes a lanza, separado por espacios. • <nombre de agente>:<clase de agente>(<parámetros de agente>) 2. JADE - Java Agent Development Framework 8 Ejemplo: • java jade.Boot –gui –nomtp –port 1200 W1:x.y.W(20) W2:x.y.W(10) *Los argumentos no deben tener espacios en blanco* Herramientas graficas de JADE. Soportan gestión, control, monitorizado y depuración multiagente: • RMA • Dummy Agent • snuffer agent • Introspector Agent • Log Manager Agent • DF (Directory Facilitator) GUI 1) Remote Management Agente (RMA). • Monitoriza y controla la plataforma y todos sus contenedores remotos. • Gestión remota del ciclo de vida de los agentes (creación, suspensión, reactivación, eliminación, migración y clonación). • Compone y envía un mensaje a cualquier agente. • Lanza otras herramientas gráficas. • Monitoriza (simplemente operaciones de lectura) otras plataformas compatibles FIP. 2. JADE - Java Agent Development Framework 9 2) Dummy agent. • Compone y envía mensajes. • Lee, almacena la cola de mensajes desde/a un archivo 3) Sniffer agent • Muestra el flujo de interacciones entre los agentes seleccionados. • Muestra el contenido de cada mensaje • Carga/almacena el flujo en/desde un archivo 2. JADE - Java Agent Development Framework 10 4) Introspector agent • Monitoriza el estado interno del agente: Recibe/envía mensajes pendientes y realiza comportamientos programados • Permite depuración en ejecución: Paso a paso, ejecución lenta, o mediante break points. 5) Log manager agent Se trata de una interfaz grafica para modificar en periodo de ejecución el almacenamiento de la plataforma. Está basado en java.util.logging y permite: • Navegar en todos los objetos almacenados en sus contenedores • Modificar el nivel de almacenamiento añadir nuevos gestores de almacenamiento 2. JADE - Java Agent Development Framework 11 6) DFGui Interfaz con el usuario para interaccionar con el servicio de páginas amarillas. Permite: • Navegar registrar, desregistrar, modificar y buscar descripciones de agentes. • Federarse con otros DFs. • Ejecutar búsquedas federadas Programación en JADE Creación de un agente Es posible crear un agente extendiendo la clase jade.core.Agent y redefiniendo el método setup(). Inicialización de un agente El método setup() tiene la intención de incluir la inicialización de los agentes, es el primer método que se ejecuta. Cada instancia del agente se identifica por un Agent ID (AID): • Un AID está compuesto de un nombre único y algunas direcciones. • Un agente puede obtener su AID invocando al método getAID() de la clase Agent. • Los nombres de agente tienen la forma <local-name>@<platform-name> 2. JADE - Java Agent Development Framework 12 El nombre completo de un agente debe ser globalmente único. Por defecto, el nombre de la plataforma es <main-host>:<main-port>/JADE. El nombre de la plataforma se puede poner usando la opcion –name. Dado el nombre de un agente, su AID puede ser creado de la siguiente forma: • AID id = new AID(localname, AID.ISLOCALNAME); • AID id = new AID(name, AID.ISGUID); Pasarle argumentos a un agente Es posible pasarle argumentos a un agente mediante el método: • java jade.Boot .... a:myPackage.MyAgent(arg1 arg2) El agente obtiene sus argumentos mediante el método getArguments() de la clase Agent. Terminación de un agente Un agente concluye cuando se invoca el método doDelete() Durante la terminación del agente se invoca al método takeDown(), cuya función es realizar operaciones de limpieza: Grao en Enxeñaría Informática 3º curso – 1º cuadrimestre Computación Distribuída 17-11-2021 Pablo Gil Pérez, Adrián Vidal Lorenzo, Nicolás Vilela Pérez Clase 21 Temas traballados: Tema 8: Introdución aos sistemas multiaxente. Programando en Jade 1. Nomes locais, GUID e direccións 2 Índice 1. Nomes locais, GUID e direccións ............................................................................................. 3 2. Pasándolle argumentos a un axente ........................................................................................... 3 3. Terminación dun axente ............................................................................................................ 3 4. A clase Behaviour ..................................................................................................................... 4 5. Scheduling e execución de comportamentos ............................................................................. 4 6. Tipos de comportamentos ......................................................................................................... 5 7. Planificar operacións en momentos específicos ........................................................................ 5 8. Máis acerca dos comportamentos ............................................................................................. 6 9. O modelo de comunicación ....................................................................................................... 6 10. A clase ACLMessage .............................................................................................................. 6 11. Envío e recepción de mensaxes ............................................................................................... 7 12. Bloqueo dun comportamento esperando unha mensaxe ......................................................... 7 13. Lectura selectiva da cola de mensaxes .................................................................................... 7 14. Recepción de mensaxes en modo bloqueante ......................................................................... 8 1. Nomes locais, GUID e direccións 3 1. Nomes locais, GUID e direccións Os nomes do axente teñen a forma <local-name>@<plataform-name>. O nome completo dun axente debe ser globalmente coñecido e único. No caso de que non se especifique platarforma suponse que esta é a nosa máquina. O nome por defecto da plataforma é <main-host>@<main- port>/JADE e este pódese especificar usando a opción -name. Dentro dunha plataforma JADE os axentes identifícanse exclusivamente polo seu nome, que á súa vez serve para indicar a quen se lle mandan as distintas mensaxes. Dado o nome dun axente, o seu AID pode ser creado das seguintes maneiras: - AID id = new AID(localname, AID.ISLOCALNAME); - AID id = new AID(name, AID.ISGUID); 2. Pasándolle argumentos a un axente É posible pasarlle argumentos a un axente a través da execución do comando de inicio da plataforma: java jade.Boot .... a:myPackage.MyAgent(arg1 arg2), sen comas polo medio. O axente obtén os seus argumentos mediante o método getArguments() da clase Agent. 3. Terminación dun axente Un axente conclúe cando se invoca ao método doDelete(). Durante a terminación do axente invócase ao método takeDown(), cuxa función é realizar operacións de limpeza. 4. A clase Behaviour 4 4. A clase Behaviour O traballo que realiza un axente normalmente realízase dentro de behaviours (comportamentos). Pódense crear comportamentos estendendo a clase java.core.behaviours.Behaviour. Para que un axente realice unha tarefa é suficiente con crear unha instancia do correspondente comportamento e invocar ao método addBehaviour() da clase Agent. Cada subclase Behaviour debe implementar: - public void action(): o que fai realmente o comportamento. - public boolean done(): o que se fai cando conclúe a execución do comportamento. 5. Scheduling e execución de comportamentos Un axente pode executar varios comportamentos en paralelo, non obstante, o scheduling de comportamentos non é apropiativo, senón cooperativo e todo ocorre nun único fío Java. Recordemos estes conceptos: - Scheduling cooperativo: O programador ten que decidir especificamente cando ceder a cpu, e neste caso faise cando remata o método action. - Scheduling apropiativo: É o método de linux, que asigna quantums e cando estes rematan é cando se levan a cabo os cambios de contexto. A conmutación entre comportamentos ocorre cando o método action() do comportamento en execución conclúe. O fluxo de execución é o seguinte: Se ó terminar o método Action() xa non quedan tarefas pendentes, este non se volve a executar. En caso contrario, cédese a cpu e retómase posteriormente con outra tarefa. 6. Tipos de comportamentos 5 6. Tipos de comportamentos • Comportamentos dun só disparo (one shot) Conclúen de forma inmediata e o seu método action() é executado unha única vez. O seu método done() é devolve sempre o valor true. Exténdese a clase jade.core.behaviours.OneShotBehaviour. • Comportamentos cíclicos (cyclic behaviour) Nunca terminan e o seu método action() executa a mesma operación cada vez que é invocado. O seu método done() é devolve sempre o valor false. Exténdese a clase jade.core.behaviours.CyclicBehaviour. • Comportamentos complexos (complex) Teñen un estado interno e o seu método action() executa unha operación diferente dependendo de dito estado. Terminan cando se verifica unha determinada condición. Normalmente extenden a clase jade.core.behaviours.Behaviour 7. Planificar operacións en momentos específicos JADE proporciona dúas clases por medio das cales é posible implementar facilmente comportamentos que executan certas operacións en momentos específicos: • WakerBehaviour Os métodos action() e done() xa están implementados de forma que o método onWake(), que debe ser implementado por unha subclase, é executado despois dun certo tempo. Despois da execución, o comportamento conclúe. • TickerBehaviour Os métodos action() e done() xa están implementados de forma que o método onTick(), que debe ser implementado por unha subclase, é executado periodicamente. O comportamento execútase indefinidamente cada certo tempo a non ser que se execute o método stop(). 8. Máis acerca dos comportamentos 6 8. Máis acerca dos comportamentos O método onStart() da clase Behaviour invócase só unha vez antes da primeira execución do método action(). É a apropiada para operacións que deben ocorrer ao comezo do comportamento. O método onEnd() da clase Behaviour invócase só unha vez despois de que o método done() devolva true. É a apropiada para operacións que deben ocorrer ao final do comportamento. Cada comportamento ten un punteiro ó axente que o está executando: a variable protexida myAgent. Os métodos de envío e recepción de mensaxes perténcelle á clase Agent e non a Behaviour, polo que debemos usar esta variable se queremos comunicar os axentes. O método removeBehaviour() da clase Agent pode utilizarse para suprimir un comportamento da lista de comportamentos do axente. Neste caso non se invoca o método onEnd(). Cando a lista de comportamentos activos dun axente está baleira, o axente entra no estado IDLE e o seu fío durme. 9. O modelo de comunicación Está baseado no paso de mensaxes de forma asíncrona. O formato da mensaxe está definido pola linguaxe ACL (FIPA). 10. A clase ACLMessage As mensaxes que intercambian axentes son instancias da clase jade.lang.acl.ACLMessage. Esta proporciona métodos de acceso tipo get e set a todos os campos definidos pola linguaxe ACL: - get/setPerformative() - get/setSender() - add/getAllReceiver() (Pódese engadir un ou varios receptores) - get/setLanguage() - get/setOntology() - get/setContent() 11. Envío e recepción de mensaxes 7 entre outros. 11. Envío e recepción de mensaxes Enviar unha mensaxe é tan simple como crear un obxecto ACLMessage e chamar ao método send() da clase Agent. Como este send() non fai referencia á variable myAgent, podemos deducir que non está dentro dun behaviour. A lectura de mensaxes da cola privada realízase co método receive() da clase Agent. A recepción de mensaxes non é boa tela nos Behaviour porque cada vez que a mensaxe é null estamos perdendo CPU. 12. Bloqueo dun comportamento esperando unha mensaxe Un comportamento que procesa as mensaxes recibidas non sabe cando chegarán ditas mensaxes, polo que debe facer un poll da cola de mensaxes chamando continuamente a myAgent.receive(). Isto supón unha perda innecesaria de tempo de CPU. Para solucionalo emprégase o método block() da clase Behaviour, que elimina un comportamento da cola do axente e colócao nun estado bloqueado. Cada vez que se recibe unha mensaxe, todos os comportamentos bloqueados son inseridos novamente na cola de comportamentos, tendo así a oportunidade de ler e procesar a mensaxe. 13. Lectura selectiva da cola de mensaxes O método receive() devolve a primeira mensaxe da cola de mensaxes e elimínaa de devandita cola. Se hai dous ou máis comportamentos recibindo mensaxes, un pódelle roubar a mensaxe ao outro. Para evitar isto, é posible ler mensaxes cunhas determinadas características (por exemplo, 14. Recepción de mensaxes en modo bloqueante 8 aqueles cuxo emisor é Peter). Para conseguir isto debe especificarse o parámetro jade.lang.acl.MessageTemplate no método receive(). Neste exemplo, unicamente se están recibindo mensaxes dunha determinada ontoloxía. A xestión de plantillas é moi complexa e o profesor recomenda consultala na documentación de JADE. 14. Recepción de mensaxes en modo bloqueante A clase Agent proporciona o método blockingReceive(), que conclúe só cando hai unha mensaxe na cola de mensaxes. Hai versións sobrecargadas que aceptan unha MessageTemplate (o método conclúe só cando hai unha mensaxe que se axusta á plantilla) e/ou un timeout (se conclúe o tempo, devolve o valor null). Posto que é unha chamada bloqueante, é perigoso utilizar este método dentro dun comportamento. De feito, ningún comportamento pode executarse ata que finalice blockingReceive(). Por esta razón, recoméndase usar receive() + Behaviour.block() para recibir mensaxes dentro dun comportamento. Usarase blockingReceive() para recibir mensaxes dentro dos métodos setup() e takeDown() dun axente. Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 22-11-2021 Autores: Javier Beiro Piñón, Martín Campos Zamora Clase 22 Temas trabajados: Tema 8 - Código Agentes Índice 1. Explicación genérica 2 2. Agente vendedor 2 3. Agente comprador 6 1 Se explica el código relacionado con la ejecución de dos agentes que gestionan la compraventa de libros, poseyendo uno el rol de comprador y otro el de vendedor. Es importante destacar que el comportamiento está generalizado para cualquier número de agentes compradores o vendedores. 1. Explicación genérica Por norma general, los atributos del agente se inicializan en el setup(), este se usa a modo de “constructor” del agente. Los comportamientos que sean cíclicos, también se suelen añadir en este fragmento de código ya que duran hasta que el agente muere (a no ser que se quiera establecer el inicio según una condición determinada en tiempo de ejecución). 2. Agente vendedor public class BookSellerAgent extends Agent { // Catalogo con los libros que posee el vendedor ( libro y precio asociado . private Hashtable catalogue ; // Interfaz grafica del vendedor private BookSellerGui myGui ; // Metodo que se ejecutara al iniciar el agente ( similar al concepto de constructor ) protected void setup () { // Iniciamos las variables y mostramos la interfaz catalogue = new Hashtable () ; myGui = new BookSellerGui ( this ); myGui . showGui () ; // Registramos al agente en el servicio de paginas amarillas como vendedor , de manera que pueda ser localizado por otros agentes ( los compradores ). // 1- Indicamos las caracteristicas del agente DFAgentDescription dfd = new DFAgentDescription () ; dfd . setName ( getAID () ); ServiceDescription sd = new ServiceDescription () ; sd . setType (\" book - selling \" ); sd . setName (\" JADE - book - trading \"); dfd . addServices ( sd ); // 2- Lo registramos en las paginas amarillas try { DFService . register ( this , dfd ); } catch ( FIPAException fe ) { fe . printStackTrace () ; } 2 // Anadimos los comportamientos addBehaviour ( new OfferRequestsServer () ); addBehaviour ( new PurchaseOrdersServer () ); } // Operacones que ejecuta el agente cuando termian protected void takeDown () { // Eliminamos su registro de las paginas amarillas try { DFService . deregister ( this ); } catch ( FIPAException fe ) { fe . printStackTrace () ; } // Cerramos la interfaz grafica myGui . dispose () ; // Imprimimos un mensaje por pantalla System . out . println (\" Seller - agent \"+ getAID () . getName () +\" terminating .\"); } // Metodo invocado al anadir un nuevo libro a traves de la interfaz grafica public void updateCatalogue ( final String title , final int price ) { // Debido a que se va a actualizar el catalogo de libros es necesario anadir un comportamiento que se ejecute una unica vez que se encargue de insertarlo en la tabla hash . Esto es debido a que los atributos del agente \\ textbf { unicamente } pueden ser modificados a partir de comportamientos ( desde el hilo de agente ) addBehaviour ( new OneShotBehaviour () { public void action () { catalogue . put ( title , new Integer ( price )); } } ); } // Clase con el comportamiento encargado de gestionar las peticiones de clientes de libros private class OfferRequestsServer extends CyclicBehaviour { public void action () { // Creamos una plantilla de mensajes para recibir call for proposals . MessageTemplate mt = MessageTemplate . MatchPerformative ( ACLMessage . CFP ); 3 // Recibimos un mensaje que concuerde con la plantilla ACLMessage msg = myAgent . receive ( mt ); // En caso de haber recibido un CFP lo procesamos if ( msg != null ) { // Obtemenos el contido del mensaje . En este caso el mensaje contendra el titulo del libro que quiere el comprador String title = msg . getContent () ; // Creamos un mensaje de respuesta a partir del mensaje recibido . Empleado esta funcion nos ahorramos la necesidad de obtener el emisor y crear un mensaje con el como destinatario ya que lo hace automaticamente ACLMessage reply = msg . createReply () ; // Obtenemos el valor que tenemos definido para ese libro en nuestro catalogo Integer price = ( Integer ) catalogue . get ( title ); // En caso de disponer del libro en nuestro catalogo , enviamos una respuesta con un propose y con contenido el precio que tenemos fijado if ( price != null ) { reply . setPerformative ( ACLMessage . PROPOSE ); reply . setContent ( String . valueOf ( price . intValue () )); } // En caso de no disponer del libro enviamos un refuse y en el contenido indicamos que no se encuentra disponible else { reply . setPerformative ( ACLMessage . REFUSE ); 4 reply . setContent (\" not - available \"); } // Enviamos el mensaje al comprador solicitante myAgent . send ( reply ); } // En caso de que no exista ningun mensaje que concuerde con la plantilla en el buzon bloqueamos el hilo del agente . El agente se volvera a desbloquear automaticamente en el momento en el que llegue un mensaje nuevo para comprobar que si concuerda con la plantilla else { block () ; } } } // Clase encargada de gestionar las propuestas de compra aceptadas . Es decir , todas aquellas respuestas que los compradores hayan hecho al vendedor con la intencion de comprar el libro al precio que se encuentra en el catalogo private class PurchaseOrdersServer extends CyclicBehaviour { public void action () { // Recibimos los mensajes que acepten las propuestas de precio enviadas MessageTemplate mt = MessageTemplate . MatchPerformative ( ACLMessage . ACCEPT_PROPOSAL ); ACLMessage msg = myAgent . receive ( mt ); // Realizamos el mismo comportamiento en caso de disponer / no disponer mensajes que concuerden con la plantilla if ( msg != null ) { // Obtenemos el libro del cual se solicita la compra String title = msg . getContent () ; ACLMessage reply = msg . createReply () ; // Obtenemso el precio del libro y lo eliminamos del catalogo de libros disponibles Integer price = ( Integer ) catalogue . remove ( title ); 5 // En caso de aun disponer del libro enviamos un inform , indicando que se realizo la compra if ( price != null ) { reply . setPerformative ( ACLMessage . INFORM ); } // En caso de no disponer del libro ( porque alguien se le adelanto , devolvemos un failure indicando que no esta disponible ) else { reply . setPerformative ( ACLMessage . FAILURE ); reply . setContent (\" not - available \"); } // Enviamos la respuesta myAgent . send ( reply ); } else { block () ; } } } } 3. Agente comprador Agente comprador encargado de adquirir un solo libro al mejor precio disponible entre todos los vendedores disponibles. public class BookBuyerAgent extends Agent { // Titulo del libro a comprar y lista de vendedores conocidos private String targetBookTitle ; private AID [] sellerAgents ; protected void setup () { // Obtenemos el titulo del libro a adquirir como argumento del agente al rancarlo Object [] args = getArguments () ; if ( args != null && args . length > 0) { // Obtenemos el titulo del libro targetBookTitle = ( String ) args [0]; 6 // Creamos un tickerBehaviour que se va a encargar de hacer una solicitud de compra del libro a los agentes vendedores cada minuto addBehaviour ( new TickerBehaviour ( this , 60000) { protected void onTick () { // Creamos una plantilla para buscar a agentes vendedores DFAgentDescription template = new DFAgentDescription () ; ServiceDescription sd = new ServiceDescription () ; sd . setType (\" book - selling \"); template . addServices ( sd ); try { // Usamos la plantilla para buscar los agentes vendedores en las paginas amarillas DFAgentDescription [] result = DFService . search ( myAgent , template ); // Almacenamos la lista de vendedores obtenidos sellerAgents = new AID [ result . length ]; for ( int i = 0; i < result . length ; ++ i) { sellerAgents [i] = result [i ]. getName () ; } } catch ( FIPAException fe ) { fe . printStackTrace () ; } 7 // Anadimos el comportamiento para obtener el mejor precio de venta del libro de todos los agentes vendedores encontrados myAgent . addBehaviour ( new RequestPerformer () ); } } ); } else { // En caso de no haber especificado ningun libro mostramos un error System . out . println (\" No target book title specified \"); doDelete () ; } } protected void takeDown () { // Imprimimos que finalizamos el agente System . out . println (\" Buyer - agent \"+ getAID () . getName () +\" terminating .\"); } // Comportamiento encargado de gestionar la comparacion de precios de agentes private class RequestPerformer extends Behaviour { private AID bestSeller ; // Agente con la mejor oferta private int bestPrice ; // Mejor precio private int repliesCnt = 0; // Numero de respuestas obtenidas private MessageTemplate mt ; // Plantilla de mensajes a recibir private int step = 0; // Controlador de punto de ejecucion del switch en cada iteracion public void action () { switch ( step ) { case 0: // Enviamos una solicitud de compra , en forma de cfp a todos los vendedores obtenidos en el onTickerBehaviour , idicando el libro a comprar como contendio 8 ACLMessage cfp = new ACLMessage ( ACLMessage . CFP ); for ( int i = 0; i < sellerAgents . length ; ++ i) { cfp . addReceiver ( sellerAgents [i ]) ; } cfp . setContent ( targetBookTitle ); cfp . setConversationId (\" book - trade \"); cfp . setReplyWith (\" cfp \" + System . currentTimeMillis () ); myAgent . send ( cfp ); // Modificamos la plantilla para obtener mensajes de vendedores que responda al cfp enviado mt = MessageTemplate . and ( MessageTemplate . MatchConversationId ( \" book - trade \") , MessageTemplate . MatchInReplyTo ( cfp . getReplyWith () )); step = 1; break ; case 1: // Obtenemos los mensajes que respondan a la solicitud ( respuestas de los vendedores al cfp ) ACLMessage reply = myAgent . receive ( mt ); if ( reply != null ) { // En caso de que sea un propose significa que posee el libro por lo que compararemos el precio que indica con el mejor precio hasta el momento if ( reply . getPerformative () == ACLMessage . PROPOSE ) { // This is an offer int price = Integer . parseInt ( reply . getContent () ); if ( bestSeller == null || price < bestPrice ) { // This is the best 9 offer at present bestPrice = price ; bestSeller = reply . getSender () ; } } repliesCnt ++; // En caso de haber obtenido respuesta de todos los vendedores continuamos al siguiente paso if ( repliesCnt >= sellerAgents . length ) { step = 2; } } else { block () ; } break ; case 2: // Aceptamos la propuesta del vendedor que ofrecio la mejor oferta ACLMessage order = new ACLMessage ( ACLMessage . ACCEPT_PROPOSAL ); order . addReceiver ( bestSeller ); order . setContent ( targetBookTitle ); order . setConversationId (\" book - trade \"); order . setReplyWith (\" order \"+ System . currentTimeMillis () ); myAgent . send ( order ); // Preparamos la plantilla para obtener la respuesta mt = MessageTemplate . and ( MessageTemplate . MatchConversationId ( \" book - trade \") , MessageTemplate . MatchInReplyTo ( order . getReplyWith () )); // Obtenemos la respuesta en el siguiente paso step = 3; break ; case 3: 10 // Obtenemos la respuesta a la solicitud de compra reply = myAgent . receive ( mt ); if ( reply != null ) { // En caso de que sea un inform , hemos obtenido el libro , por lo que finalizamos el agente if ( reply . getPerformative () == ACLMessage . INFORM ) { myAgent . doDelete () ; } else { System . out . println (\" Attempt failed : requested book already sold .\"); } step = 4; } else { block () ; } break ; } } public boolean done () { // Si hemos llegado al paso dos sin haber obtenido ninguna oferta del libro no existe ningun vendor , por lo que termina el comportamiento y esperamos a la ejecucion del onTickerBehaviour para obtener de nuevo la lista actualizada de vendedores . // En caso de haber llegado al paso 4, alguien se ha adelantado en la compra por lo que tenemos que volver a buscar tambien la lista actualizada de compradores if ( step == 2 && bestSeller == null ) { System . out . println (\" Attempt failed : \"+ targetBookTitle +\" not available for sale \"); } return (( step == 2 && bestSeller == null ) || step == 4) ; } 11 } } 12 Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 24-11-2021 Pablo Martínez, Roberto de la Iglesia Clase 23 Temas trabajados: Ontologías, Ontologías en JADE 1. Ontologías 2 Índice 1. Ontologías........................................................................................................................3 1. Comunicación entre agentes ......................................................................................3 2. DATOS EN FORMATO STRING .....................................................................................3 3. OBJETOS SERIALIZABLES ............................................................................................3 4. DEFINIR LOS OBJETOS A TRANSMITIR .........................................................................3 5. ¿QUÉ ES UNA ONTOLOGÍA? .......................................................................................4 6. ¿QUÉ PROBLEMAS RESUELVE? ...................................................................................4 2. ONTOLOGÍAS Y JADE .........................................................................................................4 a. CONCEPT ..................................................................................................................5 b. PREDICATE ................................................................................................................5 c. AGENTACTION ..........................................................................................................6 d. OTRAS CONSIDERACIONES (I) .....................................................................................6 e. LA CLASE ONTOLOGY .................................................................................................6 f. LA CLASE ONTOLOGY Y LOS BEANS .............................................................................7 g. LENGUAJES DE CONTENIDO .......................................................................................7 h. SL VS LEAP ................................................................................................................7 i. OTRAS CONSIDERACIONES (II) ....................................................................................7 j. CONTENTMANAGER ..................................................................................................8 1. Ontologías 3 1. Ontologías 1. Comunicación entre agentes Se trata de una característica fundamental del sistema multiagente. Los agentes se comunican entre ellos usando mensajes, usando el estándar ACL (Agent Communication Language). Los agentes tienen que utilizar un formato y semántica acordados en el contenido de los mensajes para poder entenderse entre ellos. Si se espera un valor, pero aparece otro tipo de dato, el agente no sabe cómo continuar. La forma en las que se representa el contenido de los mensajes es decisión del programador. Se puede decir cómo estandarizar el campo de contenido, es decir, lo que contiene el mensaje. Sin embargo, esto tiene un inconveniente, ya que si dos agentes han sido programados por programadores distintos pueden no ser compatibles. Existen tres formas de enviar datos dentro de un mensaje ACL: • Datos en formato String (“valor=5”) . • Objetos serializables de Java. • Definir los objetos que se pueden transmitir mediante objetos Java que se puedan traducir directamente a un mensaje ACL y viceversa: Ontologías. 2. DATOS EN FORMATO STRING Consiste en escribir el contenido del mensaje directamente en un String. Por ejemplo “valor=10;fecha=20/10;coste=5”. Fácil de leer y comprender para las personas. Sin embargo, es difícil de leer para una máquina ya que el receptor debe procesar (parsear) el String para extraer los valores. Esto se puede hacer en java mediante el método de la clase String split(). 3. OBJETOS SERIALIZABLES JavaBean que extienden a java.io.Serializable. Se transmite directamente el objeto serializable como contenido del mensaje, por lo que ya no es necesario parsearlo. Es ilegible para un humano. Para poder hacer esto, todos los agentes deben estar implementados en el mismo lenguaje de programación, ya que Un agente solo podrá dialogar con otro agente del mismo lenguaje 4. DEFINIR LOS OBJETOS A TRANSMITIR Otro método es definir clases que representan los contenidos a transmitir y esquemas que representan jerarquías entre ellos. Estos objetos se traducen directamente al contenido de un mensaje ACL, lo que proporciona interoperabilidad entre sistemas multiagente. Este concepto, el de implementar clases para enviar el contenido, es la aplicación de las ontologías 2. ONTOLOGÍAS Y JADE 4 5. ¿QUÉ ES UNA ONTOLOGÍA? Una ontología es una nomenclatura y definición formal de los tipos y propiedades de las entidades que forman un dominio, así como de las relaciones entre ellas. Permite describir la estructura y las relaciones en un dominio sin ambigüedad y con precisión. Las ontologías suelen ser diseñadas por expertos en el dominio, y no por programadores. El programador no suele hacer el diseño por que suele estar incorrecto, por lo que solo se limitan a su uso. Un ejemplo de ontologías puede ser en el ámbito médico con las guías clínicas, las cuales son un guion que debe seguir un médico cuando llega un paciente. 6. ¿QUÉ PROBLEMAS RESUELVE? • Las ontologías eliminan la ambigüedad en la semántica y la sintaxis del dominio. Es decir, cuando se usa una ontología es imposible construir un mensaje mal formado. • Proporciona una comprensión del dominio que puede ser adquirida por múltiples entidades, de forma que tendrán un modelo común del mismo dominio. • Dos entidades que adopten la misma ontología permitirán la comunicación entre sí • Una misma ontología puede ser representada en múltiples lenguajes sin dejar de significar lo mismo, de modo que favorece la interoperabilidad. • La ontología es independiente de su implementación. Esto quiere decir que si dos agentes tienen distintos objetos que representan la misma ontología, podrán entenderse sin problemas. Se puede tener un objeto que representa a un vinilo, y otro agente puede tener un objeto que representa la misma entidad, pero le puede llamar cd. Si el primero le dice al segundo “dame un vinilo”, este entiende que le tiene que dar un cd. Esto es gracias a las ontologías. Sirven para referenciar al mismo elemento de manera distinta. • El uso de ontologías facilita la verificación sintáctica de los mensajes. Si un agente recibe un mensaje que dice adherirse a una ontología, pero no lo hace, será descartado (en JADE, se generará una excepción). 2. ONTOLOGÍAS Y JADE USO DE ONTOLOGÍAS EN JADE En JADE las ontologías se usan para representar los elementos que pueden ser usados como contenido de un mensaje ACL Las ontologías se componen de dos partes: 2. ONTOLOGÍAS Y JADE 5 • Una clase derivada de la clase Ontology que los elementos del dominio y las relaciones entre ellos mediante esquemas • Una serie de clases que implementan los esquemas anteriores (Concept, Predicate, AgentAction) JADE proporciona formas de traducir directamente los objetos Java (elementos de la ontología) a secuencias de caracteres o bytes. Tenemos dos tipos de codex: El SLcode y el litcode. El primero codifica en modo texto, el segundo transmite en modo binario. El primero se usa más al ser más sencillo de depurar. El litcode se usa en ambientes relacionados con la eficiencia, ya que es mucho más eficiente. • Secuencias de caracteres: fácil de transmitir • Objetos java: fáciles de manipular por los agentes a. CONCEPT • Representa un concepto básico de la ontología • El resto de elementos de la ontología se construyen en base a los Concept • Se implementan como beans que implementan jade.onto.Concept • Un Concept puede contener a otros Concept • No suele tener sentido usarlos directamente como contenido. En el campo de contenido se suele poner una accion, o algo que se quiere verificar si es cierto o falso b. PREDICATE • Predicados o hechos • Expresiones que afirman algo sobre el estado del mundo real • Beans que implementan jade.content.Predicate • Pueden tomar un valor cierto o falso • Suelen contener Concept Se tiene el predicado trabajar que tienen una persona y una compañía. 2. ONTOLOGÍAS Y JADE 6 c. AGENTACTION • Un tipo especial de Concept • Representan una acción que puede llevar a cabo un agente • Ejemplos: realizar una petición, solicitar un servicio, ofrecer un objeto, registrarse para notificaciones… • Beans que implementan jade.content.AgentAction • Al contrario que Concept, sí tiene sentido usarlos como contenido • Un AgentAction no contiene directamente el agente que realiza la acción • En su lugar, a la hora de enviar un AgentAction en un mensaje ACL, se encapsula en un Action junto con el AID del agente. Es decir, no se enviaría un AgentAction, sino un new Action(AID, AgentAction) d. OTRAS CONSIDERACIONES (I) • Se puede aprovechar la funcionalidad de herencia de Java para refinar Concepts, Predicates o AgentActions • Es una buena práctica definir interfaces para poder variar la implementación de los beans sin tener que modificar la ontología • Los atributos de los Concept, Predicate y AgentAction se conocen como slots o ranuras, en el sentido de que representan un “hueco” genérico que podrá ser rellenado por los agentes e. LA CLASE ONTOLOGY Se trata de una instancia de jade.content.onto.Ontology. Esta contiene los Contiene los esquemas que definen la estructura de los predicados, conceptos y acciones. Estos esquemas se implementan como instancias de la clase jade.content.schema.Schema. Además, JADE proporciona varias clases abstractas con ontologías para usar como base. La más relevante es BasicOntology. BasicOntology proporciona varios esquemas predefinidos, incluyendo: • Tipos primitivos • Predicados, conceptos, acciones • El concepto de AID 2. ONTOLOGÍAS Y JADE 7 f. LA CLASE ONTOLOGY Y LOS BEANS La clase Ontology Contiene Schemas y define la estructura de la ontología para su procesado. No varía durante la ejecución del programa. Los Beans de implementación implementan los patrones definidos mediante Schemas. Se usan para manipular datos como cualquier objeto Java Su contenido puede variar durante la ejecución del programa. g. LENGUAJES DE CONTENIDO Una vez codificada la clase ontología y sus Beans de implementación, es necesario un mecanismo para traducirlos a mensajes AC. Para representar los Beans dentro del contenido del mensaje se utilizan los lenguajes de contenido o códecs. Estos son lenguajes de contenido que proporcionan una manera estándar de codificar los Beans de una ontología en un formato que se puede transmitir dentro del mensaje ACL. Por otro lado, JADE proporciona dos lenguajes de contenido en el paquete jade.content.lang: SL y LEAP h. SL VS LEAP SL Los elementos se codifican en base a cadenas de caracteres. Es legible por humanos y además es el lenguaje de contenido de uso mayoritario. Por último, es compatible con un gran número de sistemas. LEAP Los elementos se codifican como secuencias de bytes, por lo que no legible por humanos. Se usa en contextos de alto rendimiento o bajos recursos ya que es más ligero. En principio sólo compatible con JADE. i. OTRAS CONSIDERACIONES (II) • La clase Ontology no varía durante la ejecución de la aplicación. Por este motivo se considera buena práctica usar la misma instancia en todos los usos (patrón de diseño Singleton). • Si se examina un mensaje codificado en LEAP con el agente sniffer de JADE, se observará que es (relativamente) legible: el agente sniffer traduce los bytes a texto ASCII para que puedan ser legibles. • Se pueden aprovechar los mecanismos de herencia e interfaces de Java para refinar las clases Ontology. • Es obligatorio definir qué ontología y códec utiliza cada mensaje ACL en los slots correspondientes COMPUTACIÓN DISTRIBUIDA - ONTOLOGÍAS 2. ONTOLOGÍAS Y JADE 8 j. CONTENTMANAGER ContentManager es una clase de servicio que se encarga de administrar todo lo relacionado con ontologías y lenguajes de contenido. Proporciona métodos registerOntology() y registerLanguage(), que permiten registrar las instancias de la ontología y el códec en ContentManager para su posterior uso. Además, proporciona los métodos como: • fillContent(): codifica e inyecta un Bean de implementación en el slot de contenido de un ACLMessage. • extractContent(): extrae y decodifica el contenido de un ACLMessage. Cuando se recibe un mensaje, se lo paso al extractContent y lo que devuelve es una clase con el mensaje El contentManager se obtiene mediante el método Agent.getContentManager(). Grado en Ingeniería Informática 3º curso – 1º cuatrimestre Computación Distribuida 29-11-2021 Elena Segade Martínez, Teresa Gutiérrez Blanco Clase 24 Temas trabajados: Jess y Jade 1. Jess y Jade 2 Índice 1. Jess y Jade.................................................................................................................................. 3 1. Jess y Jade 3 1. Jess y Jade Jess es un paquete de software desarrollado por Sandia Lab, un laboratorio de investigación del gobierno de Estados Unidos perteneciente al departamento de energía y que poseen los ordenadores más potentes del mundo. Se dedican a la gestión del arsenal nuclear. Una de las cosas que hacen es monitorizar armamento nuclear a través de sensores que monitorizan en todo momento las armas de forma que cuándo detectan que un arma no es segura, la desmontan y la rehacen. Esta empresa desarrolló en su día la herramienta Jess basada en Java y que implementa un sistema experto basado en CLIPS. Este núcleo de CLIPS se utiliza, entre otras cosas, para la gestión de la monitorización. Con la idea de que Jess sea lo más robusto y eficiente posible, Sandia Lab proporciona el código fuente para que todo el mundo pueda utilizarla sin ánimo de lucro. Un sistema experto consta de un motor de reglas conocido como motor de inferencias, una base de hechos, una base de conocimientos, un nodo de entrada y un nodo de salida. El núcleo de todo esto es el motor de inferencias, el cuál está interconectado a la base de hechos y la base de conocimiento. La base de hechos son, básicamente, las variables de la aplicación. La base de conocimientos es un conjunto de reglas, descritas una detrás de otra, dónde hay una precondición que debe cumplirse y una consecuencia a raíz del cumplimiento de esta precondición. La parte antecedente de cada regla une de forma lógica determinadas variables que pertenecen a la base de hechos. La parte consecuente pude implicar ejecutar acciones y, a su vez, modificar la base de hechos, de forma que cuándo se ejecuta una regla, puede repercutir que, cómo consecuencia de eso, se disparen nuevas reglas. El módulo de entrada es el módulo a través del cuál el usuario introduce datos en el sistema experto. Está conectado a la base de hechos. Por último está el motor de inferencias. Este está conectado directamente a la salida debido a que la parte consecuente de la regla puede indicar una salida en el sistema. 1. Jess y Jade 4 ¿Cómo funciona el sistema experto? Este comienza ejecutando la base de conocimientos desde la primera regla hasta llegar a la última. Cuándo llega a la última, si alguna de las reglas se ha disparado, vuelve otra vez a ejecutarlas una detrás de otras. Sigue realizando esta acción una y otra vez hasta que no se dispare ninguna regla en un ciclo de ejecución. Si esto último ocurre, se dice que el sistema experto se ha estabilizado. La única manera de que se vuelva a ejecutar el sistema experto es que se introduzca un dato y se modifique una variable de la base de hechos. Si un sistema experto está bien diseñado, llegará un momento en el que se estabilice y no haya ninguna regla que se ejecute. Un ejemplo de sistema experto mal diseñado sería aquel en el cuál una regla hace que se dispare una segunda regla y, esta segunda, hace que se ejecute la primera, generando así un bucle. Desde este punto de vista se puede ver un agente como un sistema de protocolo que actúa sobre un medio, en este caso su entorno de forma que tiene una serie de percepciones que miden el estado del entorno y realiza una serie de acciones sobre este. Un sistema de calefacción sería lo mismo, tiene un sensor que mide la temperatura y un efector que abre el agua caliente en función de la temperatura. Se debe tener en cuenta que un sistema experto cuando comienza a realizar su ejecución, no se sabe cuánto tiempo va a tardar en ejecutarse, generando un gran problema a nivel de repartición de tiempo de CPU. Generalmente son muy lentos. Para solucionar este problema, Jess implementa un objeto que se llama Rete, el cuál a su vez implementa un algoritmo también denominado Rete. Este algoritmo lo que hace es: Imaginemos que tenemos 2 reglas: 1ª. (x+y)+z 2ª. x+y Motor inferencia S Base conocimientos Base Hechos E 1. Jess y Jade 5 Si se ejecuta primero la regla 1 y luego la regla 2 esto sería ineficiente, puesto que se trata del mismo cálculo. Para esto Rete tiene una estructura en grafo como la siguiente para representar las reglas: Lo que intenta con este grafo es optimizar el uso de cada una de las operaciones. En este ejemplo, realizaría la siguiente optimización: La estructura de un sistema experto consiste en ejecutar la base de conocimiento una y otra vez para que se estabilice. Cuando se ejecuta el sistema experto en Jess, se le puede especificar cuántas veces se desea ejecutar la base de conocimientos. Si se pone 1 vez, se intentará ejecutar sólo 1 vez todas las reglas de la base de conocimientos, si se pone 2, 2 veces… Al pasar este límite, devuelve al control al usuario, indicando si se ha estabilizado o no el sistema experto, de forma que, cuándo se ejecuta Jess se indica al Rete las veces que se desea ejecutar la base de conocimiento, se ejecuta, devuelve el control e indica si se encuentra estabilizado. En caso afirmativo, el comportamiento ha terminado y se ha ejecutado el sistema experto completo. En caso contrario, el comportamiento no ha terminado y la salida será true o false dependiendo de la salida de Rete. 1. Jess y Jade 6 EL funcionamiento normal es: se instancia un objeto de tipo Rete, se instancia otro objeto parse que leerá la base de conocimiento, la cuál está en un archivo legible que utiliza una sintaxis tipo CLIPS. Se ejecuta el parse para comprobar que todo es correcto, se carga la base de conocimientos en el sistema experto y se arranca el sistema experto. Se debe tener en cuenta que las entradas pueden proceder de mensajes recibidos. Entonces, se deben recibir mensajes, extraer su contenido, parsearlo y ejecutar acciones que modifiquen la base de hechos. De la misma forma puede ocurrir que el resultado de alguna ejecución de alguna regla produzca una salida, lo que implica envío de mensajes.","libVersion":"0.5.0","langs":""}