{"path":"COMDIS/bibliografía/02-El API de Sockets.pdf","text":"Distributed computing 1 Computación Distribuida Tema 2: El API de Sockets Introducción  El API de sockets es un interfaz de programación para la comunicación entre procesos (IPC) originalmente disponible en el sistema operativo Unix de Berkeley.  Ha sido traducido a todos los sistemas operativos modernos, incluyendo Solaris de Sun y sistemas Windows.  Es el estándar de factopara la programación IPC y es la base de interfaces IPC más sofisticados tales como remote procedure call (RPC) y remote method invocation (RMI). Distributed computing 2 Protocolo TCP/IP  Introducido por el DoD en ARPANET a principios de los años 80.  Principales características:  Independiente del fabricante  Disponible desde ordenadores personales a grandes supercomputadores  Usado tanto en LANs como WANs  Actualmente es el protocolo más extendido en Internet Capa de datos Actualmente TCP/IP soporta múltiples interfaces de comunicación  Líneas dedicadas de alta capacidad (T1, T3)  Redes locales  Incluso existen implementaciones sobre puertos serie (SLIP, PPP) Distributed computing 3 Capa de red En esta capa se proporciona un mecanismo no fiable de comunicación entre sistemas Se introduce el concepto de dirección IP Cada ordenador en la red dispone de una dirección única de 32 bits Clasificación de las redes IP Distributed computing 4 Capa de transporte UDP y TCP Un proceso interacciona con el protocolo TCP/IP mediante el envío de datos TCP o UDP A veces se conoce a estos protocolos bajo el nombre TCP/IP o UDP/IP Orden de transmisión Los datos se pueden almacenar en la memoria de un ordenador de dos formas distintas:  Big endian: PowerPC, Sparc ...  Litle endian: Intel x86, ... Los datos a través de la red siempre se transmiten en formato big endian Distributed computing 5 UDP  UDP es un protocolo no orientado a conexión sino al paso de mensajes.  No garantiza la correcta recepción de los datos ni el orden de los mismos  Simple = rápido  Proporciona únicamente dos características no presentes en el protocolo IP  Número de puerto  Verificación del contenido de un paquete  Existen fronteras entre mensajes  UDP se utiliza fundamentalmente en aplicaciones que requieren una alta tasa de transferencia de información y en donde las pérdidas de datos no son importantes  Ejemplo: videoconferencia  No obstante, no existe el concepto de QoS (Quality of Service). No está garantizado un ancho de banda y pueden existir retardos. Esto implica que la telefonía IP necesita algo más que el protocolo TCP/IP Distributed computing 6 TCP TCP es un protocolo orientado a conexión Garantiza la correcta recepción de la información y el orden de los paquetes La comunicación es bidireccional TCP se usa para la transmisión fiable de información. Ejemplos:  telnet  ftp  Correo electrónico  http Distributed computing 7 Encapsulación UDP Encapsulación TCP Distributed computing 8 Concepto de puerto Una máquina que dialoga con otra puede estar ejecutando varios procesos Es necesario identificar sin ambigüedad los procesos que intervienen en el diálogo Para ello se utiliza el concepto de puerto: entero de 16 bits Asociación  Una asociación en Internet consta de los siguientes elementos  Protocolo (TCP o UDP)  Dirección IP de la máquina local (32 bits)  Puerto de la máquina local (16 bits)  Dirección IP de la máquina remota (32 bits)  Puerto de la máquina remota (16 bits)  Ejemplo: {tcp, 193.144.84.100, 1500, 193.170.2.11, 21} Distributed computing 9 Fragmentación  La mayoría de las capas de red tienen un tamaño máximo de paquete de información que pueden manejar (MTU)  Ejemplo: ethernet = 1500 bytes  Es necesario fragmentar la información  Paquetes pertenecientes a un mismo mensaje pueden recibirse fuera de orden Ensamblado En recepción es necesario reconstruir el mensaje ordenando los paquetes recibidos Se establece un número de orden de paquete. Sirve para varias cosas:  Reconstruir correctamente el mensaje  Detectar fallos en la transmisión y solicitar de nuevo la retransmisión Distributed computing 10 Out of Band (OOB)  Generalmente la transmisión/recepción de información a través de una interfaz de comunicación se hace a través de una memoria intermedia  A veces nos interesaría podernos saltar ese procedimiento  Para ello surge el mecanismo de Out of Band.  Los datos en el canal de Out of Band siempre se envían antes que el resto de los datos Distributed computing 11 IPC de UNIX BSD 4.x  A partir de BSD 4.2 se implementa una IPC a través de llamadas al sistema  socket: destino de mensajes  A través de un socket se pueden enviar y recibir mensajes  Los mensajes se ponen en una cola en el socket transmisor hasta que el protocolo de red los haya transmitido  En el socket receptor los mensajes estarán en una cola hasta que el proceso destinatario los haya extraído Antes de comunicarse, cada proceso debe crear explícitamente un socket Se crean mediante la llamada al sistema socket Es necesario especificar:  Protocolo: TCP o UDP  Dominio: UNIX (archivo dentro del árbol de directorios) o Internet (dirección IP+puerto) Devuelve un descriptor del socket susceptible de ser utilizado en llamadas al sistema posteriores Distributed computing 12 Hay que darle un identificador que los demás procesos pueden utilizar como dirección de destino Para ello se utiliza la llamada al sistema bind Comunicación por datagramas Primitiva de envío de mensajes: sendto  Además del mensaje hay que especificar •Descriptor de socket propio •Identificación del socket de destino (dirección IP+puerto) Distributed computing 13 Primitiva de recepción de mensajes: recvfrom  Además del descriptor de socket propio, debe especificar el buffer en el que se almacena el mensaje y el remitente La comunicación tendrá lugar si se produce un emparejamiento  Un sendto hacia la dirección de un socket  Un recvfrom sobre el socket asociado a esa dirección Comunicación cliente-servidor  El servidor crea un socket, le asocia una dirección y la publica mediante algún método (NIS, p.ej.)  El cliente crea un socket, le asocia una dirección y obtiene la dirección del servidor  Mensaje de solicitud •El cliente lo envía con sendto •El servidor lo recoge con recvfrom  Mensaje de respuesta •Papeles invertidos Distributed computing 14 Cliente dsc = socket(AF_INET, SOCK_DGRAM, 0); ... bind(dsc, &idCliente, longidCliente); sendto(dsc, solicitud, longSol, 0, idServ, longidServ); n = recvfrom(dsc, &buffer, longBuf, 0, &idServ, &longidServ); ... Servidor dss = socket(AF_INET, SOCK_DGRAM, 0); bind(dss, &idServ, longidServ); n = recvfrom(dss, &buffer, longBuf, 0, &idCliente, &longidRemite); ... sendto(dss, respuesta, longResp, 0, idCliente, longidCliente); Distributed computing 15 Comunicación encauzada (stream)  Primero se crea e identifica el par de sockets, de forma similar a como se hace por datagramas  El servidor “escucha” llamadas: listen  El cliente solicita la conexión: connect  El servidor acepta la conexión: accept  Conexión  se emparejan 1 connect y 1 accept  El Sistema Operativo crea un nuevo socket y lo conecta al del cliente  El servidor puede seguir escuchando en el socket original La comunicación entre el par de sockets conectados se hace por medio de las llamadas  read y write  send y recv La conexión concluye al cerrar el socket: close Distributed computing 16 Cliente dsc = socket(AF_INET, SOCK_STREAM, 0); connect(dsc, idServ, longServ); ... (se suspende) n = write(dsc, buffer, longBuf); Servidor dss = socket(AF_INET, SOCK_STREAM, 0); bind(dss, &idServ, longServ); listen(dss, 5); ... (se suspende) dsn = accept(dss, &remite, &long); ... n = read(dsn, &buffer, longBuf); Distributed computing 17 Servidor TCP en Java import java.io.*; import java.net.*; public class Servidor { public static void main(String[] args) { try { ServerSocket s = new ServerSocket(8189); Socket socket = s.accept(); DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream output = new DataOutputStream(socket.getOutputStream()); System.out.println(input.readByte()); System.out.println(input.readShort()); System.out.println(input.readInt()); System.out.println(input.readUTF()); output.writeByte(5); output.writeShort(345); output.writeInt(33270762); output.writeUTF(\"Se acabo correctamente\"); socket.close(); s.close(); } catch(Exception e) { System.out.println(e); } } } Cliente TCP en Java import java.io.*; import java.net.*; public class Cliente { public static void main(String[] args) { try { Socket socket = new Socket(\"gsi2.dec.usc.es\", 8189); DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream output = new DataOutputStream(socket.getOutputStream()); output.writeByte(5); output.writeShort(345); output.writeInt(33270762); output.writeUTF(\"Se acabo correctamente\"); System.out.println(input.readByte()); System.out.println(input.readShort()); System.out.println(input.readInt()); System.out.println(input.readUTF()); socket.close(); } catch(Exception e) { System.out.println(e); } } } Distributed computing 18 Algunas consideraciones Tanto bajo TCP como UDP existe un rango de puertos reservados [1,1023]. Únicamente los procesos con permisos de root podrán generar un socket en uno de esos puertos El puerto siempre se fija en la parte del servidor. El cliente genera su puerto de forma automática Por defecto, un socket siempre es bloqueante, de forma que cuando realizamos una operación de lectura sobre el mismo, se suspende la ejecución del proceso si no hay datos en el buffer Suele ser preferible generar un proceso aparte para leer datos de un socket que ponerlo en modo no bloqueante y gestionar su lectura por interrupciones. De todas formas, eso es un parámetro de diseño Distributed computing 19 Datagramas en Java En Java tenemos dos clases proporcionadas por el API de sockets para datagramas: 1. la clase DatagramSocket para especificar el socket. 2. La clase DatagramPacketpara representar al datagrama intercambiado. Un proceso que desee enviar o recibir datos usando esta API debe crear una instancia de DatagramSocket. Cada socket esta ligado (bound) a un puerto UDP de la máquina local donde reside el proceso. Datagramas en Java Para enviar un datagrama a otro proceso, un proceso:  Crea un objeto que representa al datagrama. Este objeto puede ser creado como una instancia del objeto DatagramPacket que contiene 1. (i) los datos a ser transmitidos 2. (ii) la dirección de destino (dirección IP y puerto del socket receptor al cual está ligado).  emite una llamada al método senddel objeto DatagramSocket, especificando como argumento una referencia al objeto de tipo DatagramPacket. Distributed computing 20 Datagramas en Java  En el proceso receptor se debe instanciar un objeto de tipo DatagramSockety ligarlo a un puerto local. Este número debe coincidir con el especificado en el datagrama del emisor.  Para recibir datagramas enviados al socket, el proceso crea un objeto de tipo DatagramPacket que referencia a un array de bytes y llamar al método receive del objeto DatagramSocket, especificando como argumento una referencia al objeto DatagramPacket. Estructuras de datos en los programas emisor y receptor a by t e a r r a y a D a t a g r a m Pa c k e t o bje c t r e c e i ve r ' s a ddr e s s a D a t a g r a m S o c k e t o bje c t s e nde r pro c e s s a by t e a r r a y a D a t a g r a m Pa c k e t o bje c t a D a t a g r a m S o c k e t o bje c t re c e i ve r pro c e s s s e n d r e c e i v e o bje c t r e f e r e n c e da t a f l o w Distributed computing 21 Sincronización de eventos con datagramas s e r ver c l i ent reques t res ponse bloc k ed s e nd r e c ei ve r e c ei ve s e nd bl oc ki ng r ec ei ve , no nbl o c ki ng s end i n a r eque s t-r e s po ns e pr o to c o l i f da t a i s s e n t be f o r e a c o r r e s po n di n g r e c e i v e o pe r a t i o n i s i s s u e d, t h e da t a wi l l be di s c a r de d by t h e r u n t i m e s u ppo r t a n d wi l l n o t be r e c e i v e d. Programando un timeout Para evitar un bloqueo indefinido, debe programarse un timeout en un objeto socket: void setSoTimeout(int timeout) Programa un timeout para la recepción bloqueante de este socket en milisegundos. Una vez programado, este timeout estará en vigor para todas las operaciones de carácter bloqueante. Distributed computing 22 Métodos clave y constructores Method/Constructor Description DatagramPacket(byte[ ] buf, int length) Construct a datagram packet for receiving packets of length length; data received will be stored in the byte array reference by buf. DatagramPacket(byte[ ] buf, int length, InetAddress address, int port) Construct a datagram packet for sending packets of length length to the socket bound to the specified port number on the specified host; data received will be stored in the byte array reference by buf. DatagramSocket( ) Construct a datagram socket and binds it to any available port on the local host machine; this constructor can be used for a process that sends data and does not need to receive data. DatagramSocket(int port) Construct a datagram socket and binds it to the specified port on the local host machine; the port number can then be specified in a datagram packet sent by a sender. void close( ) Close this datagramSocket object void receive(DatagramPacket p) Receive a datagram packet using this socket. void send (DatagramPacket p) Send a datagram packet using this socket. void setSoTimeout(int timeout) Set a timeout for the blocking receive from this socket, in milliseconds. El código / / Ex ce rp t f ro m a rec eiv er p ro g ram Dat a g ramS o cketd s = n ewDat ag ramS o cket( 2 345) ; Dat a g ramPacketd p = n ewD at a g ramPacket( b u f f er, M A X L EN ) ; d s. rec ei ve (d p) ; l en =d p. g et L en g t h ( ) ; S ys t em.o u t . Prin t l n ( l en + \" b yt es receiv ed . \\ n \") ; S t ri n g s = n e w S t ri n g (d p. g et D at a ( ) , 0, l en ) ; S ys t em.o u t . p rin t l n (d p. g et A d d ress( ) + \" at p o rt \" +d p. g et Po rt ( ) + \" s ays \" + s) ; / / Excerp t f ro m t h e s en d in g p ro c ess I n et A d d ress rec eive rH o st = I n et A d d ress. g et B yN ame( \" l o c al Ho st \") ; Da t ag ramS o ckett h eS o ck et = n ewD at a g ramS o ck et( ) ; S t ri n g me ssag e = \" H el l o w o rl d ! \" ; b yt e [ ]d at a = me ss ag e. g et By t es ( ) ; d at a = t h eL i n e. g et B yt e s( ) ; Da t ag ramPackett h ePac ke t = n ewDa t a g ramPacket(d at a, d at a. len g t h , rec ei verH o st , 2345) ; t h eS o cket.se n d ( t h eO u t p u t ) ; Distributed computing 23 Sockets no orientados a conexión Con sockets no orientados a conexión es posible que múltiples procesos simultáneamente envíen datagramas al mismo socket creado por el proceso receptor, en cuyo caso el orden de recepción de los mensajes no es predecible. Pr o c e s s A Pr o c e s s B Pr o c e s s C Pr o c e s s A Pr o c e s s B Pr o c e s s C Fi g u r e 3 a Fi g u r e 3 ba c o n n e c t i o n l e ss da t a gr a m s o c k e t El API de sockets en modo stream  El API de socket para datagramas permite el intercambio de unidades de datos discretas (esto es, datagramas).  El API de sockets en modo stream proporciona un modelo para la transmisión de datos basado en el modo encauzado de E/S proporcionado por los sistemas operativos Unix.  Por definición, un socket en modo stream da soporte únicamente a comunicaciones orientadas a conexión. Distributed computing 24 El API de sockets en modo stream (API de sockets orientado a conexión) . . . . . . a da t a s t r e am p r o c e s s w r it e o p e r a t io n r e a d o p e r at io n P1 P2 a s t r e a m - m o d e d at a s o c k e t El API de sockets en modo stream Un socket en modo stream se crea para el intercambio de datos entre dos procesos específicos. Los datos es escriben en un extremo del socket y se leen en el otro extremo. Un socket stream no puede utilizarse para comunicarnos con más de un proceso. Distributed computing 25 El API de sockets en modo stream En Java, el API de sockets en modo stream se proporciona mediante dos clases:  Server socket: para aceptar conexiones; llamaremos a un objeto de esta clase un socket de conexión.  Socket: para el intercambio de datos; llamaremos a un objeto de esta clase un socket de datos. El servidor s e r v e r c l i e n t 1 c o n n e c t io n o p er a t io n s e n d / r e c e iv e o p e r a t o n A s e r v e r u s e s t wo s o c k e t s : o n e f o r a c c e pt i n g c o n n e c t i o n s , a n o t h e r f o r s e n d/ r e c e i v e c l i e n t 2 c o n n e c t i o n s o c k e t d a t a s o c k e t Distributed computing 26 Métodos clave de la clase ServerSocket M e th o d/c o nstru c to r D e scrip tio n S erverS o ck et(in t p ort) C reates a serve r so ck et o n a sp e c ified p o rt. S o ck et ac cep t() thro w s IO E x cep tio n Listen s fo r a co n n ection to b e m a de to th is so ck e t an d ac ce p ts it. T h e m e th od b lo ck s un til a co n n ec tio n is m a de . p u b lic vo id clo se() th ro w s IO E x ce ptio n C lo se s th is so ck et. vo id se tS o T im e ou t(int tim e ou t) th ro w s S o ck etE x c ep tio n S e t a tim e o u t p erio d (in m illise co n ds) so th at a c all to ac ce p t( ) for this soc ke t w ill b lo ck fo r o n ly th is a m o un t o f tim e . If th e tim e ou t e x pires, a ja va .io .In te rru p ted IO E x c ep tio n is ra ise d Nota: Accept es una operación bloqueante. Métodos clave en la clase Socket Method/constructor Description Socket(InetAddress address, int port) Creates a stream socket and connects it to the specified port number at the specified IP address void close() throws IOException Closes this socket. InputStream getInputStream( ) throws IOException Returns an input stream so that data may be read from this socket. OutputStream getOutputStream( )throws IOException Returns an output stream so that data may be written to this socket. void setSoTimeout(int timeout) throws SocketException Set a timeout period for blocking so that a read( ) call on the InputStream associated with this Socket will block for only this amount of time. If the timeout expires, a java.io.InterruptedIOException is raised Una operación de lectura en el InputStream es bloqueante. Una operación de escritura es no bloqueante. Distributed computing 27 API de sockets orientados a conexión Server establishes a socket sd1 with local address, then listens for incoming connection on sd1 Client establishes a socket with remote (server's) address. server client 1. 2.Server accepts the connection request and creates a new socket sd2 as a result. sd1 sd1 sd2 sd1 sd2 sd1 sd2 3. Server issues receive operation using sd2. Client issues send operation. 4. Server sends response using sd2. sd1 5. When the protocol has completed, server closes sd2; sd1 is used to accept the next connection Client closes its socket when the protocol has completed API de sockets orientados a conexión Distributed computing 28 API de sockets no orientados a conexión P1 P2 P2 e s t ablis he s a local s ock e t P1 e s t ablis he s a l ocal s ock e t P2 s e nds a dat agram addre s s e d to P1 P1 is s ue s a re ce ive ope ration t o re ce ive t he dat agram. Ejemplo: Diagrama de eventos a c c e pt w r i t e c l o s e d a t a s o c k e t c l o s e c o n n e c t i o n s o c k e t c o n n e c t r e q u e s t ( f r o m S o c k e t c o n s t r u c t o r ) r e a d C o n n e ct i o n A c c e pt o r C o n n e c t i o n R e qu e s t o r t i m e p r o c e s s e x e c u t i n g pr o c e s s s u s p e n d e dc l o s e s o c k e t a n o pe r a t i o n m e s s a g e Distributed computing 29 Ejemplo t r y { n t po r t N o ; S t r i n g m e s s a g e ; / / i n s t a n t i a t e s a s o c k e t f o r a c c e pt i n g c o n n e c t i o n S e r ve r S o c k e t c o n n e c t i o n S o c k e t = n e w S e r ve r S o c k e t ( p o r t N o ) ; S o c k e t da t a S o c k e t = c o n n e c t i o n S o c k e t . a c c e p t ( ) ; / / g e t a o u t pu t s t r e a m f o r w r i t i n g t o t h e d a t a s o c k e t O u t p u t S t r e a m o u t S t r e a m = da t a S o c k e t . g e t O u t p u t S t r e a m ( ) ; / / c r e a t e a P r i n t e r W r i t e r o b j e c t f o r c h a r a c t e r - m o d e o u t pu t P r i n t W r i t e r s o ck e t O u t p u t = n e w P r i n t W r i t e r ( n e w O u t pu t S t r e a m W r i t e r ( o u t S t r e a m ) ) ; / / w r i t e a m e s s a g e i n t o t h e da t a s t r e a m s o c k e t O u t pu t . pr i n t l n ( m e s s a g e ) ; / /Th e e n s u i n g f l u s h m e t h o d c a l l i s n e c e s s a r y f o r t h e d a t a t o / / be w r i t t e n t o t h e s o c k e t d a t a s t r e a m be f o r e t h e / / s o c k e t i s c l o s e d. s o c k e t O u t pu t . f l u s h ( ) ; da t a S o c k e t . c l o s e ( ) ; c o n n e c t i o n S o c k e t . c l o s e ( ) ; } // e n d t r y c a t c h ( Ex c e p t i o n e x ) { S y s t e m . o u t . pr i n t l n ( e x ) ; } E xam p l e 4 C o nne c t i o nAc c e p t o rE xam p l e 4 C o n ne c t i o nRe c e i v e r t r y { In e t A dd r e s s a c c e pt o r H o s t = In e t A dd r e s s . g e t B y N a m e ( a r g s [ 0 ] ) ; i n t a c c e p t o r P o r t = In t e g e r . pa r s e In t ( a r g s [ 1 ] ) ; / / i n s t a n t i a t e s a da t a s o c k e t S o c k e t m y S o c k e t = n e w S o c k e t ( a c c e pt o r H o s t , a c c e p t o r P o r t ) ; / / g e t a n i n pu t s t r e a m f o r r e a d i n g f r o m t h e da t a s o c k e t In pu t S t r e a m i n S t r e a m = m y S o c k e t . g e t In p u t S t r e a m ( ) ; / / c r e a t e a B u f f e r e d R e a de r o bj e c t f o r t e x t - l i n e i n p u t B u f f e r e dR e a de r s o c k e t I n p u t = n e w B u f f e r e d R e a d e r ( n e w In pu t S t r e a m R e a de r ( i n S t r e a m ) ) ; / / r e a d a l i n e f r o m t h e d a t a s t r e a m S t r i n g m e s s a g e = s o c k e t In pu t . r e a dLi n e ( ) ; S y s t e m . o u t . p r i n t l n ( \"\\ t \" + m e s s a g e ) ; m y S o c k e t . c l o s e ( ) ; } // e n d t r y c a t c h ( Ex c e p t i o n e x ) { S y s t e m . o u t . pr i n t l n ( e x ) ; } Sockets seguros https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERef Guide.html  Los sockets seguros realizan un cifrado de los datos transmitidos.  El JavaTMSecure Socket Extension (JSSE) es un paquete Java que permite comunicaciones seguras en Internet.  Implementa una versión Java de los protocolos SSL (Secure Sockets Layer) y TLS (Transport Layer Security)  Incluye funcionalidades para el cifrado de datos, autentificación del servidor, integridad de mensajes y, opcionalmente, autentificación del cliente. Distributed computing 30 El API Java Secure Socket Extension  Import javax.net.ssl;  La clase SSLServerSocket es una subclase de ServerSocket, y hereda todos sus métodos.  La clase SSLSocket es una subclase de Socket, y hereda todos sus métodos.  Para más información  https://www.owasp.org/index.php/Using_the_Java_Secure_Socket _Extensions Multidifusión  La multidifusión IP se construye sobre el protocolo IP. La multidifusión IP permite que el emisor transmita un único paquete IP a un conjunto de computadores que forman un grupo de multidifusión. El emisor no está al tanto de las identidades de los receptores y del tamaño del grupo.  Los grupos de multidifusión se especifican utilizando direcciones Internet de la clase D. Distributed computing 31  El convertirse en miembro de un grupo de multidifusión permite al computador recibir paquetes IP enviados al grupo.  La pertenencia a los grupos de multidifusión es dinámica, permitiendo que los computadores se apunten o borren a un número arbitrario de grupos en cualquier instante. Es posible enviar mensajes a un grupo de multidifusión sin pertenecer al mismo. Multidifusión en IPv4  Routers multidifusión: los paquetes IP pueden multidifundirse tanto en una red local como en toda Internet. Si la multidifusión va dirigida a Internet, debe hacer uso de las capacidades de multidifusión de los routers, los cuales reenvían los datagramas únicamente a otros routers de redes que pertenezcan al mismo grupo. Para limitar la distancia de propagación de un datagrama multidifusión, el emisor puede especificar el número de routers que puede cruzar (TTL Time to Live). Distributed computing 32  Reserva de direcciones multidifusión: las direcciones multidifusión se pueden reservar de forma temporal o permanente. Existen grupos permanentes, incluso cuando no tengan ningún miembro. Sus direcciones son asignadas de forma arbitraria por la autoridad de Internet en el rango de 224.0.0.1 a 224.0.0.255.  El resto de las direcciones multidifusión están disponibles para su uso por parte de grupos temporales.  Cuando se crea un grupo temporal, se necesita una dirección de multidifusión libre para evitar conflictos. El protocolo de multidifusión IP no resuelve el problema de reservar la dirección.  Cuando la comunicación es a nivel local, si se pone un TTL pequeño, es difícil que entremos en conflicto con otros grupos. Distributed computing 33  Si se necesita multidifusión a nivel de Internet, es necesario reservar previamente una dirección. El programa de directorio de sesiones (sd) sirve para arrancar o unirse a una sesión multidifusión. Proporciona una herramienta que permite a los usuarios detectar sesiones multidifusión existentes y anunciar su propia sesión, especificando el tiempo y la duración de la reserva.  Para España quien gestiona dicha agenda es RedIris http://www.rediris.es/mmedia/agenda/ Multidifusión import java.net.*; import java.io.*; public class MulticastPeer{ public static void main(String args[]){ // args give message contents & destination multicast group (e.g. \"228.5.6.7\") MulticastSocket s =null; try { InetAddress group = InetAddress.getByName(args[1]); s = new MulticastSocket(6789); s.joinGroup(group); byte [] m = args[0].getBytes(); DatagramPacket messageOut = new DatagramPacket(m, m.length, group, 6789); s.send(messageOut); // this figure continued on the next slide Distributed computing 34 // get messages from others in group byte[] buffer = new byte[1000]; for(int i=0; i< 3; i++) { DatagramPacket messageIn = new DatagramPacket(buffer, buffer.length); s.receive(messageIn); System.out.println(\"Received:\" + new String(messageIn.getData())); } s.leaveGroup(group); }catch (SocketException e){System.out.println(\"Socket: \" + e.getMessage()); }catch (IOException e){System.out.println(\"IO: \" + e.getMessage());} }finally {if(s != null) s.close();} } }","libVersion":"0.5.0","langs":""}