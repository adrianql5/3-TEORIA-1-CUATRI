{"path":"COMDIS/bibliografía/ApuntesAndrea.pdf","text":"CO M P U T A C I Ó N D I S T R I B U I D A An dr e a M . G ar cía ÍNDICE TEMA 1 Paradigmas computación distribuida 1 __________________________________________________________________________ Introducción 1 ................................................................................................................................................................................................................................... Aplicación distribuida vs convencional 1 ................................................................................................................................................................... Paradigmas en computación distribuida 1 ........................................................................................................................................................................................ 1. Paradigma del paso de mensajes 1 ......................................................................................................................................................................... 2. Paradigma cliente–servidor 2 ................................................................................................................................................................................. 3. Paradigma peer–to–peer (P2P) 2 ............................................................................................................................................................................ 4. Paradigma de sistema de mensajes 2 ..................................................................................................................................................................... 5. Paradigma de llamadas a procedimientos remotos (Remote Procedure Call) 3 .................................................................................................... 6. Paradigma de objetos distribuidos 4 ...................................................................................................................................................................... 7. Paradigma de agentes móviles 5 ............................................................................................................................................................................. 8. Paradigma de aplicaciones colaborativas (Groupware) 5 ....................................................................................................................................... TEMA 2 El API de SOCKETS 6 ___________________________________________________________________________________________ Introducción 6 ................................................................................................................................................................................................................................... Protocolo TCP/IP 6 ........................................................................................................................................................................................................................... Comunicación 7 ................................................................................................................................................................................................................................ Servidor TCP vs Cliente TCP 7 ......................................................................................................................................................................................................... Sockets datagramas en Java 7 ............................................................................................................................................................................................................ API de sockets en modo stream 9 ..................................................................................................................................................................................................... API de Sockets seguros 9 .................................................................................................................................................................................................................. Multidifusión 9 ................................................................................................................................................................................................................................. Multidifusión en IPv4 10 ............................................................................................................................................................................................ TEMA 3 Objetos Distribuidos 11 _________________________________________________________________________________________ Paso de mensajes vs Objetos Distribuidos 11 .................................................................................................................................................................................. 1. Paradigma de paso de mensajes 11 ........................................................................................................................................................................ 2. Paradigma de objetos distribuidos 11 .................................................................................................................................................................... Llamadas a procedimientos remotos vs Invocación de métodos remotos 12 ................................................................................................................................... 1. Llamada a procedimiento remoto 12 ..................................................................................................................................................................... 2. Remote Method Invocation 13 ............................................................................................................................................................................... El API de Java RMI 14 ....................................................................................................................................................................................................................... 1. Interfaz remota 14 .................................................................................................................................................................................................. 2. Software del servidor 15 ........................................................................................................................................................................................ 3. Software del cliente 16 ........................................................................................................................................................................................... Diferencias entre RMI y el API de Sockets 17 .................................................................................................................................................................................. Anexos 18 ......................................................................................................................................................................................................................................... TEMA 4 RMI AVANZADO 19 ____________________________________________________________________________________________ Cuestiones avanzadas 19 .................................................................................................................................................................................................................. Stub downloading 19 ........................................................................................................................................................................................................................ 1. Interacción entre cliente de objeto, servidor de objeto y el registro RMI cuando se utiliza descarga de resguardo 19 ......................................... 2. Uso de descarga de resguardo y un ﬁchero de políticas de seguridad 19 .............................................................................................................. 3. Fichero java.policy 20 ............................................................................................................................................................................................. 4. Colocación de los ﬁcheros 20 ................................................................................................................................................................................. RMI Security Manager 21 ................................................................................................................................................................................................................. 1. Algoritmo para construir aplicación RMI 21 .......................................................................................................................................................... RMI Callbacks 21 .............................................................................................................................................................................................................................. 1. Comunicaciones en ambos sentidos vs con Callbacks 22 ...................................................................................................................................... 2. Interacciones Cliente–Servidor con Callback 22 .................................................................................................................................................... 3. Ficheros de una aplicación Callback 23 .................................................................................................................................................................. 4. Colocación de los ﬁcheros en una RMI Callback 23 .............................................................................................................................................. 5. Interfaz RMI de Callback 23 ................................................................................................................................................................................... 6. Algoritmo para construir aplicación RMI con Callback 23 .................................................................................................................................... Serialización y envío de objetos 24 ................................................................................................................................................................................................... TEMA 5 CORBA 25 _____________________________________________________________________________________________________ Cuestiones avanzadas 25 .................................................................................................................................................................................................................. Arquitectura básica 25 ...................................................................................................................................................................................................................... Interfaz de objetos de CORBA 25 ..................................................................................................................................................................................................... Protocolos Inter–ORB 26 .................................................................................................................................................................................................................. Servidores de objetos y clientes de objetos 26 .................................................................................................................................................................................. Referencias a objetos CORBA 26 ...................................................................................................................................................................................................... Servicio de nombres de CORBA 27 .................................................................................................................................................................................................. Servicio de nombres interoperable de CORBA 28 ..................................................................................................................................................... Servicio de objetos CORBA 28 ......................................................................................................................................................................................................... Adaptadores de objetos 28 ................................................................................................................................................................................................................ IDL de Java 29 ................................................................................................................................................................................................................................... 1. Paquetes claves de Java IDL 29 .............................................................................................................................................................................. 2. Herramientas de Java IDL 29 ................................................................................................................................................................................. TEMA 6 CORBA Avanzado 30 ___________________________________________________________________________________________ Componentes de la arquitectura CORBA 30 .................................................................................................................................................................................... 1. Arquitectura de Gestión de objetos (OMA) 30 ...................................................................................................................................................... 2. Interoperabilidad en CORBA: GIOP/IIOP 31 ........................................................................................................................................................ CORBA IDL 31 ................................................................................................................................................................................................................................. 1. Interfaces con IDL 31 ............................................................................................................................................................................................. 2. Componentes 31 .................................................................................................................................................................................................... 3. Correspondencia IDL a Java 34 .............................................................................................................................................................................. 4. Resumen correspondencias IDL–Java 36 ............................................................................................................................................................... Interfaz de Invocación Dinámica (DII) 37 ........................................................................................................................................................................................ 1. Repositorio de interfaces 37 ................................................................................................................................................................................... 2. Interfaz de invocación dinámica (DII) 37 ............................................................................................................................................................... Servicio de eventos 38 ...................................................................................................................................................................................................................... 1. Tipos de modos de interacción con el canal 38 ...................................................................................................................................................... 2. Tipos de eventos 39 ................................................................................................................................................................................................ 3. Gestión del canal de eventos 39 ............................................................................................................................................................................. 4. Políticas del canal de eventos 39 ............................................................................................................................................................................ 5. Aplicación con eventos 40 ...................................................................................................................................................................................... TEMA 7 P2P 41 ________________________________________________________________________________________________________ Introducción 41 ................................................................................................................................................................................................................................. Características 41 .............................................................................................................................................................................................................................. Beneﬁcios 41 ..................................................................................................................................................................................................................................... Sistemas P2P populares 41 ............................................................................................................................................................................................................... 1. Napster 42 .............................................................................................................................................................................................................. 2. Gnutella 42 ............................................................................................................................................................................................................. 3. Kazaa 42 ................................................................................................................................................................................................................. 4. Freenet 43 .............................................................................................................................................................................................................. Redes P2P estructuradas 43 .............................................................................................................................................................................................................. Características 43 ....................................................................................................................................................................................................... DHT (Distributed Hash Tables) 43 ................................................................................................................................................................................................... Chord 44 ........................................................................................................................................................................................................................................... TEMA 8 Sistemas Multiagente 45 _______________________________________________________________________________________ Introducción 45 ................................................................................................................................................................................................................................. 1. Ubicuidad 45 .......................................................................................................................................................................................................... 2. Interconexión 45 .................................................................................................................................................................................................... 3. Inteligencia 45 ........................................................................................................................................................................................................ 4. Delegación 45 ......................................................................................................................................................................................................... 5. Orientado a humanos 45 ........................................................................................................................................................................................ Progreso de la programación 45 ....................................................................................................................................................................................................... Puntos de vista 46 ...................................................................................................................................................................................................... Cuestiones importantes 46 ............................................................................................................................................................................................................... Características de los agentes 46 ...................................................................................................................................................................................................... 1. Son entidades autónomas 46 ................................................................................................................................................................................. 2. Inteligencia 47 ........................................................................................................................................................................................................ 3. No actúan solos, sino como un sistema multi–agentes 47 .................................................................................................................................... 4. Habilidad social 47 ................................................................................................................................................................................................. 5. Movilidad 47 .......................................................................................................................................................................................................... Utilidad de los agentes 47 ................................................................................................................................................................................................................. Sistemas multiagentes vs orientados a objetos 48 ............................................................................................................................................................................ Sistemas multiagentes vs Sistemas expertos 48 ............................................................................................................................................................................... Desarrollar sistemas multi–agentes 48 ............................................................................................................................................................................................. Diferencias entre entornos 48 ........................................................................................................................................................................................................... 1. Entorno accesible 48 .............................................................................................................................................................................................. 2. Entorno determinístico 48 ..................................................................................................................................................................................... 3. Entorno episódico 48 ............................................................................................................................................................................................. 4. Entorno estático 48 ................................................................................................................................................................................................ 5. Entorno dinámico 49 .............................................................................................................................................................................................. 6. Entorno discreto 49 ................................................................................................................................................................................................ Sistemas de intenciones 49 ............................................................................................................................................................................................................... Metodologías para construir agentes 49 ........................................................................................................................................................................................... 1ª clasiﬁcación: en función del acceso a los sensores y actuadores de capas de control 49 ....................................................................................... 2ª clasiﬁcación: según el tipo de procesamiento 49 ................................................................................................................................................... Problemas en un sistema multi–agente 50 ....................................................................................................................................................................................... Comunicación entre agentes 50 ........................................................................................................................................................................................................ 1. Niveles de comunicación 51 ................................................................................................................................................................................... 2. Mecanismos de transporte 51 ................................................................................................................................................................................ 3. Lenguaje de comunicación 51 ................................................................................................................................................................................ 4. Protocolos de comunicación 51 .............................................................................................................................................................................. 5. Ontologías 51 ......................................................................................................................................................................................................... Servicio de transporte 51 .................................................................................................................................................................................................................. Objetivos de los actos del habla 51 ............................................................................................................................................................................ Requerimientos de los agentes 51 .................................................................................................................................................................................................... Tipos de mensajes 52 ........................................................................................................................................................................................................................ Protocolo FIPA–ACL 52 .................................................................................................................................................................................................................... 1. FIPA–query 52 ........................................................................................................................................................................................................ 2. FIPA–request 53 ..................................................................................................................................................................................................... 3. FIPA–request–when 53 .......................................................................................................................................................................................... 4. FIPA–contract–net 53 ............................................................................................................................................................................................. 5. FIPA–iterated–contract–net 53 ............................................................................................................................................................................... 6. FIPA–english–auction 54 ........................................................................................................................................................................................ 7. FIPA–dutch–auction 54 .......................................................................................................................................................................................... 8. FIPA–brokering 54 ................................................................................................................................................................................................. 9. FIPA–recruiting 54 ................................................................................................................................................................................................. 10. FIPA–subscribe 55 ................................................................................................................................................................................................ 11. FIPA–propose 55 .................................................................................................................................................................................................. JADE 55 ............................................................................................................................................................................................................................................ 1. Agentes auxiliares 55 ............................................................................................................................................................................................. 2. Tipos de comportamientos 56 ................................................................................................................................................................................ 3. Características de JADE 56 .................................................................................................................................................................................... ANEXOS Exámenes 59 __________________________________________________________________________________________________ 2015: resuelto 59 .............................................................................................................................................................................................................................. 2010: resuelto 61 .............................................................................................................................................................................................................................. Preguntas extras 64........................................................................................................................................................................................................................... TEMA 1: P a r a d ig ma s C om p . Dis tr ib u id a TEMA 1 PA R A D I G M A S C O M P U T A C I Ó N D I S T R I B U I D A INTR ODUCCIÓN Paradigma: patrón, ejemplo o modelo. Útil para clasiﬁcar los elementos (aplicaciones) de la materia. Una misma aplicación puede comportarse como dos modelos diferentes. Abstracción: proceso de encapsulación, esconder detalles. Se consigue gracias a herramientas o funcionalidades que permitan el desarrollo de software sin que el programador tenga que conocer las complejidades subyacentes. Middleware: capa de software que aumenta el nivel de abstracción. Deﬁnición del libro: software que actúa como intermediario entre procesos independientes. Los sistemas de mensajes son unos de los tipos de middleware, los ORB o broker de peticiones son otros. Ap l i c a c i ó n d i s t r i b u i d a vs c o nve n c i o n a l Lo que distingue a una aplicación distribuida de una convencional son las siguientes características: Comunicación entre procesos: necesita la participación de varias entidades (procesos). Los procesos necesitan comunicarse (repartir información) entre ellos. Los mecanismos de comunicación consiguen esto. Sincronización de eventos: el envío de mensajes debe ser sincronizado, es decir, si desde un proceso se envían datos tiene que haber otro proceso que esté esperando para recibirlos. PA R A D I G M A S E N C O M P U T A C I Ó N D I S T R I B U I D A \u0000 1. Paradi gm a de l paso de mensa jes Es el más básico e importante. Un proceso (emisor) envía un mensaje (petición) a otro proceso (receptor). El mensaje se entrega al receptor que lo procesa y envía una respuesta. Esta respuesta desencadena una serie de una serie de peticiones que darán lugar a más mensajes. Las operaciones básicas son enviar y recibir. También se necesitan conectar y desconectar para la comunicación orientada a conexión. Se realizan las operaciones como si se tratara de un ﬁchero: las operaciones sirven para encapsular el de talle de la comunicación a nivel del SO (el programador puede hacer uso de ellas para enviar y recibir mensajes sin preocuparse por los detalles). La interfaz de programación de aplicaciones de sockets se basa en este paradigma. Los procesos intercambian información así: un emisor inserta un mensaje en el socket y el receptor extrae el mensaje del socket para leerlo. En este modelo no está establecido el orden en el envío y recepción de \u0000 de \u00001 64 TEMA 1: P a r a d ig ma s C om p . Dis tr ib u id a mensajes. Además surge el paradigma Cliente–Servidor para resolver que ambos procesos (emisor y receptor) estén escuchando o escribiendo a la vez. 2. Paradi gm a client e–ser vidor Uno de los más conocidos. Este modelo asigna roles diferentes a los dos procesos que colaboran. De esta manera la sincronización de eventos se simpliﬁca. Servidor: proveedor del servicio, espera de forma pasiva la llegada de peticiones. Cliente: envía las peticiones al servidor y espera por las respuestas. Las operaciones serán aquellas necesarias para, en el servidor, esperar y aceptar peticiones y, en el cliente, emitir peticiones y aceptar respuestas. Este modelo proporciona una abstracción eﬁciente para servicios de red por lo que se usan mucho en los servicios de Internet. Ejemplos: HTTP, FTP, DNS... Protocolo de comunicación: descripción detallada de las situaciones que se encuentran los procesos y se establece el orden de la transmisión de mensajes. Para que el protocolo sea un estándar público debe tener un Request for comment (archivo). Este será revisado muy atentamente, si lo aceptan se le asignará un número. Cualquier protocolo de cualquier aplicación tiene su RFC asociado. Problemas: ‣ Cuello de botella al tener un solo servidor y muchos clientes. ‣ No da soporte para que el proceso servidor inicie la comunicación. Estos problemas se resuelven con el paradigma peer–to–peer. 3. Paradi gm a peer–t o–peer (P2P) Los procesos participantes interpretan los mismos papeles (pueden actuar al mismo tiempo como clientes y servidores en función del rol más eﬁciente para la red). Los ordenadores que en cliente–servidor eran clientes se intercambian recursos y servicios (intercambio de información, almacenamiento, etc.) entre ellos de manera directa. Cualquier participante puede enviar una petición a otro y recibir una respuesta. Para servicios centralizados es mejor el paradigma de cliente–servidor. El paradigma P2P es más apropiado para aplicaciones menos centralizadas como transferencia de mensajes, transferencia de ﬁcheros o videoconferencia. Un ejemplo muy conocido es Napster. A pesar de esto hay muchas aplicaciones que utilizan los dos modelos combinados es mejor esta solución desde el punto de vista de la privacidad. 4. Paradi gm a de sis t ema de mensa jes Este paradigma es una soﬁsticación de paso de mensajes. Intenta resolver el problema de la sincronización del envío de mensajes. Un servidor (sistema de mensajes) sirve de intermediario entre procesos separados e independientes. Este sistema tiene como funcionalidad que los procesos intercambien mensajes de forma asíncrona de una manera desacoplada. El emisor deposita un mensaje en el sistema de mensajes y este lo \u0000 de \u00002 64 TEMA 1: P a r a d ig ma s C om p . Dis tr ib u id a redirige a la cola de mensajes del receptor correspondiente (cada receptor tiene asociada una cola de mensajes). Una vez enviado el mensaje el emisor queda libre para realizar cualquier otra tarea. El receptor puede consultar en cualquier momento su cola de mensajes. El problema es que la cosa es estática por lo que si el receptor se desentiende de los mensajes se colapsaría. Es responsabilidad del receptor leer los mensajes para evitar este caso. Existen dos subtipos: Modelo punto a punto: el sistema de mensajes redirige el mensajes desde el emisor hasta la cola del receptor. El middleware proporciona un depósito para los mensajes de manera que permite que el envío y la recepción de mensajes estén desacoplados.  Comparándolo con el modelo de paso de mensajes este paradigma proporciona una abstracción para operaciones asíncronas. Para conseguir esto con el modelo básico sería necesario utilizar hilos o procesos hijo. Modelo pública/subscribe: cada mensaje tiene asociado un evento (información que puede ser requerida o no por los otros procesos). Las aplicaciones interesadas en la información de un evento pueden subscribirse a este. Cuando ocurre el evento el proceso publica un mensaje anunciándolo y el middleware se encarga de distribuir los mensajes a todos los subscriptores. Las operaciones utilizadas son publicar, que permite al proceso difundir a un grupo de otros procesos y suscribir que permite a un proceso escuchar esta difusión.   Este modelo aporta una gran abstracción para comunicaciones multicast. 5. Paradi gm a de llamadas a pr ocedimient os r emo t os (Remo t e Pr ocedur e Call) Según las aplicaciones crecen en complejidad se va necesitando un nivel mayor de abstracción para la programación distribuida. Sería deseable tener un paradigma que permita que el software distribuido se programase de forma similar al convencional. Esto se consigue gracias al paradigma de llamadas a procedimientos remotos que además consigue un alto nivel de abstracción tanto para la comunicación de procesos como para la sincronización de eventos. Imaginemos dos procesos independientes (pueden residir en máquinas diferentes) A y B. Si A desea realizar una petición a B, invoca un procedimiento de B pasando unos argumentos junto a la llamada. Una llamada a un procedimiento remoto dispara una acción predeﬁnida en un procedimiento de B. Al ﬁnalizar dicho procedimiento el proceso B devuelve un valor a A. Hay fundamentalmente dos APIs y las dos incorporan herramientas para transformar invocaciones remotas a llamadas a procedimientos locales: Los módulos se generan automáticamente. Se busca que el programador se abstraiga de los módulos y que para él sea como una llamada local. \u0000 de \u00003 64 TEMA 1: P a r a d ig ma s C om p . Dis tr ib u id a 6. Paradi gm a de obje t os dis tr ibuidos La idea es aplicar una orientación a objetos a las aplicaciones distribuidas de manera que estas acceden a objetos distribuidos sobre una red. Los objetos proporcionarán métodos e invocándolos desde una aplicación se tendrá acceso a los servicios. Existen los siguientes paradigmas basados en este: Invoc ac ión de mé t odos remo t os (Remo t e Me t hod Invoc at ion) Este paradigma es el equivalente orientado a objetos de la llamada a procedimientos remotos (RPC). Se basa en invocar métodos de un objeto que reside en otro ordenador (remoto). Igual que RPC se pueden pasar los argumentos y se puede devolver un valor. Un problema grave es la localización de recursos. Es necesario un mecanismo de localización de recursos dentro de la máquina: servicio de nombres (proceso activo todo el tiempo en la máquina del servidor. El cliente puede recurrir a él para conectarse a un recurso). El diálogo entre el cliente y el servidor de nombres es una aplicación cliente–servidor. El servidor de nombres es obligatorio que exista en cada máquina si hay objetos o recursos remotos. Paradi g ma de los ser v i c i os de red Existen proveedores de servicios que se registran en servidores de directorio de una red. Un proceso que desea un servicio contacta con el servidor de directorio/nombres (en tiempo de ejecución) y si está disponible se le dará una referencia al servicio deseado.   El proveedor de servicios debe registrarse (primero de todo) en el servicio de nombres. Este registro caduca así que es necesario renovar la entrada. De esta forma el cliente acude al servidor de directorio y hace uso del servicio. Este paradigma es una extensión del RPI. La diferencia es que los objetos de servicio se registran en un directorio permitiéndoles ser localizados y accedidos por solicitantes de servicios. Un ejemplo de este paradigma es la tecnología Jini de Java. Paradi g ma del Ob jec t Requ es t Broker Un proceso solicita una petición a un ORB (Object Request Broker) y este la redirige al objeto apropiado. Este paradigma se parece al anterior (RPI) en que los dos proporcionan un soporte para acceder remotamente a objetos. Sin embargo, la diferencia es que este paradigma funciona como middleware (permite a la aplicación acceder a varios objetos remotos o locales). Además este modelo funciona también como mediador para objetos heterogéneos (permite la interacción entre objetos implementados de forma diferentes o ejecutados en diferentes plataformas). Este paradigma es la base de la arquitectura CORBA de OMG. Las tecnologías basadas en componentes (JavaBeans, Enterprise Java Beans, etc.) también se basan en los paradigmas de objetos distribuidos (los componentes son básicamente objetos empaquetados y especializados). demás los servidores de aplicaciones son herramientas de tipo middleware para proporcionar acceso a objetos y componentes. Otras herramientas basadas en este modelo son Orbix de IONA, Java IDL o Visibroker de Inspire. Diferencias entre CORBA y RMI: Java RMI es propietario (propiedad de Oracle). CORBA es de código abierto pero en sentido del protocolo (son conocidos, abiertos y cualquiera puede implementarlo). \u0000 de \u00004 64 TEMA 1: P a r a d ig ma s C om p . Dis tr ib u id a CORBA es más complejo (implementaciones para multitud de lenguajes de programación). Paradi g ma del Esp ac i o de Ob je t os Quizás el más abstracto de los paradigmas orientados a objetos (todos los participantes van a converger en un espacio común abstracto). En este modelo existen entidades lógicas llamadas espacios de objetos. Un proveedor de servicios coloca los objetos en un espacio de objetos y el proceso quiere un proceso se suscribe al espacio y accede al objeto. El tener el espacio de objetos cumple que la abstracción adquirida oculta los detalles implicados en la búsqueda de recursos u objetos que son necesarios en otros paradigmas como RPI u ORB. Una herramienta basada en este paradigma es JavaSpaces. 7. Paradi gm a de ag ent es móviles Un agente es un programa u objeto transportable. En este modelo, el agente se lanza desde un ordenador viajando de forma autómata a otro de acuerdo con el itinerario que posea. En cada parada accederá a los recursos y servicios necesarios para realizar su tarea. Es necesario proporcionarle unos argumentos y él resolverá el problema. Un agente ha de ser móvil, autónomo e inteligente. Además tiene un lenguaje de programa muy complejo. El nivel de abstracción es muy alto ya que en lugar de intercambio de mensajes los datos son transportados. 8. Paradi gm a de aplicaciones colabor at i vas (Gr oupwar e) Los procesos participan en una sesión colaborativa como grupo. Cada participante puede hacer contribuciones a todos o parte del grupo. Esto se logra utilizando multidifusión (multicasting) para enviar los datos o usando pizarras virtuales (permiten a cada participante leer y escribir datos sobre una visualización compartida). \u0000 de \u00005 64 TEMA 2: El A PI d e s oc k e ts TEMA 2 EL A PI DE SO C K ET S INTR ODUCCIÓN API de sockets: interfaz de programación para la comunicación entre procesos (IPC) y ha sido traducido a todos los SO modernos. Es el estándar de facto para la programación IPC y es la base de interfaces IPC más soﬁsticados tales como Remote Procedure Call (RPC) y Remote Method Invocation (RMI). PR O T OC OL O T CP/IP Protocolo TCP/IP: protocolo independiente del fabricante, que sirve para permitir que un equipo pueda comunicarse en una red. Está disponible para cualquier ordenador o supercomputador, se utiliza tanto en LANs como WANs y es el más extendido en Internet. Tiene cuatro capas y cada una se construye sobre su predecesora: Capa física: topología de la red y conexiones globales a la red. Capa de datos: se ocupa del direccionamiento físico, del acceso al medio, de la detección de errores, de la distribución ordenada de tramas y del control del ﬂujo. Utiliza interfaces de comunicación (líneas dedicadas a alta capacidad, redes locales, implementaciones sobre puertos en serie…). Capa de red: se encarga de identiﬁcar el enrutamiento existente entre una o más redes. El objetivo de la capa de red es hacer que los datos lleguen desde el origen al destino (enrutamiento). Aparecen las direcciones IP y cada ordenador en la red dispone de una dirección única de 32 bits. Capa de transporte: se encarga de efectuar el transporte de los datos, independizándolos del tipo de red física que esté utilizando. Los datos a través de la red siempre se transmiten en formato Big Endian. Clases de redes IP: UDP: protocolo no orientado a conexión sino al paso de mensajes. No garantiza la correcta recepción de los datos ni el orden de los mismos. Es simple y rápido (poca carga adicional en la red). UDP utiliza puertos para permitir la comunicación entre aplicaciones. Existen fronteras entre mensajes. Es ideal para apps que requieres alta tasa de transferencia y donde las pérdidas no son importantes (videoconferencias...). Pero no existe el concepto Quality of Service, es decir, no garantiza un ancho de banda y puede haber retardos. TCP: protocolo orientado a conexión que garantiza la correcta recepción de la información y el orden de los paquetes (comunicación bidireccional). Se usa para transmisión ﬁable de información (telnet, FTP, HTTP…). A la hora de encapsular un frame para convertirlo en un Ethernet frame: Puerto: entero de 16 bits que se utiliza para identiﬁcar sin ambigüedad los procesos que intervienen en un diálogo. Asociación: una comunicación en Internet que consta de un protocolo (TCP o UDP), una dirección IP de la máquina local y otra de la remota de 32 bits y un puerto local y otro remoto de 16 bits. Fragmentación: dividir un mensaje en paquetes porque la mayoría de capas de red tienen un tamaño máximo de paquete que pueden manejar. Los paquetes de un mensaje pueden recibirse en desorden, \u0000 de \u00006 64 TCP/UDP TEMA 2: El A PI d e s oc k e ts pero los paquetes tienen un número de orden para reconstruirlos después y detectar fallos de transmisión en el ensamblado. Ensamblado: reconstruir el mensaje ordenando sus paquetes por el número y detección de fallos de transmisión (y solicitarlos de nuevo en caso de que sea necesario). Out of Band (OOB): mecanismo utilizado para no necesitar una memoria intermedia en la transmisión/recepción de información a través de una interfaz de comunicación. Los datos del canal OOB se envían antes que el resto. IPC de UNIX BSD 4.x: a partir de BSD 4.2 se implementa una IPC a través de llamadas al sistema. Antes de comunicarse, cada proceso debe crear un socket (mediante llamada al sistema socket()) especiﬁcando protocolo (UDP o TCP) y dominio (UNIX o Internet) y se devolverá un descriptor del socket susceptible de ser utilizado en llamadas posteriores. Debe tener un id que los demás procesos utilicen como dirección destino (llamada al sistema bind).   El socket es el encargado del envío y recepción de mensajes que se ponen en una cola hasta que se transmiten/extraen. CO M U N I C A C I Ó N Comunicación por datagramas: ‣ Primitiva de envío de mensajes: sendto (especiﬁcando mensaje, descriptor de socket propio y destino) ‣ Primitiva de recepción de mensajes: recvfrom (especiﬁcando socket propio, buﬀer de almacenamiento y remitente) Comunicación cliente–servidor: ‣ El cliente y servidor crean un socket –socket()– asociándole una dirección –bind()–. El servidor la publica de algún modo y el cliente la obtienes. El cliente envía un sendto() y el servidor lo recoge con un recvfrom(). Para responder, sus papeles se invierten. Comunicación encauzada (stream): ‣ Crear e identiﬁcar el par de sockets (similar a por datagramas). ‣ En este caso, el servidor escucha con listen(). ‣ El cliente solicita la conexión: connect(), y el servidor aceptará la conexión: accept(). ‣ Cuando hay una conexión (connect––accept), el SO crea un nuevo socket y los conecta al del cliente de modo que el servidor sigue escuchando en el socket original. ‣ Una vez conectados, la comunicación se hace a través de read(), write(), send() y recv(). ‣ Finalmente, se cierra la conexión: close(). SER VIDOR T CP VS CLIENTE T CP SOC KET S D A T A GRAMAS EN J A V A En Java tenemos dos clases proporcionadas por el API de sockets para datagramas: 1. La clase DatagramSocket para especiﬁcar el socket. 2. La clase DatagramPacket para representar al datagrama intercambiado. Servidor TCP en JAVA ServerSocket s = new ServerSocket(port); Socket socket = s.accept(); DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream output = new DataOutputStream(socket.getOutputStream()); System.out.println(input.readByte()); output.writeInt(8); socket.close(); s.close(); Clientes TCP en JAVA Socket socket = new Socket(\"usc.es\", port); DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream output = new DataOutputStream(socket.getOutputStream()); output.writeByte(5); System.out.println(input.readInt()); socket.close(); \u0000 de \u00007 64 TEMA 2: El A PI d e s oc k e ts Un proceso que desee enviar o recibir datos usando esta API debe crear una instancia de DatagramSocket. Cada socket está ligado (bound) a un puerto UDP de la máquina local donde reside el proceso. Para enviar un datagrama a otro proceso, un proceso hay que crear un objeto que represente el datagrama (DatagramPacket) que contenga los datos y la dirección de destino. Se emite una llamada a send() del DatagramSocket cuyo argumento es el DatagramPacket. En el proceso receptor se debe instanciar un objeto de tipo DatagramSocket y ligarlo a un puerto local. Para recibir datagramas enviados al socket, el proceso crea un objeto de tipo DatagramPacket que referencia a un array de bytes y llamar al método receive del objeto DatagramSocket, especiﬁcando como argumento una referencia al objeto DatagramPacket. Timeout: se usa para evitar bloqueos indeﬁnidos. Datos: 1. Tanto bajo TCP como UDP existe un rango de puertos reservados [1, 1023]. Únicamente los procesos con permisos de root podrán generar un socket en uno de esos puertos. 2. El puerto siempre se ﬁja en la parte del servidor. El cliente genera su puerto de forma automática. 3. Por defecto, un socket siempre es bloqueante, de forma que cuando realizamos una operación de lectura sobre el mismo, se suspende la ejecución del proceso si no hay datos en el buﬀer. 4. Suele ser preferible generar un proceso aparte para leer datos de un socket que ponerlo en modo no bloqueante y gestionar su lectura por interrupciones. Sockets no orientados a conexión: socket con lo que es posible que múltiples procesos simultáneamente envíen datagramas al mismo socket creado por el proceso receptor (el orden de recepción no es predecible). Programa receptor DatagramSocket ds = new DatagramSocket(2345); InetAddress receiverHost = InetAddress.getByName(“localHost\"); DatagramPacket dp = new DatagramPacket(buffer, MAXLEN); ds.receive(dp); Programa emisor InetAddress receiverHost = InetAddress.getByName(“localhost\"); DatagramSocket theSocket = new DatagramSocket(); String message = “Hola mundo”; byte[] data = message.getBytes(); DatagramPacket paq = new DatagramPacket(data, data.length, receiverHost, 2345); theSocket.send(theOutput); \u0000 de \u00008 64 TEMA 2: El A PI d e s oc k e ts API DE SOC KET S EN MODO S TREAM API de sockets en modo stream: en modo stream proporciona un modelo para la transmisión de datos basado en el modo encauzado de E/S proporcionado por los SO Unix. Da únicamente soporte a comunicación orientada a conexión. Un socket en modo stream se crea para el intercambio de datos entre dos procesos especíﬁcos. Los datos es escriben en un extremo del socket y se leen en el otro extremo. Un socket stream no puede utilizarse para comunicarnos con más de un proceso. Receive y accept son bloqueantes; send es no bloqueante. En Java, el API de sockets en modo stream se proporciona mediante dos clases: ServerSocket: para aceptar conexiones; llamaremos a un objeto de esta clase un socket de conexión. Socket: para el intercambio de datos; llamaremos a un objeto de esta clase un socket de datos. API DE SOC KET S SEGUR OS Sockets seguros: estos sockets realizan un cifrado de los datos transmitidos. El paquete Java TM Secure Socket Extensión (JSSE) permite comunicaciones seguras en Internet (implementa una versión Java de los protocolos SSL (Secure Sockets Layer) y TLS, e incluye funcionalidades de cifrado, autentiﬁcación e integridad). MUL TIDIFUSIÓN Multidifusión: la multidifusión IP se construye sobre el protocolo IP. La multidifusión IP permite que el emisor transmita un único paquete IP a un conjunto de computadores que forman un grupo de multidifusión. El emisor no está al tanto de las identidades de los receptores y del tamaño del grupo. Los grupos de multidifusión se especiﬁcan utilizando direcciones Internet de la clase D. La pertenencia a los grupos de multidifusión es dinámica, permitiendo que los computadores se apunten o borren a un número arbitrario de grupos en cualquier instante. Es posible enviar mensajes a un grupo de multidifusión sin pertenecer al mismo, pero debes ser miembro para recibir paquetes. Aceptador de conexión ServerSocket connectionSocket = new ServerSocket(port); Socket dataSocket = connectionSocket.accept(); OutputStream outStream = dataSocket.getOutputStream(); PrintWriter socketOutput = new PrintWriter(new OutputStreamWriter(outStream)); socketOutput.println(message); dataSocket.close(); connectionSocket.close(); Receptor   de conexión InetAddress acceptorHost = InetAddress.getByName(args[0]);  int acceptorPort = Integer.parseInt(port); Socket mySocket = new Socket(acceptorHost, acceptorPort);  InputStream inStream = mySocket.getInputStream(); BufferedReader socketInput = new BufferedReader(new InputStreamReader(inStream)); String message = socketInput.readLine(); mySocket.close(); \u0000 de \u00009 64 TEMA 2: El A PI d e s oc k e ts Mult idifusión en IPv4 Routers multidifusión: los paquetes IP pueden multidifundirse tanto en una red local como en todo Internet. Si la multidifusión va dirigida a Internet, debe hacer uso de las capacidades de multidifusión de los routers, los cuales reenvían los datagramas únicamente a otros routers de redes que pertenezcan al mismo grupo. Para limitar la distancia de propagación de un datagrama multidifusión, el emisor puede especiﬁcar el número de routers que puede cruzar (TTL, Time to Live). Reserva de direcciones multidifusión: las direcciones multidifusión se pueden reservar de forma temporal o permanente. Existen grupos permanentes, incluso sin ningún miembro. Sus direcciones son asignadas por la autoridad de Internet en el rango de 224.0.0.1 a 224.0.0.255. El resto de las direcciones multidifusión están disponibles para su uso por parte de grupos temporales. Cuando se crea un grupo temporal, se necesita una dirección de multidifusión libre para evitar conﬂictos. El protocolo de multidifusión IP no resuelve el problema de reservar la dirección. Cuando la comunicación es a nivel local, si se pone un TTL pequeño, es difícil que entremos en conﬂicto. Si se necesita multidifusión a nivel de Internet, es necesario reservar previamente una dirección. El programa de directorio de sesiones sirve para arrancar o unirse a una sesión multidifusión. Proporciona una herramienta que permite a los usuarios detectar sesiones multidifusión existentes y anunciar su propia sesión, especiﬁcando el tiempo y la duración de la reserva. Para España quien gestiona dicha agenda es RedIris. Multidifusión en JAVA Enviar MulticastSocket s = MulticastSocket(6789); InetAddress group = InetAddress.getByName(args[1]); s.joinGroup(group); byte [] m = args[0].getBytes(); DatagramPacket messageOut = new DatagramPacket(m, m.length, group, 6789); s.send(messageOut); Recibir byte[] buffer = new byte[1000]; for(int i = 0; i < n; i++) { DatagramPacket messageIn = new DatagramPacket(buffer, buffer.length); s.receive(messageIn); } s.leaveGroup(group); \u0000 de \u000010 64 TEMA 3: O b je t os d is tr ib u id os TEMA 3 OB J E T OS D IS T R IB UID OS PA S O D E M E N S A J E S VS OBJET OS DIS TRIBUIDOS 1. Pa r a d i g m a d e p a s o d e m e n s a j e s El paradigma de paso de mensajes es un modelo natural a usar en la computación distribuida ya que simula la comunicación entre personas. Es apropiado para los servicios de red porque estos procesos interactúan mandando y recibiendo mensajes. Sin embargo no proporciona la abstracción necesaria para aplicaciones de red complejas por varios motivos: • Los procesos estén fuertemente acoplados: los procesos deben comunicarse directamente entre ellos y si la comunicación se pierde la colaboración falla. • Está orientado a datos: los mensajes contienen datos en un formato determinado (acordado previamente) y se interpretan como peticiones o respuestas. Que sea orientado a datos está bien para servidores de red o aplicaciones de red sencillas pero si es una aplicación compleja que requiera un gran número de peticiones y respuestas sería una tarea imposible tratar con la interpretación de los mensajes. 2. Par adigma de obje t os dis tr ibuidos El paradigma de objetos distribuidos proporciona una mayor abstracción que el anterior. Está basado en objetos existentes en un sistema distribuido (en diferentes máquinas). Los objetos son entidades signiﬁcativas para la aplicación y contienen: • El estado o datos de la entidad (en java son las variables). • Las operaciones de la entidad que modiﬁcan el estado de la entidad (en Java son los métodos) Podemos clasiﬁcar los objetos en: Objetos locales: objetos cuyos métodos solo se pueden invocar desde un proceso local (proceso en la misma máquina en donde se encuentra el objeto) Objetos distribuidos: objetos cuyos métodos pueden invocarse por un proceso remoto (proceso en distinta máquina de la que se encuentra el objeto). El paradigma de objetos distribuidos es orientado a acciones (se hace hincapié en la invocación de métodos mientras que los datos tienen un papel secundario). Además es más natural para el desarrollo de software orientado a objetos. Sin embargo, el paradigma de paso de mensajes es orientado a datos.   Los recursos de la red son objetos distribuidos y si un proceso quiere solicitar un servicio de uno de estos recursos debe invocar a uno de sus métodos pasándole parámetros (datos). El método se ejecuta en la máquina remota y la respuesta se le envía al proceso solicitante.   Un proceso que se ejecuta en la máquina A realiza una llamada a un método (con los datos necesarios) de un objeto distribuido de la máquina B. Esta llamada invoca una acción realizada por el método en la máquina A y una salida que se pasa de A a B. Arquit ectura El objeto distribuido exportado por un proceso se llama servidor de objeto. Es necesario que exista un registro de objetos para registrar los objetos distribuidos. Para acceder a un objeto distribuido el cliente de objeto busca en el registro la referencia al objeto y la utiliza para realizar llamadas a métodos del objeto remoto (métodos remotos). Un componente software se encarga de gestionar la llamada, este componente se llama proxy de cliente. Se encarga de interactuar con el software en la máquina cliente para proporcionar soporte en tiempo de ejecución para el sistema de objetos distribuidos. Y \u0000 de \u000011 64 TEMA 3: O b je t os d is tr ib u id os este soporte se encarga de la comunicación, entre procesos, necesaria para la llamada a la máquina remota y el empaquetamiento de los argumentos En la parte del servidor el soporte en tiempo de ejecución gestiona la recepción de mensajes y envía la llamada al componente software llamado proxy de servidor. Este componente invoca la llamada al método local en el objeto distribuido (pasándole los datos desempaquetados como argumentos). El resultado de la ejecución del método se empaqueta y se envía desde el proxy del servidor al proxy del cliente a través del soporte en tiempo de ejecución y el soporte de red de ambas partes. Sis t emas Existe un gran número de herramientas basadas en el en este paradigma: • Java RMI (Remote Method Invocation), la más sencilla de todas. • Sistemas basados en CORBA (Common Object Request Broker Architecture). • Modelo de objetos de componentes distribuidos o DCOM (Distributed Componens Objet   Model). • Herramientas y API para el protocolo SOAP (Simple Object Acces Protocol). LL AMAD AS A PR OCEDIMIENT OS REMO T OS VS INV OC A CIÓN DE MÉT ODOS REMO T OS 1. L l a m a d a a p r o c e d i m i e n t o r e m o t o En este paradigma un proceso realiza una llamada a un procedimiento de otro proceso (en otra máquina). Como siempre, os datos se pasan a través de argumentos. Cuando un proceso recibe una llamada, se ejecuta la acción codiﬁcada en ese procedimiento. Después se le informa al proceso que invocó la llamada de que ha ﬁnalizado y si existe un valor de retorno (salida) se le envía. El modelo es orientado a procedimiento. Llamada a p roc edi mi en t o loc al y a p roc edi mi en t o remo t o El modelo RPC se ha utilizado mucho en las aplicaciones de red. Existen dos APIs que prevalecen en este paradigma: • Open Network Comuting Remote Procedure Call: evolución del API de RPC que desarrolló Sun Microsystems. • Open Group Distributed Computing Enviroment (DCE) RPC. Estas dos interfaces incorporan la herramienta rpcgen, que transforma las llamadas a procedimientos remotos en llamadas a procedimientos locales.   \u0000 de \u000012 64 TEMA 3: O b je t os d is tr ib u id os 2. Remo t e Me t hod Invocat ion El paradigma RMI es una implementación orientada a objetos del modelo RPC. Además es una API exclusiva para programas Java. En este paradigma un servidor de objeto exporta un objeto remoto y lo registra en el servicio de directorios. El objeto proporciona métodos remotos que pueden invocar los clientes. El objeto remoto se declara como una interfaz remota (extensión de la interfaz Java). El servidor de objeto implementa la interfaz remota y el cliente accede al objeto gracias a la invocación de sus métodos. Arquit ectura Parte del cliente ‣ La capa de resguardo o stub: un proceso cliente invoca un método remoto y esta invocación es dirigida a un objeto proxy (stub). Esta capa de resguardo está justo debajo de la de aplicación y sirve para interceptar las invocaciones a métodos remotos. Una vez interceptada la invocación se envía a la capa inferior, la capa de referencia remota. \u0000 de \u000013 64 TEMA 3: O b je t os d is tr ib u id os ‣ La capa de referencia remota interpreta y gestiona las referencias a los objetos hechas por los clientes e invoca las operaciones entre procesos de la siguiente capa, la capa de transporte, para transmitir las llamadas a la máquina remota. ‣ La capa de transporte (basada en TCP) es orientada a conexión. Esta capa y el resto de arquitectura se encargan de la conexión entre procesos y transmiten los datos (llamada al método) a la máquina remota Parte del servidor ‣ La capa esqueleto o skeleton está justo debajo de la capa de aplicación y se utiliza para interactuar con la capa de resguardo de la parte cliente. ‣ La capa de referencia remota gestiona y transforma la referencia remota originada por el cliente, en una referencia local. ‣ La capa de transporte es orientada a conexión igual que la del cliente. Registro de objetos ‣ El API de RMI posibilita el uso de diferentes servicios de directorios para registrar un objeto distribuido (uno de ellos es la interfaz de nombrado y directorios de JAVA = JNDI, es más general que el registro RMI ya que lo pueden usar aplicaciones que no usan el API RMI). ‣ El registro RMI, rmiregistry, es un servicio de directorios sencillo que proporciona el kit de desarrollo de software Java (SDK). Este registro es un servicio cuyo servidor se ejecuta en una máquina del servidor del objeto y utiliza el puerto 1099. EL API DE J A V A RMI 1. I n t e r f a z r e m o t a Este es el punto inicial para crear un objeto distribuido. Es una clase que se utiliza como plantilla para otras clases. Contiene las declaraciones de los métodos que deben implementar las clases que utilizan dicha interfaz. Es una interfaz que hereda de la clase remote que permite implementar la interfaz utilizando sintaxis RMI. Aparte de la extensión que se hace de esta clase y de que todas las declaraciones de los métodos deben especiﬁcar la clase RemoteException, una interfaz remota utiliza la misma sintaxis que una interfaz Java local. Cada declaración de un método debe especiﬁcar la excepción (líneas 9 y 12). Cuando ocurre un error durante el procesamiento de la invocación del método remoto se lanza la excepción que debe ser gestionada en el programa del método que lo invoca. \u0000 de \u000014 64 TEMA 3: O b je t os d is tr ib u id os Estos errores pueden ser: problemas en la comunicación entre los procesos (fallos de acceso, fallos de conexión) o problemas asociados a la invocación de métodos remotos (no encontrar un objeto, el resguardo o el esqueleto). 2. Sof twar e del ser vidor Es un objeto que proporciona los métodos y la interfaz de un objeto distribuido. Cada servidor objeto debe: - Implementar cada uno de los métodos remotos especiﬁcados en la interfaz. - Registrar en un servicio de directorios un objeto que contiene la implementación. Im plement ac ión int er f az remo t a Se debe crear una clase que implemente la interfaz remota. La sintaxis es similar a una clase que implementa una interfaz local. Las importaciones son necesarias para usar las clases UnicastRemoteObject y RemoteException (líneas 1 y 2). La cabecera de la clase (línea 8) debe especiﬁcar que es una subclase de la clase Java UnicastRemoteObject, y que implementa una interfaz remota especíﬁca. Se debe deﬁnir un constructor de la clase (líneas 11-13). La primera línea del código debe ser una sentencia (la llamada super()) que invoque al constructor de la clase base. A continuación, debe aparecer la implementación de cada método remoto (líneas 15-21). \u0000 de \u000015 64 TEMA 3: O b je t os d is tr ib u id os Gen erac i ón del resg u ardo y del esqu ele t o (s t u b y skele t on ) Un objeto distribuido requiere un proxy por cada uno de los servidores y clientes del objeto (skeleton y stub). Estos proxies se generan utilizando el compilador RMI rmic: rmic <nombre de la clase de la implementación de la interfaz remota>. Se generarán entonces: (nombre de la clase)_skel.class y (nombre de la clase)_stub.class. El ﬁchero del stub y el de la interfaz remota deben compartirse con cada cliente del objeto (son imprescindibles para que el cliente compile). Además, una copia de cada ﬁchero debe colocarse manualmente en la parte del cliente. (Java RMI dispone del stub downloading para que el cliente obtenga de forma dinámica el stub). El ser v i dor de ob je t o La clase del servidor de objeto instancia y exporta un objeto que implementa la interfaz remota. Creación de un objeto de la implementación de la interfaz remota. En la línea 19 se crea un objeto de la clase que implementa la interfaz remota; después, se exportará la referencia a este objeto. Exportación del objeto. Las líneas 20–23 exportan al objeto. Para esta exportación se debe registrar la referencia del objeto en un servicio de directorios (rmiregistry). Este rmiregistry debe ejecutarse en la máquina del servidor que exporta el objeto y está localizado en el puerto 1099. Además puede ejecutarse dinámicamente por el servidor. En un sistema de producción donde se utilice el servidor de registro RMI por defecto y esté ejecutando continuamente la llamada arrancarRegistro y el método pueden omitirse. La clase Naming proporciona métodos para almacenar y obtener referencias del registro. (rebind = almacenar en el registro una referencia a un objeto con una URL). El método rebind sobreescribe cualquier referencia en el registro asociada al nombre de la referencia (para no sobreescribir usar bind). El nombre de la máquina debe corresponder con el nombre del servidor (o usar localhost). El nombre de la referencia debe ser único en el registro. Cuando se ejecuta un servidor de objeto la exportación de los objetos distribuidos provoca que el proceso servidor comience a escuchar por el puerto y espere a que los clientes se conecten y soliciten el servicio. Este servidor es concurrente (cada solicitud de un cliente de objeto se procesa a través de un hilo independiente del servidor, por lo que es importante que la implementación de un objeto sea thread–safe). 3. Sof twar e del client e Es como cualquier otra clase Java. Para hacer uso de RMI supone: • Localizar el registro RMI en el nodo servidor. • Buscar la referencia remota para el servidor de objeto. Se realizará un cast de la referencia a la clase de la interfaz remota y se invocarán los métodos remotos. \u0000 de \u000016 64 TEMA 3: O b je t os d is tr ib u id os Sentencias de importación. Las sentencias de importación (líneas 1-4) se necesitan para que el programa pueda compilar. Búsqueda del objeto remoto. El código entre las líneas 24 y 27 permite buscar el objeto remoto en el registro. El método lookup de la clase Naming se utiliza para obtener la referencia al objeto, si existe, que previamente ha almacenado en el registro el servidor de objeto. Obsérvese que se debe hacer un cast de la referencia obtenida a la clase de la interfaz remota (no a su implementación. Invocación del método remoto. Se utiliza la referencia a la interfaz remota para invocar cualquiera de los métodos de dicha interfaz, como se muestra en las líneas 29-30. DIFEREN CIAS ENTRE RMI Y EL API DE SOC KET S El API de RMI es una herramienta eﬁciente para construir aplicaciones de red. Puede utilizarse en lugar del API de sockets (que representa el paradigma de paso de mensajes) para construir una aplicación de red rápidamente. S Algunas de estas ventajas y desventajas: ‣ El API de sockets está más cercano al SO, por lo que tiene menos sobrecarga de ejecución. RMI requiere soporte software adicional, incluyendo los proxies y el servicio de directorio, que inevitablemente implican una sobrecarga en tiempo de ejecución. Para aplicaciones que requieran alto rendimiento, el API de sockets puede ser la única solución viable. ‣ El API de RMI proporciona la abstracción necesaria para facilitar el desarrollo de software. Los programas desarrollados con un nivel más alto de abstracción son más comprensibles y por tanto más sencillos de depurar. ‣ Debido a que el API de sockets opera a más bajo nivel, se trata de una API independiente de plataforma y lenguaje. Puede no ocurrir lo mismo con RMI. Java RMI, por ejemplo, requiere soportes de tiempo de ejecución especíﬁcos de Java. Como resultado, una aplicación implementada con Java RMI debe escribirse en Java y sólo se puede ejecutar en plataformas Java. La elección de un paradigma y una API apropiados es una decisión clave en el diseño de una aplicación. Dependiendo de las circunstancias, es posible que algunas partes de la aplicación utilicen un paradigma o API y otras partes otro. Debido a la relativa facilidad con la que las aplicaciones de red pueden desarrollarse utilizando RMI, RMI es un buen candidato para el desarrollo rápido de un prototipo de una aplicación. \u0000 de \u000017 64 TEMA 3: O b je t os d is tr ib u id os ANEX OS \u0000 de \u000018 64 TEMA 4: RMI a v a nza d o TEMA 4 RMI A V ANZADO CUES TIONES A V ANZAD AS RMI avanzado incorpora nuevos mecanismos que pueden ser útiles para los desarrolladores de aplicaciones: • Descarga de resguardo (stub downloading). • Gestiones de seguridad (security manager). • Callback de cliente. • Serialización y envío de objetos. ST U B D O W N L O A D I N G Como ya vimos en el tema anterior Java RMI incorpora un método para que los clientes obtengan dinámicamente el stub. A este método se le llama descarga dinámica de resguardo. Se puede obtener dinámicamente la clase resguardo de un servidor HTTP de forma que puede interactuar con el cliente de objeto. Es necesario establecer medidas de seguridad tanto en la parte del cliente como del servidor. En concreto, es necesario un ﬁchero que describa la política de seguridad (java.policy). Debe realizarse una instancia de un Java Security Manager tanto en el cliente como en el servidor. 1. I n t e r a c c i ó n e n t r e c l i e n t e d e o b j e t o , s e r v i d o r d e o b j e t o y e l r e g i s t r o R M I cuando se ut iliza descar g a de r esguar do 2. Uso de descar g a de r esguar do y un f ic her o de polít icas de segur idad 1. Si debe descargarse el resguardo de un servidor HTTP, transﬁera la clase resguardo a un directorio apropiado del servidor HTTP y es necesario asegurarse de que tiene los permisos de acceso adecuados. 2. Cuando activamos el servidor se debe especiﬁcar las siguientes opciones: \u0000 de \u000019 64 TEMA 4: RMI a v a nza d o java –Djava.rmi.server.codbase=<URL>  –Djava.security.policy=  <ruta completa del fichero de políticas de seguridad>  donde <URL> es el URL del directorio donde se encuentra la clase resguardo; por ejemplo, http://www.miempresa.com/resguardos/. Obsérvese la barra del ﬁnal del URL, que indica que el URL especiﬁca un directorio, no un ﬁchero. <ruta completa del ﬁchero de políticas de seguridad> especiﬁca el ﬁchero de políticas de seguridad de la aplicación; por ejemplo, java.security, si el ﬁchero java.security se encuentra en el directorio actual. 3. Fic her o ja va.policy El ﬁchero de políticas de seguridad de Java es un ﬁchero de texto que contiene códigos que permiten la concesión de permisos especíﬁcos. Es recomendable hacer una copia del ﬁchero en el directorio tanto de la máquina del cliente como en la del servidor. Cuando activemos el cliente se debe utilizar la siguiente opción para especiﬁcar los permisos que debe tener el cliente de objeto, deﬁnidos en el ﬁchero de políticas: java –Djava.security.policy=java.policy ClienteEjemplo Lo mismo para el servidor: java –Djava.security.policy=java.policy ServidorEjemplo 4. Colocación de los f ic her os \u0000 de \u000020 64 TEMA 4: RMI a v a nza d o RMI SECURIT Y MAN A GER Puesto que RMI involucra el acceso desde/a una máquina remota y posiblemente la descarga de objetos, es importante que tanto el servidor como el cliente se protejan ante accesos inadecuados o no permitidos. RMISecurityManager es una clase Java que puede ser instanciada tanto en el cliente como en el servidor para limitar los privilegios de acceso. Para escribir nuestro propio gestor de seguridad podemos utilizar: System.setSecurityManager(new RMISecurityManager()); 1. A l g o r i t m o p a r a c o n s t r u i r a p l i c a c i ó n R M I LADO SERVIDOR 1. Crear un directorio donde se almacenen todos los ﬁcheros generados por la aplicación. 2. Especiﬁcar la interfaz remota y compilarla para generar el archivo .class de la interfaz. 3. Construir el servidor remoto implementando la interfaz y compilarlo hasta que no haya ningún error que no haya ningún error. 4. Usar rmic para procesar la clase del servidor y generar un ﬁchero .class de stub y un ﬁchero .class de skeleton:   rmic SomeServer. 5. Si se desea stub downloading, copiar el ﬁchero stub al directorio apropiado del servidor HTTP. 6. Activar el RMIRegistry en el caso de que no haya sido activado previamente. 7. Construir un ﬁchero de políticas de seguridad para la aplicación llamado java.policy. 8. Activar el servidor especiﬁcando: (i) campo codebase si se utiliza stub downloading. (ii) nombre del servidor. (iii) ﬁchero de políticas de seguridad. LADO CLIENTE 1. Crear un directorio donde se almacenen todos los ﬁcheros generados por la aplicación. 2. Implementar el programa cliente o applet y compilarlo para generar la clase cliente. 3. Si no se puede usar stub downloading, copiar el ﬁchero class de stub a mano. 4. Especiﬁcar el ﬁchero de políticas de seguridad java.policy. 5. Activar el cliente especiﬁcando: (i) nombre p() del servidor. (ii) ﬁchero con las políticas de seguridad. RMI C ALLB A C KS En el modelo cliente–servidor, el servidor es pasivo (la comunicación IPC es iniciada por el cliente, el servidor espera por la llegada de las peticiones y proporciona las respuestas). Pero algunas aplicaciones necesitan que el servidor inicie la comunicación ante la ocurrencia de determinados eventos (juegos, subastas…). Una forma de llevar a cabo la transmisión de información es que cada proceso cliente realice un sondeo (pulling) a un servidor pasivo repetidas veces si necesita ser notiﬁcado de que un evento ha ocurrido en el servidor. \u0000 de \u000021 64 TEMA 4: RMI a v a nza d o 1. C o m u n i c a c i o n e s e n a m b o s s e n t i d o s vs con Callbac k s Algunas aplicaciones necesitan que ambos lados puedan iniciar una comunicación IPC. Al usar sockets (dos en cada lado) podemos conseguir una comunicación dúplex. Con sockets orientados a conexión cada lado actúa tanto como cliente como servidor. Sin embargo un cliente callback se registra en un servidor RMI. El servidor realiza el callback a cada cliente registrado ante la ocurrencia de un determinado evento. 2. Int er acciones Client e–Ser vidor con Callbac k 1. El cliente busca el objeto interfaz en el registro RMI del host del servidor. 2. El registro RMI le devuelve una referencia remota del objeto interfaz 3. El cliente invoca al método de registrarse con callback gracias al stub del servidor. Le pasa una referencia remota de sí mismo y el servidor guarda la referencia en su lista de callback. 4. Gracias al stub del servidor el cliente interactua con el skeleton del objeto interfaz para acceder a los métodos de este objeto. 5. Cuando el evento ocurre el servidor hace el callback a cada uno de sus clientes registrados por callback mediante su stub y el skeleton del cliente. \u0000 de \u000022 64 TEMA 4: RMI a v a nza d o 3. Fic her os de una aplicación Callbac k 4. Colocación de los f ic her os en una RMI Callbac k 5. Int er f az RMI de Callbac k El servidor proporciona un método remoto que permite al cliente registrarse para recibir callbacks. Para esto es necesario una interfaz remota para callback además de la interfaz de servidor. Esta interfaz epeciﬁca un método para aceptar llamadas de un servidor. El programa cliente es una subclase de RemoteObject e implementa la interfaz callback (incluido el método de callback). El cliente se registra en su método main para el callback y el servidor invoca al método remoto del cliente ante la ocurrencia de un determinado evento. 6. A lgor itmo par a cons tr uir aplicación RMI con Callbac k LADO SERVIDOR 1. Crear un directorio donde se almacenen todos los ﬁcheros generados por la aplicación. 2. Especiﬁcar la interfaz remota de servidor y compilarla para generar el ﬁchero .class de la interfaz. 3. Construir la clase remota del servidor implementando el interfaz y compilarla hasta que no exista ningún error de sintaxis. \u0000 de \u000023 64 TEMA 4: RMI a v a nza d o 4. Utilizar rmic para procesar la clase del servidor y generar un ﬁchero .class de stub y otro ﬁchero .class de skeleton. 5. Si se requiere stub downloading, copiar el ﬁchero stub al directorio apropiado del servidor HTTP. 6. Activar el registro de RMI, si no estaba previamente activo. 7. Establecer la política de seguridad en el archivo java.policy. 8. Activar el servidor especiﬁcando: (i) el codebase si se requiere stub downloading. (ii) nombre del servidor. (iii) ﬁchero con la política de seguridad. 9. Obtener el CallbackInterface. Compilarlo con javac y usar rmic para generar el ﬁchero de stub para la callback. LADO CLIENTE 1. Crear un directorio donde se almacenen todos los ﬁcheros generados por la aplicación. 2. Implementar el programa cliente o applet y compilarlo para generar la clase cliente. 3. Si no está activo el stub downloading, copiar el ﬁchero .class del stub correspondiente al interfaz del servidor a mano. 4. Implementar la interfaz de callback. Compilarla usando javac, y usando rmic generar los ﬁcheros .class correspondientes al stub y el skeleton. 5. Establecer la política de seguridad en el ﬁchero java.policy. 6. Activar el cliente especiﬁcando: (i) nombre del servidor. (ii) ﬁchero con la política de seguridad. SERIALIZA CIÓN Y ENVÍO DE OBJET OS A veces, resulta necesario pasar como argumento a un método de un objeto remoto tipos de datos complejos (objetos que hayamos creado nosotros). Es posible gracias a la serialización: es un mecanismo que encapsula el contenido de un objeto (código + datos) en una cadena de bytes que puede ser enviada a través de la red –canal de comunicación– o almacenada en una base de datos. Java nos garantiza que será correcta la reconstrucción del objeto recibido y que funcionará sin problemas. Para pasar como argumento en una invocación remota un objeto es indispensable que dicho objeto sea serializable. Ejemplo: integración numérica (programa iterativo para calcular una suma, aproximación numérica de integrales, regla del punto medio). Este ejemplo codiﬁcado está en los apuntes. \u0000 de \u000024 64 TEMA 5: C O RB A TEMA 5 CO R B A CUES TIONES A V ANZAD AS CORBA (Common Object Request Broker Architecture) es una arquitectura de objetos distribuidos diseñada para permitir que dichos objetos distribuidos interoperen sobre entornos heterogéneos, donde los objetos pueden estar implementados en diferentes lenguajes de programación y/o desplegados sobre diferentes plataformas. CORBA es diferente a Java RMI en: • Java RMI es una tecnología propietaria de Sun Microsystems Inc. y CORBA fue desarrollada por OMG (Object Management Group), un consorcio de empresas. • Java RMI solo soporta objetos que se encuentren en lenguaje Java y CORBA fue diseñado para maximizar el grado de interoperabilidad. Es importante saber que CORBA en sí mismo NO es una herramienta para dar soporte a objetos distribuidos, sino que se trata de un conjunto de protocolos. La herramienta que da soporte a dichos protocolos se denomina compatible con CORBA (CORBA compliant) y los objetos que se desarrollan sobre ella podrán interoperar con otros objetos desarrollados por otra herramienta compatible con CORBA. AR QUITECTURA B ÁSIC A Un cliente de objeto realiza una llamada a un método de un objeto distribuido. El cliente interactúa con un proxy, un stub, mientras que la implementación del objeto interactúa con un proxy del servidor, un skeleton. Existe una capa de software llamada ORB (Object Request Broker). En el lado del cliente la capa ORB actúa como intermediaria entre el stub y la red y el SO del cliente. En el lado del servidor la capa ORB sirve de intermediaria entre el skeleton y la red y el SO del servidor. Las capas ORB de los dos extremos son capaces de resolver las diferencias ente los lenguajes de programación así como las relativas a las plataformas. El cliente utiliza el servicio de nombrado para localizar el objeto. INTERF AZ DE OBJET OS DE C ORB A Un objeto distribuido se deﬁne usando un ﬁchero similar al ﬁchero que deﬁne la interfaz remota en Java RMI. Debido a que CORBA es independiente del lenguaje, la interfaz se deﬁne por medio de un lenguaje universal con una sintaxis especíﬁca, conocido como CORBA Interface Deﬁnition Languaje (IDL). La sintaxis de este lenguaje es muy similar a la de Java o C++, pero un objeto distribuido en CORBA puede implementarse en un gran número de lenguajes. Para cada uno de estos lenguajes, OMG (Object Management Group) tiene una traducción estándar de CORBA IDL a dicho lenguaje. De esta forma se puede usar un compilador para procesar interfaces CORBA y generar los proxies necesarios para servir de interfaz ante la implementación o ante el cliente (escritos en cualquier lenguaje soportado por CORBA). \u0000 de \u000025 64 TEMA 5: C O RB A En Java RMI tengo un registro por cada máquina que soporta un servidor. Sin embargo en ORB tengo un único servicio de nombres al que van a acudir tanto los clientes como servidores. Puede ocurrir que dos elementos situados en ORB distintas puedan interactuar entre ellos, ORB lo permite. \u0000 PR O T OC OL OS INTER–ORB Para que dos ORB puedan interoperar se ha especiﬁcado un protocolo conocido como General Inter–ORB Protocol (GIOP). Es una especiﬁcación que proporciona un marco general para que se construyan protocolos interoperables encima de un nivel de transporte especíﬁco. Un caso especiales el Internet Inter–ORB Protocol (IIOP) que se corresponde con el GIOP aplicado sobre el nivel de transporte TCP/IP. IIOP incluye los siguientes elementos: Requisitos de gestión de transporte. Especiﬁcan qué se necesita para conectarse y desconectarse, y los papeles que el cliente y el objeto servidor interpretan en establecer y liberar conexiones. Deﬁnición de la representación común de datos. Se necesita deﬁnir un esquema de codiﬁcación para empaquetar y desempaquetar los datos para cada tipo de datos IDL. Formatos de los mensajes. Se necesita deﬁnir diferentes formatos de los distintos tipos de mensajes. Estos permiten a los clientes enviar solicitudes al objeto servidor y recibir sus respuestas. Un ORB que soporte la especiﬁcación IIOP puede interoperar con otro ORB compatible con IIOP a través de internet (bus de objetos). Internet se ve como un bus de objetos CORBA interconectados, como en la siguiente imagen: SER VIDORES DE OBJET OS Y CLIENTES DE OBJET OS Un servidor de objetos exporta cada objeto distribuido CORBA. Un cliente de objetos obtiene la referencia a un objeto distribuido por medio de un servidor de nombres o de directorio y posteriormente invoca los métodos de dicho objeto. REFEREN CIAS A OBJET OS C ORB A Un objeto distribuido CORBA se localiza por medio de una referencia a objeto. Ya que CORBA es independiente del lenguaje, una referencia a un objeto es una entidad abstracta traducida a una referencia de objeto especíﬁca de cada lenguaje por medio del ORB. \u0000 de \u000026 64 TEMA 5: C O RB A Por interporabilidad, OMG especiﬁca un protocolo para referencias abstractas de objetos, Interoperable Object Reference (IOR). Un ORB que sea compatible con el protocolo IOR permitirá que una referencia a objeto se registre y se obtenga desde un servicio de directorio compatible con IOR. Las referencias de objetos CORBA se denominan también IOR. Una IOR es la cadena de caracteres que contiene codiﬁcada la siguiente información: - Tipo de objeto. - Ordenador donde se encuentra el objeto. - Número de puesto del servidor del objeto. - Clave del objeto (cadena de bytes que identiﬁca al objeto). Esta clave la utiliza el servidor de objetos para localizar al objeto internamente. Ejemplo de cadena IOR: Preﬁjo con los caracteres “IOR:” seguido por una secuencia hexadecimal de caracteres numéricos (cada carácter representa 4 bits de datos binarios en la IOR). SER VICIO DE N OMBRES DE C ORB A CORBA especiﬁca un servicio de directorio, servicio de nombres (Naming Service). Sirve como un directorio de objetos CORBA. Se diferencia del registro RMI en que es independiente de plataforma y de lenguaje de programación. Permite que los clientes basados en ORB obtener las referencias a los objetos que desean usar y asociar nombres a referencias objetos. Los clientes pueden consultar al servicio usando un nombre predeterminado para obtener la referencia asociada al objeto. Para exportar un objeto distribuido, un servidor de objetos CORBA contacta con el Servidor de Nombres para asociar (bind) un nombre simbólico al objeto. El servicio mantiene una BD con los nombres y sus objetos asociados. Para obtener una referencia a un objeto, un cliente de objetos solicita que el Servicio de Nombres busque el objeto asociado con dicho nombre (resolución, resolve). El API para el Servicio de Nombre se encuentra especiﬁcada por medio de una interfaz IDL. El esquema de nombrado de objetos en CORBA es complejo. Esto es porque el espacio de nombrado es universal, se deﬁne una jerarquía de nombrado estándar de una manera similar a un directorio de ﬁcheros. Un contexto de nombrado (naming context) se corresponde con una carpeta o directorio en un árbol de ﬁcheros, mientras que los nombres de objetos se corresponden con los ﬁcheros. El nombre de un objeto incluidos sus contextos de nombrado se denomina nombre compuesto (el primer componente proporciona un nombre de contexto de nombrado donde se encuentra el segundo). Los contextos de nombrado y los nombres se crean utilizando los métodos de la interfaz del Servicio de Nombres. Sintaxis nombre de un objeto: <contexto de nombrado>.<contexto de nombrado>. ... .<contexto de nombrado>.<nombre del objeto> \u0000 de \u000027 64 TEMA 5: C O RB A Ejemplo: Ser vicio de nombr es int er oper able de C ORBA Interoperable Naming Service (INS): es un sistema de nombrado basado en el formato URL, para el Servicio de Nombres de CORBA. Permite que las aplicaciones compartan un contexto inicial de nombrado y que proporcionen un URL para acceder a un objeto CORBA. SER VICIO DE OBJET OS C ORB A CORBA proporciona servicios que pueden ser usados habitualmente por los objetos distribuidos para construir aplicaciones: Cada servicio se deﬁne por medio de un IDL y los métodos del objeto de servicio se pueden invocar desde cualquier cliente. AD APT ADORES DE OBJET OS La implementación de objetos distribuidos interactúa con el skeleton para conectarse con el stub (en el lado del cliente). Se añadió un componente software al skeleton del lado del servidor, el adaptador de objetos (object adapter). Este simpliﬁca las responsabilidades que tiene un ORB asistiéndole en hacer peticiones del cliente a la implementación del objeto. Cuando un ORB recibe una petición del cliente localiza al adaptador asociado a ese objeto y le redirige la petición. Este adaptador interactúa con el skeleton de la implementación del objeto que realiza el empaquetamiento e invoca al método del objeto. Hay diferentes tipos de adaptadores de objetos CORBA. El Potable Object Adapter (POA) es un tipo particular de adaptador de objetos. Permite que una implementación de objeto funcione en carios ORB de forma que la implementación del objeto sea portable a través de varias plataformas. Servicio de concurrencia (Concurrency Service) Servicio que proporciona control de concurrencia Servicio de eventos (Event Service) Para la sincronización de eventos Servicio de log (Logging Service) Para registrar eventos Servicio de nombres (Naming Service) Servicio de directorio Servicio de planiﬁcación (Schedulling Service) Para planiﬁcación de eventos Servicio de seguridad (Security Service) Para gestión de seguridad Servicio de negociación (Trading Service) Para localizar servicio por tipo (no por nombre) Servicio de tiempo (Time Service) Un servicio para eventos relativos al tiempo Servicio de notiﬁcación (Nottiﬁcation Service) Para notiﬁcación de eventos Servicio de transacciones de objetos (Object Transaction Service) Servicio de transacciones de objetos (Object Transaction Service) \u0000 de \u000028 64 TEMA 5: C O RB A IDL DE J A V A Java IDL es parte de la plataforma Java 2, Standard Edition (J2SE). Incluye un ORB, un compilador IDL-a- Java y un subconjunto de los servicios estándar de CORBA. Además de esta, Java proporciona más herramientas compatibles con CORBA como RMI sobre IIOP que permite que una aplicación CORBA se escriba con la sintaxis y la semántica de RMI. 1. Pa q u e t e s c l a ve s d e J a va I D L org.omg.CORBA – Contiene las interfaces y clases que proporcionan la traducción de las API de CORMA al lenguaje Java. org.omg.CosNaming – Contiene las interfaces y clases que dan soporte al Servicio de Nombres para Java IDL. org.omg.CORBA.ORB – Contiene interfaces y clases para soportar el API de acceso al ORB. 2. Her r amient as de Ja va IDL idlj – El compilador IDL–a–Java. orbd – Proceso servidor que da soporte al Servicio de Nombres, así como otros servicios. servertool – Proporciona una interfaz en línea de mandatos para que los programadores puedan   registrar/desregistrar objetos, y arrancar/parar servidores. tnameserv – Una versión antigua del Servicio de Nombres de Java IDL. Se desaconseja su uso   \u0000 de \u000029 64 TEMA 6: C O RB A a v a nza d o TEMA 6 CO R B A A V A N Z A D O CO M P O N E N T E S D E L A A R Q U I T E C T U R A CO R B A   Invocación estática \u0000 Invocación dinámica \u0000   1. A r q u i t e c t u r a d e G e s t i ó n d e o b j e t o s ( O M A ) \u0000 de \u000030 64 TEMA 6: C O RB A a v a nza d o 2. Int er oper abilidad en C ORBA: GIOP/IIOP CO R B A I D L 1. I n t e r f a c e s c o n I D L Una especiﬁcación IDL es un contrato entre cliente y servidor: • IDL especiﬁca la sintaxis de las interfaces. • La semántica se puede expresar como comentarios. • El lenguaje IDL es independiente de lenguajes de programación y sistemas operativos. La correspondencia de IDL a Java o C++ la realiza el compilador. Una especiﬁcación IDL comprende: • Declaraciones de módulos. • Declaraciones de interfaces (soporta herencia y declaraciones de operaciones y atributos). • Declaraciones de tipos de datos, constantes y excepciones (necesarios para deﬁnir las   operaciones y atributos). 2. Com ponent es Ident if ic adores miObjeto y MIOBJETO son identiﬁcadores distintos aunque no pueden usarse en la misma declaración de interfaz. En Java se corresponde con un package y en C++ con un nameespace. Coment ar ios Módu los Permiten agrupar varias deﬁniciones IDL que comparten un propósito. Un módulo deﬁne un ámbito de nombrado: module Banca{ interface CuentaCoriente{…} interface Banco{…} } Para referirse a un identiﬁcador de otro módulo se usa :: Banca::CuentaCorriente // Comentarios hasta ﬁnal de línea /*…*/ Comentarios hasta donde se quiera siempre que esté cerrado ( */ ) \u0000 de \u000031 64 TEMA 6: C O RB A a v a nza d o Ti p os d e va r i a b le s Tipos primitivos  - void: para métodos que no devuelven ningún valor. - boolean: TRUE o FALSE. - char y wchar: un carácter guardado en 8 o 16 bits. - short: un entero con signo de 16 bits. - unsigned short: un entero sin signo de 16 bits. - long: un entero con signo de 32 bits. - unsigned long: un entero sin signo de 32 bits. - long long: un entero con signo de 64 bits idlltiid64bit - unsigned long long: un entero sin signo de 64 bits - ﬂoat: número de coma ﬂotante de precisión simple en formato IEEE (4 bytes). - double: número de coma ﬂotante de precisión doble en formato IEEE (8 bytes). - octet: grupo de 8 bits que se transmiten tal cual. - any: sirve para especiﬁcar que un parámetro puede ser de cualquier tipo. El proceso que lo recibe   debe determinar qué tipo de valor tiene y extraerlo. Hace las interfaces más difíciles.   Tipos construidos  - string: representa una cadena de caracteres   (tipo char = strig; tipo wchar = wstring).   Para limitar la longitud de un string debemos colocar la limitación entre < y >. - enum: deﬁne un nuevo tipo con un conjunto de valores deﬁnidos por el usuario.   Ej: enum Dia(lunes, martes, miércoles, jueves, viernes, sábado, domingo). - struct: empaqueta un conjunto de miembros nombrados de varios tipos. - union: estructura que tiene un solo miembro entre varias alternativas. Ej: union compilador  switch (Lenguaje){case Java: string versionstring; default: long versionlong;} - sequence: representa una secuencia de datos de un mismo tipo. Puede ser limitada la longitd y puede ser vacía. Debe deﬁnirse con un typedef o un struct.  Ej: typedef sequence <long,3> números; - array: representa un array de uno o más dimensiones de tamaño ﬁjo - typedef: para dar un nombre más signiﬁcativo a un tipo dado. También permite la deﬁnición de   nuevos tipos con sequence y array.   Comparación entre array y sequence: ‣ En un array se transmiten todos sus elementos en cada llamada a operación. ‣ Un array es siempre de longitud ﬁja, una secuencia puede variar de tamaño. ‣ Un array no puede ser limitado una secuencia sí. ‣ Una secuencia puede no tener ningún elemento, un array no. ‣ Una array puede ser multidimensional, las secuencias no. Primitivos Contruidos Entero short, long, long long struct signed & unsigned unión Coma ﬂotante ﬂoat, doublem long doublé, ﬁxed enum char, wchar, boolean, octet sequence any string, wstring Referencia a objeto CORBA Contenedores array typedef \u0000 de \u000032 64 TEMA 6: C O RB A a v a nza d o Int er f az Una interfaz es un grupo de operaciones y atributos, una unidad de herencia o un objeto que implementa uno o más interfaces. Herencia de interfaces Permite obtener una nueva interfaz a partir de uno o más interfaces ya existentes. Soporta herencia múltiple y todas las interfaces heredan de CORBA. Se pueden añadir nuevos elementos (constantes, atributos, operaciones...). Aunque no se pueden redeﬁnir las operaciones heredadas ni hacer nuevas operaciones con el mismo nombre que las ya existentes. Operación Las operaciones de una interfaz deﬁnen la funcionalidad del objeto. La dirección de cada parámetro puede ser: • in: el cliente puede pasar una copia de un valor ya inicializado al servidor. Este no lo puede modiﬁcar. • out: el cliente puede pasar una referencia de un valor sin inicializar al servidor. Este lo   inicializará y lo modiﬁcará. • inout: el cliente puede pasar una referencia de un valor sin inicializar al servidor. Este puede   usar la referencia para acceder al valor inicial y modiﬁcarlo. • valor de retorno: el cliente recibe una copia de un calor inicializado. La comunicación puede ser: • Síncrona: el cliente se queda bloqueado hasta recibir conﬁrmación de la terminación o no de la operación. • Oneway: el cliente invoca la operación y sigue con su ejecución. No se espera ninguna respuesta, no devuelve ningún valor, no tiene parámetros y no puede tener cláusula raises. CORBA también permite que se pasen referencias a objetos como parámetros o como valor de retorno. Se declara como el tipo de la interfaz y se para una copia de la referencia de tal manera que el cliente puede manipular la implementación de la interfaz remotamente.  Es posible: • Widening: objeto de una clase derivada como de la clase base. • Narrowing: a partir de un objeto declarado como de una clase base se obtiene uno de clase derivada. • Polimorﬁsmo: los clientes que tengan referencias a una interfaz base pueden invocarlas en interfaces derivados. Atributos Un atributo deﬁne un valor de un tipo IDL accesible en la interfaz. Los atributos readonly solo pueden consultarse, no modiﬁcarse. [readonly] attributte tipo_de_atributo nombre_de_atributo; Tipo_de_atributo getNombre_de_atributo(); Void setNombre_de_atributo(in tipo_de_atributo nuevo_valor); \u0000 de \u000033 64 TEMA 6: C O RB A a v a nza d o Declaraciones adelantadas: En IDL las deﬁniciones pueden aparecer en cualquier orden pero respetando el principio “deﬁnir antes e usar”. Hay veces en las que una interfaz tiene que referenciar a otra o puede ocurrir también que la otra interfaz referencie a la primera. Excepciones: Las excepciones estándares de CORBA pueden ser lanzadas al invocar cualquier operación o atributo. Una excepción deﬁnida por el usuario puede tener varios campos y una operación puede declarar que lanza más de una excepción.   Cuando deﬁnimos excepciones de usuario hay que tener en cuenta que rompen el ﬂujo de control normal del programa y que su uso es para reﬂejar situaciones en las que la operación no puede concluir de forma normal. Se recomienda añadir información útil en las excepciones y declarar una para cada condición de fallo. Constantes: valores de datos constantes en varios tipos de básicos. Pseudo–objetos son objetos proporcionados por el ORB, están especiﬁcados en IDL. Aunque no están representados en el Repositorio de Interfaces y se corresponden a una clase abstracta que no extiende ni hereda de otras. Ejemplos: Directivas de preproceso: IDL acepta las directivas de preproceso de ANSI C++: #include, #deﬁne, #if, #error, #pragma... 3. Cor r espondencia IDL a Ja va El programador debe conocer la correspondencia para usar o implementar las deﬁniciones IDL de Java. El compilador IDL se encarga de generar el código Java correspondiente (generando archivos que tiene clases necesarias para implementar el stub y el skeleton). Ti p os p r i m i t i vos Ti p os c on s t r u i d os - String : s e c o r r e s p o n d e n c o n l a c l a s e java.lang.String. Pueden tener longitud limitada o ilimitada. Se producen excepciones si se intenta enviar un String mayor del límite máximo o si usa un carácter Unicode. - Enum: en Java se deﬁne una nueva clase que tiene: un método value() que devuelve el entero equivalente a la etiqueta, dos miembros de datos estáticos por etiqueta y un método de conversión de entero a etiqueta. CORBA::ORB Interfaz de ORB CORBA::Object CORBA::Request Objeto de invocación de ooperación CORBA::TypeCode CORBA::TCKind Raíz de todas las interfaces IDL Representación de un tipo \u0000 de \u000034 64 Solución TEMA 6: C O RB A a v a nza d o - Struct: se corresponde a tres clases Java: una de implementación de la estructura (con el mismo nombre), la clase Helper y la clase Holder. - array: la correspondencia es también un array, pero en Java los arrays no tienen predeterminada una longitud ﬁja.   - sequence: se corresponde en un array y las clases Helper y Holder. - union: se corresponde a tres clases Java: una de implementación de la unión (con el mismo nombre), Helper y Holder. - any: puede representar un tipo IDL cualquiera. Se corresponde a la clase org.omg.CORBA.Any. Utiliza el pseudo–tipo TypeCode para determinar el tipo que representa. - Typedef: en Java no existe. Los tipos deﬁnidos por el usuario en IDL se pasan en Java al tipo correspondiente. En Java no existe typedef. Además se crea una clase Helper de soporte para la manipulación del tipo.   Ejemplos:  typedef string identificador;   typedef sequence<long> numeros;  typedef Banco BancoNacional; Int er f az \u0000 de \u000035 64 IDL Java void void boolean boolean char char wchar char short short unsigned short short long int IDL Java unsigned long long long long long unsigned long long long ﬂoat ﬂoat double double octet byte any org.omg.CORBA.Any TEMA 6: C O RB A a v a nza d o Para un cliente una interfaz corresponde con una interfaz Java con el mismo nombre y la clase que implementa el stub. Por otro lado, para un servidor una interfaz corresponde con una interfaz Java del mismo nombre también y con dos clases que soportan dos modos de implementar la interfaz: herencia y delegación. • Herencia: en Java se corresponde con herencias de interfaces Java. • Operaciones: una operación se corresponde con un método Java con el mismo nombre y parámetros. • Paso de parámetros: Java pasa los parámetros por valor, también las referencias a objetos. Los parámetros in y los valores de retorno se corresponden directamente. Para los parámetros out y inout se necesita simular el paso por referencia con clases Holder. • Atributos: En Java un atributo se corresponde a dos operaciones de lectura y modiﬁcación (una sola si es readonly). • Excepciones: Una excepción CORBA se corresponde con una clase Java. • Constantes: Si la constante estaba declarada dentro de una interfaz se corresponde a un campo public static final dentro de la propia interfaz. En los demás casos se deﬁne con el nombre de la constantes y el campo value. Def i n i c i on es Todas las deﬁniciones IDL realizadas dentro de una interfaz se colocan dentro de un paquete Java con el nombre: <nombre_de_interfaz>Package. 4. Resumen cor r espondencias IDL–Ja va \u0000 de \u000036 64 TEMA 6: C O RB A a v a nza d o INTERF AZ DE INV OC A CIÓN DIN ÁMIC A (DII) El modelo basado en el uso de stubs (invocación estática) es sencillo pero tiene limitaciones: ‣ Los stubs son generados en tiempo de compilación IDL (un cambio en el IDL requiere rehacer todos los clientes). ‣ Hay aplicaciones que no saben de antemano qué tipos de interfaces van a utilizar. CORBA ofrece una solución a estas limitaciones. Se basa en el repositorio de Interfaces (guarda la descripción de las nuevas interfaces) y la interfaz de invocación dinámica (DII) que permite construir en tiempo de ejecución una petición de operación. 1. Re p o s i t o r i o d e i n t e r f a c e s Servicio estándar proporcionado por el ORB que mantiene las deﬁniciones que aparecen en los ﬁcheros IDL. Básicamente es una base de datos de deﬁniciones de objetos. Se pueden suministrar las deﬁniciones directamente al repositorio desde cualquier programa. Además se puede acceder al repositorio como un servicio bien deﬁnido. Está implementado por un conjunto de objetos persistentes que representan la información que contiene (ModuleDef, InterfaceDef…). 2. Int er f az de invocación dinámica (DII) Permite que un cliente construya una petición en tiempo de ejecución. La invocación dinámica sirve permite crear aplicaciones que descubren nuevas interfaces y sean capaces de utilizarlas, dotando así de mayor ﬂexibilidad al sistema.   Se trata de un objeto tipo Request que se le solicitará al ORB que lo envíe al objeto destino con invoke(). Se manejan para ello cuatro interfaces pseudo–objetos CORBA: Prog ra ma c i ón d e c li en t e c on i nvoc a c i ón d i n á mi c a (más detalles en las diapositivas) 1. Averiguar cómo es la operación que quiere invocar invocar. - La interfaz está descrita con un objeto InterfaceDef, que permite acceder a toda la información de la interfaz y manipular los objetos que contiene. 2. Construir un objeto Request con los parámetros y código de operación correspondientes. - Crear org.omg.CORBA.Request y conﬁgurarlo con sus operaciones, incluir los parámetros e indicar el tipo de valor de retorno. 3. Solicitar al ORB que pase este objeto Request al objeto destino que implementa la operación. - Usar método invoke() del objeto Request. 4. Leer los resultados en el objeto Request. CORBA::Object CORBA::Request Representa una petición de operación y ofrece métodos para darle parámetros, para invocarla, y leer los resultados. CORBA::NVList Permite construir listas de parámetros CORBA::ORB CORBA::Object Operaciones que soportan todos los objetos CORBA. Operaciones que soportan todos los objetos CORBA. Permite crear objetos NVList y enviar y recibir múltiples peticiones \u0000 de \u000037 64 TEMA 6: C O RB A a v a nza d o - Usar método return_value() del objeto Request. 5. Liberar el objeto Request (y la NVList si se hubiera utilizado). - En Jaca liberar referencias a esos objetos. SER VICIO DE EVENT OS Normalmente en CORBA la comunicación entre cliente y servidor es síncrona: • El cliente y el servidor deben estar presentes. • El cliente se bloquea hasta que concluya la operación. • La comunicación es unicast (de un objeto a otro). El servicio de eventos permite desacoplar cliente y servidor. Los eventos generados por un suministrador/productor pueden ser recibidos por múltiples consumidores. El suministrador no conoce el destino de los eventos y los consumidores no conocen el origen de los que reciben. No hay sincronización entre ellos. El canal de eventos es un componente de CORBA que media la transferencia de eventos entre productores y consumidores. Los consumidores registran en el canal su interés por ciertos eventos. El canal acepta eventos de los productores y los va distribuyendo a los consumidores que han registrado su interés. Este canal es el que permite desacoplar productores de consumidores (para el productor es como si solo hubiera un consumidor: el canal y para el consumidor es como si solo hubiera un productor: el canal también). 1. T i p o s d e m o d o s d e i n t e r a c c i ó n c o n e l c a n a l Modo p u sh Cuando el productor genera un evento, el canal lo notiﬁca al consumidor. El consumidor solo espera pasivamente los eventos y el productor inicia la propagación con una operación en un objeto del canal. El canal invoca una operación en un objeto de cada consumidor que se ha registrado. \u0000 de \u000038 64 TEMA 6: C O RB A a v a nza d o Modo p u ll Cuando el consumidor solicita un evento al canal, éste lo solicita al productor. El consumidor solicita activamente eventos e inicia la transferencia de un evento con una operación en un objeto del canal. El canal invoca una operación en cada productor y el evento generado se envía al consumidor que inició la transferencia. \u0000 Modo mi xt o El canal guarda los eventos generados hasta que algún consumidor pull los solicite o hasta que un consumidor push se conecte al canal. Puede hacer cualquier mezcla de productores y consumidores push/pull. 2. T ipos de event os Los datos se transﬁeren en forma de eventos. Teniendo esto en cuenta se pueden diferenciar dos tipos de canales: Canales sin tipo: los eventos se pasan con operaciones de pull/push genéricas y se declaran como tipo any. Lo más importante es que se necesita un acuerdo entre productor y consumidor sobre el tipo de datos para poder procesarlo. Canales tipados: se deﬁnen interfaces especíﬁcas a través de las cuales se propagan los eventos. Con push se invocan operaciones en la interfaz, con el modelo pull se invocan operaciones en una interfaz construida a partir de la deﬁnida en la aplicación. 3. Ges t ión del canal de event os En un principio se crea el canal sin productores ni consumidores. El módulo CosEventChannelAdmin proporciona las interfaces para añadir los consumidores/productores. La primera interfaz de módulo es EventChannel. La factoría para productores es ConsumerAdmin y para los consumidores es SupplierAdmin. 4. Polít icas del canal de event os Determina cómo se gestionan los eventos en el canal. Se puede decir también que cuánto tiempo puede un canal guardar los eventos caracteriza su calidad de implementación. \u0000 de \u000039 64 TEMA 6: C O RB A a v a nza d o 5. A plicación con event os Primero hay que decidir: - Qué modo de conexión queremos con el canal de eventos para los distintos componentes del sistema. - Si los eventos son tipados o no. - Ver la política de gestión de eventos de la implementación del servicio que se vaya a utilizar. - Ver cómo se gestiona la creación de canales de eventos con el servicio que se vaya a utilizar (esto no está estandarizado). \u0000 de \u000040 64 TEMA 7 : P2P TEMA 7 P2P INTR ODUCCIÓN La arquitectura cliente-servidor es el modelo clásico de computación distribuida, en el que todos los clientes realizan peticiones a un servidor centralizado potente y ﬁable. Sin embargo tiene ciertas limitaciones: • Poca escalabilidad. • Punto de fallo único: si falla el servidor cae todo el sistema. • Necesita administración: el servidor debe ser administrado. • Desequilibrio en el uso de recursos: el servidor realiza todo el trabajo mientras los clientes se limitan a realizar peticiones. El modelo P2P nace para intentar solucionar estas limitaciones. La computación P2P consiste en compartir recursos y servicios mediante el intercambio directo entre sistemas. Esto no se limita a archivos, sino que se pueden compartir también otros recursos como ciclos de procesamiento, almacenamiento caché, espacio de almacenamiento, etc. Las redes P2P eliminan el concepto de tener una máquina que da servicio a las demás (servidor) y otras que sólo reciben servicio (cliente). En su lugar, todos los elementos de una red P2P, denominados “nodos” o “pares”, se comportan simultáneamente como clientes y servidores. Todos ellos proporcionan y consumen datos, y cualquiera de ellos puede iniciar una conexión con los demás. CA R A C T E R Í S T I CA S Los nodos actúan como clientes (reciben contenido), servidores (sirven contenido) y routers (ayudan a otros nodos a encontrar contenido u otros nodos). Los nodos son autónomos y autogestionados. No existe una autoridad administrativa. La red es dinámica. Los nodos entran y salen con frecuencia de la red. Los nodos colaboran directamente entre ellos, en lugar de a través de servidores conocidos. Tienen una amplia gama de capacidades. Esto quiere decir que los nodos varían en capacidad de procesamiento, memoria, cantidad de servicios que proporcionan... Es decir, los nodos son heterogéneos. BENEFICIOS ‣ Uso de recursos eﬁciente: las redes P2P son equilibradas en cuanto a carga y se tiende a no desperdiciar recursos. ‣ Escalabilidad. Los consumidores de los recursos también los donan. Esto quiere decir que cuando un nodo recibe un recurso pasará a proporcionarlo a otros nodos, y por lo tanto, cuantos más nodos posean un recurso, más sencillo será para nuevos nodos conseguirlo. ‣ Fiable. Existen réplicas de los archivos en diversos nodos, y la red abarca una amplia distribución geográﬁca. No hay un único punto de fallo, si un nodo falla, la red se mantiene. ‣ Fácil de administrar. Los nodos se autoorganizan y no es necesario añadir servidores para satisfacer la demanda, dado que las redes son autoescalables. Las redes P2P poseen, de forma implícita, tolerancia a fallos, replicabilidad y equilibrio de carga. SIS TEMAS P2P POPUL ARES Los sistemas P2P populares tienen o tenían como ﬁnalidad principal compartir archivos a gran escala (gran número de usuarios). Funcionan de la siguiente manera: 1. El usuario A publica en la red que ciertos archivos están disponibles en su ordenador. 2. El usuario B se conecta a la red, busca los archivos y los descarga directamente del ordenador de A. Típicamente estas redes P2P han tenido problemas de infracción de copyright. \u0000 de \u000041 64 TEMA 7 : P2P 1. N a p s t e r Napster era un servicio P2P para compartir archivos de música (en formato mp3) entre usuarios. Cada usuario agregaba una lista de archivos al servidor central. Para buscar un archivo concreto, se enviaban consultas por palabras clave y el servidor devolvía las IP de los usuarios que tenían archivos que concordasen con la búsqueda. A continuación, se escoge el archivo y se produce la conexión con el usuario especiﬁcado. El modelo de la red Napster puede considerarse una mezcla entre P2P y cliente–servidor: los usuarios realizan las búsquedas en el servidor centralizado, pero el intercambio de archivos se produce directamente entre usuarios. Al haber un servidor centralizado, la red toma algunas características de la arquitectura cliente–servidor: hay un punto central de fallo y el servidor actúa como cuello de botella en la red. Por el lado bueno, que las búsquedas pasasen por el servidor implicaba que Napster tenía cierto control sobre los contenidos, reduciendo las búsquedas fraudulentas. Como la mayoría de sistemas P2P, los archivos en Napster se troceaban, de modo que se podían descargar diferentes trozos de diferentes usuarios. Napster fue cerrado por orden judicial tras diversas demandas de copyright en julio de 2001. En la actualidad funciona como un servicio de suscripción de pago similar a Rhapsody o Spotify. 2. Gnut ella Gnutella es una red P2P que permite la compartición de cualquier tipo de archivo. Su uso se vio aumentado ampliamente tras la caída de Napster en 2001. Gnutella es completamente P2P, no tiene un servidor central. Los nodos tienen “vecinos” que son los únicos nodos de la red que ven directamente como conectados. Cuando un nodo hace una petición, la pasa a todos sus vecinos. Éstos comprueban si tienen el archivo, y si no lo tienen, pasan la petición a sus vecinos a su vez. Para evitar que esta cadena se repita indeﬁnidamente las peticiones poseen un campo TTL (time to live) que se decrementa cada vez que son reenviadas. Cuando TTL llega a 0 la petición no es reenviada. Si un nodo posee el archivo que se pide, responde directamente al nodo que emitió la petición original. La red de Gnutella es completamente descentralizada: no tiene un punto único de fallo ni es susceptible, en un principio, a DoS (denial of service). Por otra parte, no hay ﬁabilidad en los resultados, dado que no hay ninguna clase de control sobre los archivos fraudulentos. Gnutella sigue teniendo un problema de escalabilidad respecto a la búsqueda: el sistema de vecinos genera un tráﬁco de peticiones muy importante (ﬂooding queries). 3. Kazaa Kazaa es un sistema P2P que utiliza una tipo de protocolo determinado FastTrack, que intenta reducir el tiempo de búsqueda y el tráﬁco generado por las peticiones en cascada de redes P2P como Gnutella. Es un híbrido entre una red P2P pura y un sistema cliente–servidor. En lugar de realizar búsquedas en todos los nodos vecinos, la red FastTrack determina un número de super–nodos (super–peers) que actúan como servidor de búsqueda para una pequeña parte de la red. Los super–nodos son escogidos automáticamente por el sistema basándose \u0000 de \u000042 64 TEMA 7 : P2P en sus capacidades (almacenamiento, ancho de banda) y su disponibilidad (tiempo conectado). Los usuarios suben sus listas de ﬁcheros a un super–nodo como lo harían al servidor Napster. Los super–nodos intercambian periódicamente las listas de ﬁcheros para que estén disponibles en distintas partes de la red. Los super–nodos son dinámicos, es decir, si un super–nodo se desconecta, en caso de ser necesario, el sistema designará un nuevo super–nodo que lo sustituya. 4. Fr eene t Freenet es una red P2P cuyo objetivo principal es compartir archivos manteniendo a los usuarios anónimos. El anonimato se implementa siguiendo un sistema de forwarding (redireccionamiento). Cuando un nodo realiza una consulta esta se redirige utilizando un algoritmo de incremental discovery (búsqueda incremental), consistente fundamentalmente en que cada nodo comprueba los caminos por los que puede reenviar la consulta para descartar los callejones sin salida o los bucles. Cuando se encuentra el archivo, en lugar de conectar el nodo que lo posee con el nodo que realiza la petición, el archivo se envía por el mismo camino que ha llegado la consulta en dirección inversa, saltando entre nodos. Esto genera más tráﬁco, pero en ningún momento ningún nodo sabe quién ha realizado la petición o enviado un archivo. Esto implica que es imposible saber si un nodo está realizando una consulta o consumiendo un archivo o simplemente retransmitiéndolos. REDES P2P ES TR UCTURAD AS Las redes P2P estructuradas son un tipo de red P2P usada mayoritariamente a nivel industrial. Buscan que todos los nodos tengan cargas homogéneas y que participen por igual. En la mayoría de los casos se usan para sistemas de archivos distribuidos. Car act erís t icas Autoorganización (si se elimina un nodo, crece o disminuye). Equilibrio de carga. Tolerancia a fallos. Garantías escalables en cuanto al número máximo de saltos antes de resolver una consulta. Esta es la mayor diferencia con respecto a las redes P2P no estructuradas. Se basan en tablas hash distribuidas (DHT). DHT (DIS TRIBUTED HASH T ABLES) Las tablas hash distribuidas o DHT son la versión distribuida de una tabla hash convencional: almacenan datos mediante un par clave-valor. Proporcionan las operaciones típicas de una tabla hash (put, get, remove) pero en lugar de estar almacenadas en un solo lugar, cada nodo de la red almacena un fragmento de la tabla. Los nodos que no tengan el valor asociado a una clave tendrán en su lugar (después de la primera búsqueda) una referencia a un nodo que sí sea responsable de esa clave: de este modo, se asegura el acceso eﬁciente a los valores. Algunos servicios que se pueden construir sobre una interfaz DHT son: ﬁle sharing, bases de datos, servicios de chat, sistemas publica–suscribe… \u0000 de \u000043 64 TEMA 7 : P2P Propiedades deseables en una DHT: • Los pares clave–valor están repartidos equitativamente entre los nodos. • Cada nodo sólo conoce a unos pocos nodos de los demás. • Los mensajes se pueden redireccionar eﬁcientemente a un nodo. • Las entradas o salidas de nodos sólo afectan a un número reducido de nodos. DHT es una interfaz genérica, y existen diversas implementaciones, entre ellas Chord, Pastry, Tapestry... CH O R D Chord es una implementación de DHT desarrollada por el MIT. Los nodos se organizan en un círculo de identiﬁcadores basado en el identiﬁcador unívoco de cada nodo. Si un nodo no tiene el valor de una clave, esta clave estará asignada a otro nodo. Se utiliza una función hash que asegura que los nodos y las claves se distribuyen de forma equitativa en el círculo, de forma que en un sistema con N nodos y k claves, podemos aproximar que habrá 𝑘/𝑁 claves asignadas por nodo. Cada nodo tendrá las referencias a los nodos de la siguiente forma: para la clave “i”, en la tabla habrá la referencia al primer nodo cuyo identiﬁcador sea mayor que el del propio nodo en al menos 2 𝑖 − 1 unidades. El tamaño de la tabla de referencias será de orden 𝑂(log(𝑁)) donde N es el número de nodos de la red. Además, las búsquedas se resuelven en 𝑂(log(𝑁)) saltos. Para la búsqueda, el nodo buscará en su tabla la referencia más próxima a la que busca pero sin pasarse, es decir, si un nodo tiene la referencia a los nodos 33 y 65 pero necesita algo que está en el nodo 60, irá a buscarlo al nodo 33, que a su vez tendrá una referencia más cercana. Ejemplo de búsqueda: quiero el 54 y estoy en el nodo 8, tengo que buscar la entrada dentro de la tabla que sea menor o igual que la clave que quiero localizar. En este caso el 42. Este tendrá su propia tabla y buscará el 50 que apuntará al 51. Este a su vez tendrá su tabla y repetiríamos el método hasta el nodo que buscamos. Cada nodo tendrá las referencias a los nodos de la siguiente forma: para la clave “i”, en la tabla habrá la referencia al primer nodo cuyo identiﬁcador sea mayor que el del propio nodo en al menos 2 𝑖 − 1 unidades. El tamaño de la tabla de referencias será de orden 𝑂(log(𝑁)) donde N es el número de nodos de la red. Además, las búsquedas se resuelven en 𝑂(log(𝑁)) saltos. Para la búsqueda, el nodo buscará en su tabla la referencia más próxima a la que busca pero sin pasarse, es decir, si un nodo tiene la referencia a los nodos 33 y 65 pero necesita algo que está en el nodo 60, irá a buscarlo al nodo 33, que a su vez tendrá una referencia más cercana. Ejemplo de búsqueda: quiero el 54 y estoy en el nodo 8, tengo que buscar la entrada dentro de la tabla que sea menor o igual que la clave que quiero localizar. En este caso el 42. Este tendrá su propia tabla y buscará el 50 que apuntará al 51. Este a su vez tendrá su tabla y repetiríamos el método hasta el nodo que buscamos. Los principales problemas que presenta Chord son: ‣ No tiene en cuenta la localidad física. ‣ No se garantiza la entrega. ‣ No hay consistencia entre réplicas. \u0000 de \u000044 64 TEMA 8: Sis t ema s mu ltia g ent e TEMA 8 SIS TEMAS MUL TIA GENTE INTR ODUCCIÓN Existen cinco grandes tendencias que han marcado la historia de la computación: 1. U b i c u i d a d Conforme la capacidad de procesamiento se hace más accesible, la complejidad se vuelve ubicua. La continua reducción en el coste de computación ha hecho posible introducir capacidad de procesamiento en sitios y dispositivos que hace poco tiempo resultaría prohibitivo económicamente. 2. Int er conexión Los sistemas de computación de hoy ya no se encuentran solos, sino que están conectados en red formando grandes sistemas distribuidos. Desde que los sistemas distribuidos y concurrentes se han convertido en norma, algunos investigadores están poniendo el acento en la investigación de modelos teóricos en los que la computación se transforma en un proceso de interacción. 3. Int elig encia La complejidad de las tareas que somos capaces de automatizar o delegar en sistemas de computación ha crecido continuamente. En general, se puede entender inteligencia como sinónimo de complejidad. 4. Deleg ación Los ordenadores están realizando cada vez más por nosotros sin nuestra intervención. Estamos dando el control a los ordenadores, incluso en tareas críticas. 5. Or ient ado a humanos Esta es una tendencia que pretende alejarnos de formas de programar orientadas a las máquinas mediante conceptos y metáforas que reﬂejan más ﬁelmente la forma en la que vemos y entendemos el mundo. Los programadores (y usuarios) se relacionan con las máquinas de manera diferente. Los programadores conceptualizan e implementan software en términos de abstracciones de más alto nivel más orientadas a los humanos. PR OGRESO DE L A PR OGRAMA CIÓN La programación ha progresado (a través de código máquina, ensamblador, subrutinas, objetos...) hacia agentes. La delegación e inteligencia implican la necesidad de construir sistemas de computación que puedan actuar efectivamente en lugar de nosotros. Esto implica: • La capacidad de los sistemas de cómputo de actuar de forma independiente. • La capacidad de los sistemas de cómputo de actuar de una forma que deﬁenda mejor nuestros intereses cuando interactúa con otros humanos o sistemas. La interconexión y distribución, unida a la necesidad de que los sistemas representen nuestros intereses, implica sistemas que puedan cooperar y llegar a acuerdos(o incluso competir) con otros sistemas que tienen diferentes intereses. Todas estas tendencias han dado lugar a un nuevo campo en las Ciencias de la Computación: sistemas multiagente. Agente: sistema de computación capaz de realizar una acción de forma independiente a favor de su dueño. Sistema multiagente: sistema que consta de un número de agentes que interactúan entre sí. En el caso más general, esto agentes actuarán representado a usuarios con diferentes objetivos y motivaciones. Para que interactúen de forma apropiada, necesitan la habilidad de cooperar, coordinarse, y negociar entre ellos, de forma similar a como lo hace la gente. \u0000 de \u000045 64 TEMA 8: Sis t ema s mu ltia g ent e Características de los agentes del sistema: ‣ No tienen información completa. ‣ Tienen puntos de vista limitados. ‣ No hay un sistema de control global. ‣ Los datos están descentralizados. ‣ Computación asíncrona. Lo que hace diferente al campo de los sistemas multiagentes el hecho de que se enfatiza que los agentes son entidades computacionales, capaces de procesar información. El primer problema con el que nos encontramos es el del diseño de agentes, y el segundo el del diseño de sociedades. El campo de los sistemas multiagente es multidisciplinado y está inﬂuenciado e inspirado por otros campos: economía, ﬁlosofía, lógica.... Además existen muchas analogías con el campo de la inteligencia artiﬁcial. Punt os de vis t a Agentes como paradigma para la ingeniería del software: Los ingenieros de software cada vez entienden mejor las características de la complejidad del software. La interacción es probablemente la característica más importante de un software complejo. En las últimas dos decadas, uno de los temas de investigación más importantes en Ciencias de la Computación es el desarrollo de herramientas y técnicas para modelar, comprender e implementar sistemas en los que la interacción es habitual. Agentes como herramienta para entender a las sociedades humanas: Los sistemas multiagente proporcionan una nueva herramienta para simular sociedades. Sist. multiagente como búsqueda de bases teóricas apropiadas: Queremos construir sistemas de agentes autónomos interaccionado, pero no sabemos todavía cómo deberían de ser dichos agentes. CUES TIONES IMPOR T ANTES No son simplemente sistemas concurrentes/distribuidos porque: - A los agentes se les supone autónomos, capaces de tomar decisiones de forma independiente, por lo que necesitan mecanismos para sincronizar y coordinar sus actividades en tiempo real. - Los agentes tienen sus propios intereses, por lo que sus interacciones son de carácter económico. No son simplemente inteligencia artiﬁcial por dos motivos: - No necesitamos resolver los problemas de la IA para construir agente útiles. - La IA clásica ignoraba los aspectos sociales que son partes importantes de la actividad inteligente del mundo. No son simplemente economía/teoría de juegos porque: - Algunas suposiciones pueden no ser válidas o útiles para construir agentes artiﬁciales. - La teoría de juegos no proporciona siempre como obtener soluciones. Nos interesan agente computacionales con recursos limitados. No son simplemente ciencias sociales porque: - Podemos ver posibles soluciones estudiando las sociedades humanas, pero no hay ninguna razón particular para creer que las sociedades artiﬁciales deban de construirse de la misma manera. CA R A C T E R Í S T I CA S D E L O S A G E N T E S 1. Son ent idades autónomas [Autonomía] Pueden trabajar sin la intervención directa del usuario y tienen cierto control sobre sus acciones y estado interno. [Reactividad] Pueden percibir su entorno y responder oportunamente a cambios que se produzcan en el mismo. \u0000 de \u000046 64 TEMA 8: Sis t ema s mu ltia g ent e [Iniciativa] El comportamiento de los agentes está determinado por los objetivos (metas) que persiguen y por tanto pueden producir acciones no sólo como respuesta al entorno. [El entorno inﬂuye en el agente] En la mayor parte de los dominios el agente sólo tendrá control parcial del entorno. Una misma acción realizada por el agente en ocasiones diferentes puede tener efectos muy distintos. Un agente debe estar preparado para fallar o para la incertidumbre de no saber si ha tenido éxito o no y tener un conjunto de acciones disponibles con sus precondiciones. El principal problema al que se enfrenta un agente es decidir qué acción realizar para alcanzar sus objetivos de diseño. 2. Int elig encia [Razonamiento] Un agente debe poder decidir qué objetivo perseguir o a qué evento reaccionar, cómo actuar para ello o suspender o abandonar un objetivo para dedicarse a otro. [Aprendizaje] Además también debe poder adaptarse progresivamente a cambios en entornos dinámicos. Principio de Racionalidad: Si un agente tiene conocimiento de que una de sus acciones dará lugar a una de sus metas, entonces el agente seleccionará esa acción. Indica que hay una conexión entre objetivos y comportamiento, por medio del conocimiento del que dispone el agente (lo que no implica que el agente tomará la mejor decisión). 3. No a c t ú a n s o l o s , s i n o c o m o u n s i s t e m a m u l t i – a g e n t e s Resolución de problemas mediante estrategias divide y vencerás: reparto de responsabilidades. [Heterogeneidad] También hay especialización. [Concurrencia y distribución] Esto da lugar a mayor ﬂexibilidad, escalabilidad, tolerancia a fallos, gestión de recursos y distribución de conocimiento. Test de Huhns–Singh: Un sistema que contiene agentes reputados debe cambiar sustancialmente si otro de los agentes reputados se añade. Requiere que el entorno del agente no sea estático, sea lo suﬁcientemente observable y el tipo del nuevo agente es alguno ya existente en el sistema. Mejora el rendimiento por lo que los agentes deben ser conscientes del nuevo que tiene un comportamiento emergente. 4. Habilidad social Interaccionan, delegan, cooperan, se coordinan y negocian. Los lenguajes de comunicación entre agentes son KQML, FIPA ACL y comunicaciones en el nivel de conocimiento. Algunos autores consideran que la capacidad de hablar un lenguaje de agentes es suﬁciente para considerar a un software como agente. 5. Movilidad Pueden migrar entre nodos de una red preservando su estado en los saltos entre nodos. Además son multi–acceso y multi–modal. UTILID AD DE L OS A GENTES En el diseño de sistemas distribuidos los agentes proporcionan: aspectos sociales, lenguajes y protocolos de comunicación de agentes y distribución de datos, control, conocimiento y recursos. En el análisis de un sistema los agentes tienen un mayor grado de abstracción que los objetos o componentes: mayor autonomía y capacidad de decisión, varios componentes heterogéneos que mantienen relaciones entre ellos y con escalas de tiempo diferentes, y modelado de sistemas naturales y sociales. Facilitan la evolución: adaptación a modiﬁcaciones y al entorno, la escalabilidad: añadir agentes para soportar mayor carga de trabajo, añadir/quitar funcionalidad en tiempo de ejecución, desarrollo incremental y los sistemas abiertos: capacidad de aceptar nuevos elementos. Pero no siempre son la solución ideal, hay ausencia de control/visión global del sistema. Aplicaciones: Servicios de información en Internet, comercio electrónico, equipos móviles y PCs domésticos, redes públicas de telecomunicación, gestión de procesos, robótica, etc. \u0000 de \u000047 64 TEMA 8: Sis t ema s mu ltia g ent e SIS TEMAS MUL TIA GENTES VS ORIENT ADOS A OBJET OS SIS TEMAS MUL TIA GENTES VS SIS TEMAS EXPER T OS DES ARR OLL AR SIS TEMAS MUL TI–A GENTES Es complejo, aunque hay soluciones tecnológicas (arquitecturas, entornos de desarrollo y plataformas de ejecución), pero hace falta saber qué problema hay que resolver, coordinar trabajo, valorar la calidad, saber qué proceso seguir... Para deﬁnir una metodología, hay que deﬁnir los resultados a producir (documentación, código, prototipos, pruebas...), elegir un lenguaje para los resultados (visuales o formales), deﬁnir las actividades orientadas a producir resultados (análisis, diseño...), deﬁnir guías, métricas, herramientas y paradigmas de ingeniería de software (estructura de actividades, estimación de habilidades de desarrolladores y gestión de proceso). En general, los SMA aplican una mezcla de técnicas de OO, sistemas de gestión de conocimiento e IA distribuida. DIFEREN CIAS ENTRE ENT ORN OS 1. Ent or no accesible Entorno en el que el agente puede obtener información completa y exacta al respecto del estado de su entorno. La mayoría son inaccesibles (el mundo real incluido). Cuanto más accesible sea un entorno, más fácil resulta construir agentes que operen sobre él. 2. Ent or no de t er minís t ico Entorno en el que cualquier acción tiene garantizado un único efecto (no hay incertidumbre al respecto del estado que resultará de la acción realizada). El mundo real es no determinístico. Como es natural, entornos no determinísticos presentan grandes problemas al desarrollador de agentes. 3. Ent or no episódico Entorno en el que las prestaciones de un agente dependen de un número discreto de episodios, no dependiendo del escenario concreto. Los entornos episódicos son más simples desde el punto de vista del desarrollador de agentes. 4. Ent or no es t át ico Entorno que permanece inalterado salvo por las acciones que tome el agente. Objetos Agentes Ejecuta los métodos invocados Autonomía de decisión Flujo de control del llamante Flujo de control propio Encapsula estado y comportamiento Encapsula la activación del comportamiento Estado: valor de las variables Estado mental: objetivos, creencias… Comportamiento: salida a partir de una entrada Comportamiento: cómo decidir qué hacer Mensajes invocan procedimiento Interacciones: actos de habla (intencionalidad) Asociaciones entre objetos Organización: relaciones sociales entre agentes SMA Sistemas expertos Sistemas cerrados Interactúan con el entorno Sistemas de decisión centralizados Distribución de la toma de decisiones: comportamiento emergente Interacción con el usuario bajo petición del usuario Mayor grado de interacción con el usuario Interacción con otros agentes \u0000 de \u000048 64 TEMA 8: Sis t ema s mu ltia g ent e 5. Ent or no dinámico Entorno en el que hay otros procesos operando sobre él, pudiendo cambiar sin que el agente tenga control sobre ello. Otros procesos pueden interferir sobre las acciones que tome el agente. El mundo real es muy dinámico. 6. Ent or no discr e t o Entorno en el que existe un número ﬁjo y ﬁnito de acciones que puede percibir. Un ejemplo es el ajedrez. Conducir un taxi es un entorno continuo. SIS TEMAS DE INTEN CIONES Cuando explicamos la actividad humana, es a menudo útil realizar sentencias como las siguientes: Ana cogió su paraguas porque creía que iba a llover. Este tipo de actitudes empleadas para describir acciones son conocidas como intenciones. Un sistema de intenciones describe entidades cuyo comportamiento puede ser predicho mediante la atribución de creencias y deseos. MET ODOL OGÍAS P ARA C ONS TR UIR A GENTES 1ª clasif icación: en función del acceso a los sensores y actuadores de capas de control Horizontal: Su ventaja es el paralelismo, pero se necesita un alto conocimiento de control para coordinar. Vertical: Su ventaja es que se necesita un menor conocimiento de control, pero la capa que interactúa con los sensores es más compleja. 2ª clasif icación: según el t ipo de procesamien t o Arquitecturas basadas en la lógica: Representación del estado interno según un conjunto de sentencias lógicas de primer orden. Usa reglas de deducción lógica para tomar decisiones. Sus ventajas con que la representación es clara y elegante, pero la complejidad temporal es elevada y es difícil encontrar una representación simbólica para entidades y procesos del mundo real. Arquitecturas deliberativas: Son aquellas arquitecturas que utilizan modelos de representación simbólica del conocimiento. Suelen estar basadas en la teoría clásica de planiﬁcación, donde existe un estado inicial de partida, un conjunto de planes y un estado objetivo a satisfacer. Las decisiones se toman utilizando mecanismos de razonamiento lógico basados en la concordancia de patrones y la manipulación simbólica. En estos sistemas parece aceptada la idea de que un agente contenga algún sistema de planiﬁcación que sea el encargado de determinar que paso debe de llevar a cabo para conseguir su objetivo. Arquitectura B.D.I.: Believes (conocimientos), Desires (metas) e Intentions (producen acciones dirigidas a las metas, persisten e inﬂuyen en los conocimientos). Es un modelo intuitivo, pero es difícil de equilibrar una conducta del agente que tenga al mismo tiempo iniciativa y reactividad.   Dos tipos de agentes: - Audaces: no se paran a reconsiderar intenciones, tienen coste temporal y computacional bajo y son aptos para entornos que no cambian rápidamente. - Cautos: constantemente se paran a reconsiderar intenciones, explotan nuevas posibilidades y son aptos para entornos que cambian rápidamente. Arquitecturas reactivas: No comprende un modelo del mundo simbólico y no usa un razonamiento simbólico complejo. Usa el modelo estímulo-respuesta. Sigue un procesamiento ascendente, es decir, patrones que se activan bajo ciertas condiciones de los sensores y tienen un efecto directo en los actuadores. Son arquitecturas verticales: los estímulos externos procesados por capas especializadas que responden con acciones y pueden inhibir las capas inferiores. Un ejemplo es la arquitectura de subsunción. Esta arquitectura se basa en el hecho de que el comportamiento inteligente puede ser generado sin utilizar propuestas del modelo simbólico y en el hecho de que la inteligencia es una propiedad emergente de ciertos \u0000 de \u000049 64 TEMA 8: Sis t ema s mu ltia g ent e sistemas complejos. Las arquitecturas de subsunción manejan jerarquías de tareas que deﬁnen un comportamiento. Suelen estar organizados en jerarquías de capas, de menor a mayor nivel de abstracción. Su ventaja es que responde inmediatamente el agente y no hay problemas de representación simbólica. Sin embargo, es difícil diseñar agentes puramente reactivos que aprendan de la experiencia y las interacciones son difíciles de entender en agentes con muchas conductas. Arquitecturas híbridas: Agente que pretende combinar aspectos de los modelos deliberativos y reactivos. Está formado por dos subsistemas: uno deliberativo (que utilice el modelo simbólico y que genere planes para satisfacer objetivos) y uno reactivo (centrado en reaccionar a eventos que ocurran y no requieran mecanismos de razonamiento complejo). La estructuración en capas puede ser vertical (solo una capa tiene acceso a sensores y actuadores) o horizontal (todas las capas tienen acceso). Las capas están organizadas jerárquicamente con información sobre el entorno.   Hay distintos niveles de abstracción: - Reactivo: nivel bajo, se toman decisiones en base a los datos recopilados por el agente. - Conocimiento: nivel intermedio, se centra en el conocimiento que posee del medio y normalmente usa representación simbólica de éste. - Social: nivel alto, maneja aspectos sociales de entorno. El comportamiento global del agente está deﬁnido por la interacción entre estos niveles. Tiene arquitectura en capas: Clase de arquitecturas divididas en subsistemas organizados en una jerarquía de capas que interaccionan. El sistema típico tiene dos capas: una para la conducta reactiva y otra para la iniciativa. Y pueden ser capas horizontales o capas verticales. Las horizontales se conectan directamente con sensores y actuadores y contribuyen con sugerencias a la acción de actuar. Tienen función mediadora: deciden qué capa tiene el control del agente, aseguran la consistencia y son un cuello de botella. En las verticales los sensores y actuadores están conectados con una capa. No son tolerantes a fallos. Las ventajas de la arquitectura en capas es que es óptima para equilibrar las diferentes conductas del agente, pero tienen falta de claridad y un número elevado de posibles combinaciones de interacción entre las capas. PR OBLEMAS EN UN SIS TEMA MUL TI–A GENTE ‣ Descomposición del problema. ‣ Comunicación entre agentes. ‣ Coherencia en las actuaciones. ‣ Representación del conocimiento de otros agentes. ‣ Coordinación de acciones. ‣ Gestionar el uso de recursos. ‣ Evitar comportamientos globales no deseados. ‣ Diseño de SMA: metodología y desarrollo. CO M U N I C A C I Ó N E N T R E A G E N T E S Está basada en la teoría de los actos del habla: • Locución (acto de decir algo). • Ilocución (intención al decirlo). - Clasiﬁcación: Asertivas (informar), directivas (pedir y preguntar), comisivas (prometer), permisivas, prohibitivas y declarativas (causan eventos) y expresivas (emociones y evaluaciones). • Perlocución (efecto al decirlo). • Performative (solo con decir algo, se produce). \u0000 de \u000050 64 TEMA 8: Sis t ema s mu ltia g ent e Objetivos de los actos del habla: completitud (cubrir amplio rango de situaciones de comunicación), simplicidad (no sobredimensionar el diseño de agente) y concisión (minimizar redundancia y ambigüedad). 1. N i ve l e s d e c o m u n i c a c i ó n Inferior: método de interconexión. Medio: formato (sintaxis) de la información. Superior: signiﬁcado (semántica) de la información. 2. Mecanismos de tr anspor t e Los mensajes deben poder ser planiﬁcables o servidos por eventos, síncronos o asíncronos, direcciones físicas o por rol, unicast, multicast o broadcast. Nos encontramos con las siguientes implementaciones posibles: CORBA, RMI, DCOM. 3. Lengua je de comunicación Debe tener una semántica bien deﬁnida y formal. Posibles implementaciones: KQML, FIPA ACL, basadas en XML. 4. Pr o t ocolos de comunicación Representan los patrones que modelan las posibles comunicaciones. Los participantes de la conversación deben conocerlo y debe estar deﬁnido formalmente. Implementaciones: FIPA ACL o pre y post condiciones. 5. Ont ologías Sirven para representar el conocimiento de distintos universos de discurso. Resuelven problemas de tener diferentes término para el mismo concepto y viceversa y tener distintos sistemas de clases. Implementaciones: OIL, Ontolingua, KIF, RDF,Esquemas XML, DTD. SER VICIO DE TRANSPOR TE Es capaz de enviar un mensaje y codiﬁcarlo para su transmisión como una secuencia de bytes. En el caso más habitual el servicio es de conﬁanza, ﬁable y ordenado. Los agentes pueden decidir si usan procesamiento síncrono o asíncrono. Los parámetros del acto de envío no se codiﬁcan a nivel de mensaje pero son parte del interfaz proporcionado por el servicio de envío. El servicio de envío detecta condiciones de error. Un agente tendrá un nombre que le permitirá acceder al servicio y remitir el mensaje a la dirección correcta. Y el servicio de envío de mensajes debe ser capaz de determinar el mecanismo de transporte correcto y permitir cambio en la ubicación del agente. Obje t i vos de los act os del habla Completitud: cubrir un amplio rango de situaciones de comunicación. Simplicidad: no sobredimensionar el diseño de agentes simples. Concisión: minimizar la redundancia y la ambigüedad para facilitar a los agentes la elección del acto comunicativo que deben emplea REQUERIMIENT OS DE L OS A GENTES 1. Los agentes ACL deben enviar un mensaje not–understood si reciben un mensaje que no reconocen o cuyo contenido no son capaces de procesar y debes estar preparados para recibirlos y manejarlos. 2. Un agente ACL puede escoger implementar cualquier subconjunto de tipos de mensajes y protocolos predeﬁnidos. 3. Un agente ACL que utilice actos comunicativos cuyos nombres están deﬁnidos en esta especiﬁcación, debe implementarlos correctamente de acuerdo a su deﬁnición. \u0000 de \u000051 64 TEMA 8: Sis t ema s mu ltia g ent e 4. Los agentes pueden usar actos comunicativos con otros nombres, pero no deben deﬁnirlos con un signiﬁcado que coincida con alguno de los estándares. 5. Un agente ACL debe ser capaz de generar mensajes sintácticamente bien formados en la forma de transporte que corresponde al mensaje que desea enviar y también de traducir una secuencia bien formada al mensaje correspondiente. TIPOS DE MENS AJES   Ejemplo mensaje FIPA: Tipos: PR O T OC OL O FIP A–A CL Protocolo: Patrón ﬁjos de intercambios de mensajes. Los agentes deben conocerlo. Conversación: una instancia particular de uno de estos diálogos.   1. FIPA–quer y Para solicitar a un agente que realice una acción de tipo inform. Tipos: query–if, query–ref.   \u0000 de \u000052 64 TEMA 8: Sis t ema s mu ltia g ent e 2. FIPA–re q u e s t Permite a un agente solicitar que otro agente haga algo. 3. FIPA–re q u e s t – w h e n Análogo a request pero el receptor debe esperar a que se cumpla una precondición para responder. 4. FIPA–contr act–ne t Un agente desea que se realice una acción. Hay varios candidatos y se desea minimizar una función que caracteriza la tarea. 5. F IPA– it er at ed–contr act–ne t Contract–net con varias rondas. Se inicia con una cfp, cada participante emite su oferta y el iniciador puede aceptar una, rechazarlas todas o emitir un cfp revisado.   \u0000 de \u000053 64 TEMA 8: Sis t ema s mu ltia g ent e 6. FIPA–eng lish–auct ion Método de subasta al alza. Al emitir una oferta, el iniciador genera un cfp con el nuevo precio. 7. FIPA–dutc h–auct ion Método de subasta a la baja. Suele haber precio mínimo. 8. FIPA–br oker ing Intermediación entre agentes. El broker envía la petición a un conjunto de agentes y proporciona las respuestas. 9. FIPA–re c r u i t i n g Análogo a brokering. El broker envía la petición a un conjunto de agentes, pero son estos quienes envían la respuesta al iniciador.   \u0000 de \u000054 64 TEMA 8: Sis t ema s mu ltia g ent e 10. FIPA–subscr ibe El iniciador solicita ser avisado cada vez que se cumpla la condición indicada en el mensaje. 11. FIPA–pr opose El emisor propone a los participantes la realización de una acción. Suele seguir la realización de la acción y la notiﬁcación del estado. JA D E Es un middleware que sirve para desarrollar aplicaciones distribuidas multiagente. Simpliﬁca el desarrollo de este tipo de apps. Es compatible con JAVA y cumple el estándar FIPA. JADE es una plataforma de agentes que implementa los servicios básicos y la infraestructura de una aplicación multiagente distribuida: ciclo de vida, movilidad del agente, servicio de páginas amarillas y blancas, transporte de mensajes, seguridad del agente, gestión de tareas, monitorización y depuración. Permite interoperabilidad a través de FIPA. Es un proyecto Open Source muy usado. Un app basada en JADE está compuesta de una colección de componentes activos llamados agentes que tienen un nombre único. Cada agente forma parte de una app P2P (comunicación bidireccional con el resto) y vive en un contenedor (que proporciona su entorno de ejecución). Para lanzar JADE: java jade.Boot –gui. Las herramientas gráﬁcas de JADE soportan la gestión, control, monitorización y depuración de una plataforma multiagente. 1. Ag e n t e s a u x i l i a r e s RMA: monitoriza y controla la plataforma y sus contenedores remotos. Permite gestionar remotamente el ciclo de vida de los agente, puede componer y enviar mensajes a cualquiera, lanzar otras herramientas gráﬁcas y monitorizar otras plataformas compatibles con FIPA–. Dummy Agent: compone y envía mensajes y lee/almacena la cola de mensajes desde/en un archivo. Sniffer Agent: muestra el ﬂujo de interacciones entre agentes, el contenido de los mensajes intercambiado y carga/almacena el ﬂujo desde/en un archivo. Introspector Agent: monitoriza el estado interno del agente y depura la ejecución. \u0000 de \u000055 64 TEMA 8: Sis t ema s mu ltia g ent e Log Manager Agent: es la interfaz gráﬁca para modiﬁcar el almacenamiento de la plataforma durante ejecución. DF GUI: interfaz con el usuario para interaccionar con el servicio de pág. amarillas (en la imagen). Es posible crear un agente extendiendo la clase jade.core.Agent y redeﬁniendo setup(). Cada instancia se identiﬁca con un Agent ID ( v). Un agente concluye con el método doDelete() y para terminar se llama al método takeDown(). El trabajo que realiza un agente se realiza dentro de behaviours (jade.core.behaviours.Behaviour). Para añadir un comportamiento a un agent hay que usar su método addBehaviour(). Cada subclase Behaviour debe implementar action() y done(). Un agente puede ejecutar varios comportamientos en paralelo. Sin embargo, el scheduling de comportamientos no es apropiativo, sino cooperativo y todo ocurre en un único hilo Java. La conmutación entre comportamientos ocurre cuando action() del comportamiento en ejecución concluye. 2. T ipos de com por t amient os Oneshot (jade.core.behaviours.OneShotBehaviour): concluye de forma inmediata y su action solo ocurre una vez. done() siempre devuelve true. Cyclic (jade.core.behaviours.CyclicBehaviour): nunca termina y action() se ejecuta cada vez que es invocado. done() devuelve false. Complex: tiene estado interno y action() ejecuta una acción diferente en función de ese estado. Termina cuando se veriﬁca una determinada condición. WakerBehaviour: action() y done() están implementados en onWake() que se ejecuta después de cierto tiempo. Después de la ejecución, el comportamiento concluye. TickerBehaviour: action() y done() están implementados en onTick() que se ejecuta periódicamente. El comportamiento se ejecuta indeﬁnidamente (stop()). Datos sobre comportamientos: • El método onStart() de la clase Behaviour se invoca solo una vez antes de la primera ejecución del método action(). Es apropiada para operaciones que deben ocurrir al comienzo del comportamiento. • El método onEnd() de la clase Behaviour se invoca solo una vez después de que el método done() devuelva true. Es apropiada para operaciones que deben ocurrir al ﬁnal del comportamiento • Cada comportamiento tiene un puntero al agente que lo está ejecutando: la variable protegida myAgent. • El método removeBehaviour() de la clase Agent puede utilizarse para suprimir un comportamiento. En este caso no se invoca al método onEnd(). • Cuando la lista de comportamientos activos de un agente está vacía, el agente entra en el estado IDLE y su thread se duerme. 3. Car act erís t icas de JADE Está basado en el paso de mensajes de forma asíncrona. El formato del mensaje está deﬁnido por el lenguaje ACL (jade.lang.acl.ACLMessage). Proporciona setters y gettes para todos los campos deﬁnidos (Ontology, Sender, Content, Receiver…). Enviar mensaje ACLMessage msg = new ACLMessage(ACLMessage.INFORM); msg.addReceiver(new AID(“Peter”, AID.ISLOCALNAME)); msg.setLanguage(“English”); msg.setOntology(“Weather–Forecast–Ontology”); msg.setContent(“Today it’s raining”); send(msg); \u0000 de \u000056 64 TEMA 8: Sis t ema s mu ltia g ent e El método block() de la clase Behaviour elimina un comportamiento de la cola del agente y lo coloca en un estado bloqueado. Cada vez que se recibe un mensaje, todos los comportamientos bloqueados son insertados de nuevo en la cola de comportamientos y tienen la oportunidad de leer y procesar el mensaje. El método receive() devuelve el primer mensaje de la cola de mensajes y lo elimina de dicha cola. Si hay dos o más comportamientos recibiendo mensajes, uno puede “robar” un mensaje al otro. Para evitar esto es posible leer mensajes con unas determinadas características. Para ello debe especiﬁcarse el parámetro jade.lang.acl.MessageTemplate. El método blockingReceive() concluye cuando solo hay un mensaje en la cola. Es bloqueante, bloquea todos los comportamientos hasta que ﬁnalice por lo que se usará para recibir mensajes en setup() y takeDown() (no en el action()). El agente DF es un agente que se comunica usando ACL. La ontología y el lenguaje que DF entiende están especiﬁcados por FIPA de modo que es posible buscar/registrar un agente DF de una plataforma remota. La clase jade.domain.DFService proporciona métodos estáticos que facilitan interactuar con DF (register(), modify(), deregister(), search()). JADE DF también soporta un mecanismo de suscripción. Cuando un agente se registra con DF, debe proporcionar una descripción compuesta del AID y descripciones de servicios (tipo, nombre...). Cuando un agente busca/se suscribe a DF, debe especiﬁcar otro DFAgentDescription que será utilizado como plantilla. El paquete jade.proto contiene los comportamientos para el rol del iniciador y el que responde en la mayoría de los protocolos de interacción más comunes (FIPA–request, FIPA–Contract–Net, FIPA–Subscribe). Todas estas clases manejan automáticamente el ﬂujo de mensajes y los timeouts. Proporciona métodos de callback que deben ser rediﬁnidos para tomar las acciones necesarias cuando, por ejemplo, se recibe un mensaje o termina un timeout. Para crear una Ontología (especíﬁco del dominio) hay que deﬁnir los elementos del esquema de la ontología, las clases JAVA y gestionar las expresiones de contenido como objetos JAVA. Se usa ContentManager para llenar y analizar mensajes de contenido. El AMS (AgentManagementSystem) representa la autoridad en la plataforma JADE. Todas las acciones de gestión de la plataforma están bajo su control. Otros agentes pueden pedirle que realice esas acciones. Se puede obtener su AID con getAMS(). JADE soporta “movilidad fuerte”, esto es, movilidad del estado y del código: Estado: un agente puede parar su ejecución en un contenedor local, moverse a un contenedor remoto y reanudar su ejecución allí. Si el código del agente móvil no está disponible en el remoto, es recuperado bajo demanda. Para que podamos moverlo, un agente debe de poder ser Serilizable. La movilidad puede ser: Auto–iniciada mediante el método doMove() de la clase Agent. Forzada por el AMS (a requerimiento de otro agente). Aparte de la movilidad, un agente puede ser clonado (doClone()). JADE es un entorno distribuido. Como consecuencia, pueden existir potenciales peligros: ‣ Un agente malicioso puede pedir al AMS que mate a otro agente. ‣ Un agente malicioso puede pedir al AMS que apague la plataforma. ‣ Un entidad maliciosa puede sniﬀear o modiﬁcar información sensible de un ACLMessage. Jade previene dichos problemas mediante la provisión de: autenticación y autorización e integridad y conﬁdencialidad punto a punto. Basado en JAAS. Todos los aspectos de seguridad han sido integrados en el denominado SecurityHelper. Puede obtenerse un SecurityHelper mediante el método getHelper() de la clase Agent. Interfaz con procesos: Permite usar JADE (esto es, crear un contenedor y ejecutar agentes en él) desde un programa externo de Java. Recibir mensaje ACLMessage msg = receive(); if (msg != null) { // Process the message } \u0000 de \u000057 64 TEMA 8: Sis t ema s mu ltia g ent e Clase jade.core.Runtime y package jade.wrapper. Comportamientos en threads: Permite ejecutar comportamientos normales en JAVA en un thread dedicado. Clase jade.core.behaviours.ThreadedBehaviourFactory. Persistencia: Permite guardar y recuperar el estado de un agente en una base de datos relacional. Basado en Hibernate. Todavía de carácter experimental.  \u0000 de \u000058 64 AN E X OS: E xáme n e s ANEX OS EX Á MENES 20 1 5: RESUEL T O 1. Deﬁne brevemente el concepto de middleware Sóftware que actúa como intermediario entre una aplicación para interactuar o comunicarse con otra aplicación, software, hardware o sistema operativo y además aumenta la abstracción. 2. En qué paradigma de computación distribuida se asignan deliberadamente roles asimétricos a los participantes en la comunicación? ¿Cuál es el objetivo que se persigue con ese tipo de asignación de roles? Se asignan como asimétricos en el paradigma de cliente/servidor. Lo que se persigue es simpliﬁcar la sincronización de eventos, el servidor solo espera peticiones y el cliente solo espera respuestas. 3. Describe qué aporta a mayores el paradigma del sistema de mensajes frente al más simple paradigma del envío de mensajes. El sistema de mensajes permite el intercambio de mensajes entre dos procesos de forma asíncrona y de una manera desacoplada. 4. ¿Si tuvieses que implementar una solución de computación distribuida basada en llamadas a procedimientos remotos y tuvieses que elegir entre Java RMI y CORBA, que criterio utilizarías para decidirte por una u otra tecnología? El criterio más importante sería el tipo de objetos distribuidos. Si vamos a usar Java es más sencillo usar RMI, sin embargo, para cualquier otro lenguaje es necesario usar CORBA. 5. La clase DatagramPacket del paquete java.net de Java tiene dos constructores a. DatagramPacket(byte[] buf, int length) \t b. DatagramPacket(byte[] buf, int length, InetAddress address, int port) ¿Cuándo deberemos utilizar uno u otro? Usaremos el primer constructor para especiﬁcar simplemente el tamaño de las cadenas de caracteres que se recibirán y se almacenarán en el array de bytes buf. El segundo constructor se emplea para, además de lo anterior, asignarle un puerto y una dirección al datagrama. 6. En una aplicación cliente/servidor explica cómo se utilizarían las clases ServerSocket y Socket de API de Sockets de Java. La clase ServerSocket la utilizaría el server para aceptar conexiones del cliente, mientras que la clase Socket la utilizan cliente y servidor para el intercambio de datos. 7. En el siguiente código, Hilo es una clase que hereda propiedades de Thread. El código pretende crear dos hilos que ejecutan el mismo código. Indica los posibles inconvenientes de usar esta forma de crear los hilos y, en el caso de ser necesario, propón las posibles modiﬁcaciones al código arriba presentado que solucionen dichos inconvenientes. public class pruebaHilo { public static void main(String[] args){ Thread hilos = new Hilo(); hilos.start(); hilos.start(); } } El inconveniente es que no se pueden ejecutar dos hilos de esta manera debido a que no se puede reinicializar un hilo, se enviaría una excepción. La manera de resolverlo es declarar otro thread e iniciar los dos. \u0000 de \u000059 64 AN E X OS: E xáme n e s 8. Dado el siguiente código correspondiente a un servidor de objetos en Java RMI, donde SomImpl es una clase que implementa una interfaz remota Import java.rmi.* public class SomeServer{ public static void main(String[]args){ try{ SomeImpl exportedObj = new SomeImpl(); registryURL = “rmi://localhost:1099/some”; Naming.bind(registryURL, exportedObj); System.out.println(“Some Server ready”); }catch(Exception e){ } } Explica bajo qué circunstancias podría no ejecutarse correctamente. Es posible que falle si antes no se ha inicializado un registro con la función startRegistry() o también es posible que nos de error si ya existe exportedObj y estamos usando bind, no rebind. 9. Teniendo en cuenta que el ejemplo del ejercicio anterior es un servidor de objetos en Java RMI, deﬁne los conceptos de “servidor de objetos” y “objeto servidor”. El servidor de objetos es un proceso que exporta un objeto remoto y lo registra en el servicio de directorios, mientras que un objeto servidor es un objeto que proporciona métodos remotos que pueden ser invocados por un objeto cliente. 10. Supongamos que ejecutamos desde un objeto cliente un método remoto en un objeto servidor Java RMI y que antes de que concluya su ejecución, otro objeto cliente desea ejecutar dicho método. ¿Cómo resuelve java RMI dicho problema (si es que lo resuelve)? RMI resuelve este proble porque un objeto servidor RMI es un servidor concurrente, cada solicitud de un objeto cliente se ejecuta en un hilo diferente. 11. IIOP e IOR son protocolos usados por CORBA. Explica para que sirve cada uno de ellos. IIOP: Es un protocolo para interoperar ORBs aplicado sobre TCP/IP IOR: Es un protocolo para referencias abstractas de objetos que contiene una cadena de caracteres indicando el tipo de objeto, el ordenador donde está el objeto, el puerto del servidor donde está el objeto y una cadena de bytes para identiﬁcar el objeto. 12. ¿En un archivo de especiﬁcación IDL, que signiﬁca que el argumento del atributo de una operación sea de tipo in, out o inout? ¿Y qué signiﬁca que una operación sea de tipo oneway? Si es in es solo lectura, si es out es solo escritura y si es inout es de lectura y escritura. Una operación oneway implica que es no bloqueante, es decir, se ejecuta sin esperar ninguna respuesta y no devuelve ningún valor. 13. Que es una Distributed Hash Tabla (DHT) y en qué contexto se utilizaría? Una DHT es una tabla hash, pero distribuída y descentralizada donde cualquier nodo participante puedo recuperar de forma eﬁciente el valor asociado con una clave dada. Se utilizan en las redes peer-to-peer para administrar los nodos. 14. En Jade los comportamientos no son apropiativos sino colaborativos. Explica que signiﬁca eso. Que los comportamientos sean colaborativos quiere decir que un agente puede ejecutar varios comportamientos en paralelo en un mismo hilo. 15. Que diferencia a un agente de un cliente peer to peer? ——— 16. Para qué sirve el método block() de la clase Behaviour en Jade? Se puede usar indistintamente los métodos block() y blockingReceive() dentro de un comportamiento? Explica por qué. El método block() sirve para eliminar un comportamiento de la cola del agente y lo coloca en un estado bloqueado hasta que recibe un mensaje y se usa para no bloquear el resto de comportamientos. El método blockingReceive() es parecido al black() pero hasta que recibe un mensaje bloquea todos los comportamientos. \u0000 de \u000060 64 AN E X OS: E xáme n e s 17. Cuando usamos Jess en JADE, normalmente utilizamos una instancia de la clase Jess.Rete para ejecutar la base de reglas dentro de un comportamiento de JADE. Por qué no se utiliza directamente el método run de la clase Jess.Rete sin argumentos y normalmente se le pasa un valor numérico entero? ¿Qué signiﬁcado tiene dicho valor numérico? Dicho valor numérico signiﬁca el número de reglas a disparar. SI no se especiﬁca ningún valor, se bloqueará el hilo y todo el agente una vez que se acaben las reglas disponibles. 20 1 0: RESUEL T O 1. Deﬁne brevemente el concepto de middleware. Es un software que asiste en forma de intermediario a una aplicación para interactuar o comunicarse con otras aplicaciones, software, hardware, redes y/o sistemas operativos y que proporciona un mayor nivel de abstracción. 2. ¿Cuáles son las principales diferencias entre el paradigma del paso de mensajes y el paradigma del sistema de mensajes?. El paso de mensajes son sólo dos procesos donde uno envía peticiones y el otro las respuestas, además necesita estar fuertemente acoplado y comunicarse entre ellos directamente. El sistema de mensajes actúa como un conmutador de mensajes a través del cual dos procesos independientes se intercambian mensajes de forma asíncrona y de manera desacoplada. 3. ¿Qué es una asociación en Internet?. Es una relación entre dos máquinas que tiene un conjunto de datos que tiene información sobre el protocolo, la ip local y remota, y el puerto local y remoto. 4. La clase DatagramPacket tiene dos constructores distintos ¿Para qué sirve cada uno de ellos? DatagramPacket(byte[] buf, int length) Construye un datagrama para recibir paquetes de una longitud lenght y donde los datos recibidos se guardán en el array de bytes buf. DatagramPacket(byte[] buf, int length, InetAddress address, int port) Igual que el anterior pero además crea el datagrama ligado al host y puerto especiﬁcados. 5. Explica la diferencia entre broadcast y multicast. Broadcast: difusión a todos los dispositivos de una red. Multicast: difusión a todos los receptores de una subred. 6. El stub y el skeleton son, respectivamente, los proxies de cliente y servidor en la arquitectura RMI. Explica cómo se generan dichos proxies. rmic -v1.1 <nombre de la clase de la implementación de la interfaz remota> 7. ¿Cuál es la razón de que todos los métodos en una interfaz remota lancen la excepción RemoteException?. Para que cuando suceda un error durante el procesamiento de la invocación de un método remoto (fallos al acceso y conexión, no encontrar el objeto, no encontrar el stub o skeleton) se lanza una excepción de este tipo que debe ser gestionada por el método que la invoca. 8. La clase Naming tiene, entre otros, dos métodos denominados bind y rebind que sirven para que el servidor de objetos publique en el registro RMI un objeto remoto. ¿En que se diferencian a nivel de comportamiento?. bind: enlaza el nombre que se especiﬁca a un objeto remoto rebind: vuelve a enlazar el nombre especiﬁcado a un nuevo objecto remoto. 9. El método rebind de la clase Naming tiene un primer argumento que es una cadena de caracteres que representa a una URL. Dicha URL siempre debe comenzar con “rmi://localhost”. Sin embargo, el método lookup de la misma clase Naming tiene una URL en la que localhost puede ser sustituido por cualquier dirección válida en Internet. Explica por qué. Porque rebind sólo registra el objecto a exportar, mientras que lookup obtiene la referencia del objeto que puede estar en una máquina local de la red o no local, por eso la dirección puede ser externa a la máquina local. 10 y 11. Colocación de archivos para Java RMI y con Callbacks: \u0000 de \u000061 64 AN E X OS: E xáme n e s \u0000 12. Explica bajo qué circunstancias puede ser necesario el uso de un SecurityManager en java RMI. En aquellas situaciones en las que la aplicación se vea involucrada al acceso desde/a una máquina remota y posiblemente a la carga de objetos. De esta manera se protegen frente a accesos inadecuados o no permitidos. 13. ¿Qué es un IOR? Es un protocolo de referencias abstractas para objetos que consta de una de cadena de caracteres codiﬁcados que contiene información sobre el tipo de objeto, el ordenador donde se encuentra el objeto, puerto del servidor del objeto y una clave que será una cadena de bytes que servirá para identiﬁcar el objeto. 14. En la sintaxis de IDL que signiﬁca que un método sea de tipo oneway?. ¿Qué repercusiones al respecto de los tipos de entrada o los parámetros de salida tiene que un método sea oneway?. Indica que es un método no bloqueante. Con respecto a la entrada, no puede tener parámetros ni cláusulas raises. Con respecto a la salida, no devuelve ningún valor y no espera ninguna información sobre la realización de la operación. 15. Deﬁne lo que se entiende por widening y narrowing? Widening: método que permite a un objeto Java convertirse en una referencia a un objeto CORBA. Narrowing: método que permite a una referencia de un objeto CORBA se pueda convertir a su objeto correspondiente tipo Java. 16. ¿Cuáles son las diferencias fundamentales entre un sistema P2P y un sistema multiagente?. Un sistema P2P aporta mejor rendimiento, escalabilidad, ﬁabilidad y disponibilidad (mejor conectividad, tolerancia a fallos y balanceo de carga para mejorar la calidad de sus servicios), no son móbiles y cada nodo de un sistema P2P está siempre en la misma máquina. Un sistema multiagente es más sencillo debido a su implementación de nodos mediante agentes y son inteligentes. 17. ¿Qué es un super-peer en Kazaa y qué criterios se utilizan para hacer que un nodo P2P se transforme en super- peer?. Es un par de una red P2P que actúa como servidor para un pequeño trozo de red. Son automáticamente elegidos por el sistema basándose en sus capacidades (almacenamiento y ancho de banda) y disponibilidad (tiempo de conexión). 18. Deﬁne las cinco características fundamentales que deﬁnen a un sistema multiagente. - Cada agente no tiene información suﬁcientes ni la capacidad para resolver el problema - Tienen puntos de vista limitados - No hay un sistema de control global - Los datos están descentralizados - La comunicación es asíncrona 19. Deﬁne los conceptos de protocolo y conversación en FIPA-ACL. Protocolo: es el patrón ﬁjo de intercambio de mensajes  Conversación: es una instancia particular de uno de estos intercambios. 20. ¿Cuál es la función del agente DF en JADE?. \u0000 de \u000062 64 AN E X OS: E xáme n e s Proporcionar los métodos para poder interaccionar con el servicio de páginas amarillas; permite navegar, registrar, deregistrar, modiﬁcar y buscar descripciones de agentes; también permite federarse con otros DF y realizar búsquedas federadas. 21. ¿Qué queremos decir cuando comentamos que los comportamientos en JADE son cooperativos y no apropiativos?. Los comportamientos no son excluyentes se ejecutan simultáneamente dentro de un mismo thread de java. 22. Cuando deseamos modiﬁcar el contenido de una variable desde un entorno gráﬁco en JADE, debemos crear un comportamiento de tipo OneShotBehaviour que realice dicha acción. Indica por qué. Porque el comportamiento OneShot concluye de forma inmediata y el método action() solo se ejecuta una vez. Así la interfaz se modiﬁcaría de inmediato y no habría comportamientos cíclicos, ni se dependa de estados y no afectaría a otros comportamientos. 23. ¿Cuál es la diferencia de comportamiento entre los métodos receive y blockingReceive de la clase Agent en JADE?. ¿Donde es oportuna su utilización?. block()-> suspende un elemento de la cola y lo coloca en un estado bloqueado. Se utiliza para recibir mensajes dentro de comportamientos junto con el método receive(). blockingReceive()-> concluye cuando hay un mensaje en la cola de mensajes. Se utiliza para recibir mensajes dentro de los métodos setup() y takedown(). Es peligroso utilizar blockingReceive() dentro de un comportamiento porque ningún otro comportamiento podrá ejecutarse hasta que este ﬁnalice. 24. El método run de la clase jess.Rete tiene un argumento numérico. ¿Qué signiﬁca dicho argumento y por qué debe utilizarse dentro de un comportamiento en JADE en lugar del correspondiente método sin argumentos?. Es el número máximo de reglas a disparar. Si no se especiﬁca una vez que se termine con las reglas que hay disponibles, se bloqueará el hilo de llamada y con ello todo el agente. 25. ¿Cuál es la función de la clase ContentManager en JADE?. Proporcionar los métodos para manejar el contenido y las ontologías conocidas por un agente y llenar/extraer el contenido de un mensaje ACL. 26. En el contexto de Java RMI, ¿cuál es el propósito de la serialización de objetos? Poder enviar como argumentos a un método de un objeto remoto tipos de datos complejos. El contenido de un objeto es encapsulado en una cadena que se puede enviar a través de la red. Además la máquina Java garantiza que la reconstrucción del objeto en la parte será remota será correcta y que el objeto funcionará sin problemas. 27. Comparada con Java RMI, ¿cuáles son los principales puntos fuertes de una herramienta CORBA, si hay alguno?. ¿Cuáles son los puntos débiles, si hay alguno? Ventajas: - Soporte de varios lenguajes (no exclusivamente Java) ejecutado en diferentes plataformas y acceder a cualquier lenguaje a través de un IDL. - Con IDL la interfaz está claramente separada de la ejecución y se pueden crear diferentes implementaciones basadas en la misma interfaz. - Es ideal para sistemas heredados y para asegurar que las aplicaciones escritas ahora se podrán acceder en el futuro. Es una forma fácil de vincular objetos y sistemas. Contras: - La descripción de los servicios requieren el uso de IDL, que debe ser aprendido. - No es compatible con la transferencia de objetos o código. - Es más difícil de dominar para los desarrolladores Java. 28. ¿Qué problemas crees que tienen los protocolos Napster y Gnutella?. ¿Cuándo utilizarías cada uno de ellos?. Napster: si el servidor cae, el sistema también. Existe control de tráﬁco y los usuarios deben estar registrados, por lo que el anonimato es nulo. Además en las versiones iniciales solo tenía archivos en formato .mp3. Lo utilizaría si quiero búsquedas rápidas, donde las actualizaciones son frecuentes y puesto que las primeras aplicaciones solo contenían .mp3 facilita la búsqueda. \u0000 de \u000063 64 AN E X OS: E xáme n e s Gnutella: las búsquedas son más lentas y la propagación de la búsqueda está limitada por el TTL (Time to live). Lo usaría si busco todo tipo de archivos y el anonimato a la hora de realizar las búsquedas. 29. Indica cuáles son las principales características que hacen que un programa se convierta en un agente. ¿Qué diferencia a un agente de un cliente peer to peer? • Entidades autónomas: pueden trabajar sin la intervención del usuario directamente y tienen cierto control sobre sus servicios y estado interno. Puede percibir y responder oportunamente a lo que suceda en su entorno y su comportamiento está determinado por los objetivos que persiguen, por lo que, pueden producir acciones no sólo como respuesta al entorno. • Inteligencia: un agente puede decidir a que objetivo perseguir o ante que evento reaccionar (actuar para para conseguir un objetivo o suspender/abandonar para dedicarse a otro). También puede adaptarse progresivamente a cambios en entornos dinámicos mediante técnicas de aprendizaje. • Sistemas Multiagente: permiten la resolución de problemas mediante la estrategia divide y vencerás, hay una mejor escalabilidad, tolerancia a fallos y gestión de recursos. • Habilidad Social: existen diálogos y asignan la realización de tareas de manera que cooperan, se coordinan y formulan un acuerdo que sea aceptable por todas las partes invitadas. • Movilidad: los agentes se pueden mover de un nodo a otro en una red preservando su estado en los saltos entre nodos. PREGUNT AS EXTRAS 1. Cuando un objeto servidor se registra en el registro de RMI, debe construir una dirección URL que será un argumento de la función rebind del objeto Naming. Describe brevemente el formato de dicha URL, indicando los valores posibles de cada uno de sus componentes. ¿En qué se diferencia (o se puede diferenciar) de la URL utilizada por el cliente y que se le suministra al método lookup también del objeto Naming?. Formato: “rmi://localhost” + portNum + ”/some”  nombre de la máquina + no del puerto + nombre del objecto (opcional) Se puede diferenciar en el nombre de la máquina ya que mientras el rebind registra el objeto a exportar, lookup obtiene la referencia del objeto que puede estar en una máquina en la red, no local, por eso la dirección puede ser externa a la máquina local. 2. Describe brevemente la lista de archivos necesarios, tanto en la parte del servidor como en el cliente para una aplicación Java RMI con callback de cliente. Servidor: interfaz remota, implementación de la interfaz remota, ﬁcheros stub y skeleton para el objeto remoto, programa del servidor de objetos. Cliente: interfaz remota más copia del ﬁchero.class, copia del ﬁchero stub para la implementación de la interfaz y programa del cliente. \u0000 de \u000064 64","libVersion":"0.5.0","langs":""}