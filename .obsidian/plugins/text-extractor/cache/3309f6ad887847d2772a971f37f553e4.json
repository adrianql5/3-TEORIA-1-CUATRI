{"path":"COMDIS/bibliografía/[1] Computación Distribuida Fundamentos y Aplicaciones-1.pdf","text":"www.FreeLibros.orgwww.FreeLibros.org COMPUTACIÓN DISTRIBUIDA. FUNDAMENTOS Y APLICACIONES www.FreeLibros.orgwww.FreeLibros.org COMPUTACION DISTRIBUIDA. FUNDAMENTOS Y APLICACIONES M. L. Liu C a lifo r n ia P o ly te c h n ic S ta te U n iv e r s ity , S a n L u is O b is p o Traducción: Jo sé M aría Peña Sánchez Fernando Pérez C o sto ya María de los S a n to s Pérez H ernández V ícto r R ob le s F orca d a F a c u lta d d e I n fo r m á tic a U n iv e r s id a d P o lité c n ic a d e M a d r id PEARS ON M adrid • M éxico • Santafé de Bogotá • Buenos A ires • Caracas • Lim a • Montevideo San Juan • San José • Santiago • Sao Paulo • Reading, M assachussets • Harlow, England www.FreeLibros.org ___________________ / t a t o s d e catalogación bibliográfica LIU, M. L. COMPUTACIÓN D ISTRIBU ID A. FUNDAM ENTO S Y APLIC ACIO N ES PEARSON EDUCACIÓN, S.A. Madrid, 2004 ISBN: 84-7829-066-4 Materia: Informática 6 8 1 3 Formato 195 x 250 Páginas: 424 Todos los derechos reservados. Q ueda prohibida, salvo excepción prevista en la Ley, cualquier form a de reproducción, distribución, com unicación pública y transform ación de e sta obra sin contar c o n autorización de los titulares de propiedad intelectual. La infracción de los derechos m encionados puede ser constitutiva de delito contra la propiedad intelectual (arts. 270 y sgts. Código Penal). DERECHOS RESERVADOS © 2004 por PEARSON EDUCACIÓN, S.A. Ribera del Loira, 28 28042 M adrid (España) COMPUTACIÓN D ISTRIBUID A. FUND AM ENTO S Y APLICACIO NES U U , M. L. ISBN: 8f-7829-O0B-4 Depósito Legal: M- PEARSON ADDISON-WESLEY es un sello editorial autorizado de PEARSON EDUCACIÓN, S A . Authorized translation from the English language edition, entitled DISTRIBUTED COMPUTING: PRINCfPLES AND APPLICATIONS, lst Edition b y LIU, M. L., published by Pearson Education, Inc, publishing a s Addison-Wesley. © 2004. All rights reserved. N o part or this book m ay be reproduced or transm itted in any form or b y any m eans, electronic cr mechanical, including photocopying, recording or b y any inform ation storage retrieval system, without permission from Pearson Education, Inc. ISBN: 0-201-79644-9 E quipo editorial: Editor: D avid Fayerman Aragón Técnico editorial: Ana Isabel G arcía Borro E quipo de producción: Director: José Antonio C lares Técnico: José Antonio Hernán Diseño de c u b ie rta : Equipo de diseño de Pearson Educación, S.A. C om posición: COM POM AR, S.L. Im preso por: IMPRESO EN ESPAÑA - PRINTED IN SPAIN Esle libro ha sido impreso con papel y tintas ecológicos www.FreeLibros.org Indice de contenido Prefacio ..................................................................................................................................... xi C apítulo 1. Introducción a la com putación d is tr ib u id a............................................ 1 1.1. D efiniciones .................................................................................................................................................. 1 1.2. L a h is to ria de la c o m p u ta c ió n d i s t r i b u i d a ........................................................................................ 2 1.3. D iferen tes fo rm a s de c o m p u ta c ió n ...................................................................................................... 5 C om putación m o n o lític a ............................................................................................................................ 5 C om putación d is trib u id a ............................................................................................................................ 5 C om putación p a r a le la ................................................................................................................................. 6 C om putación cooperativa .......................................................................................................................... 8 1.4. V irtu d e s y lim itacio n es d e la c o m p u tac ió n d is tr ib u id a ................................................................ 8 1.5. C o n cep to s básicos de sistem as o p e ra tiv o s ........................................................................................ 12 Program as y procesos d e co m p u tac ió n ................................................................................................... 12 Program ación co n c u rren te.......................................................................................................................... 16 1.6. C o n cep to s básicos de re d e s .................................................................................................................... 20 Protocolos ...................................................................................................................................................... 20 A rquitectura de r e d ...................................................................................................................................... 21 Protocolos de la arquitectura de r e d ........................................................................................................ 23 C om unicación orientada a conexión frente a com unicación sin c o n e x ió n ................................. 23 Recursos de r e d ............................................................................................................................................. 25 Identificación d e nodos y direcciones del Protocolo de In te rn e t....................................................... 26 Identificación d e procesos a través de p u e rto s ..................................................................................... 31 D irecciones de correo elec tró n ic o ............................................................................................................ 31 U R L .................................................................................................................................................................. 31 1.7. C o n cep to s básicos de in g e n ie ría d e l so ftw a re ...... ............................................................................. 34 Program ación procedim ental frente a program ación orientada a o b j e t o s ..................................... 34 UML ................................................................................................................................................................ 34 La arquitectura d e aplicaciones d istrib u id as......................................................................................... 35 C onjuntos de herram ientas, m arcos de desarrollo y com ponentes ................................................. 36 R e s u m e n ........................................................................................................................................................ 36 E jercicio s ...................................................................................................................................................... 37 R e f e r e n c ia s .................................................................................................................................................... 43 www.FreeLibros.org vi índice d e contenido C apítulo 2. IPC - C om unicación en tre procesos ................................................... 45 2.1. U n a rq u e tip o de in te rfa z de p ro g ra m a c ió n p a r a c o m u n ica ció n e n tre p r o c e s o s 47 2.2. S in cro n izació n d e e v e n to s ....................................................................................................................... 48 E nviar síncrono y recibir s ín c r o n o .......................................................................................................... 50 E nviar asincrono y recib ir s ín c r o n o ........................................................................................................ 51 E nviar síncrono y recibir a s in c r o n o ........................................................................................................ 52 E nviar asincrono y recibir asincrono ..................................................................................................... 53 2.3. T e m p o riz a d o re s e hilos de e je c u c ió n .................................................................................................. 54 2.4. In te rb lo q u e o s y te m p o riz a d o re s ......................................................................................................... 54 2.5. R e p re se n ta c ió n de d a t o s ......................................................................................................................... 55 2.6. C o d ificació n d e d a to s .............................................................................................................................. 57 2.7. P ro to co lo s b a sa d o s en t e x t o .................................................................................................................. 59 2.8. P ro to co lo s de s o lic itu d -re s p u e s ta ......................................................................................................... 59 2.9. D ia g ra m a de eventos y d ia g ra m a d e s e c u e n c ia ............................................................................. 59 2.10. C o m u n ic a c ió n e n tre p ro ce so s o rie n ta d a y no o rie n ta d a a c o n e x ió n ..................................... 62 2.11. E v o lu ció n de los p a ra d ig m a s de c o m u n ica ció n e n tre p r o c e s o s ............................................... 63 R e s u m e n ........................................................................................................................................................ 64 E jercicio s ...................................................................................................................................................... 65 R e f e r e n c ia s .................................................................................................................................................... 69 C apítulo 3. Paradigm as de com putación d is trib u id a........................................... 71 3.1. P a ra d ig m a s y a b stra c c ió n .................................................................................................................... 71 A bstracción .................................................................................................................................................... 71 P arad ig m as...................................................................................................................................................... 72 3.2. U n a a p licac ió n d e e j e m p l o .................................................................................................................... 72 3.3. P a ra d ig m a s p a r a aplicacio n es d i s t r i b u i d a s .................................................................................... 73 Paso de m e n sa je s........................................................................................................................................... 73 Paradigm a c lie n te -se rv id o r........................................................................................................................ 74 Paradigm a de igual a igual p ee r-to -p eer................................................................................................ 75 Paradigm a de sistem a d e m e n sa je s.......................................................................................................... 76 M odelo de llam adas a procedim ientos re m o to s ................................................................................... 79 Paradigm as de objetos d istrib u id o s.......................................................................................................... 81 Espacio de o b je to s ........................................................................................................................................ 82 Paradigm a de agentes m óviles ................................................................................................................. 83 Paradigm a de servicios de red ................................................................................................................. 84 Paradigm a de aplicaciones colaborativas (groupw are) ..................................................................... 85 3.4. C o m p a r a tiv a ................................................................................................................................................. 86 N ivel de abstracción frente a s o b re c a rg a .............................................................................................. 86 Esca la b ilid a d .................................................................................................................................................. 87 Soporte m ulti-plataform a .......................................................................................................................... 87 R e s u m e n ........................................................................................................................................................ 88 E jercicio s ...................................................................................................................................................... 89 R e f e r e n c ia s .................................................................................................................................................... 89 C apítulo 4. El API de s o c k e t s....................................................................................... 91 4.1. A n te c e d e n te s ................................................................................................................................................. 91 www.FreeLibros.org 4.2. L a m e tá fo ra del so ck et e n IP C ............................................................................................................. 92 4.3. E l A P I de sockets d a t a g r a m a .................................................................................................................. 92 El socket datagram a sin conexión .......................................................................................................... 93 El A PI de sockets datagram a orientados a c o n e x ió n ........................................................................... 103 4.4. E l A P I de sockets e n m o d o s t r e a m ....................................................................................................... 106 O peraciones y sincronización de e v e n to s .............................................................................................. 108 4.5. Sockets c o n o p e rac io n es de E /S no b lo q u e a n t e s ............................................................................ 117 4.6. E l A P I de sockets s e g u r o s ........................................................................................................................ 117 El nivel de sockets s e g u ro s......................................................................................................................... 117 La extensión de sockets seguros de J a v a .............................................................................................. 118 R e s u m e n ........................................................................................................................................................ 119 E jercicio s ...................................................................................................................................................... 120 R e f e r e n c ia s .................................................................................................................................................... 124 C apítulo 5. El paradigm a c lie n te -s e rv id o r................................................................. 125 5.1. A n te c e d e n te s .................................................................................................................................................. 125 5.2. C u e stio n es so b re el p a ra d ig m a c lie n te -se rv id o r ............................................................................ 126 U na sesión d e servicio ............................................................................................................................... 126 El protocolo de un se rv ic io ........................................................................................................................ 127 C om unicaciones entre procesos y sincronización de e v e n to s .......................................................... 128 R epresentación de datos ............................................................................................................................ 129 5.3. In g e n ie ría de so ftw are d e u n servicio d e r e d ................................................................................... 130 A rquitectura de s o ftw a re ............................................................................................................................ 130 M ecanism o de IPC ...................................................................................................................................... 131 C liente-servidor D aytim e usando sockets datagram a sin c o n e x ió n ................................................ 131 C liente-servidor D aytim e usando sockets en m odo s tr e a m ............................................................. 138 Prueba de un servicio de r e d ..................................................................................................................... 145 5.4. S e rv id o re s o rie n ta d o s a conexión y sin co nexión .......................................................................... 145 C liente-servidor E cho sin conexión ........................................................................................................ 145 El servidor E c h o ........................................................................................................................................... 146 C liente-servidor E cho orientado a conexión ....................................................................................... 149 5.5. S e rv id o r ite ra tiv o y se rv id o r c o n c u rre n te ........................................................................................ 154 5.6. S e rv id o re s con e s t a d o ............................................................................................................................... 156 Inform ación de estado g l o b a l ................................................................................................................... 157 Inform ación de estado d e s e sió n ............................................................................................................... 160 R e s u m e n ........................................................................................................................................................ 164 E jercicio s ...................................................................................................................................................... 165 R e f e r e n c ia s .................................................................................................................................................... 169 Capítulo 6. C om unicación de g r u p o ............................................................................. 171 6.1. U n id ifu sió n fre n te a m u ltid ifu sió n ...................................................................................................... 171 6.2. U n a A P I de m u ltid ifu sió n a rq u e típ ic a ............................................................................................... 172 6.3. M u ltid ifu sió n sin conexión fre n te a o rie n ta d a a c o n e x ió n ........................................................... 172 6.4. M u ltid ifu sió n fiab le fre n te a n o fiab le ............................................................................................... 173 M ultidifusión no f i a b l e ............................................................................................................................... 173 M ultidifusión f ia b le ...................................................................................................................................... 174 6.5. E l A P I de m u ltid ifu sió n b á sic a d e J a v a ............................................................................................. 176 índice d e contenido v i i www.FreeLibros.org viii índice d e contenido D irecciones IP de m u ltid ifu sió n ............................................................................................................... 177 Incorporación a un grupo de m ultidifusión ......................................................................................... 178 E nvío a un grupo de m u ltid ifu sió n .......................................................................................................... 178 6.6. E l A P I de m u ltid ifu sió n f i a b l e ............................................................................................................... 184 R e s u m e n ........................................................................................................................................................ 185 E jercicio s ...................................................................................................................................................... 186 R e f e r e n c ia s .................................................................................................................................................... 189 C apítulo 7. O bjetos d is trib u id o s................................................................................... 191 7.1. P a so de m e n sa je s fre n te a o b je to s d istrib u id o s ............................................................................ 191 7.2. U n a a r q u ite c tu r a típ ic a de o b jeto s d is trib u id o s ............................................................................ 193 7.3. S istem as d e o b je to s d i s t r i b u i d o s ........................................................................................................... 194 7.4. L la m a d a s a p ro c ed im ien to s re m o to .................................................................................................... 195 7.5. R M I (re m ó te m e th o d in v o catio n ) ........................................................................................................ 197 7.6. L a a r q u ite c tu ra d e ja v a R M I .................................................................................................................. 197 Parte cliente de la a rq u ite c tu ra ................................................................................................................. 197 Parte servidora d e la a rq u ite c tu ra ............................................................................................................ 198 Registros d e los objetos ............................................................................................................................ 199 7.7. A P I d e J a v a R M I ....................................................................................................................................... 200 La interfaz r e m o ta ........................................................................................................................................ 200 Softw are de la parte servidora ................................................................................................................. 201 Softw are d e la parte cliente ..................................................................................................................... 205 7.8. U n a a p lica ció n R M I d e ejem p lo ........................................................................................................... 207 7.9. P aso s p a r a c o n s tru ir u n a a p lica ció n R M I ........................................................................................ 210 A lgoritm o para desarrollar el softw are de la parte servidora ......................................................... 211 A lgoritm o para desarrollar el softw are de la parte c lie n te ................................................................ 212 7.10. P ru e b a s y d e p u r a c i ó n ............................................................................................................................... 212 7.11. C o m p a ra c ió n e n tre R M I y la A P I de so ck e ts ................................................................................. 213 7.12. P a r a p e n s a r .................................................................................................................................................. 213 R e s u m e n ........................................................................................................................................................ 214 E jercicio s ...................................................................................................................................................... 214 R e f e r e n c ia s .................................................................................................................................................... 216 C apítulo 8. R M I a v a n z a d o..................................................................................................2 19 8.1. C a llb a c k de cliente .................................................................................................................................... 219 E xtensión de la parte cliente para callback de c lie n te ....................................................................... 221 E xtensión de la parte servidora para callback de c lie n te .................................................................. 225 Pasos para construir una aplicación R M I con callback de cliente ................................................ 230 8.2. D esca rg a d e r e s g u a r d o ............................................................................................................................. 232 8.3. E l g e sto r de se g u rid a d de R M I ............................................................................................................. 233 Instanciación de un G estor de Seguridad en un program a R M I .................................................... 234 La sintaxis d e un fichero de políticas de seguridad de J a v a ........................................................... 237 U so de descarga de resguardo y un fichero d e políticas de s e g u r id a d ........................................ 238 A lgoritm os para co n struir una aplicación RM I, que perm ita descarga de re s g u a r d o 240 R e s u m e n ........................................................................................................................................................ 241 E jercicio s ...................................................................................................................................................... 242 R e f e r e n c ia s .................................................................................................................................................... 244 www.FreeLibros.org C apítulo 9. Aplicaciones de In ternet .......................................................................... 245 9.1. H T M L ............................................................................................................................................................ 247 9.2. X M L .............................................................................................................................................................. 247 9.3. H T T P ............................................................................................................................................................ 248 La petición del c lie n te ................................................................................................................................. 249 La respuesta del servidor .......................................................................................................................... 251 T ipos de contenido y M I M E ..................................................................................................................... 253 U n cliente H TTP s e n c illo .......................................................................................................................... 254 HTTP, un protocolo orientado a conexión y sin e s ta d o ..................................................................... 256 9.4. C o n te n id o w eb g e n e ra d o d e fo rm a d in á m ic a ............................................................................... 257 9.5. C G I ................................................................................................................................................................. 258 U n form ulario web ...................................................................................................................................... 261 Procesam iento de la C adena de In te rro g a c ió n ..................................................................................... 264 C odificación y decodifícación de la cadena de in te rro g a c ió n ......................................................... 265 Variables de entorno utilizadas en los CGI ......................................................................................... 268 9.6. Sesiones w eb y d a to s de e sta d o d e la s e s ió n .................................................................................... 269 U so d e cam pos ocultos de form ulario para transferir datos de estado de s e s i ó n ....................... 271 U so d e Cookies para el envío de datos de estado d e s e s ió n ........................................................... 276 Sintaxis de la línea d e cabecera de respuesta HTTP Set-C ookie .................................................. 277 Sintaxis de la línea d e cabecera de petición HTTP C o o k ie ............................................................. 279 C ódigo de ejem plo de la utilización de C ookies para transm itir d atos de estado ................... 281 Privacidad de los datos y consideraciones d e s e g u r id a d .................................................................. 284 R e s u m e n ........................................................................................................................................................ 285 E jercicio s ...................................................................................................................................................... 287 R e f e r e n c ia s .................................................................................................................................................... 291 C a p ítu lo lO . C O RBA - C om m on O b ject R eq uest B roker Architecture .............293 10.1. A rq u ite c tu ra b á s i c a .................................................................................................................................. 294 10.2. L a in te rfa z de o b jeto s d e C O R B A .................................................................................................... 295 10.3. P ro to co lo s in te r-O R B ............................................................................................................................. 295 10.4. S e rv id o re s de o b je to s y c lien tes de o b jeto s ..................................................................................... 296 10.5. R efe ren cias a o b je to s C O R B A ............................................................................................................ 296 10.6. S ervicio d e n o m b re s y servicio d e n o m b re s in te ro p e ra b le de C O R B A ................................. 297 Servicio de nom bres de C O R B A ............................................................................................................ 297 Servicio de nom bres interoperable d e C O R B A ................................................................................... 298 10.7. Servicios d e o b je to s C O R B A ................................................................................................................ 299 10.8. A d a p ta d o re s de O b j e t o s ......................................................................................................................... 300 ID L de Java ................................................................................................................................................. 300 Paquetes claves d e Java IDL ................................................................................................................... 301 H erram ientas de Jav a IDL ........................................................................................................................ 301 U na aplicación C O R B A de e je m p lo ....................................................................................................... 302 C om pilación y ejecución d e una aplicación Java I D L ....................................................................... 315 Callback de cliente ...................................................................................................................................... 316 10.9. C o m p a r a tiv a ................................................................................................................................................ 316 R e s u m e n ........................................................................................................................................................ 316 índice d e contenido ix www.FreeLibros.org X índice d e contenido E jercicio s ...................................................................................................................................................... 317 R e f e r e n c ia s .................................................................................................................................................... 319 Capítulo 11. Aplicaciones de In ternet - Parte 2........................................................ 321 11.1. A p p lets ......................................................................................................................................................... 321 11.2. S e r v l e t s ......................................................................................................................................................... 323 Soporte arqu itectó n ico ................................................................................................................................. 324 Program ación d e servlets .......................................................................................................................... 327 M antenim iento d e la inform ación d e estado en la program ación de s e rv le ts ............................. 332 11.3. Servicios w e b ............................................................................................................................................. 344 11.4. S O A P .............................................................................................................................................................. 346 U na petición S O A P ...................................................................................................................................... 347 U na respuesta S O A P .................................................................................................................................... 349 A pache S O A P ............................................................................................................................................... 351 Servicios w eb ya im plem entados ............................................................................................................ 353 Invocación de un servicio web utilizando A pache S O A P ................................................................ 354 Im plem entación de un servicio web utilizando A pache S O A P ...................................................... 356 R e s u m e n ........................................................................................................................................................ 357 E jercicio s ...................................................................................................................................................... 358 R e f e r e n c ia s .................................................................................................................................................... 366 Capítulo 12. Paradigm as avanzados de com putación d is trib u id a......................367 12.1. P a ra d ig m a de siste m a s d e colas de m e n s a je s ................................................................................. 368 M odelo d e m ensajes punto-a-punto ........................................................................................................ 368 M odelo d e m ensajes p ublicación/suscripción ....................................................................................... 368 12.2. A gentes m ó v ile s ......................................................................................................................................... 373 A rquitectura básica ...................................................................................................................................... 374 Ventajas d e los agentes m ó v ile s ................................................................................................................ 380 Sistem as basados en entornos para agentes móviles ........................................................................... 381 12.3. Servicios d e r e d ......................................................................................................................................... 382 12.4. E spacios d e o b j e t o s .................................................................................................................................. 385 R e s u m e n ........................................................................................................................................................ 388 E jercicio s ...................................................................................................................................................... 389 R e f e r e n c ia ...................................................................................................................................................... 390 Epílogo ...................................................................................................................................... 393 índice a lfa b é tic o..................................................................................................................... 395 www.FreeLibros.org P r e f a c io En el modelo de curriculum de computación del año 2001 (Computing Curricula 2001 http://www.computer.org/education/cc2001/report/index.htmi) desarrollado por Joint IEEE Computer Society/ACM Task Forcé, la computación en red se incluye como un área clave d e las ciencias de la computación: Los últimos avances en las redes d e computación y telecomunicaciones, par­ ticularmente en aquellas basadas en TCP/IP, han incrementado la importancia de las tecnologías de red en las disciplinas de computación. L a computación en red cubre una serie de subespecialidades, incluyendo protocolos y conceptos de redes de comunicación de computadores, sistemas multimedia, estándares y tec­ nologías web, seguridad en redes, computación sin cables y móvil y sistemas distribuidos. El dominio de esta área de trabajo necesita de teoría y d e práctica. Las téc­ nicas de aprendizaje que supongan la realización de experimentos y análisis propios, son m uy recomendadas, ya que refuerzan la comprensión de los con­ ceptos de los estudiantes y su aplicación a los problemas de la vida real. Las prácticas de laboratorio deberían incluir la recolección y síntesis de datos, m o­ delado empírico, análisis de protocolos a nivel de código fuente, monitorización de paquetes de red, construcción de software y evaluación de modelos de dise­ ño alternativos. Todos estos son conceptos importantes que pueden ser mejor comprendidos en las prácticas de laboratorio. El modelo de curriculum de ACM enum era una serie de tem as dentro de esta área, especificando un mínimo de 15 horas de tem as troncales y tem as de libre elección adicionales. La mayor parte de estos tem as se cubren en una serie de cursos de com­ putación distribuida que inicié e impartí en California Polytechnic State University (Cal Poly), San Luis Obispo, desde 1996. Para estos cursos utilicé material de varias publicaciones, así como material propio, incluyendo transparencias, códigos de ejem ­ plo y tareas d e laboratorio, problemas e investigación, que proporcionaba como un curso completo a mis estudiantes. Este libro de texto es una síntesis de los materiales del curso que he acumulado a lo largo de seis años y ha sido diseñado para impartir tem as técnicos optativos a es­ tudiantes universitarios. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones M otivaciones del libro Tradicional mente, los cursos de computación distribuida se ofertan a estudiantes de postgrado. Sin embargo, con el crecimiento de Internet y de las aplicaciones para in- tranets, cada vez más estudiantes universitarios em plean la computación basada en red, y a sea en el trabajo o en casa. La computación distribuida es diferente de (1) co­ municaciones y redes y (2) sistemas operativos distribuidos. Opera a un mayor nivel de abstracción que el nivel de red y que los sistem as operativos y se ocupa de los pa­ radigmas de programación, de A PI y conjuntos de herramientas y de protocolos y de estándares en e l contexto de la computación basada en red. Aunque hay numerosos libros disponibles sobre programación de redes y tecnolo­ gías, existe una carencia de libros escritos en estilo de libro de texto que combinen la teoría y la práctica de la computación distribuida. Este libro tiene las siguientes características diferenciadoras: • Está diseñado para introducir a los estudiantes universitarios en los fundamen­ tos de la computación distribuida, tem as normalmente destinados a estudiantes de postgrado. • S e centra en las capas más altas de la arquitectura d e la computación basada en red, y más específicamente en los paradigmas y abstracciones de dicha compu­ tación. • Incorpora temas conceptuales y prácticos, utilizando programas de ejemplo y ejercicios para ilustrar y reforzar los conceptos presentados. • Está diseñado como un libro de texto, con un estilo narrativo apropiado para el ám bito académico, con diagramas ilustrativos de los temas, ejercicios al final de los capítulos y listas de referencias para que los estudiantes puedan realizar sus investigaciones. • Está diseñado para e l aprendizaje con la experimentación: se presentan ejem ­ plos de programación sobre los tem as presentados y se incorporan actividades de laboratorio y ejercicios al final de cada capítulo. • El autor proporcionará materiales de enseñanza complementarios, incluyendo transparencias d e presentación, un sitio w eb y un manual para instructores. • Además del libro impreso y de los artículos, este libro cita referencias fiables accesibles a través de la Web. Por ejemplo, las referencias incluyen enlaces a sitios d e archivo donde se tiene acceso a los Requests f o r Comments (RFC) de Internet. El autor opina que los estudiantes universitarios están más motivados para buscar referencias que se encuentran disponibles en la Web. (Nota: aunque he elegido incluir como referencias enlaces w eb que son fiables y estables, es posible que alguno de ellos se quede obsoleto con el tiempo. Apreciaría cual­ quier información sobre dichos enlaces inactivos). Lo que no encontrarás en este libro • Este libro no es de redes. En sentido general las redes abarcan la computación distribuida ya que forma parte de las redes de computadoras. Sin embargo, en la universidad, los cursos de redes se suelen centrar en los niveles más bajos de la arquitectura de red y tratan tem as como la transmisión de la señal, los erro­ res de conexión, los protocolos del nivel de enlace, los protocolos del nivel de transporte y e l protocolo del nivel de Internet. En comparación, este libro trata www.FreeLibros.org los niveles más altos de la arquitectura de red, en concreto los niveles de apli­ cación, presentación y sesión, haciendo hincapié en e l punto de vista de los pa­ radigmas y abstracciones de computación y no en la arquitectura del sistema. • Este libro no es sobre sistem as distribuidos. El enfoque no está en la arquitec­ tura del sistem a o en recursos del sistema. • Este libro no es sobre el desarrollo de aplicaciones web. Aunque Internet es la red más popular, la programación para Internet es una forma específica de com­ putación distribuida. Este libro trata la computación distribuida en general, in­ cluyendo Internet, intranets y redes de área local. • Este libro no es sobre API o tecnologías. Aunque a lo largo del libro se intro­ ducen una serie de API, son presentadas como conjuntos de herramientas para paradigmas particulares; la introducción de estas API tiene la intención de per­ mitir a los estudiantes escribir programas para los ejercicios de laboratorio con el fin de reforzar los conceptos y fundamentos. Para los profesores Este libro está diseñado para su uso en un curso técnico optativo en el ámbito uni­ versitario. Los doce capítulos del libro pueden ser cubiertos en un cuatrimestre como mínimo o en un semestre de forma más pausada. Los materiales no requieren cono­ cimientos avanzados de redes, de sistem as operativos o de ingeniería del software. Se puede dar un curso basado en este libro para estudiantes de segundo ciclo. En un campo tan amplio como la computación distribuida es imposible cubrir to ­ dos los aspectos en un solo libro. De forma particular, no se intentan cubrir las últi­ mas tecnologías. Este libro tiene la intención de dar a conocer los conceptos funda­ mentales de la intercomunicación entre procesos. A lo largo d e todo el libro está la idea de abstracción, en el sentido de encapsu- lación: cómo se aplica esta idea en varios paradigmas de computación distribuida y las diferencias entre herramientas que proporcionan diversos niveles de abstracción. Creo firmemente que estos conceptos e ideas son importantes para todos los estu­ diantes de ciencias e ingenierías de la computación, independientemente del área de especialización. Con la comprensión de estos conceptos fundamentales, los estudian­ tes deberían estar bien preparados para explorar nuevas herramientas y tecnologías por sí mismos, como se espera que hagan a lo largo de su carrera profesional. Los tres primeros capítulos del libro contienen material d e introducción que pue­ de ser explicado en la primera o dos primeras sem anas del curso académico. Duran­ te este tiempo se introducirá a los estudiantes en multitud de tem as que pueden o no ser nuevos para ellos. Los siguientes capítulos son más técnicos y detallados y pue­ den ser explicados a razón de un capítulo por semana. Debido a la amplitud del tem a d e la computación distribuida, es probable que se quiera aportar materiales adicionales a este texto que se consideren importantes. Por ejemplo, se puede añadir una introducción a los algoritmos distribuidos o se puede profundizar más en e l área de seguridad. Para tener tiempo para estos añadidos se puede considerar prescindir de algunos capítulos del libro. No se asume que los lectores de este libro tienen experiencia previa en computa­ ción distribuida. En Cal Poly, he utilizado este material para enseñar a estudiantes con diversos perfiles, desde estudiantes sin ninguna experiencia en programación multi- proceso, hasta estudiantes que han desarrollado complejo software de red. Sin em ­ www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones bargo, los estudiantes con conocimientos avanzados tam bién encontrarán estos temas de interés. Nota p ara los lectores Unos comentarios sobre los tipos de letra en la redacción de este libro: • Los términos y frases clave están en negrita; por ejemplo: este libro trata la con fu tación distribuida • Palabras especiales, tales como las utilizadas como identificadores de progra­ mas, nombres de protocolo no estándares o nombres de operaciones son expre­ sados en letra itálica para su diferenciación del resto de la frase; por ejemplo: ¿cuál es la salida esperada cuando se ejecuta thread3? Compílelo y ejecútelo. • Las palabras reservadas y los identificadores, tales como los definidos por el lenguaje Java o por los protocolos conocidos, aparecen en itálica; por ejemplo: para dar soporte a los hilos en un programa, Java proporciona la clase denomi­ nada thread, además de la interfaz denominada runnable. Sobre la introducción de artículos y enlaces web: A lo largo del texto de este libro, se insertan extractos de artículos previamente publicados en otros medios. Estos artículos han sido escogidos por su relevancia en los tem as y por e l interés que pueden suponer para los lectores. Muchas de las referencias listadas al final de cada capítulo son enlaces web. Esta es una elección premeditada, porque el autor cree que el acceso a contenido disponi­ ble en la Web incrementará la iniciativa de los estudiantes. Los enlaces w eb elegidos son aquellos que el autor considera fiables y estables. Sin embargo, la obsolescencia de alguno de estos enlaces es inevitable, un cuyo caso el autor ofrece sus disculpas y agradece su notificación. C ontactar con el autor La compilación de un libro de texto es una tarea larga y laboriosa. Hasta el punto que pueda intentaré maximizar la precisión de los materiales presentados en este libro. Si se descubre algún error o falta de coherencia o si se tienen sugerencias d e mejora, es­ taré encantada de saberlo. Por favor, mándeme un correo a mliu@csc.calpoly.edu. M ateriales com plem entarios Los materiales complementarios, incluyendo los programas fuentes de los ejemplos de programación y las transparencias, están disponibles en el URL www.aw.com. Los materiales adicionales para profesores están sólo disponibles contactando con el representante de ventas de Addison Wesley. Agradecim ientos Agradezco la generosidad de diversos autores y editores que han concedido permiso de reimpresión para la inclusión de trabajos previamente publicados, en el texto de este libro. www.FreeLibros.org Prefacio XV Estoy en deuda para siem pre con mis directores de programa de doctorado, Dr. Divyakant Agrawal y Dr. Amr El Abbadi, Computer Science Department, University of California en Santa Barbara, que me introdujeron en e l campo d e la computación distribuida. Debo dar las gracias a los estudiantes de Cal Poly Jared Smith, Domingo Colon, Vinh Pham, Hafeez Jaffer, Erik Buchholz y Lori Saw dey por el regalo de su tiempo y su esfuerzo en la revisión del libro. También tengo que agradecer a los estudiantes que se matricularon en estos cursos de Cal Poly en los años académ icos 2001-2003: Computer Engineering 369, Computer Engineering 469, y Computer Science 569, por su paciencia con los numerosos errores en los borradores del manuscrito de este libro. Agradezco a mis compañeros del Computer Science Department y del College of Engineering en Cal Poly, que me dieron la oportunidad de dar clases en estos cursos que inspiraron e l libro, y sin cuyos ánimos el libro no hubiera sido posible. Agradezco al personal de Addison Wesley por su inestimable dirección y asisten­ cia que permitió que el libro viera la luz, y a los siguientes revisores por la genero­ sidad de compartir su tiem po y sabiduría: Anup Talukdar Motorola Labs, Schaumburg Dr. R ay Toal Loyola Marymount University Mr. David Russo Computer Science and Engineering Sénior Lecturer, University of Texas en Dallas Dr. Alvin Lim Computer Science and Software Engineering Department Auburn University Isaac Ghansah, Professor Computer Science and Computer Engineering California State University, Sacramento Bruce Char Department o f Computer Science Drexel University Finalmente, agradezco a mi familia y en particular a mi hijo, Marlin, el haberme proporcionado razones para esforzarme. M. L. Liu Cal Poly, San Luis Obispo Enero, 2003 www.FreeLibros.orgwww.FreeLibros.org CAPITULO In t r o d u c c ió n a la c o m p u t a c ió n d is t r ib u id a Este libro trata sobre com putación distribuida. Este capítulo com enzará Indicando qué se entiende por com putación d istribuida en el contexto de este libro. Para ello, se m uestra la historia de la com putación d istrib u ida y se com para este tip o de com putación con otras form as de com putación. A continuación, se presentan algunos co nceptos básicos en los cam pos de sistem as operativos, redes e ingeniería del software, co nceptos con los que el lector debe fam iliarizarse para com prender el material presentado en capítulos sucesivos. Uno de los orígenes de la confusión existente en el campo d e la computación distri­ buida es la falta de un vocabulario universal, tal vez debido al increíble ritmo a l que se desarrollan nuevas ideas en este campo. A continuación se definen algunos de los términos claves utilizados en el contexto de este libro. Durante la lectura del libro es necesario mantener en la mente estas definiciones, teniendo en cuenta que algunos de dichos términos pueden tener diferentes definiciones en otros contextos. En sus orígenes, la computación se llevaba a cabo en un solo procesador. Un m o- noprocesador o la c o n y u ta r ió n m onolítica utiliza una única unidad central de pro­ ceso o CPU (Central Processing IJnit) para ejecutar uno o más programas por cada aplicación. Un sistem a distribuido es un conjunto de computadores independientes, interco- nectados a través de una red y que son capaces de colaborar con el fin de realizar una tarea. Los computadores se consideran independientes cuando no comparten me­ moria ni espacio de ejecución de los programas. Dichos computadores se denominan computadores ligeram ente acoplados, frente a computadores fuertonm te acoplados, que pueden compartir datos a través de un espacio de memoria común. www.FreeLibros.org 2 C om putación distribuida. Fundam entos y aplicaciones Request for Comments Petición de comentarios) son especificaciones propuestas por ingenieros de Internet que invitan a realizar comentarios públicos. A través de los años, se han realizado miles de especificaciones, que se han archivado y que están accesibles en un gran número de sitios web, incluyendo los Archivos de Internet RFC/STD/FYI/BCP yaqs.org, 5].___________ La red ARPAN ET, creada en 1970, fue la predecesora de Internet. La confutación distribuida es computación que se lleva a cabo en un sistema dis­ tribuido. Este libio explora las formas en que los programas, ejecutando en computado­ res independientes, colaboran con otros con el fin de llevar a cabo una determinada ta­ rea de computación, tal como los servicios de red o las aplicaciones basadas en la Web. • Un servicio d e red es un servicio proporcionado por un tipo de programa es­ pecial denominado servidor en una red. La W W W (World Wide Web) o sim ­ plemente Web es un servicio de este tipo, así como el correo electrónico (<email) y la transferencia de ficheros (FTP: File Transfer Protocol). Un programa de servidor es justam ente la mitad del denominado modelo cliente-servidor de la computación distribuida. Este modelo se estudiará detalladamente en sucesivos capítulos de este libro. • Una aplican A i d e red es una aplicación para usuarios finales, que se ejecuta en computadores conectados a través de una red. Existe un gran número d e apli­ caciones de red, que van desde aplicaciones comerciales, tales como carritos de la compra y subastas electrónicas, a aplicaciones no comerciales tales como sa­ lones d e chat o juegos de red. La diferencia entre servicios y aplicaciones de red no es siempre nítida y estos tér­ minos frecuentemente se intercambian. 1 .2 . LA H IS TO R IA DE LA C O M P U TA C IÓ N D IS T R IB U ID A Al comienzo se utilizaban computadores aislados, cada uno de los cuales era capaz de ejecutar programas almacenados. La conexión de computadores aislados de forma que los datos se pudieran intercambiar fue una progresión natural. La conexión rudi­ mentaria de computadores a través de cables fue utilizada ya en los años 60 para la compartición de ficheros. No obstante, esta práctica requiere intervención manual y no puede denominarse aplicación de computación a uno o más programas que ejecu­ tan d e forma autónoma con el objetivo de realizar una determinada tarea. Tal aplica­ ción requiere comunicación de datos, donde dos computadores intercambien datos es­ pontáneamente y utilicen determinado software y hardware para la realización d e las tareas inherentes de dicha aplicación. El primer RFC (Request F or Comments) de Internet, RFC 1, es una propuesta que especifica cómo las máquinas participantes pueden intercambiar información con otras a través del uso de mensajes. Mientras pudiera haber intentos individuales de crear aplicaciones de red a pequeña escala (tal vez mediante la conexión de dos o más com­ putadores a través de cable), la primera aplicación de red fue el correo electrónico, también denominado em ail, y a que el primer mensaje fue enviado y registrado en 1972 en una red ARPAN ET de cuatro nodos. (Un nodo de una red es un computador o má­ quina que participa en la misma.) Los mecanismos de transferencia de ficheros auto­ matizados, que permiten e l intercambio de ficheros de datos entre las máquinas, su­ pusieron otra progresión natural y y a en 1971 hubo una propuesta para dicho tipo de mecanismo (véase los RFC 114 y RFC 141). Hasta el día de hoy, e l correo electró­ nico y la transferencia d e ficheros siguen siendo dos de los más populares servicios de red. Sin embargo, el más conocido servicio de red es indudablemente la WoHd K fidbK t*(W W W ) L a Web fue concebida originalmente a finales de los años 80 por científicos del centro de investigación suizo CERN en Ginebra como una aplicación que permite e l acceso a hipertexto sobre una red. Desde entonces, la W W W se ha convertido en una plataforma para aplicaciones y servicios de red, incluyendo el co­ rreo electrónico, motores de búsqueda y comercio electrónico (e-commerce) . www.FreeLibros.org Introducción a la com p u ta ció n distribuida 3 La W W W ha sido responsable d e la gran explosión que ha habido en el uso de Internet. Hasta 1990, ARPANET, el predecesor de Internet, fue utilizado principal­ mente por científicos, investigadores y académicos como una red de datos. Estimula­ do por la popularidad de la WWW, la red creció espectacularmente en los años 90, tal y como se muestra en las Figuras 1.1 y 1.2. Algunos sitios d e la Web con información d e la historia de la red y que son m uy visitados son [vlmp.museophile.com, 1), [zakon.org, 2) y [isoc.org, 38]. Además, [Hafner and Lyon, 4] es un fascinante inform e de los primeros pasos de Internet, incluyendo información sobre las personas y las organizaciones que estuvieron im­ plicados. 160,000,000 140.000.000 120.000.000 100,000,000 80,000,000 60,000,000 40.000,000 Hobbes* Internet Timeline Copyright ©2002 Robert H Zakon http://www. zakon.org/robert/internet/timeline/ 1 2 /6 9 4 0 5 /8 2 235 0 6 /7 0 9 0 8 /8 3 562 1 0 /7 0 11 1 0 /8 4 1 /0 2 4 1 2 /7 0 13 1 0 /8 5 1 /9 6 1 0 4 /7 1 23 0 2 /8 6 2 /3 0 8 1 0 /7 2 31 1 1 /8 6 5 /0 8 9 0 1 /7 3 35 1 2 /8 7 2 8 /1 7 4 0 6 /7 4 62 0 7 /8 8 3 3 /0 0 0 0 3 /7 7 111 1 0 /8 8 5 6 /0 0 0 1 2 /7 9 188 0 7 /8 9 1 3 0 /0 0 0 0 8 /8 1 213 1 0 /8 9 1 5 9 /0 0 0 New O íd S u c v e y Survey 2 0 .0 0 0,000 0 4iifnrftfi'ltnfi rfufriHdlitntnt ntmT iim i im u n m o • - - -O - IN CN ^ oí o o í a i o í oí ¿ ¿ c ¿ i n i i ii i ii 11 ti i ii n i i ii 11 ii rrrmTrrr i r r » ' r - f ^ 5 i n < o ¡ O N N N C o o : o i o i o i o i o i ° * o i o i o > o i o i o > o í o > * t ¿ é i | é-i 7 < (r, HTTTTT OI OI HUI IIIII o í o ¿ o. ¿>OI OI en u. Q 2 0 1 0 1 0 1 ^ * 0 0 0 0 O F ig u ra 1.1. El c re c im ie n to de lo s se rvid o re s de In te rn e t [zako n.org, 2] (reim preso c o n perm iso). 1,600,000 1.400.000 1.200.000 | 1,000,000 s 800.000 Q 600,000 400.000 2 00.000 Hobbes’ Internet Timeline Copyright ©2002 Robert H Zakon http.//www. zakon. org/robert/internet/timeline/ 0 i i rri n rniT i^im n rrf ri t rirn f i i^ r.f i n f i it i oí o> oí 1 1 1 roai oí 6. ¿ a» ai CO u- t í o OI o» OI Q B término hipertexto fue creado por el visionario Ted Nelson, para referirse a bs documentos textuales desde los que se puede acceder a documentos adicionales a través de rutas asociadas. El ejemplo más conocido de hipertexto es una página web que contiene enlaces. Un dominio Internet es parte del esquema de nombrado de recursos de Internet. F ig u ra 1 .2 . D o m inios d e In te rn e t [zako n.org, 2] (re im p re so c o n perm iso). www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones T e n d e n c ia s h is tó ric a s _________ p o r R ic h a rd G ab riel y J im W a ld o , S u n M ic ro s y s te m s , p b t e n id o d e h ttp ://w w w .s u n .c o m /jin i/o v e rv ie w / [7].) R eim preso c o n p e rm is o d e J im W a ld o . ¿ C óm o h e m o s lle g a d o ha sta e l p u n to en qu e lo s s e rv ic io s y d is p o s itiv o s c o n e c ta d o s son la s p rin cip a le s fu e rz a s q u e c o n d ic io n a n las nuevas fo rm a s d e c o m p u ta c ió n ? La ra z ó n m á s s ig n ific a tiv a e s n u e s tro m e jo r e n te n d im ie n to d e la fís ic a , la q u ím i­ ca , q u e son la s b a se s fís ic a s d e la c o m ­ p u ta c ió n , y e l p r o c e s o d e c re a c ió n d e c h ip s . H o y e n día , un c o m p u ta d o r s ig n ifi­ ca tiv a m e n te p o te n te s e puede c o n s tru ir a p a rtir d e u n o o d o s c h ip s p e q u e ñ o s y un sis te m a d e c o m p u ta c ió n c o m p le to e n una pequeña tarje ta . E x is te n tre s d im e n s io n e s q u e p u e d e n m ejorarse: el ta m a ñ o , e l c o s te y la p o te n ­ cia c o m p u ta c io n a l. D e sde tos a ñ o s 6 0 , el ta m a ñ o y el c o s te d e tos c o m p u ta d o re s se han d e c re m e n ta d o d ra m á tic a m e n te , m ie n ­ tra s q u e la p o te n cia c o m p u ta c io n a l ha id o su p e ra n d o d is tin to s to p e s. Una m á q u in a o m a in fra m e de lo s a ñ o s 60 e s ta b a fo rm a d a p o r un a c o le c c ió n de e n o rm e s c a ja s , s itu a d a s e n un a h a b ita c ió n gra nd e, c o s ta b a m illo n e s d e d ó la re s, lo qu e su p o n ía un fre n o para in c re m e n ta r la p o ­ te n cia c o m p u ta c io n a l. S ó lo una c o m p a ñ ía c o m p le ta podía a fro n ta r s u c o s te . La a p a ric ió n d e l m in ic o m p u ta d o r fu e p o s ib le c u a n d o la fu n c io n a lid a d d e l m a in ­ fr a m e p u d o a b o rd a rs e m e d ia n te e l u s o d e p e q u e ñ a s c a ja s . El m in ic o m p u ta d o r te n ía la p o te n c ia c o m p u ta c io n a l d e la g e n e ra ­ c ió n a n t e r io r d e m a in fr a m e s , p e r o un ú n ic o d e p a rta m e n to p o d ía c o m p ra rlo . La m a yo ría d e lo s m in ic o m p u ta d o re s se c o ­ n e c ta ro n a te rm in a le s in te ra c tiv o s , e s to c o n s titu y ó lo s c o m ie n z o s d e la c u ltu ra b a ­ sad a e n lo s c o m p u ta d o re s , un a c o m u n i­ d a d . C u a n d o un c o m p u ta d o r c o n la p o te n cia de un m in ic o m p u ta d o r se re d u jo a un a ú n i­ ca c a ja q u e podía situa rse e n la m e s a de un d e s p a c h o , se o b tu v o la e s ta c ió n d e tr a ­ b a jo . U n d e p a r ta m e n to p o d ía c o m p r a r a p ro x im a d a m e n te un a e s ta c ió n d e tra b a jo p o r c a d a d o s p ro fe sio n a le s. U na e s ta c ió n de tra b a jo te n ía s u fic ie n te p o te n cia c o m ­ p u ta cio n a l pa ra a b o rd a r ta re a s ta le s c o m o d ise ñ o s o fis tic a d o , a p lic a c io n e s d e in g e n ie ­ ría y c ie n tífic a s , y so p o rte g rá fic o para la s m ism as. C u a n d o e l c o m p u ta d o r p e rson al se h izo s u fic ie n te m e n te p e q u e ñ o para s itu a rs e en un e s c rito rio y s u fic ie n te p o te n te para s o ­ p o rta r in te rfa c e s g rá fic a s d e u su a rio in tu iti­ va s, lo s in d iv id u o s p o d ía n u tiliz a rlo s in g ra n d e s p ro b le m a s y la s c o m p a ñ ía s e m p e ­ zaron a c o m p ra rlo s pa ra c a d a u n o d e s u s e m p le ado s. E ve n tu a lm e n te lo s p ro c e s a d o re s se h i­ cieron s u fic ie n te m e n te p e q u e ñ o s y b a ra to s para c o lo c a rlo s en un c o c h e su stitu y e n d o ei s is te m a d e e n c e n d id o a n te rio r, o e n un te le v is o r en lu g a r d e lo s a n te rio re s d is p o s i­ tiv o s e le c tró n ic o s d is c re to s . H o y e n día , lo s c o c h e s pu ed en te n e r m á s d e 5 0 p ro c e s a ­ dores, y lo s h o g a re s a lre d e d o r d e 100. La p o te n cia c o m p u ta c io n a l tien e o tro pro­ blem a. La te n d e n c ia h a cia p ro c e s a d o re s m ás pe qu eñ os, m á s rá p id o s y m ás ba ratos im p lica q u e m en os g e n te tie n e q u e c o m ­ partir un a CPU , pe ro ta m b ié n im p lica q u e la ge nte d e una org an ización en c ie rto m od o se aísla. C u a n d o se c o m p a rte un a herra­ m ienta, se crea un a co m u n id a d ; d e b id o a qu e la s h e rra m ie n ta s s e re d u ce n , m e n o s p e rso n a s la u tiliza n c o n ju n ta m e n te y, p o r tan to , la c o m u n id a d s e dispersa. N o o b s ­ tante, un a c o m u n id a d n o sue le d a rs e p o r vencida. A fortu n a d a m e n te , la p o te n cia c o m ­ pu tacio na l e stá relacionada c o n la reducción d e tos procesadores, y y a q u e la c o m u n id a d utiliza un sistem a d e co m p u ta c ió n reducido, existe suficien te p o te n cia pa ra p e rm itir la c o ­ m u n ic a c ió n e n tre lo s s is te m a s . A sí, p o r ejem plo, las e sta cio n e s d e tra b a jo em piezan a d a r resu ltad os sa tisfa cto rio s un a v e z qu e se pu ed en c o m u n ic a r e in te rca m b ia r datos. El tra m o fin a l d e la d im e n s ió n d e la p o ­ te n cia c o m p u ta c io n a l lo c o n s titu y e el h e ch o de q u e a h o ra lo s p ro c e s a d o re s s o n s u fi­ c ie n te m e n te p o te n te s pa ra s o p o rta r un le n ­ gu aje d e p ro g ra m a ció n d e a lto nivel, o rie n ­ ta d o a o b je to s y q u e p e rm ite el m o v im ie n to de o b je to s e n tre d ife re n te s p ro cesa dore s. D ic h o s p ro c e s a d o re s s o n s u fic ie n te m e n te p e qu eñ os y b a ra to s c o m o para c o n s titu ir b s d is p o s itiv o s m á s se n c illo s . www.FreeLibros.org Introducción a la com p u ta ció n distribuida U n a v e z q u e h a y s u fic ie n te p o te n c ia co m p u ta c io n a l, la h a b ilid a d pa ra c o n e c ta r­ se y c o m u n ic a rs e se c o n v ie rte e n e l fa c to r d e te rm in a n te . A c tu a lm e n te pa ra la m ayo ría de la g e n te , un c o m p u ta d o r s ó b e je c u ta un as p o c a s a p lic a c io n e s y p rin c ip a lm e n te u tilid a d e s re la c b n a d a s c o n la c o m u n ic a - c b n : c o rre o e le c tró n b o , la W eb. R ecuerda c ó m o In te rn e t s e h iz o p o p u la r rá p id a m e n ­ te, p rim e ro c o n el c o rre o e le c tró n ic o , y, m á s recien te m ente , c o n e l u s o d e la W e b y lo s navegadores. 1 .3 . D IF E R E N TE S FO R M A S DE C O M P U TA C IÓ N Para comprender qué significa la computación distribuida en el contexto de este libro, resulta instructivo analizar diferentes formas de computación. C om putación m onolítica En la forma más sencilla de computación, un único computador, tal como un com­ putador personal (PC, Personal Computer) se utiliza para la computación. Dicho computador no está conectado a ninguna red y, por tanto, sólo puede utilizar aque­ llos recursos a los que tiene acceso de manera inmediata. Esta forma de com puta­ ción se denom ina com putación m onolítica En su form a más básica, un único usua­ rio utiliza el com putador a la vez. Las aplicaciones de usuario sólo pueden acceder a aquellos recursos disponibles en el sistema. Un ejem plo de este tipo de com puta­ ción, que puede denom inarse computación monolítica m onousuario, es el uso de aplicaciones tales com o un programa de procesam iento de texto u hojas de cálculo en un PC. La computación monolítica permite la convivencia de múltiples usuarios. Esta for­ ma de computación (véase la Figura 1.3a), donde varios usuarios pueden compartir de forma concurrente los recursos de un único computador a través de una técnica denom inada tiem po compartido, fue popular en los años 70 y 80. El computador que proporciona el recurso centralizado se denom ina mainframe para diferenciarlo de pequeños com putadores tales como m inicomputadores o microcomputadores. Los usuarios, que podrían estar dispersos geográficamente, se pueden conectar a l m ain­ fram e e interaccionar con e l mismo durante una sesión a través de dispositivos de­ nominados terminales. Algunos mainframes am pliamente utilizados incluyen las se­ ries IBM 360 y las series Univac 1100. Las aplicaciones que utilizan esta forma de computación son típicam ente programas separados y diseñados para llevar a cabo una sola función, tal como programas de nóminas o contabilidad para una em presa o una universidad. C om putación distribuida En contraste, la computación distribuida implica el uso de múltiples computadores conectados a la red, cada uno de los cuales tiene su propio procesador o procesado­ res y otros recursos (véase la Figura 1.3b). Un usuario que utilice una estación de tra­ bajo puede usar los recursos del computador local al que la estación de trabajo está conectada. Adicionalmente, a través de la interacción entre e l computador local y los computadores remotos, el usuario también puede acceder a los recursos de estos últi­ mos. La Web es un excelente ejem plo de este tipo de computación. El uso de un na­ www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones vegador para visitar un sitio web, tal como Netscape o Internet Explorer, implica la ejecución de un programa en un sistem a local que interactúa con otro programa (co­ nocido como servidor web) que se ejecuta en un sistema remoto, a fin d e traer un fi­ chero desde dicho sistem a remoto. F ig u ra 1.3. C o m p u ta c ió n c e n tra liz a d a (a) fre n te a c o m p u ta c ió n d is trib u id a (b). C om putación paralela Sim ilar a la com putación distribuida, aunque diferente, es la denom inada compu­ tación paralela o procesam iento paralelo; q ue utiliza más de un procesador si­ m ultáneam ente para ejecutar un único programa. «Idealm ente, el procesam iento pa­ ralelo perm ite que un program a ejecute m ás rápido porque hay más m otores (más CPU) ejecutándolo. En la práctica, suele ser difícil dividir un program a d e forma que CPU separadas ejecuten diferentes porciones del program a sin ninguna inte­ racción» [Koniges, 9]. La com putación paralela se suele realizar sobre un único computador que tiene m últiples CPU, aunque, de acuerdo a Koniges, es tam bién posible «llevar a cabo procesam iento paralelo m ediante la conexión d e varios com ­ putadores en una red. Sin em bargo, este tipo de procesam iento paralelo requiere softw are m uy sofisticado denom inado softw are d e procesam iento distribuido» [Ko­ niges, 9]. Mediante la computación paralela se pueden resolver problemas que de otra ma­ nera sería imposible resolver con un único computador. También permite la resolu­ ción de problemas d e computación intensiva que d e otra forma serían insostenibles económicamente. Hoy en día, la computación paralela se utiliza principalmente en computación científica a gran escala, en áreas tales como la biología, la aeronáutica, la predicción atmosférica y el diseño de semiconductores. Aunque se trata de una ma­ teria fascinante, la computación paralela se encuentra fuera de los objetivos de este libro. www.FreeLibros.org Introducción a la com p u ta ció n distribuida 7 P o r d ó n d e v ia ja ___________________________ p o r J o s e p h M e n n . P e L o s A n g e le s T im e s, L o s A ng eles, C alif., D e c. 2 ,1 9 9 9 , J o s e p h M en n C o p yrig h t © 1999, L o s A n g e le s T im es.) R eim preso c o n pe rm iso. Los u su a rio s d e e B a y ra ra m e n te piensan sob re e l p ro ­ c e s o q u e im p lic a la realización d e o fe rta s, ha sta q u e el siste m a fa lla . Inte rn a m e n te , e l s is te m a d e su b a sta t ie ­ ne un n ú m e ro d e s a lv a g u a rd a s q u e se basan p rin c i­ palm e nte e n la d u p lic a c ió n o m irroring d e la te c n o lo ­ gía, p a ra e l c a s o e n el q u e un a p ie z a h a rd w a re o so ftw a re falle. La in fo rm a c ió n d e b e p a s a r a tra v é s de m uch as c o m p a ñ ía s y tip o s d e e q u ip a m ie n to d ife re n te s para q u e to d o fu n c io n e co rre c ta m e n te . 1. La p e rso n a q u e ha ce la o fe rta s e re g istra y e n ­ vía un a o fe rta e le c tró n ic a d e sd e s u PC. 2. La o fe rta v ia ja d e s d e e l p ro v e e d o r d e s e rvicio s de In te rn e t d e l c o n s u m id o r, a tra v é s d e lo s c o n ­ m u ta d o re s (s w ltc h e s) y e n c a m in a d o re s (rou- ters), a l ISP d e tos se rv id o re s d e la co m p a ñ ía . 3. S e en vía la o fe rta a tra v é s d e l b a c k b o n e d e In­ ternet. 4. La o fe rta v ia ja d e sd e un o d e lo s ISP d e eBay, m u y p ro b a b le m e n te S p rin t o UUNET, y a tr a ­ vés d e tu b e ría s a eBay. 5. La o fe rta pa sa a tra v é s d e lo s c o n m u ta d o re s y e n ca m in a d o re s C is c o d e eBay. 6. La in fo rm a c ió n llega a u n o d e lo s a p ro x im a d a ­ m ente 20 0 s e rv id o re s fr o n t-e n d C o m p a q , qu e q e c u ta n W in d o w s NT. L o s se rv id o re s s o n d u ­ plica d o s, d e fo rm a qu e s i un o falla, e l o tro re a ­ lz a la tarea . 7. La o fe rta pa sa p o r u n o d e lo s se rv id o re s S ta r- fire d e S u n M torosyste m , lla m a d o s B ull y Bear, e sta n d o d u p lic a d o s e n tre sí. 8. La o fe rta s e a ñ a d e a la s d o s b a s e s d e d a to s de a lm a c e n a m ie n to d e in fo rm a c ió n , qu e e je c u ­ tan O ra cle , d o n d e se c o m p ru e b a la in fo rm a ció n de l ven dedor. 9. El flu jo d e in fo rm a c ió n s e en vía d e vu e lta , m a n ­ d a n d o c o rre o s e le c tró n ic o s al v e n d e d o r y a lo s p o sib le s c o m p ra d o re s d e l p ro d u c to d e la o fe r­ ta. Tam bién se en vía un a c o n firm a c ió n a la p e r­ sona q u e e n v ió la o fe rta . 10. D e sde B ull, se en vía la c a n tid a d d e la o fe rta y otra in fo rm a c ió n a o tro s e rv id o r S ta rfire , d e n o ­ m in a d o A n a co n d a , y s e g u a rd a e n d is c o s d e a lm a ce n a m ie n to d u p lic a d o s . Fuente: T im e s sta ff, EBay. Ebay tiene planificado añadir otro servidor Starfire para los discos de datos finales, sirviendo de mirror de Anaconda. UUNet Anaconda Discos mirrored con logs de datos Discos compartidos de Oracle (discos mirrored con la base de datos dual) Nuevo servidor Starfire planificado Vendedor envía información□ Comprador realiza ofert Conmutadores/ encaminadores mirrored Cisco Muchos servidores front-end mirrored ü M ------ ► B m Bull Market Bear www.FreeLibros.org 8 C om putación distribuida. Fundam entos y aplicaciones Un propietario de un computador interesado descargará de SETKíhome una pieza de software libre (por ejemplo, un salvapantallas). A continuación, cuando su computador esté ocioso, el software descarga un fichero de datos de un sitio de Internet para analizarlo en dicho computador. Los resultados del análisis se vuelven a enviar al sitio de Internet, ctonde se combinan con el resto de participantes de SETI@home, en el intento de buscar señales de vida extraterrestre. C om putación cooperativa Recientemente, e l térm ino computación distribuida se ha aplicado tam bién a pro­ yectos de computación cooperativa tales como el de la búsqueda de inteligencia ex ­ traterrestre (SETI, Search f o r Extraterrestrial Intelligence) [setiathom e.ssl.berke- ley.edu, 10] y d istributed.net [distributed.net, 33]. E stos proyectos dividen la computación a gran escala entre las estaciones de trabajo d e las m áquinas de Inter­ net, utilizando ciclos de CPU excedentes, como se describe en el m argen (Nota: La discusión más avanzada sobre este tipo de computación queda fuera del alcance de este libro.) 1 .4 . V IR T U D E S Y L IM IT A C IO N E S D E LA C O M PU TA C IÓ N D IS TR IB U ID A Antes d e la aparición de la Web, la com putación m onolítica, tal com o la ejecu ­ ción d e aplicaciones d e em presa en m ainfram es o la ejecución de un procesador de texto o una hoja d e cálculo en un com putador personal por parte de un ú n i­ co usuario, era la form a de com putación dom inante. S e dice que Thom as Wat- son, e l fundador de IBM , dijo esta frase en 1943: «creo que hay un m ercado m un­ d ial para ta l v ez cinco com putadores». S in em bargo, desd e lo s años 80, la com putación distribuida se ha vuelto tan im portante, si no más, com o la com pu­ tación m onolítica. E xisten d iferen tes razones para la popularidad de la com putación d is tri­ buida: • L os con fu tad ores y el acceso a la red son económicos. Los computadores personales actuales tienen una potencia superior a los primeros mainframes, ade­ más de tener mucho menor tamaño y precio. Unido al hecho de que la cone­ xión a Internet está disponible universalmente y es económica, el gran número d e computadores que existen interconectados se convierte en una comunidad ideal para la computación distribuida. • Com partídón de recw sos. La arquitectura de la computación distribuida re­ fleja la arquitectura de computación d e las organizaciones modernas. Cada or­ ganización mantiene de forma independiente los computadores y recursos loca­ les, m ientras perm ite com partir recursos a través d e la red. M ediante la computación distribuida, las organizaciones pueden utilizar sus recursos de for­ ma efectiva. La Web, por ejemplo, consiste en una plataforma m uy potente para la compartición de documentos y otros recursos dentro y entre las organiza­ ciones. • Escalabflidad. En la computación monolítica, los recursos disponibles están li­ mitados por la capacidad de un computador. Por el contrario, la computación distribuida proporciona escalabilidad, debido a que permite incrementar el nú­ mero d e recursos compartidos según la demanda. Por ejemplo, se pueden aña­ dir más computadores que proporcionen servicio de correo electrónico si se pro­ duce un incremento en la demanda d e este servicio. www.FreeLibros.org Introducción a la com p u ta ció n distribuida • Tolerancia a fados. Al contrario que la computación monolítica, la computa­ ción distribuida permite que un recurso pueda ser replicado (o reflejado) con el fin de dotar al sistem a de tolerancia a fallos, de tal forma que proporcione dis­ ponibilidad de dicho recurso en presencia de fallos. Por ejemplo, las copias o backups de una base de datos se pueden mantener en diferentes sistemas d e la red, de modo que si un sistema falla, se puede acceder al resto de las copias sin interrumpir el servicio. Aunque no es posible construir un sistema distribui­ do completamente fiable en presencia de fallos [Fischer, Lynch, and Paterson, 30], el desarrollador que diseña e imple menta un sistem a es el responsable de maximizar la tolerancia a fallos del mismo. La tolerancia a fallos en la compu­ tación distribuida es un tem a complejo que ha recibido mucha atención en la comunidad investigadora. Los lectores interesados en este tem a pueden leer el trabajo de Pankaj Jalóte [Jalóte, 31]. En cualquier forma de computación, existe siempre un compromiso entre sus venta­ ja s y sus desventajas. Además de las ventajas descritas, la computación distribuida también tiene algunas desventajas. Las más significativas son: • M últiples puntos d e fa llo . H ay más puntos d e fallo en la com putación d is ­ tribuida. D ebido a que m últiples com putadores están im plicados en la com ­ putación distribuida, y todos son dependientes d e la red para su com unica­ ción, e l fallo de uno o m ás com putadores, o uno o m ás enlaces d e red, puede suponer problem as para un sistem a de com putación distribuida. E x is­ te una cita popular, atribuida a l notable científico L eslie Lam port, que dice que «un sistem a distribuido es aquél en e l que e l fallo de un com puta­ dor que ni siquiera sabes que existe, puede dejar tu propio com putador inu- tilizable». • A spectos de seguridad. En un sistem a distribuido hay m ás oportunidades de ataques no autorizados. M ientras que en un sistem a centralizado todos los com ­ putadores y recursos están normalmente bajo e l control de una administración única, en un sistem a distribuido la gestión es descentralizada y frecuentemen­ te implica a un gran número de organizaciones independientes. L a descentra­ lización hace difícil implementar y ejecutar políticas de seguridad; por tanto, la computación distribuida es vulnerable a fallos de seguridad y accesos no autorizados, que desafortunadam ente puede afectar a todos los participantes en el sistema. Este problema está claramente ilustrado por ataques bien conoci­ dos en Internet, tales como los gusanos y los virus [Eichen and Rochlis, 21; Zetter, 22]. Debido a su importancia, la seguridad en la computación es un tem a am ­ pliamente investigado y estudiado, y se han desarrollado varias técnicas para la escritura y realización de aplicaciones seguras. Tales técnicas incluyen cifrado, claves, certificados, firmas digitales, entornos seguros, autenticación y autoriza­ ción. La seguridad es un am plio tema que queda fuera del alcance de este li­ bro. S e recomienda a los lectores proseguir el estudio de este tem a en referen­ cias tales como [Oaks, 32]. Ahora que se han clarificado los objetivos de este libro, se van a analizar algunos conceptos básicos en tres disciplinas de informática relacionadas: los sistem as opera­ tivos, las redes y la ingeniería del software. Aunque para este libro no se requiere un conocimiento m uy profundo de estas disciplinas, el libro sí se refiere a algunos con­ ceptos y términos asociados con las mismas. El resto d e este capítulo introducirá d i­ chos conceptos y términos. www.FreeLibros.org Los a ta q u e s w e b p o d rían te n e r m u c h o s o ríg e n e s C om putación distribuida. Fundam entos y aplicaciones p o r M a tt R ic h te l y Sara fío b in s o n (NYT), 11 d e fe b rero d e 2 0 0 0 . R e im p re so c o n p e r m is o d e l N e w York T im es. S an F ra n c is c o , 10 F eb. L o s e x p e rto s d e s e g u rid a d e n in fo rm á tic a d ije ro n h o y q u e las p ru e b a s s u g ie re n q u e lo s a ta q u e s d u ­ ra n te tre s d ía s a im p o rta n te s s itio s w e b p o d ría n s e r o b ra d e m á s d e un a p e rs o n a o g ru p o . El a n á lis is d e q u e m á s d e un g r u p o e s ­ tu v ie ra d e trá s c u e s tio n a la s c o n c lu s io n e s d e a lg u n o s e x p e r to s d e s e g u rid a d q u e fu e ro n in ic ia lm e n te e s c é p tic o s d e q u e s i ­ g u ie n d o e l a ta q u e d e l lu n e s a Y a h o o , m ú ltip le s v á n d a lo s s e h u b ie r a n u n id o p a ra re a liz a r a s a lto s « c o p y c a t» a o tr o s s itio s . M ie n tra s la c o m u n id a d d e In te rn e t b u s ­ c a d e fo rm a v e h e m e n te a lo s re s p o n s a ­ b le s , lo s e x p e r to s in fo rm á tic o s a firm a n q u e s e rá d ifí c il d e te r m in a r in c lu s o q u é c o m p u ta d o re s in ic ia ro n lo s a ta q u e s . CERT, un a o rg a n iz a c ió n d e s e g u rid a d d e c o m p u ta d o re s , fin a n c ia d a fe d e ra lm e n ­ te , y a n te r io r m e n te c o n o c id a c o m o la C o m p u te r E m e r g e n c y R e s p o n s e T ea m , ha a firm a d o q u e n u n ca ha bía v is to e s te n ú ­ m e ro in u s u a l d e in fo r m e s d e a ta q u e s . D e sde e l lu n e s h a sta e l m ié rc o le s , lo s s e r ­ v ic io s d e v a rio s s itio s w e b p u n te ro s , in ­ c lu y e n d o lo s d e l p o rta l Y ahoo, la c o m p a ­ ñía d e la B o ls a E*Trade G roup , la e m p re s a d e s u b a s ta s e B a y y e l s it io d e n o tic ia s CNN d e T im e W arner, fu e ro n in te r ru m p i­ d o s y e n a lg u n o s c a s o s p a ra d o s p o r a s a l­ t o s p ro v o c a d o s p o r d o c e n a s d e c o m p u ­ ta d o re s in u n d a n d o a lo s s e rv id o re s c o n m ú ltip le s d a to s . P e ro lo s e x p e r to s e n s e g u r id a d ha n a firm a d o q u e lo s s itio s w e b e In te rn e t en g e n e ra l q u e d a rá v u ln e ra b le e n un fu tu ro c e rc a n o , d e b id o a q u e m u c h a s o rg a n iz a ­ c io n e s n o e s tá n to m a n d o m e d id a s o p o r ­ tu n a s p a ra e v ita r q u e v á n d a lo s p u e d a n in ic ia r a ta q u e s e n s u s c o m p u ta d o re s . Un o fic ia l d e l g o b ie rn o ha d ic h o h o y q u e e s n e c e s a rio e n d u re c e r la s le y e s a fin d e c o m b a tir ta le s a ta q u e s . « N o s o tro s n o c o n ­ sid e ra m o s e s to un a travesu ra» d ijo e l s u b - fis c a l g e n e ra l E ric H older. « E s to s h e c h o s s o n m u y serios». A d e m á s h o y se ha re v e la d o q u e m á s s i­ tio s w e b im p o rta n te s , q u e ha b ía n s id o a d ­ v e rtid o s , fu e ro n a s a lta d o s e l m ié rc o le s , ú l­ tim o d ía d e lo s a s a lto s . E s to s in c lu y e n a E xcite@ H om e , un p ro v e e d o r d e a c c e s o a In te rn e t a a lta v e lo c id a d s o b re c a b le m ó ­ de m , q u e fu e a ta c a d o e n la ta rd e d e l m ié r­ c o le s a p e s a r d e h a b e r to m a d o p re c a u ­ c io n e s pa ra d e fe n d e r su red. A l m e n o s o tra s d o s c o m p a ñ ía s im p o r ­ ta n te s d e c o m e rc io e le c tró n ic o fu e ro n a ta ­ c a d a s e l m ié rc o le s , d e a c u e rd o a IFsec, una c o m p a ñ ía d e s e g u rid a d in fo rm á tic a d e N u eva Y ork, q u e re c h a z ó d a r e l n o m b re d e la s c o m p a ñ ía s , a firm a n d o q u e un a d e e lla s fu e un c lie n te . « N o s o tro s e s ta m o s v ie n d o m á s d e lo s q u e a p a re c e n e n lo s m e d io s d e c o m u n i­ cación », a firm ó D a vid M . R e m n itz, el je fe e je c u tiv o d e IFsec. A d ic io n a lm e n te , u s u a rio s d e l I.R .C . (In­ te r n e t R e la y C h a t) d ije ro n q u e e n la s d o s ú ltim a s s e m a n a s e l fo ro ha bía s u frid o a ta ­ q u e s s im ila re s a lo s d e la s c o m p a ñ ía s d e c o m e rc io e le c tró n ic o . M ie n tra s ta n to , lo s p ro v e e d o re s d e s e r­ v ic io d e re d e s e in v e s tig a d o re s c o n tin ú a n a n a liz a n d o la s p ru e b a s , in c lu y e n d o lo s p a q u e te s d e d a to s u tiliz a d o s p a ra s o b r e ­ c a rg a r y p a ra liz a r a lo s s itio s w e b v íc ti­ m as. E x p e rto s d e s e g u rid a d in fo rm á tic a d e la U n iv e rs id a d S ta n fo rd e n P a lo A lto , C a ­ lifo rn ia , d ije ro n q u e la s p rim e ra s p ru e b a s s u g ie re n q u e lo s a ta q u e s p o d ría n h a b e r s id o o b ra d e m á s d e un a p e rs o n a o g r u ­ p o . D a v id J. B ru m le y, a s is te n te o fic ia l d e s e g u rid a d in fo rm á tic a e n S ta n fo rd , a firm ó q u e e l t ip o d e d a to s in c lu id o e n lo s p a ­ q u e te s u tiliz a d o s p a ra a ta c a r a Y a h o o el lu n e s e ra n d ife re n te s d e lo s d a to s d e l a s a l­ t o el m a rte s a eBay. «Los a ta q u e s fu e ro n c o m p le ta m e n te d i­ fe re n te s e s o s d o s día s» d ijo Mr. B rum ley. «Las p e rs o n a s q u e a ta c a ro n Y a h o o e ra n d ife re n te s d e la s q u e a ta c a r o n e B a y y C N N .» www.FreeLibros.org Introducción a la com p u ta ció n distribuida Lo s p ro v e e d o re s d e s e rv ic io d e re d e s d ije ro n q u e lo s a s a lto s re c ie n te s in c lu ía n d o s tip o s d e a ta q u e s , s u g irie n d o q u e m á s de un g ru p o p o d ría e s ta r im p lic a d o . A m ­ b o s tip o s d e a ta q u e s c o rre s p o n d e n a lo qu e s e d e n o m in a d e n e g a c ió n d e se rvicio , ya q u e e s to s a ta q u e s e v ita n q u e lo s s itio s p u e d a n s e rv ir a lo s c lie n te s . En el p rim e r tip o , c o n o c id o c o m o S Y N flo o d, lo s a ta c a n te s a c c e d ie ro n e in s ta la ­ ron s o ftw a re e n un g ra n n ú m e ro d e c o m ­ p u ta d o re s. A c o n tin u a c ió n , u tiliz a ro n e s ta s m á q u in a s pa ra b o m b a rd e a r al s itio v íc tim a c o n p e tic io n e s p a ra c o m e n z a r un a s e s ió n de c o m e rc io e le c tró n ic o . El g ra n n ú m e ro de p e tic io n e s s o b re c a rg ó a lo s se rvid o re s, q u e n o p e rm itie ro n q u e lo s c lie n te s p u ­ d ie ra n a c c e d e r a l s itio . Para e v ita r q u e se p u d ie ra re a liz a r una traza d e e s ta s p e tic io n e s , lo s v á n d a lo s e m ­ plearon un a té c n ic a d e n o m in a d a s p o o fin g, q u e c o n s is te e n a lte r a r la d ir e c c ió n d e o rig e n . El s e g u n d o t ip o d e a ta q u e , c o n o c id o c o m o s m u r f a tta c k , d e n u e v o im p lic a el u s o d e o tra s m á q u in a s, p e ro a d e m á s e m ­ plea un a g ra n re d d e c o m p u ta d o re s e x ­ te rn a p a ra « a m p lific a r» e l n ú m e ro d e d a ­ to s u t iliz a d o s e n e l a ta q u e y, d e e s ta fo rm a , in c re m e n ta r la e fe c tiv id a d d e l a s a l­ to. S e c re e q u e la re d d e c o m p u ta d o re s d e S ta n fo rd s e p o d ría h a b e r u tiliz a d o d e e sta fo rm a e n e l a ta q u e a Y ahoo. L o s e x p e rto s d e s e g u rid a d a firm a n q u e es s e n c illo c o n fig u ra r la s re d e s d e fo rm a qu e n o se p u e d a n u tiliz a r e n un s m u r f at­ ta ck, a u n q u e m u c h o s a d m in is tra d o re s no c o n o c e n c ó m o lle v a r a c a b o e s ta c o n fig u ­ ración. L o s e x p e rto s d e s e g u rid a d in fo rm á tic a h iciero n h in c a p ié e n q u e e l g ra n n ú m e ro de c o m p u ta d o re s u tiliz a d o s p a ra in ic ia r lo s a ta q u e s e s ta se m a n a ha ce m u y d ifíc il re ­ a liz a r un a tra za d e lo s m ism o s. «En e s te p u n to , e x is te ta n to trá fic o q u e e s m u y d ifíc il re a liz a r un a traza», a firm ó J o e l d e la G arza d e K ro ll-O ’ G ara In fo rm a ­ tio n S e c u rity G roup, un a c o m p a ñ ía pa ra m in im iz a r lo s rie sgo s. A d e m á s, e x p e rto s d e s e g u rid a d in fo r­ m á tic a ha n c o m e n ta d o q u e la s c o m p a ñ í­ a s c u y o s c o m p u ta d o re s ha n s id o a s a lta ­ d o s y u tiliz a d o s c o m o p la ta fo rm a s p a ra un a s a lto , n o rm a lm e n te n o tie n e n n in g u n a idea d e l p ro b le m a , in c lu s o c u a n d o el a s a l­ t o c o n tin ú a . L o s v á n d a lo s p u e d e n a c tiv a r el a s a lto d e s d e un a u b ic a c ió n re m o ta , y a una c o m p a ñ ía o a un in d iv id u o c u y o c o m ­ p u ta d o r se e s tá u tiliz a n d o ; e l ú n ic o im ­ p a c to q u e p u e d e p ro v o c a r e s un d e c re ­ m e n to d e la v e lo c id a d e n la a c tiv id a d d e la red. Las c o m p a ñ ía s v íc tim a s y lo s e x p e rto s d e s e g u rid a d a firm a ro n h o y q u e e n a lg u ­ n o s c a s o s lo s a ta q u e s p a re c e n m á s c o m ­ p lic a d o s d e lo q u e o rig in a lm e n te se p e n ­ só, re fo rz a n d o la d ific u lta d d e p re v e n irlo s . E x c ite O H o m e , p o r e je m p lo , ha a firm a ­ d o q u e in te n tó to m a r m e d id a s d e p re c a u ­ c ió n a la lu z d e lo s a ta q u e s a n te rio re s , p e ro q u e fu e in c a p a z d e p re v e n ir e l a ta ­ q u e a s u s itio w e b d u ra n te al m e n o s m e ­ d ia hora. «Según n u e s tro c o n o c im ie n to , un s itio no p u e d e to m a r m e d id a s p re v e n tiv a s c o n ­ tra lo s a ta q u e s s in la a y u d a d e otros», a f ir ­ m ó K e lly D is te fa n o , un a p o rta v o z d e E x c i- te@ H om e. D ijo q u e la c o m p a ñ ía h u b ie ra n e c e s ita d o m á s c o o p e ra c ió n d e la s c o m ­ pa ñías q u e p ro p o rc io n a n s e rv ic io s d e red a E xcite. P e te r N e u m a n n , p rin c ip a l c ie n tífic o d e SRI In te rn a tio n a l e n M e n lo Park, C a lifo r­ nia, re ite ró q u e e l é x ito d e lo s a ta q u e s ha m o s tra d o q u e lo s s itio s d e In te rn e t n o e s ­ tá n to m a n d o la p re c a u c io n e s a d e c u a d a s pa ra e v ita r s e r a s a lta d o s m e d ia n te a ta q u e s d e e s te tip o . «Es h o ra d e q u e la g e n te d e s p ie rte » , d ijo Mr. N e u m a n n . «La g e n te e s tá a c e le ­ rá n d o se en u tiliz a r e l c o m e rc io e le c tró n ic o en la R ed sin c o n o c e r lo s rie sgo s, y hay g ra n d e s rie sgo s, c o m o h e m o s p o d id o v e r aquí.» www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones 1 .5 . C O N C E P T O S B Á SIC O S DE S IS T E M A S OPERATIVO S La computación distribuida supone la ejecución de programas en múltiples computa­ dores. A continuación se describen algunos de los conceptos implicados en la ejecu­ ción de programas en computadores actuales. Program as y procesos de com putación Un programa software es un artefacto construido por un desarrollador software utili­ zando alguna forma de lenguaje de programación. Típicamente, e l lenguaje es de alto nivel y requiere un compilador o intérprete para traducirlo a lenguaje máquina. Cuan­ do un programa se ejecuta en un computador se representa como un procesa En los computadores modernos, un proceso consiste en un programa que se ejecuta, sus va­ lores actuales, la información de estado y los recursos utilizados por e l sistema ope­ rativo para gestionar la ejecución del programa. En otras palabras, un proceso es una entidad dinám ica que sólo existe cuando un programa se ejecuta. La Figura 1.4 muestra las transiciones de estados durante la vida d e un proceso. Un proceso entra en e l estado listo cuando un programa inicia su ejecución, y el sis­ tem a operativo lo sitúa en una cola, ju n to a otros programas que van a ejecutarse. Cuando los recursos del sistem a (tales como la CPU) se encuentran disponibles, un proceso es lanzado para ejecutarse, de tal forma que entra en el estado de ejecución. Continúa ejecutándose hasta que debe esperar por la ocurrencia de un evento (tal como la finalización d e alguna operación de E/S), momento en e l que e l proceso en­ tra en el estado bloqueado. Una vez que e l evento ocurra, el sistem a operativo co­ loca a l proceso en la cola d e ejecución, esperando a su tum o para ejecutar de nue­ vo. El proceso repite e l ciclo listo-ejecución-bloqueado tantas veces com o sea necesario hasta que la ejecución del proceso se complete, momento en el cual el pro­ ceso queda terminado. En este libro se utilizarán program as Java, o fragm entos de ellos, como ejem ­ plos de código. H ay tres tipos de program as Java: aplicaciones (Figura 1.5), ap- plets (Figura 1.6) y servlets (Figura 1.7). Independientem ente del tipo de progra­ ma, cada programa se escribe com o una d a se Java Una aplicación Java tiene un método principal (main) y se ejecuta com o un proceso independiente (stand-aloné). F ig u ra 1 .4 . Un d ia g ra m a s im p lific a d o d e tra n s ic ió n d e e s ta d o s d e un pro ceso . www.FreeLibros.org Introducción a la com p u ta ció n distribuida Por otro lado, un applet no tiene un m étodo main y se ejecuta mediante el uso de un navegador o de la herramienta que perm ite ver applets, appletviewer. Un servlet es parecido al applet en e l hecho d e que no tiene un método main. S e ejecuta en el contexto de un servidor web. En este libro se m ostrarán ejem plos d e los tres tipos de programas y fragm entos de programas, siendo las aplicaciones las m ás frecuen­ tem ente utilizados. Un program a Java se com pila y se convierte a un código denom inado byieco- «fe un código objeto universal. Cuando se ejecuta, la M áquina V irtual Java (JVM, Java Virtual M achiné) traduce e l bytecode a código m áquina nativo del com puta­ dor, siguiendo las transiciones de estados que se han estudiado anteriorm ente. La ejecución d e una aplicación stand-alo ne Java en una m áquina local. C om putador /******************************************************* * Un ejemplo de una aplicación Java sencilla. * M. Li u 1/8/02 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / import java.io.*; class MiPrograma{ public static void main(String[ ] args) throws IOException{ BufferedReader teclado = new BufferedReader(new InputStreamReader(System.in)); String nombre; System.out.println(\"¿Cuál es tu nombre?\"); nonbre = teclado. readLine( ); System. ou t . p r int (\" Hola \" + nombre); System.out.prinln(\" - bienvenido a CSC369.\\n\"); } // fin main > // fin clase F ig u ra 1 .5 . Una a p lic a c ió n sta n d -a lo n e Java (arriba) y el c ó d ig o c o rre s p o n d ie n te (abajo). www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Un a p p let e s un o b je to d esca rg a d o (tansferido) d e sd e una m áquina rem ota y ejecutado en una m áquina local y * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * Un e je m p lo d e u n a p p l e t s e n c i l l o . * M. L i u 1 / 8 / 0 2 ***************************************************/ i m p o r t j a v a . a p p l e t . A p p l e t ; i m p o r t j a v a . a w t . * ; p u b l i c c l a s s M iA p p le t e x t e n d s A p p l e t { p u b l i c v o i d p a i n t ( G r a p h i c s g ) { s e t B a c k g r c u n d ( C o l o r . b l u e ) ; Font Claude = new Font(\"Arial\", Font.BOLD, 40); g.setFont(Claude); g.setColor(Color.yellow); g.drawString(\"Hola Mundo\", 100, 100); } / / f i n p a i n t } / / f i n c l a s e < 1 - Una p á g i n a w eb q u e c u a n d o s e a b r e , e j e c u t a > < ! - e l a p p l e t M iA p p le t> < ! - M. L i u l / 8 / 0 2 > < t i t l e > U n a p p l e t s e n c i l l o < / t i t l e > < h r> < a p p l e t c o d e = \" M i A p p l e t .c l a s s \" w id th = 5 0 0 h e ig h t= 5 0 0 > < / a p p l e t > < h r> < a h r e f = \" H o la M u n d o .ja v a \" > E l f i c h e r o f u e n t e . < / a > F ig u ra 1.6. U n a p p le t (arriba) y la p á gina w e b (abajo) q u e p e rm ite a c tiv a r e l ap p let. www.FreeLibros.org Introducción a la com p u ta ció n distribuida Un servlet es un o b je to qu e ejecu ta en una m áquina rem ota e interactúa con un proceso local m ediante un pro to colo d e petición-respuesta. Un servlet n Petición O ^ j — Respuesta ------------- - w / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * Un e je m p lo d e un s e r v l e t s e n c i l l o . * M. L i u 1 / 8 / 0 2 ********************************************************/ i m p o r t j a v a . i o . * ; i m p o r t j a v a . t e x t . * ; i n p o r t j a v a . u t i l . * ; i m p o r t j a v a x . s e r v l e e e e s e r v l e v l e t . * ; i m p o r t j a v a x . s e r v l e t . h t t p . * ; p u b l i c c l a s s M i S e r v l e t e x t e n d s H t t p S e r v l e t { p u b l i c v o i d d o G e t ( H t t p S e r v l e t R e q u e s t r e q u e s t , H t t p S e r v l e t R e s p o n s e r e s p o n s e ) th r o w s S e r v l e t E x c e p t i o n , I O E x c e p ti o n { P r i n t W r i t e r s a l i d a ; S t r i n g t i t u l o = \" S a l i d a d e M i S e r v l e t \" ? / / p r i m e r o e s t a b l e c e r e l t i p o d e c o n t e n i d o y o t r o s //c a m p o s d e l a c a b e c e r a r e s p o n s e . s e t C o n t e n t T y p e ( \" t e x t / h t m l \" ) ; / / a c o n t i n u a c i ó n e s c r i b i r l o s d a t o s d e r e s p u e s t a s a l i d a = r e s p o n s e . g e t W r i t e r ( ) ; s a l i d a . p r i n t l n (\" <3fTML><HEAD><TITLE>\" ) ; s a l i d a . p r i n t l n ( t i t u l o ) ; s a l i d a . p r i n t l n (\" < /T IT L E x /H E A IX B O D Y > \" ) ; s a l i d a . p r i n t l n ( \" < H l > \" + t i t u l o + \" < / H l > \" ) ; s a l i d a . p r i n t l n ( \" < P > H ola M undo\" ) ? s a l i d a . p r i n t l n ( \" </B O D Y x/H T M L >\") ; s a l i d a . c i ó s e ( ) ; } / / f i n d o G e t > / / f i n c l a s e F ig u ra 1.7. Un se r v le t (arriba) y la p á gina w e b (abajo) q u e p e rm ite a c tiv a r e l servlet. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Debido a que e l bytecode es un código intermedio independiente d el tipo de má­ quina y que se traduce al código d e m áquina específico en tiem po d e ejecución, se dice que los program as Java son indepcndiaites d e la plataform a indicando que el mismo program a se puede ejecutar en cualquier tipo de m áquina que tenga una JVM. Este libro asume que el lector tiene un conocimiento básico del lenguaje de pro­ gramación Java, hasta e l punto de que es capaz de compilar y ejecutar una aplicación ¿ ú u x fa fa n e o un applet. Un programa stand-alone es aquél que se ejecuta por sí solo, sin intercambiar mensajes con otros programas. Program ación concurrente La computación distribuida supone el uso de la programación concurrente, que con­ siste en la ejecución simultánea de procesos. Los siguientes párrafos muestran tres cla­ ses d e programación concurrente. • Procesos concurrentes ejecutados en m últiples confutadores. Gran parte del material de este libro incluye ejemplos de procesos separados ejecutando con­ currentemente en computadores independientes ínter conectados a través de una red. Los procesos interactúan con otros procesos mediante el intercambio d e da­ tos sobre la red, pero su ejecución es por otra parte completamente indepen­ diente. Cuando alguien accede a una página web utilizando un navegador, un proceso del mismo que ejecuta en la máquina local interactúa con un proceso que se ejecuta en la máquina del servidor web. La programación concurrente que implica a múltiples máquinas requiere de­ terminado soporte de programación; es decir, el software utilizado para los pro­ gram as participantes debe contener la lógica necesaria para permitir la interac­ ción entre los procesos. Uno de los tem as principales de este libro es cómo se expresa esta lógica en los programas. • Procesos concurrentes ejecutados en un tm ko computador. Los computado­ res modernos utilizan sistemas operativos multitarea, que permiten la ejecución concurrente de múltiples tareas o procesos. La concurrencia puede ser real o vir­ tual. L a verdadera concurrencia multitarea sólo es posible si el computador tie­ n e múltiples CPU, de forma que cada CPU pueda ejecutar un proceso. En un computador con una sola CPU, se utiliza tiempo compartido (véase la Figura 1.8) o rodajas de tiempo para permitir que los procesos puedan ejecutarse por tumos, creando la ilusión de que se ejecutan en paralelo. Procesos P1 P2 P3 ______ P4 ______ ► T ie m p o Tiem po co m p a rtid o d e un recurso F ig u ra 1 3 . T ie m p o c o m p a rtid o en un c o m p u ta d o r. www.FreeLibros.org Introducción a la com p u ta ció n distribuida Ya que la multitarea es una funcionalidad del sistema operativo, no se nece­ sita una programación especial para llevar a cabo este tipo de programación con­ currente, es decir, no se necesita una lógica software especial en el programa para iniciar la multitarea. • Programación concurrente dentro d e u n proceso. Además de la program a­ ción concurrente entre diferentes procesos, m uchas veces un único programa necesita iniciar diferentes tareas que se ejecuten concurrentemente. Por ejem ­ plo, un programa podrá necesitar realizar otras tareas mientras espera indefi­ nidam ente por la entrada de un usuario en una interfaz de ventanas. También podría ser aconsejable que un programa ejecute varias tareas en paralelo, por m otivos de rendimiento. La program ación concurrente dentro d e un proceso se lleva a cabo a través de dos tipos de herramientas proporcionadas por el sistem a operativo. P ro ce so s p a d re s e hijos En tiempo de ejecución, un proceso puede crear procesos subordinados, o procesos fagos A través de la multitarea real o virtual, el proceso original, denominado pro­ ceso padre continúa ejecutando simultáneamente con el proceso hijo (véase la Figu­ ra 1.9). Un proceso hijo es un proceso completo, que consiste en un programa en eje­ cución, sus propios valores actuales e información de estado, parte de la cual es heredada del proceso padre. Un proceso padre puede saber cuándo un proceso hijo ha finalizado. Un p ro ce so padre puede crear proce sos hijos. Proceso padre Un p ro ce so puede cre a r hilos. / Hilo hijo 1 Procesos hijos (a) (b) Proceso Hilo principal Hilo hijo 2 / F ig u ra 1.9. E jecución c o n c u rre n te d e n tro d e un pro ceso . Threads o hilos En lugar de procesos hijos, un proceso puede crear ütreads o hilos también conoci­ dos como procesos ligeros Los hilos poseen un mínimo d e información de estado, comportándose por lo demás de la misma forma que los procesos. Debido a que im­ plican menos sobrecarga, es preferible utilizar hilos que utilizar procesos hijos. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones La creación y coordinación de hilos requiere el soporte d e la programación. El software correspondiente al programa debe escribirse con la lógica necesaria para la creación de hilos y la coordinación, o sincronización de la ejecución de la familia de hilos creados por el hilo padre. La ejecución concurrente de los hilos puede ocasionar una condición d e ca- rrera Una condición de carrera ocurre cuando una serie de m andatos de un pro­ grama se ejecutan d e una forma arbitraria e intercalada, pudiendo llevarse a cabo una ejecución no determ inista. La Figura 1.10 ilustra esta situación. Siendo conta­ d or una variable com partida entre dos hilos concurrentes. Al ejecutar la secuencia 1, en la cual las instrucciones de los d os procesos se ejecutan secuencialm ente, el valor del contador se increm enta en dos. Por otro lado, si se ejecuta la secuencia 2, en la cual el conjunto de instrucciones se intercala, el contador sólo se incre­ menta en uno. Las condiciones de carrera se pueden evitar si se utiliza exd u aón n v tu a dentro de un segmento de código, de forma que se asegure que los mandatos de dicho seg­ mento sólo puedan ejecutarse por parte de un único hilo en un determinado momen­ to. A dicho segmento de código se le denomina región a ític a En nuestro ejemplo, la región crítica comprende el código en el cual se accede y se incrementa la varia­ ble contador. La programación que utiliza hilos se denomina progpamarión m iJ ti títre a d e d o programación nmiKM o Un programa multi-threaded escrito para evitar condiciones de carrera se dice que es th re a d sa fe El desarrollo de programas thread-safe com­ plejos requiere unos avanzados conocimientos de programación. Afortunadamente, en este libro apenas se utilizan hilos de forma explícita, ya que muchas de las herra- Tiem po Obtener valor del contador y cargarlo en un registro Increm entar el va lo re n el registro Alm acenar valor del registro en el contador ¡Obtener valor del contador y cargarlo en un registro | Increm entar el va lo r en el registro Alm acenar va lo r del registro en el contador Esta ejecución tie n e com o resultado el con tado r con valor 2. Obtener valor del contador y cargarlo en un registro Obtener valor del contador y cargarlo en un registro Increm entar el va lo re n el registro Increm entar el va lo re n el registro Alm acenar va lo r del registro en el con tado r Almacenar valor del registro en el con tado r Esta ejecución tiene com o resultado el co n ta d o r con va lo r 1. Instrucciones ejecutadas en el proceso concurrente o hilo 1 Instrucciones ejecutadas en el proceso concurrente o hilo 2 F ig u ra 1.10. C o n d ició n d e ca rre ra p ro c e d e n te d e p ro c e s o s o h ilo s c o n c u rre n te s no sin cron izad os. www.FreeLibros.org Introducción a la com p u ta ció n distribuida 19 mientas que dan soporte a aplicaciones de red frecuentemente utilizan programación multihilo internamente. H ilos J a v a La máquina virtual Java permite que una aplicación tenga múltiples hilos ejecutando concurrentemente. Cuando una máquina virtual Java se inicia, hay normalmente un único hilo (aunque en algunos sistemas un programa se puede iniciar con más de un hilo), que típicamente invoca al método denominado main de alguna clase, tal como la clase de una aplicación escrita por el programador. Se pueden crear otros hilos adi­ cionales a partir de un hilo activo, y cada hilo se ejecutará independientemente y en paralelo con el resto hasta que termine. Para permitir el uso de hilos en un programa, Java proporciona una clase deno­ minada thread y una interfaz denominada runnable. En un programa Java hay dos formas de crear un nuevo hilo de ejecución: 1. Declarar una clase como subclase de la clase thread. Esta subclase debe so- breescribir e l método run de la clase thread. Cuando se crea e inicia una ins­ tancia de la subclase, el código del método run se ejecuta concurrentemente con el hilo principal. 2. Declarar una clase que implemente la interfaz runnable. Esta clase implemen- ta el método run de dicha interfaz. Cuando se crea e inicia una instancia de la subclase, el código del método run se ejecuta concurrentemente con e l hilo principal. La Figura 1.11 muestra el uso d e la primera forma de crear un nuevo hilo d e ejecu­ ción, mientras que la Figura 1.12 muestra el uso de la segunda forma. p u b l i c c l a s s E j e c H i l o s { p u b l i c s t a t i c v o i d m a in ( S t r i n g [ ] a r g s ) { H ilo E je m p lo p l = new H ilo E j e m p l o ( 1 ) ; p l . s t a r t ( ) ; H ilo E je m p lo p 2 = new H i l o E j e m p l o ( 2 ) ; p2 . s t a r t ( ) ; H ilo E je m p lo p3 = new H i l o E j e m p l o ( 3 ) ; p 3 . s t a r t ( ) ; > } / / f i n c l a s e E j e c H i l o s p u b l i c c l a s s H ilo E je m p lo e x t e n d s T h r e a d { i n t m i l d e n t ; H ilo E j e i r p l o ( i n t i d e n t ) { t h i s . m i l d e n t = i d e n t ; > p u b l i c v o i d r u n ( ) { i n t i ; f o r ( i = 1 ; i < 1 1 ; i+ + ) S y s te m . o u t . p r i n t l n ( \" H i l o \" + m i l d e n t i ) ; > } / / f i n c l a s e H ilo E je m p lo F ig u ra 1.11. A p lica ció n sen cilla qu e c re a tre s hilos u tiliza n d o un a su b cla se d e la c la s e thread. www.FreeLibros.org 20 C om putación distribuida. Fundam entos y aplicaciones c l a s s H iló E je m p lo 2 im p le m e n ts R u n n a b le { i n t m i l d e n t ; H ilo E je m p lo 2 ( i n t i d e n t ) { t h i s . m i l d e n t = i d e n t ; > p u b l i c v o i d r u n ( ) { i n t i ; f o r ( i = 1 ; i < 1 1 ; i+ + ) S y s te m . o u t . p r i n t l n ( \" H ilo \" - K n iI d e n t + \" : \" + i ) ; > > / / f i n c l a s e H ilo E je m p lo 2 q u e c re a tre s h ilo s u tiliza n d o un a im p le m e n ta c ió n d e la in te rfa z runnable. En Java, la manera más sencilla de evitar las condiciones de carrera es a través de la utilización de los m étodos estíticos sincronizados Un método estático que con­ tenga en su cabecera la palabra reservada synchronized puede ejecutarse por un úni­ co hilo simultáneamente. Por tanto, se garantiza que el código de un método estático sincronizado sea mutuamente exclusivo. En el ejemplo mostrado en la Figura 1.10, el código correspondiente al incremento de la variable contador debe encapsularse den­ tro de un método estático sincronizado, tal que e l contador sólo se incremente por parte de un único hilo simultáneamente. Un ejemplo d e código Java que ilustra e l uso de hilos y métodos estáticos sincronizados puede encontrarse en el Ejercicio 2(d.) al final de este capítulo. En subsecuentes capítulos, se utilizarán los térm inos proceso e h ilo frecuente­ mente. Si el lector no se encuentra familiarizado con los threads, a l final de este capítulo hay un conjunto de ejercicios que le permitirán practicar a través del uso de hilos Java. 1 .6 . C O N C E P T O S B Á SIC O S DE REDES Después de analizar algunos conceptos básicos de los sistem as operativos que son re­ levantes para la computación distribuida, se procederá a realizar lo mismo con con­ ceptos básicos de redes. Protocolos En el contexto de las comunicaciones, un protocolo es un conjunto de reglas que los participantes deben seguir. En una reunión, los seres humanos siguen instintivamente p u b l i c c l a s s E j e c H i l o s 2 { p u b l i c s t a t i c v o i d m a in ( S t r i n g [ ] a r g s ) { T h re a d p l = new T h r e a d ( new H ilo E je m p lo 2 ( 1 ) ) ; p l . s t a r t ( ) ; T h re a d p2 = new T h r e a d (new H ilo E je m p lo 2 ( 2 ) ) ; p2 . s t a r t ( ) ; T h re a d p3 = new T h r e a d (new H ilo E je m p lo 2 ( 3 ) ) ; p 3 . s t a r t ( ) ; > } / / f i n c l a s e E je c H ilo s 2 F ig u ra 1.12. A p lic a c ió n sen cilla www.FreeLibros.org Introducción a la com p u ta ció n distribuida 21 un protocolo no establecido explícitamente, basado en la visión, el lenguaje del cuer­ po y los gestos. Este protocolo establece que sólo una persona debe hablar en un mo­ mento determinado mientras el resto escucha. En una conversación telefónica, una par­ te inicia la llamada, y a continuación, después de que la llam ada es aceptada, las dos partes se turnan en la comunicación, utilizando pausas y preguntas para indicar cuan­ do la otra parte tiene la palabra. En la comunicación entre computadores, los protocolos deben estar definidos for­ malmente e implementados de una manera precisa. Para cada protocolo, debe existir un conjunto de reglas que especifiquen las siguientes cuestiones: • ¿Cómo se codifican los datos intercambiados? • ¿Cómo los eventos (envío, recepción) se sincronizan (ordenan) de modo que los participantes puedan enviar y recibir información de una forma coordinada? El concepto de protocolo se concretará más cuando se estudien diferentes protocolos en el resto del libro. Debe destacarse que un protocolo es un conjunto de reglas. La especificación de un protocolo no indica cómo deben imple mentarse dichas reglas. Por ejemplo, el pro­ tocolo HTTP ( Hypertexí Transfer Protocoí) especifica las reglas que deben seguir un proceso del navegador web y un proceso del servidor web. Cualquier programa en el servidor web que cumpla las reglas establecidas satisfará el protocolo, sin importar el lenguaje de programación o sintaxis utilizada. Por tanto, es importante entender que un protocolo (tal como HTTP) es distinto de su implementación (tal como indica la gran variedad d e navegadores web, incluyendo los navegadores Netscape e Internet Explorer). Análogamente, las reglas de un deporte, tal como el baloncesto, son especificadas por alguna autoridad, como por ejemplo la NBA (National Basketball Association), pero es responsabilidad de cada equipo y cada jugador llevar a cabo dicho juego, siempre si­ guiendo dichas reglas. A rquitectura de red En los libros sobre redes de datos, normalmente se presentan las funciones de una red utilizando una arquitectura de red (véase la Figura 1.13). Dicha arquitectura de red clásica se denomina arquitectura OSI (Open System ¡nterconnect) y divide las fun­ ciones complejas de una red en siete capas. Todas o parte de estas funciones deben estar presentes en un computador que participa en la comunicación de datos y, por tanto, también en la computación distribuida. El lector interesado en cuestiones más específicas del modelo OSI deberá buscar más información en libros de redes tales como [Tanenbaum, 35]. Para los objetivos de este libro, se presenta una arquitectura apropiada para Internet. La arquitectura de red de Internet está representada en la Figura 1.14, y está for­ mada por cuatro capas: física, Internet, transporte y aplicación. La capa fiá ca pro­ porciona las funciones de transmisión de señales, representando los flujos de datos en­ tre los computadores. La capa Internet permite dirigir y entregar un paquete de datos a un computador remoto. La capa de transporte proporciona las funciones necesa­ rias para la entrega de paquetes de datos a un proceso específico que se ejecuta en el computador remoto. Finalmente, la capa d e aplicación permite que los mensajes se puedan intercambiar entre los programas, a fin de posibilitar el funcionamiento de una aplicación, tal como la Web. La sintaxis de un lenguaje de programación es el conjunto de reglas de lenguaje, incluyendo la ortografía y la gramática del mismo. OSI significa Open System Interconnect, y es el nombre dado al modelo de arquitectura de red realizado por una organización denominada International Organizaron for Standardizaron (ISO). www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Capa de aplicación ...................... ► Capa de a p lic a c ió n -* Capa de presentación Capa de presentación Capa de sesión Capa de sesión Capa de tra n s p o rte Capa de tra n s p o rte Capa de red Capa de red Capa de enlace Capa de enlace ► Capa física ----------- ------ ► Capa física F ig u ra 1.1 3. La a rq u ite c tu ra d e re d d e sie te c a p a s OSI. Capa de ap lica ció n — Capa de aplicación Capa de tra n s p o rte Capa de tra n sp o rte Capa de In te rn e t Capa de In te rn e t Capa física -------- I— ------------- ----------- Capa física - * F ig u ra 1.14. La a rq u ite c tu ra d e re d d e Internet. La división de las capas es conceptual: la implementación de estas funciones no necesita dividirse claramente en e l hardware y software que implementa la arquitec­ tura. La división conceptual de la arquitectura en capas sirve al menos para dos pro­ pósitos útiles. Primero, permite que los protocolos se puedan especificar de una for­ ma sistemática; es decir, utilizando una arquitectura de red, estos protocolos se pueden especificar capa a capa, resolviendo la problemática asociada a cada capa. Segundo, la arquitectura de capas permite que los detalles de las funciones de la red se puedan abstraer u ocultar. Cuando se escribe una aplicación, es útil no preocuparse por los detalles de la comunicación de los datos y concentrarse en el protocolo de la aplica­ ción. Una arquitectura de capas hace posible que los programas se escriban como si los datos se intercambiaran directamente (véase las líneas disjuntas de las Figuras 1.13 y 1.14). Realmente, el mensaje enviado desde una aplicación debe procesarse por to­ das las capas de la arquitectura d e la red (véanse las líneas punteadas). Eventualmente, www.FreeLibros.org Introducción a la com p u ta ció n distribuida la señal de datos que representa el mensaje se transmite a través del enlace físico que une los computadores (véanse las líneas continuas). Una vez que las señales llegan al computador receptor, éste las procesa en el orden inverso, hasta que finalmente los datos son reconstruidos en el mensaje original y éste es entregado a l proceso apro­ piado. Protocolos de la arquitectura de red Ahora se van a describir algunos protocolos específicos d e la arquitectura de Internet. El protocolo para la capa de Internet se denomina, como su nombre indica, Protoco­ lo de Internet (IP, Internet Protocol). Este protocolo utiliza un esquema de nombrado particular, que se estudiará a continuación, para identificar los computadores en una red y para encaminar los datos. En la capa de transporte, hay dos protocolos amplia­ mente utilizados: el Protocolo de Control d e Transmisión (TCP, Transmission Control Protocol), que proporciona una comunicación o rie n ta d a a co n e rió n y el Protocolo de Datagrama de Usuario (UDP, User Datagram Protocol), que ofrece una comuni­ cación s in e o n e rió n (En la próxima sección se analizarán más detenidamente estos conceptos y posteriormente en el Capítulo 2). Finalmente, en la capa de aplicación, existen diferentes protocolos especificados para aplicaciones de red, tales como el Pro­ tocolo de Transferencia de ficheros (FTP, File Transfer Protocol), e l Protocolo de Co­ rreo Electrónico Sencillo (SNMP, Simple Network M ail Protocol) y e l Protocolo de Transmisión de Hipertexto (HTTP, Hypertext Transmission Protocol). El conocido pro­ tocolo Transmission Control Protocol/Internet Protocol (TCP/IP) es un conjunto de protocolos que incluye a los protocolos de Internet y transporte de esta arquitectura; estos protocolos se utilizan universalmente para la comunicación a través de Internet. Por tanto, una aplicación de Internet debe ejecutarse en un computador que imple- mente esta parte de la arquitectura de Internet, coloquialmente denominada ¡ d a d e protocolos T C P/IP. Los lectores interesados en protocolos de capas inferiores pueden consultar libros de texto tales como [Stallings, 12; Tanenbaum, 13). Este libro está orientado al estu­ dio de protocolos de la capa de aplicación. El libro comienza analizando algunos de los protocolos de aplicación más populares, como los que se mencionan en el párra­ fo anterior. A continuación, se estudiará cómo tales aplicaciones se utilizan en la com­ putación distribuida. Com unicación orientada a conexión frente a com unicación sin conexión Aunque la comunicación orientada a conexión y la comunicación sin conexión son te ­ mas relacionados con las redes de datos, en esta sección se discutirán los aspectos que distinguen ambos tipos de comunicación. En una comunicación orientada a conexión, una conexión, que puede ser física (es decir, tangible, proporcionada mediante dispositivos hardware tales como cables, mó­ dem y receptores) o lógica (es decir, abstracta o virtual, utilizando software que em u­ la una conexión), se establece entre dos partes, e l emisor y e l receptor. Por ejemplo, alguien (el emisor) puede marcar un número para realizar una llamada telefónica a un amigo (el receptor). Una vez establecida la conexión, los datos (voz en el caso de una llam ada telefónica) pueden enviarse continuamente a través d e la conexión hasta que la sesión finaliza. En el caso de la llamada telefónica, la sesión termina cuando el emisor cuelga el teléfono al final de la conversación, punto en el cual la conexión se www.FreeLibros.org 24 C om putación distribuida. Fundam entos y aplicaciones Una red de datos transmite datos; una red de voz transmite voz. Las redes modernas transmiten tanto datos como voz. corta. H ay que destacar que en este modo de comunicación no es necesario especifi­ car explícitamente la dirección del destinatario para cada paquete d e datos individual durante e l tiempo que la conexión se utilice. Como su nombre indica, la comunicación sin conexión implica que no existe co­ nexión. En su lugar, los datos se envían mediante e l uso de paquetes y cada emisor debe indicar de forma explícita en cada paquete la dirección del receptor. Un ejem ­ plo de comunicación sin conexión es la correspondencia entre dos amigos a través de mensajes de correo electrónico o cartas. Cada correo electrónico o carta, que contie­ ne un mensaje, deben contener la dirección del destinatario. El intercambio continúa hasta que la correspondencia o sesión finaliza. En una red de datos es más sencillo proporcionar una comunicación sin cone­ xión, ya que ésta no necesita mantener conexiones separadas. Sin embargo, la falta de conexión puede im plicar la pérdida de paquetes de datos en la entrega o la en ­ trega fuera d e orden de los mismos. Por ejemplo, cuando se envían m últiples y su ­ cesivos correos electrónicos o cartas a una única persona, cada uno de los cuales contiene parte de un mensaje, es posible que el destinatario reciba los correos elec­ trónicos o cartas desordenados, ya que cada correo o carta se entregan de forma in­ dependiente. Por otro lado, la comunicación orientada a conexión puede asegurar la entrega se­ gura y ordenada de los paquetes de datos a través de una conexión establecida, pero con el coste adicional de la sobrecarga que implica este proceso. Este es otro ejem ­ plo de compromiso entre am bas soluciones. La Figura 1.15 muestra gráficamente la diferencia entre estas dos formas de co­ municación. En e l Ejercicio 3 que se encuentra a l final de este capítulo, se realiza un análisis sencillo de las diferencias existentes entre am bas formas de comunicación a través de un estudio guiado. En cualquier capa de una arquitectura de red, la com unicación se puede lograr a través de utilidades orientadas a conexión o sin conexión. En la capa de trans­ porte d e la pila TCP/IP, el protocolo UDP es un protocolo sin conexión, mientras C om unicación sin conexión □ □ Fáquete d e da tos F ig u ra 1.15. C o m u n ica ció n o rie n ta d a a c o n e x ió n fre n te a c o m u n ic a c ió n s in c o n e x ió n . www.FreeLibros.org Introducción a la com p u ta ció n distribuida 25 que el protocolo TCP es un protocolo orientado a conexión. Se dice que una apli­ cación o protocolo que utiliza UDP para transm itir datos es una aplicación o pro­ tocolo sin conexión a nivel de transporte, m ientras que uno que utiliza TCP es orien­ tado a conexión en dicha capa o nivel. Es necesario destacar que es posible que una aplicación sea orientada a conexión en una capa y sin conexión en otra. Por ejem ­ plo, una aplicación que utiliza el protocolo HTTP, un protocolo orientado a cone­ xión en la capa de aplicación, podría utilizar UDP en la capa de transporte para transm itir y recibir los datos. La Tabla 1.1 compara los dos modos de comunicación. T a b la 1.1 . C o m p a ra ció n de la c o m u n ic a c ió n e n tre p ro c e s o s o rie n ta d a a c o n e x ió n y s in c o n e x ió n . O rientado a conexión Sin conexión D ireccionam iento Se especifica en el momento de la conexión; posteriormente no es necesario volver a especificarlo con cada operación (envío o recepción). Se especifica en cada operación. Sobrecarga de la conexión Existe sobrecarga de establecimiento de la conexión. No se aplica. Sobrecarga del direccionam iento No existe sobrecarga de direccionamiento en cada operación. Existe sobrecarga en cada operación. Orden de llegada de los datos La abstracción de la conexión permite al mecanismo de comunicación entre procesos mantener el orden de llegada de los paquetes de datos. La falta de conexión hace difícil a la aplicación que hace uso del mecanismo de comunicación entre procesos mantener el orden de llegada. Protocolos Este modo de comunicación es apropiado para protocolos que requieren el intercambio de grandes conjuntos de datos y/o un gran número de intercambios. Este modo de comunicación es apropiado para protocolos que intercambian un pequeño conjunto de datos y realizan un número pequeño de intercambios. Recursos de red Este libro utilizará frecuentemente el térm ino recursos de red. Por recursos de red se entiende aquellos recursos que están disponibles para los participantes d e una comu­ nidad de computación distribuida. Por ejemplo, en Internet los recursos de red inclu­ yen hardware tal como los computadores (incluyendo servidores d e Internet y cn- caminadores) o equipamiento (impresoras, máquinas de fax, cámaras, etc.), y software, tal como procesos, buzones de correo electrónico, ficheros o documentos web. Una clase importante de recursos de red son los servicios d e red, tales como la Web o el servicio de transferencia de ficheros, que son implementados por procesos que ejecu­ tan en computadores. Aunque la idea parece simple, uno de los retos claves en la computación distri­ buida es la identificación única de los recursos disponibles en la red. La próxima sec­ ción describe cómo se lleva a cabo la identificación de recursos en Internet. Un nodo de Internet es un computador que implementa la arquitectura de protocolos de Internet y, por tanto, es capaz de participar en comunicaciones de Internet. Un encaminador o router es un computador especializado en encaminar los datos entre las redes. En Internet, un encaminador implementa la funcionalidad de la capa de Internet. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Identificación de nodos y direcciones del protocolo de In ternet Físicamente, Internet es una gigantesca malla de enlaces de red y computadores o no­ dos. Conceptualmente (véase la Figura 1.16), las principales arterias de Internet son un conjunto de enlaces de red de alto ancho de banda que constituyen el esqueleto central o «backbone» de la red. Conectadas a este backbone existen redes individua­ les, cada una de las cuales tiene un identificador único. Los computadores con soporte TCP/IP, denominados nodos o m áquinas de Internet, están unidos a redes indivi­ duales. A través de este sistem a de «autopistas de la información», los datos pueden transmitirse desde una máquina Mi en una red Ri a otra máquina M2 en una red R>. Para realizar la transferencia de datos desde un programa es necesario identificar de forma única al proceso receptor, de forma sim ilar al proceso de envío de una carta por parte del servicio postal. Como se mencionó anteriormente, un proceso es una representación en tiempo real de un programa cuando se ejecuta en un computador. Por otro lado, también se ha descrito que en Internet un computador o una máquina se encuentra enlazado a una red. Por tanto, para identificar un proceso es necesario indicar la red, el computador enlazado a dicha red y a continuación e l proceso que se ejecuta en el computador. En la arquitectura d e Internet, la identificación de la máquina es parte del proto­ colo Internet (IP), el cual, como ya se describió, es e l protocolo de la capa Internet de la pila de protocolos TCP/IP. A continuación se analiza el esquema de identifica­ ción de nodos especificado en la versión 4 de IP, conocida como IPv4. Aunque el es­ quema se ha modificado en la versión 6 (IPv6) para permitir el uso de más direccio­ nes Internet, los principios del esquem a son los mismos para las dos versiones, habiéndose escogido IPv4 por su mayor simplicidad. En el contexto de este libro, las diferencias entre las dos versiones no son significativas. En IPv4, cada máquina de Internet se identifica por una única cadena de 32 bits. Dada una longitud de 32 bits, e l número total de direcciones posibles es 2a2, o lo que es lo mismo, el espacio de direcciones de IPv4 permite 2a2 (4.294.967.296 o sobre cua­ tro mil millones) direcciones. Máquina de Internet Redes Backbone de Internet F ig u ra 1.16. La to p o lo g ía d e Internet. www.FreeLibros.org Introducción a la com p u ta ció n distribuida Cada dirección IP debe identificar tanto la red en la cual la máquina reside como la máquina en sí. El esquem a de direccionam iento IPv4 funciona de la siguiente forma: El espacio de direcciones se divide en cinco clases, que van desde la clase A has­ ta la clase E. Como queda representado en la Figura 1.17, cada clase tiene un único prefyo. La clase A comienza con el bit 0, la clase B comienza con la secuencia de bits 10, la clase C con la secuencia 110 y así sucesivamente. El resto de los bits de cada dirección se utilizan para identificar la red y la máquina correspondiente. Por tanto, una dirección de clase A tiene 31 bits para identificar el par red-máquina, una dirección de clase B tiene 30 bits y así sucesivamente. Esto significa que hay un to­ tal de 231 (aproximadamente dos mil millones) direcciones de clase A disponibles, mientras que hay un máximo de 232 (aproximadamente mil millones) direcciones de clase B disponibles. El número máximo de direcciones de clase C, D o E se puede calcular de forma similar. Es importante destacar que dentro de cada clase un peque­ ño número d e direcciones (tales como la dirección con todos los bits a 0 o todos los bits a 1) queda reservado para propósitos especiales. Byte 0 Byte I Byte 2 Byte 3 Direcciones clase A Direcciones clase B Direcciones clase C Direcciones multidifusión Direcciones reservadas F ig u ra 1.17. El e sq u e m a d e d ire c c io n e s IPv4. Es im portante saber por qué es necesario tener diferentes clases de d ireccio­ nes. Esto está relacionado con el núm ero de com putadores que cada red indivi­ dual puede soportar. C onsidérese una dirección d e clase A (véase la la F igura 1.17): lo s 7 bits que siguen a l prefijo 0 se utilizan para la identificación d e la red y el resto (32-8 = 24 bits) identifican la m áquina dentro de la red. Por ta n ­ to, cada red d e clase A puede albergar hasta 224 (aproxim adam ente 16 m illones) com putadores, aunque no puede haber m ás d e 27 o 128 redes d e este tipo. Del mismo m odo, se puede analizar que cada una de la s 214 (16.384) redes de clase B pueden tener hasta 2,e (65.536) m áquinas. Igualm ente, existen m uchas m ás re ­ des d e clase C que de clase B, aunque cada red d e clase C puede contener m u­ chos m enos com putadores. Como se ha mencionado anteriormente, en raras ocasiones tendremos ocasión de identificar máquinas IP utilizando la dirección d e 32 bits. En las ocasiones que utili­ cemos la dirección numérica, lo más probable es que usemos la denominada notación decimal con puntos en su lugar. La notación decim al con puntos de una dirección IP utiliza un valor decim al para cada uno de los 4 bytes de la dirección IP. Como un ejemplo, supongamos que la notación decimal con puntos de una direc­ ción Internet particular es 129.65.24.50. La expansión binaria de 32 bits de dicha no­ tación es la siguiente: 0 1 0 1 1 0 1 1 1 0 Grupo multidifusión 1 1 1 1 Reservado Dirección de red Dirección de máquina www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones ^ 129. 65l 24.50 10000001 j \\ 01000001 \\ 000 1 1 0 0 0 \\ 00110010 Ya que la secuencia de bits comienza por 10, la dirección es una dirección de cla­ se B. Dentro de esta clase, la porción correspondiente a la identificación de la red co­ rresponde a los restantes bits en los primeros 2 bytes, es decir, 00000101000001, y la porción correspondiente a la identificación de la máquina corresponde a los últimos 2 bytes, 0001100000110010. Por conveniencia, el prefyo binario que identifica la cla­ se se suele incluir como parte de la porción de red de la dirección, d e forma que se dice que esta dirección tiene como identificación d e red 129.65 y como identificación del computador en la red 24.50. Veamos otro ejemplo. Dada la dirección 224.0.0.1, se puede expandir de la si­ guiente forma: 224 .0.0.1 El prefijo binario 1110 indica que esta dirección es de clase D, también denomina­ da dirección de multidifusión (multicast). Los paquetes de datos enviados a esta direc­ ción deben ser entregados al grupo de multidifusión 0000000000000000000000000001. Las direcciones IP las asigna una autoridad conocida como IA N A [In á a n e t A s- s ig ie d N u m b e r s A u th a rity |community-ml.org, 25] a organizaciones tales como uni­ versidades o proveedores de servicio en Internet (ISP, Internet Service Provider). (,Nota: La asignación de esta autoridad es dinámica. Véase http://www.wia.org/pub/iana.html, donde se describe la historia de la evolución de esta autoridad.) Dentro de cada red, la asignación de la identificación de la máquina se hace d e forma interna a la orga­ nización. Normalmente, una organización hace uso de esta porción de la dirección para subdividir su red en una jerarquía d e subredes, con un único número de nodo asignado a cada computador unido a una subred. Por ejemplo, el administrador de la clase B 129.65 podría designar el segundo byte (es decir, los 8 bits de la parte iz­ quierda de la porción del nodo) como identificador de una subred. Bajo este esque­ ma d e subredes, la dirección IP 129.65.32.3 identifica a una máquina con identifica­ dor 3 en una subred de identificador 32 de esta red. www.FreeLibros.org Introducción a la com p u ta ció n distribuida Desde la década de los 90, la demanda de direcciones IP se ha disparado hasta el punto de que el espacio de direcciones se ha agotado. El esquema de direccionamiento estático que se acaba de describir se ha aumentado con numerosos cambios en respuesta a la demanda creciente de direcciones, incluyendo el esquema de direcdonanaento di­ nám ico que se ha hecho popular con los proveedores de servicio de Internet o ISP, ta­ les como American Online (AOL). Utilizando direccionamiento dinámico, un ISP o gran­ des organizaciones pueden extender el espacio de direcciones para una red IP dada mediante la unión de direcciones. Por ejemplo, una dirección estática de red de clase B puede tener hasta 2,e o 65.536 máquinas estáticas. Uniendo las aproximadamente 65.000 direcciones y asignando cada una de ellas a una sesión activa bajo demanda, es posible dar soporte a millones de computadores IP, asumiendo que no hay más d e 65.000 se­ siones activas en un determinado momento. Por esta razón, cuando se accede a Inter­ net a través de un ISP, la dirección IP del computador puede variar de una sesión a otra. L a mayoría de los usuarios tienen problemas para memorizar una cadena de 32 bits, incluso con la ayuda de la notación decim al con puntos. Por tanto, es preferible utilizar un nombre simbólico para identificar un computador. Esta es la razón por la que la comunidad de Internet adoptó el sistem a d e nom brado de dominio (DNS, Do- main Ñame System). El acrónimo DNS también se refiere al servicio de nombrado de dominio (Domain Ñame Service), que consiste en el servicio que proporciona un sis­ tema de nombrado de dominio. Cada vez que se utiliza el correo electrónico o se vi­ sualiza una página web, se identifica la máquina de Internet utilizando un nombre de dominio basado en el protocolo DNS. Cada nombre de dominio contiene al menos dos componentes separados por pun­ tos. En una dirección como acme.com, el último componente, com en este caso, se denomina dom inio d e primo* nivel A la izquierda del punto en el nombre, acmé en este caso, se encuentra lo que se denomina dom inio d e seg u id o n ivel Es posible también que existan subdominios, tales como marketing.acme.com. Los nombres de dominios no son sensibles a las mayúsculas y minúsculas, por lo que se pueden uti­ lizar indistintamente. Actualmente, los dominios de primer nivel están clasificados como se muestra en la Tabla 1.2 [Brain, 15]. T a b la 1.2. N o m b re s d e d o m in io d e a lto nivel. .com Para entidades comerciales, que cualquiera, desde donde sea, puede registrar. net Originalmente se designó para organizaciones directamente relacionadas con las operaciones de Internet. Actualmente, este dominio también se está utilizando para negocios, cuando el nombre .com deseado ya está registrado por otra organización. Hoy en día cualquiera puede registrar un nombre en el dominio .net. •org Para organizaciones misceláneas, incluyendo aquellas organizaciones sin ánimo de lucro. .edu Para instituciones de educación superior. •gov Para entidades del gobierno federal de los EEUU. .m il Para el ejército de EEUU. Códigos de países Para países individuales basados en la organización de estándares internacionales; por ejemplo, .ca para Canadá, y .jp para Japón. Véase [Connolly, 18] para ver una lista de los códigos existentes de países. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Los dominios de segundo nivel combinados con los dominios de primer nivel (por ejemplo, calpoly.edu) normalmente, aunque no siempre, corresponden a la porción de red de una dirección IP, mientras que el resto del nombre del dom inio (por ejemplo, www. esc) se utiliza para identificar la subred, si existe, y el nombre de la máquina. Véase la Figura 1.18 donde se describe gráficamente esta característica. .(Dominio raíz) C ódigo d e país F ig u ra 1 .1 8 . Jera rqu ía d e n o m b re s d e d o m in io . Cada nombre d e dominio corresponde a una dirección IP, aunque esta asociación no tiene por qué ser permanente. Por ejemplo, el nombre de dom inio ebay.com ac­ tualmente corresponde a la dirección IP 216.32.120.133. La resolución de un nombre de domino para obtener la correspondiente dirección IP y viceversa se lleva a cabo a través de un servicio conocido como resolución de nom bres DNS. El Ejercicio 4 muestra una forma de probar este servicio. Finalmente, el nombre de dominio localhost se puede utilizar para identificar el computador en el cual se ejecuta el proceso. Este nombre se corresponde siempre a la dirección IP 127.0.0.1 y permite identificar al computador local. Una vez que se identifica una máquina utilizando una dirección IP o un nombre de dominio, se pueden identificar también recursos individuales dentro d e la máqui­ www.FreeLibros.org Introducción a la com p u ta ció n distribuida na. A continuación se mostrarán tres ejemplos de esquemas de identificación de un proceso, un receptor de correo electrónico y documentos web, respectivamente. Identificación de procesos a través de puertos Especificar el nombre de dominio o su dirección IP de forma correcta permite loca­ lizar una máquina o computador en Internet. Pero en las aplicaciones d e red, los da­ tos deben entregarse a un proceso específico que se ejecuta en un computador. Por tanto, se necesita un esquema de nombrado que permita identificar d e forma única un proceso. H ay muchos esquemas que permiten realizar esto. Por ejemplo, una posibi­ lidad es utilizar un único identificada* d e proceso (PID, Process Identifier), que le asigna el sistema operativo al proceso (véase el Ejercicio 4). En Internet, el protoco­ lo utilizado para identificar un proceso usa una entidad lógica conocida como puer­ to d e protocolo, o simplemente puerto. Es importante recordar que la capa de trans­ porte de la arquitectura de Internet es la encargada d e distribuir los datos a los procesos, siendo los dos protocolos más conocidos de esta capa TCP y UDP. Cada uno de es­ tos protocolos utiliza un conjunto separado de puertos en cada máquina para llevar a cabo esta tarea. Un proceso que desee intercambiar datos con otro proceso utilizando TCP o UDP debe tener asignado uno de estos puertos. Una aplicación que desee en­ viar datos a un proceso actualmente asociado al puerto p en la máquina M, debe d i­ rigir los datos a (M, p). En IPv4, existen 2'6 puertos (desde el puerto 0 hasta el puer­ to 65.535) en cada máquina, bajo los protocolos TCP o UDP. Por ejemplo, cuando se accede a un sitio web, normalmente se hace uso del servicio de un proceso que eje­ cuta en la máquina que se especificó (por ejemplo, www.calpoly.edu) utilizando el protocolo TCP y el puerto 80. En los protocolos TCP y UDP, los números entre el 0 y el 1023 (2'°) están reser­ vados para servicios conocidos. Estos puertos se denominan puertos bien conocidos y los asigna la autoridad IANA [isoc.org, 38]. En algunos sistem as sólo los procesos del sistema o los programas que ejecutan usuarios privilegiados pueden utilizan estos números. A cada servicio de red popular, tal como telnet, FTP, HTTP o SMTP, se le asigna uno de estos números d e puerto (23, 21, 80, 25, respectivamen­ te), que permite localizar cada uno de estos servicios. En los ejemplos de programa­ ción d e este libro se especificarán en muchas ocasiones estos números de puerto. Direcciones de correo electrónico Una dirección de correo electrónico utiliza e l formato nombreUsuario@nombreDomi- nio. Por ejemplo, mliu@csc.calpoly.edu identifica al autor de este libro. Cuando se envía un correo electrónico identificando esta dirección como destinatario, un progra­ ma de correo electrónico en el computador correspondiente a l nombre de dom inio es­ pecificado entrega e l correo al buzón del usuario especificado en este sistema; en este caso, el autor d e este libro. URL Los usuarios de los navegadores web están familiarizados con los URL ( U m fo m R e - so u rce Locatons) Cuando se introduce una cadena, tal como http://www.csc.cal- poly.edu en el navegador para visitar un determinado sitio web, se está utilizando un URL. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Un URL es un esquema de nombrado que se encuentra debajo de un esquema más general denominado URI (U n ifa n n R e m u ir e I d a it i fí m ) Los URI son cadenas cor­ tas que identifican recursos en la Web, incluyendo documentos, imágenes, ficheros, servicios y buzones de correo. El esquema URI permite identificar de una forma uni­ forme estos recursos, bajo una variedad de esquemas de nombrado utilizados en pro­ tocolos de aplicación específicos, tales como HTTP, FTP y correo electrónico. URL es un térm ino informal asociado con populares esquemas URI para protoco­ los tales como HTTP, FTP o correo electrónico. URN { U n ifa n n R esource Ñamé) es un esquema especificado por el RFC2141 y otros documentos relacionados, que permite e l uso de identificadores de recursos per­ sistentes e independientes de su localización. Un URN proporciona nombres persis­ tentes dentro d e un espacio de nombres, permitiendo de esta forma que un objeto per­ manente tenga varias copias en varios sitios conocidos; si uno d e los sitios no está disponible, el objeto podría encontrarse en cualquiera de los otros sitios. Existen va­ rias propuestas para la implantación de los URN, pero ninguna de ellas ha sido am ­ pliamente adoptada aún [aboutdomains.com, 16]. Aunque sea un térm ino informal, e l URL es con diferencia e l mejor conocido de todos estos términos. Un URL proporciona una forma no persistente (es decir, no ne­ cesariamente permanente) de identificar un objeto de forma única dentro de un espa­ cio d e nombres. Un espacio de nombres, en el contexto de un sistema de nombrado, se refiere al conjunto de nombres que el sistema proporciona. En su forma más ge­ neral, el formato de un URL es: <prot<icolc»//<iKuaio>:<dave>@ <id-m ánim a>:<pugta>/<ruta> donde • <protocolo> es e l nombre no sensible a mayúsculas o minúsculas del protoco­ lo de la capa de aplicación utilizado para acceder al recurso; por ejemplo, HTTP en el caso de acceder a un navegador web; • <usuario>:<dave> es la autorización de acceso, en el caso de que sea reque­ rida por el protocolo; • <id-niáqm na> es e l nombre d e dominio o dirección IP decim al con puntos de la máquina que proporciona el servicio a través del protocolo; por ejemplo, www. calpoly. edu; • <puerto> es e l puerto para el protocolo de la capa de transporte del proceso que proporciona el servicio en la máquina remota; por ejemplo, el puerto 80 (por defecto) para los servidores HTTP o Web; • <ruta> especifica la ruta dentro del sistema de ficheros de la máquina remota donde se encuentra el recurso; por ejemplo, mliu/cscl02/index.html. Cuando se introduce un URL en un navegador, es posible no especificar el protoco­ lo (en cuyo caso se asume que se utiliza el protocolo HTTP), e l par usuarioxlave (no utilizado en HTTP), e l número de puerto (80 por defecto), y la ruta (se supone que se selecciona la raíz de la jerarquía d e directorios de documentos). Por ejemplo, el URL www.csc.calpoly.edu introducido en el navegador Netscape permite acceder a la página inicial de la Universidad Politécnica de California de San Luis Obispo, que se encuentra en la máquina con nombre de dominio www.csc.calpoly.edu, y que utiliza el puerto 80. A veces se puede utilizar una forma acortada de un URL, denominada URL re­ lativo. Durante una sesión, cuando se está accediendo a un documento (por ejemplo, http://www.csc.calpoly.edu/index.html), se puede utilizar un URL relativo para nom­ www.FreeLibros.org Introducción a la com p u ta ció n distribuida 33 brar otro fichero en el mismo directorio, trayéndose dicho fichero desde el mismo ser­ vidor web. Por ejemplo, si hay otro fichero en e l mismo directorio llamado cour- ses.html, entonces el URL courses.html se puede utilizar en lugar del URL completo http: //www. esc. calpoly. edu/courses. html. Servicio de n o m b re s extensible El servicio d e nombres extensible (XNS, Extensible Ñame Service) es un servicio de nombres de Internet gestionado por la Organización XNS Public Trust Organization (XNSORG), una organización independiente. El servicio permite un esquema de nom­ brado con una dirección única y universal para llevar a cabo «todos los tipos de co­ municaciones: teléfono, fax, páginas web, mensajería instantánea, e incluso correo or­ dinario... Como cualquier servicio d e nombrado, XNS opera a más alto nivel que DNS. DNS está diseñado para traducir un nombre a una dirección de una máquina Inter­ net. XNS está diseñado para resolver una dirección universal en cualquier otro tipo de direcciones de cualquier tipo de red de comunicaciones. Se podría decir que XNS es a DNS como DNS es a un número de teléfono (y, d e hecho, XNS utiliza DNS para resolver la dirección Internet de una agencia XNS)» [omg.org, 27]. Un XNS es una cadena de caracteres. H ay tres tipos de nombres XNS: nombres personales, nombres de negocio y nombres generales, cada uno de los cuales empieza por un único ca­ rácter (=, @, y +, respectivamente) y cada uno de los cuales puede contener hasta 64 caracteres Unicode. R esolución de n o m b re s Siempre que se utiliza un nombre simbólico para identificar un recurso, el nombre debe traducirse a la correspondiente dirección física para localizar dicho recurso. Como se ha mencionado anteriormente, un nombre de dominio tiene e l siguiente formato: nombreComputador. nombreDivisión. nombre Compañía, com que para una máquina Internet debe ser traducido a la dirección numérica, por ejem ­ plo 129.65.123.7, del computador correspondiente. Al proceso de traducción se le co­ noce como resolución de nombres, o simplemente búsqueda de nom bres Para realizar la resolución de nombres, se debe utilizar una base de datos (tam­ bién llamada directorio o registro) que contenga las asociaciones entre nombres sim ­ bólicos y nombres físicos. Si el espacio de nombres de un esquema de nombrado tie­ ne un tam año lim itado, entonces es posible realizar la resolución de nom bres manualmente. En el caso de DNS o XNS, un proceso manual no tiene sentido; en su lugar se utiliza un servicio de red para permitir la resolución de nombres dinámica­ mente. En el caso de DNS, los servidores DNS se encargan de realizar el servicio de bús­ queda de nombres. Una autoridad central mantiene la base d e datos de nombres y per­ mite que la base de datos se distribuya a través d e Internet a los servidores DNS. Cuando se especifica un nombre de dominio, tanto si se introduce en un navegador como si se codifica en un programa que se va a ejecutar, dicho nombre se envía al servidor DNS más cercano para su resolución. Si el servidor más cercano no tiene la asociación, envía la petición a otro servidor DNS. La petición se propaga hasta que el nombre es resuelto, respuesta que es enviada de nuevo a l proceso que originó la petición. Unicode es un estándar para representar caracteres. De acuerdo con la página inicial de Unicode, «Unicode proporciona una [representación numérica] única para cada carácter, sin importar cuál sea la plataforma, el programa o el lenguaje» [Unicode.org, 29].______ www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones En posteriores capítulos de este libro se tendrá la oportunidad de trabajar con es­ quemas de nombrado y sus utilidades asociadas. 1 .7 . CO NCEPTO S BÁSICO S DE INGENIERÍA D EL SOFTW ARE La ingeniería del software es la disciplina d e informática que aborda el proceso de desarrollo de las aplicaciones. Aunque este libro proporciona el conocimiento técnico necesario para construir aplicaciones d e red, no cubre el proceso de desarrollo de ta­ les aplicaciones. De la misma forma, algunos de los conceptos básicos de la ingenie­ ría del software son relevantes para este libro. A continuación se introducen estos con­ ceptos. Program ación procedim ental fren te a program ación orientada a objetos A la hora de construir aplicaciones, hay dos clases de lenguajes d e programación: len­ guaje procedimental y lenguaje orientado a objetos. (Aunque existen otros tipos de lenguajes, tales como el lenguaje funcional, estos lenguajes no son normalmente uti­ lizados en aplicaciones de red.) Los lenguajes procedimentales (siendo el lenguaje C el prototipo d e este tipo de lenguajes) utilizan procedimientos para reducir la complejidad de las tareas de la apli­ cación. Por ejemplo, una aplicación puede implementarse utilizando un procednmento (también llamado función, aunque en algunos contextos el térm ino procedimiento se utiliza para funciones que no devuelven nada) que lleve a cabo la entrada, otro pro­ cedimiento para realizar la computación, y un tercer procedimiento para generar la sa­ lida. Los lenguajes orientados a objetos, como por ejem plo Java, que es el lenguaje ele­ gido para este libro, utiliza objetos para encapsular los detalles. Cada objeto simula un objeto de la vida real, almacenando tanto los datos de estado como los diferentes comportamientos del mismo. Los datos de estado se representan como variables de instancia (en Java) o variables miembro (en C++). Los comportamientos se represen­ tan mediante los métodos. U M L Un paso importante en la ingeniería del software es la producción de artefactos, o documentos, para realizar el diseño conceptual de la aplicación que se está desarro­ llando. Por legibilidad, estos documentos deben escribirse utilizando un conjunto de notaciones y lenguajes universales. El lenguaje de m odelado unificado (UML, Uai- 6 e d M odefíngL anguagt^ desarrollado por la organización Object M anagement Group [omg.org, 27] es una utilidad de este tipo. UML proporciona un conjunto común de lenguaje y notaciones «para especificar, visualizar, construir y documentar los arte­ factos de los sistemas software» [omg.org, 27]. OMG-UML proporciona un conjunto rico de herramientas para todas las facetas de la ingeniería del software. Estas herramientas son explicadas en cursos de inge­ niería del software. En este libro se utilizará ocasionalm ente una de estas notacio­ nes: los diagram as d e clase de UM L (y sólo un subconjunto de ellos), para docu- www.FreeLibros.org Introducción a la com p u ta ció n distribuida mentar las relaciones de algunas d e las clases Java que aparecen en la presentación. La Figura 1.19 presenta el subconjunto de diagram as de clase que se utilizará en este libro. Una clase o interfaz se representa d e la siguiente forma: N om bre de clase/interfaz A tributos O peraciones Una clase q u e im plem enta una interfaz Java se representa d e la siguiente forma: N om bre clase A tributos O peraciones Ntombre d e Interfaz Clase B depende Clase B im plem enta Clase B hereda de la clase A la interfaz A d e la clase A Clase A Interfaz A Clase A Atributos A tributos Operaciones O peraciones Operaciones Clase B Clase B Clase B Atributos A tributos A tributos O peraciones O peraciones Operaciones Nota: El estilo d e las líneas y la form a d e las flechas son significativas. F ig u ra 1.19. Un s u b c o n ju n to d e lo s d ia g ra m a s d e c la s e s UM L. La arquitectura de aplicaciones distribuidas La idea de utilizar una arquitectura multicapa para organizar las funciones de una red de datos se puede aplicar a las aplicaciones distribuidas. La Figura 1.20 presenta un ejemplo de dicha arquitectura. Resentación Lógica d e aplicación (negocio) Servicios F ig u ra 1.20. A rq u ite c tu ra d e la s a p lic a c io n e s d istrib u id a s. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Utilizando esta arquitectura, las funciones d e una aplicación distribuida se pueden clasificar en tres capas: • La capa de prcsm tadóa proporciona la interfaz de usuario. Por ejemplo, si la aplicación es un carrito d e la compra, esta capa genera el conjunto de páginas w eb de la tienda correspondiente que se ven desde un navegador. • La capa ló^ ca de apficarión proporciona la computación necesaria para la aplica­ ción. Esta capa también se llama cqia Hg£ca de negado para las aplicaciones em ­ presariales. En una aplicación de carrito de la compra, esta capa se encarga de tareas tales como la verificación de la tarjeta de crédito, calcular las cantidades correspon­ dientes a las peticiones, calcular los impuestos de venta o el coste de la entrega. • L a capa de servicio proporciona los servicios necesarios para soportar las fun­ ciones d e las otras dos capas. Los servicios pueden incluir utilidades de acceso a los datos (tales como un sistema de gestión de base de datos), servicios de di­ rectorio para búsquedas de nombres (tal como DNS) y comunicación entre pro­ cesos (que permita que se puedan intercambiar datos entre los procesos). Este libro se v a a centrar en la capa de servicio. Las otras dos corresponden a temas de ingeniería del software. Conjuntos de herram ientas, m arcos de desarrollo y com ponentes Los conjuntos de herramientas (más conocidos por su palabra inglesa toolkits), entor­ nos de desarrollo fram ew orks) y componentes son términos asociados con la inge­ niería del software para sistem as empresariales (es decir, aplicaciones comerciales a gran escala). En el contexto del desarrollo de software, un too B d to ñm new oH ces una colec­ ción de clases, herramientas y ejemplos d e programación. Por ejemplo, el toolkit JDK (Java Development Toolkit) es una colección de herramientas para desarrollar progra­ mas Java, mientras que el fram ew ork .NET de Microsoft está orientado a la cons­ trucción de aplicaciones web. Se supone que el lector sabe desarrollar programas Java mediante JDK; otros toolkits para computación distribuida (por ejemplo, e l Java Soc­ ket Toolkit) se cubrirán en otros capítulos de este libro. El desarrollo de software basado en componentes es una técnica para la construc­ ción de sistemas software empresariales. Utilizando esta técnica, el software se desa­ rrolla y evoluciona mediante la unión de componentes ya probados y reutilizables. Esta técnica se basa en la reutilización del software y tiene como principal ventaja que reduce significativamente los costes y errores de desarrollo [Pour, 37]. Los en­ tornos Enterprise Java Bean (EJB) y Component Object M odel (COM) (Microsoft) son plataformas que dan soporte a aplicaciones basadas en componentes. Aunque es­ tas plataformas son importantes para la computación distribuida empresarial, su estu­ dio queda fuera del alcance de este libro. En este capítulo introductorio se han discutido los siguientes temas: • Qué se entiende por computación distribuida y cómo se relaciona y diferencia d e otros tem as como los sistemas distribuidos y la computación paralela. www.FreeLibros.org Introducción a la com p u ta ció n distribuida • Conceptos básicos de sistemas operativos que son importantes para el estudio realizado en este libro. Estos conceptos incluyen a los procesos y los hilos. • Conceptos básicos de comunicación de datos relevantes para este libro. Dichos tem as incluyen I Arquitecturas de red: el modelo OSI y el modelo d e Internet I Comunicación orientada a conexión frente a comunicación sin conexión I Esquemas de nombrado para recursos de la red, incluyendo — Sistema d e Nombrado de Dominio (DNS) — Sistema d e Nombres Extensible (XNS) — Números de puertos d e protocolo — Identifícador de Recursos Uniforme (URI) y Localizador d e Recursos Uni­ forme (URL) — Dirección de correo electrónico • Conceptos básicos de ingeniería del software que son importantes para el estu­ dio realizado en este libro. Tales conceptos incluyen I Programación procedimental comparada con la programación orientada a ob­ jetos I Diagramas de clases que utilizan la notación del Lenguaje de Modelado Uni­ ficado (UML) I La arquitectura de tres capas de las aplicaciones distribuidas, que consiste en (i) la capa de presentación, (ii) la capa de aplicación o de lógica de negocio, y (iii) la capa de servicios I Los términos toolkit, fra/new ork y componente en el contexto de la ingenie­ ría del software E J E R C IC IO S 1. Computación distribuida a. Considérese la computación distribuida tal y como se ha definido en este capítulo. Para cada una de las siguientes actividades, determine y explique si es un ejemplo de computación distribuida: i. Utilizar Excel en un computador personal aislado ii. Realizar navegación web iii. La mensajería instantánea iv. Compilar y probar un programa escrito en Cobol en una máquina de­ partamental sin conexión de red v. Utilizar el correo electrónico en el computador de un departamento para enviarlo a uno mismo. vi. Utilizar Napster.com para descargar música b. En este ejercicio se utilizará un modelo matemático simplificado para ana­ lizar los fallos d e un sistema distribuido. Explique las respuestas. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Supóngase que cada computador tiene una probabilidad p de fallar cada cierto tiempo, p< 1. i. Si n computadores se interconectan y se necesita que todos los com­ putadores estén disponibles para mantener un determinado servicio, dado que se utiliza un sistem a distribuido que incluye a estos compu­ tadores, a. ¿Cuál es la probabilidad p de que el servicio no esté disponible en un determinado momento, asumiendo que ningún otro componente del sistem a distribuido falle? Exprese p como un función matemá­ tica de n y p. b. Basándose en la respuesta del apartado a, ¿cuál es la probabilidad p cuando el sistema no es distribuido, es decir, para e l caso n= 1? c. Basándose en la respuesta del apartado a, utilice p=0.2 y n =3 para calcular la probabilidad p. ¿Cómo es esta probabilidad comparada con la probabilidad de fallo en el caso de utilizar computación mo­ nolítica, es decir, en un único computador? ii. Ahora supóngase que el servicio proporcionado sólo requiere uno de los tres computadores, con los otros dos sirviendo como copias de res­ paldo o backups (es decir, cada uno de los tres computadores, es ca­ paz por sí mismo de proporcionar el servicio). ¿Cuál es la probabili­ dad d e que el servicio no esté disponible en un determinado momento, asumiendo que ningún otro componente del sistema distribuido falle? ¿Cóm o es la probabilidad d e fallo de este sistem a comparada con la probabilidad d e fallo del mismo sistema utilizando computación mo­ nolítica, es decir, un único computador? c. Investigue e l gusano de Internet [Eichin and Rochlis, 21] o un ataque de virus tal como el del virus I-Love-you [Zetter, 22] y resuma en qué con­ sisten y cómo se originaron. ¿Por qué estos hechos son significativos en la computación distribuida? Piense en algunas medidas para evitar estos pro­ blemas. d. Investigue en la «computación distribuida» (o, de forma más precisa, com­ putación colaborativa) de los proyectos seti@ home [setiathome.ssl.berke- ley.edu, 10] y genome@ home Igenomeathome.stanford.edu, 23]. Escoja uno de ellos. Escriba un informe para (i) explicar el objetivo del proyecto, (ii) explicar cómo se lleva a cabo la computación en el sistema distribuido, y (iii) explicar qué hay que hacer para participar en el proyecto. e. Investigue sobre los comienzos de Internet (véanse las referencias [vlmp.mu- seophile.com, 1], [zakon.org, 2] [silkroad.com, 3], o [Hafner and Lyon, 4], por ejemplo) y escriba un informe corto sobre una de las organizaciones clave y una de las figuras prominentes en la historia de Internet. 2. Programación concurrente a. Busque la especificación del API de Java [java.sun.com, 20]. Escoja el enlace d e la interfaz runnable y a continuación la clase thread. Lea detenidamente cada una de ellas, leyendo las especificaciones de los métodos de cada una. www.FreeLibros.org Introducción a la com p u ta ció n distribuida 39 i. De acuerdo a las especificaciones, ¿cuál de las dos, la interfaz runna- ble o la clase thread, es preferible si sólo se pretende implementar el método ruri? ¿Por qué? ii. ¿Qué hace e l método sleep de la clase thread? Escriba la sentencia (s) Java que aparece(n) en el código para que un hilo suspenda la ejecu­ ción durante 5 segundos. iii. ¿Qué hace e l método activeCount de la clase thread? ¿Qué debería de­ volver e l método en un programa donde se crean tres hilos? iv. S e dice que el método stop de la clase thread es deprecated. ¿Qué sig­ nifica que un método sea deprecated? v. ¿Cuántos métodos hay en la interfaz runnablel Nómbrelos. vi. ¿Cóm o se utiliza la interfaz runnable para crear un hilo? Explíquelo. b. Compile y ejecute los ficheros class Java que se muestran en la Figura 1.11 y que se encuentran en la carpeta de ejemplos del programa. ¿Cuál es el resultado? Capture la salida d e la ejecución y escriba un párrafo explican­ do la salida, prestando especial atención al orden de las líneas de la salida. c. Compile y ejecute los ficheros class Java que se muestran en la Figura 1.12. ¿Cuál es el resultado? Capture la salida d e la ejecución y escriba un pá­ rrafo explicando la salida, prestando especial atención al orden de las líne­ as de la salida. Además, compare la salida con la salida del apartado b (la segunda parte). d. Considérense las siguientes clases Java: i. ¿Cuál es la salida esperada cuando se ejecuta EjecHilo3? Compílelo y ejecútelo. ii. Comente la palabra reservada synchronized en la cabecera del método update. Compílelo y ejecute d e nuevo EjecHilo3. ¿Cuál es la salida? Explíquelo. p u b l i c c l a s s EjecHilo3 { p u b l i c s t a t i c v o i d m a in ( S t r i n g [ ] a r g s ) { i n t n u m H ilo s O r ig = Thread. a c t i v e C o u n t ( ) ; f o r ( i n t i = 0 ; i < 1 0 ; i + + ) { T h re a d p = new Thread (new T h r e a d 3 E je m p lo ( ) ) ; p . s t a r t ( ) ; > S y s te m . o u t . p r i n t l n ( 11 num ero h i l o s =\" + T h r e a d . a c t i v e C o u n t ( ) ) ; w h i l e ( T h r e a d . a c t i v e C o u n t ( ) > n u m H ilo O r ig ) { / / b u c l e h a s t a q u e t o d o s l o s h i l o s h a y a n f i n a l i z a d o . > S y s t e m . o u t . p r i n t l n ( \" F i n a lm e n te , n u m ero = \" + H ilo 3 E je m p lo .n u m e r o ) ; > } / / F i n c l a s e E j e c H i l o 3 Napster.com es un servicio de música digital. AudioGalaxy y KaZaA ofrecen servicios similares. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones c l a s s Hilo3Ejemplo im p le m e n ts Runnable { s t a t i c i n t n u m e ro = 0 ; T h r e a d 3 E je m p lo ( ) { s u p e r ( ) ; > p u b l i c v o i d r u n ( ) { u p d a t e ( ) ; } s t a t i c p u b l i c synchronized v o i d update ( ) { i n t m iN um ero = n u m e ro ; i n t s e g u n d o = ( i n t ) (M a th .ra n d o m ( ) * 5 0 0 . 0 ) ; t r y { T h r e a d . s l e e p (s e g u n d o ) ; > c a t c h ( I n t e r r u p t e d E x c e p t i o n e ) { > m iN um ero++; n um ero = m iN um ero; S y s te m . o u t . p r i n t l n ( \" n u m e ro = \"+ num ero+ 11; n u m e ro h i l o =\" + Thread.a c t i v e C o u n t ( ) ) ; > } / / F i n a l c l a s e H ilo 3 E je m p lo 3. Comunicación orientada a conexión frente a comunicación sin conexión En este ejercicio se utilizará un modelo matemático simplificado para compa­ rar la comunicación orientada a conexión y la comunicación sin conexión. Ex­ plique las respuestas. En una determinada red se proporcionan ambas formas de comunicación: • Utilizando comunicación orientada a conexión, establecer una conexión su­ pone 50 segundos, después de los cuales un paquete de hasta 10 caracteres se envía en 1 segundo sobre la conexión, en cualquier dirección. • Utilizando comunicación sin conexión, se puede enviar un paquete de hasta 10 caracteres en 1,2 segundos (el envío de cada paquete lleva un tiempo li­ geramente superior al del modelo orientado a conexión, debido a que cada paquete debe encontrar el camino al receptor). Supóngase que los procesos A y B intercambian mensajes en esta red. A ini­ cia la comunicación y envía un mensaje de 100 caracteres, que se reparten en 10 paquetes. En respuesta, B envía un mensaje de 50 caracteres, repartidos en 5 paquetes. Asumiendo que no hay ningún retardo diferente del correspondiente al es­ tablecimiento de la conexión (en el caso orientado a conexión) y la transm i­ sión d e los paquetes: www.FreeLibros.org Introducción a la com p u ta ció n distribuida 41 a. ¿Cuánto tiempo dura la sesión entre A y B, utilizando comunicación orien­ tada a conexión? Explíquelo. b. ¿Cuánto tiempo dura la sesión entre A y B, utilizando comunicación sin co­ nexión? Explíquelo. c. ¿Cuántos datos (en número de caracteres) deben ser intercambiados entre A y B para que la comunicación orientada a conexión lleve a una sesión más corta que la comunicación sin conexión? Explíquelo. 4. Nombrado a. ¿Cuál es el tam año del espacio d e direcciones (es decir, el número total de direcciones posibles) en cada una de las cinco clases de direcciones IPv4? Muestre los cálculos. b. Descubra la IP d e la dirección d e red asignada a la organización del lector. ¿Qué clase de red es (A hasta E)? c. Descubra e l nombre de dominio del servidor w eb de la organización del lector. ¿Cuál es su dirección IP? d. El programa de red nslookup se puede utilizar para obtener el servicio de búsqueda de nombres de DNS. Se puede invocar de al menos tres formas: • En un sistema UNIX, ejecutando nslookup desde el intérprete de man­ datos. • En un sistem as Windows, ejecutando nslookup desde la ventana de intér­ prete de mandatos. • Accediendo a la página http://cc-www.uia.ac.be/ds/nslookup.html. Utilice este servicio para completar la siguiente tabla: Dirección IP Nombre d e dambdo 127.0.0.1 ifi.uio.no ie.technion.ac.il 204.198.135.62 224.0.1.24 cse.cuhk.edu.hk 129.65.2.119 www.mit.edu e. Completar la siguiente tabla: C lase d e Id m t red (ea I d a it nodo ( a i Nombre dirección notadOa decim al notación decimal D irección IP dambdo (A-E) con puntas) con puntas) 18.181.0.31 129.65.2.119 204.198.135.62 224.0.1.24 www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones f. Utilice los códigos de país correspondientes a dominios de alto nivel lista­ dos por la autoridad IANA [iana.org, 19] para encontrar los códigos de pa­ íses de nombres de dominios correspondiente a los siguientes países: Armenia, Brasil, Canadá, Cuba, Alemania, España, Francia, Guatemala, India, Méjico, Qatar, Singapur, Suiza, El Salvador, Turquía. Identifique las naciones correspondientes a los siguientes códigos: td, tv, zw, nz, ph, pk, eg, bt, ao. g. Considérese esta URI: http://www.algunsitio.org: 8081/foo/index.html. i. ¿Cuál es el protocolo especificado? ii. ¿Cuál es el nombre del servidor? iii. ¿Cuál es el número de puerto del proceso que proporciona el servicio? iv. ¿Dónde se encuentra ubicado el documento? h. Busque los números de puertos bien conocidos a través de la página web http://www.iana.org/assignments/port-numbers. i. ¿Cuál es e l número de puerto asignado a cada uno de estos servicios: (i) FTP, (ii) telnet, (iii) SMTP, y (iv) World Wide Web HTTP? ¿Estos servicios están disponibles utilizando TCP, UDP, o ambos? ii. ¿Qué servicios están asociados a los puertos 13 y 17 respectivamente? iii. En un sistem a UNIX, o desde una ventana de intérprete de mandatos de un sistema Windows, una forma de acceder a un servicio de red es a través del siguiente mandato: telnet<espacioxnom bre dominio o dirección IP de un sistem a cono­ cido x e s p a c io x n ú m e ro de puerto asignado al servicio> Por ejemplo, el mandato telnet foo.com 13 permite acceder al servicio del proceso que ejecuta en el puerto 13 del nodo de Internet foo.com. Utilice este método para acceder a los servicios ofrecidos por el puer­ to 13 de alguna máquina conocida. Describa el resultado. i. En lugar de utilizar el esquema d e Internet que usa el número de puerto del protocolo como parte de la dirección para la entrega de datos a un proce­ so en una determinada máquina, considérese un esquema alternativo donde e l proceso se localiza utilizando un identificador de proceso único (PID), d e forma que el sistema operativo UNIX se encarga de asignar dicho iden­ tificador a cada proceso activo. Obsérvese que el PID se asigna de forma dinám ica a cada proceso cuando se crea, de forma que no es posible co­ nocer a priori el identificador del proceso. Además, el rango de valores para los PID varía de un sistem a a otro. ¿Cuáles son los problemas, si existen, de este esquema de direcciones? j. Un esquema de nombrado se dice que proporciona transparencia d e loca- tizarión [community-ml.org, 25] si permite acceder a los objetos sin espe­ cificar de forma explícita su ubicación física. Por ejemplo, e l sistema de numeración de teléfonos de EEUU proporciona transparencia de localiza­ ción, ya que quien llam a no necesita conocer donde se encuentra la perso­ na que recibe la llamada. Por otro lado, el sistema d e direcciones del ser­ vicio postal de EEUU no permite transparencia de localización, ya que es necesario conocer la dirección física del receptor (excluyendo los números de apartado de correos). www.FreeLibros.org Introducción a la com p u ta ció n distribuida Considérese los siguientes esquemas de nombrado. Para cada uno d e ellos, determine si proporcionan transparencia de localización. Justifique la res­ puesta. i. El sistema de nombres de dominio (DNS) ii. El localizador de recursos uniforme (URL) iii. El localizador de recursos de nombre (URN) iv. El servicio de nombres extensible (XNS) 5. Diagrama d e clases UML a. Utilizando la notación mostrada en la Figura 1.19, dibújese el diagrama de clases de las clases de la Figura 1.11. b. Utilizando la notación mostrada en la Figura 1.19, dibújese el diagrama de clases de las clases de la Figura 1.12. R E FER EN C IA S 1. 0 museo virtual de la computación, http://www.museophile.com/computing.html 2. Descripción temporal de Internet de Hobbes - la definitiva historia de ARPAnet & Inter­ net, http://www.zakon.org/robert/internet/timeline/ 3. E l grupo S ilk Road, Lid, una breve historia de las redes, http://w ww.silkroad.com /net- history.html 4. Katie Hafner and Matthew Lyon. Where Wizards Stay Up Late: The Origins o f th e Inter­ net. New York, NY: Simón & Schuster, 1996. 5. Archivos de Internet RFC/STD/FYI/BCP, http://www.faqs.org/rfcs/ 6. Todd Cam pbell, «The fir s t em a il m essage», P R E T E X T Magazine, 1998. h ttp ://w w w . pretext.com/mar98/features/story2.htm 7. http://w ww.sun.com /jini/overview/, Septiembre 2000. 8. webopedia, http://webopedia.intemet.com 9. A lic e E. Koniges. Industrial Strength Paraüel Computing. San Francisco, CA: Morgan Kauf- man Publishers, 2001. 10. SETI@ home, the Search fo r Extraterrestrial Intelligence, http://setiathome.ssl.berkeley.edu/ 11. Recursos Java, http://www.csc.calpoly.edu/~mliu/javaResources.html 12. W illia m Stallings. Data a n d Computer Communications. Upper Saddle River, NJ: Prentice H all, 1999. 13. Andrew S. Tanenbaum. Computer N etworks. Upper Saddle River, NJ: Prentice Hall, 1996. 14. Chuck Semeria, 3Com Corporation, Understanding IP Addressing: Everything You Ever Wanted To Know, 1996, http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf 15. M a rs h a ll B rain, C uestión d e l día, h ttp ://w w w .h o w s tu ffw o rk s .c o m /q u e s tio n 5 4 9 .h tm , HowStuffWorks 16. Acerca de dominios, about domains, http://www.aboutdomains.com/News/basics.htm 17. E l Centro Nacional de Aplicaciones de Supercomputación (NCSA). Una guía para princi­ p iantes sob re U R L , h ttp ://a rc h iv e .n c s a .u iu c .e d u /S D G /E x p e rim e n ta l/d e m o w e b /u rl- primer.html 18. Dan Connolly. Nombrado y direcciones: UR I, U R L http://www.w3.org/Addressing/ 19. Internet Assigned N um ber Authority. Códigos de países de los dom inios de alto nivel, http://www.iana.org/cctld/cctld.htm 20. Especificación del A P I de la plataforma Java 2 v i . 4, http://java.sun.eom/j2se/l.4/dos/api/ index.html www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones 21. M ark W. E ich in a n d Jo n A . R ochlis, M assachusetts Institute o f T echnology. With Micros- copes and Tweezers: An Anatysis o f the Internet Virus o f 1988, http://w w w .m it.edu/peo- ple/eichin/virus/m ain.htm l 22. K im Z etter. P C W orld.com , «When Love Carne to Town: A Virus Investigation», 13 N o­ viem bre, 2000. 23. The gen o m e@ h o m e project homepage, h ttp://genom eathom e.stanford.edu/ 24. Internet Assigned Numbers Authority, http://w w w .iana.org/ 25. M odelo d e referencia para O D P (Open Distributed Processing) (R M -O D P), ISO /IE C IS 10746|IT U -T X .900, http://com m unity-m l.org/R M -O D P / 26. X N S - frequently asked questions, http://w w w .xns.org/, X N SO R G . 27. ¿ Q u é e s O M G U M L ? http://w w w .om g.org/gettingstarted/w hat_is_um l.htm 28. G uía d e notación d e U M L - Versión 1.1, http://w w w .inform atikfh-luebeck.de/~st/U M L/U M Ll. 1/ 29. P ágina inicial d e U nicode, http://w w w .unicode.org/ 30. M ichael Fischer, N ancy L ynch, a n d M ichael S . Paterson. «Impossibility o f distributed con- sensus with one faulty process». Proceedings o f the 2* ACM Symposium on Principies o f Database Systems, páginas 1-7, 1983. 31. Pankaj Palote. Fault Tolerance in Distributed Systems. U pper S a d d le R iver, NJ: Prentice H all, 1994. 32. S c o tt O ak s. Java Security, Sebastopol, CA: O ’R eilly Press, 2001. 33. distributed.net: Node Zero, http://w w w .distributed.net/ 34. Internet Security Alliance, http://w w w .isalliance.org/ 35. A n d re w T anenbaum . Computer Networks. U ppers S a d d le R iver, NJ: P rentice H all, 1996. 36. http://w w w .iana.org/assignm ents/port-num bers 37. G ilda Pour. «Web-Based Architecture fo r Component-Based Application Generators». The International Multiconference in Computer Science, L as V egas, N evada, 2002. 38. Internet Society (ISO C), T o d o so b re Internet: H istoria d e Internet, http://w w w .isoc.org/in- tem et/h isto ry / www.FreeLibros.org CAPÍTULO IP C - C o m u n ic a c ió n e n t r e p r o c e s o s La espina dorsal de los sistem as d istribuidos son los m ecanism os de com unicación entre procesos (interprocess com m unication o IPC): la posibilidad de que procesos separados e independientes (com o podrá recordar el lector, los procesos son representaciones en tiem po de ejecución de programas) se com uniquen entre sí para colaborar en una tarea. En este capítulo, se van a ver los fundam entos, características, paradigm as e im plem entaciones de los m ecanism os de com unicación entre procesos. La Figura 2.1 ilustra un m ecanism o básico de com unicación entre procesos: dos procesos independientes, con la posibilidad ejecutarse en m áquinas separadas, intercam bian datos sobre una red de com unicaciones. En este caso, el proceso 1 actúa com o em isor, que transm ite datos al proceso 2, el receptor. P roce so 1 Proceso 2 Datos _ M E m isor R e ce p to r F ig u ra 2 .1 . C o m u n ica ció n e n tre p ro ceso s. En sistem as d istrib u ido s, dos o más procesos establecen una com unicación entre ellos por m edio de un protocolo (un conjunto de reglas que deben ser observadas p o r los participantes en la Un paradigma es un modelo abstracto de cómo se realiza una determinada tarea. www.FreeLibros.org 4 6 C om putación distribuida. Fundam entos y aplicaciones En ingeniería del software, se denomina abstracción a un mecanismo para ocultar las complejidades internas de una tarea. Fbr ejemplo los lenguajes de alto nivel, como Java, proporcionan una abstracción que permite al programador tener que comprender los detalles al nivel del sistema operativo._____________ com unicación de los datos) acordado por los procesos. Un proceso puede ser em isor en determ inados puntos durante el protocolo y re ce ptor en otros. C uando la com unicación es desde un proceso a únicam ente otro proceso, el m odelo de com unicación entre procesos se d ic e que es unidifusión o u n ic a s t. C uando la com unicación es desde un proceso con un grupo de procesos, el m ecanism o de com unicación se denom ina multidifusión o m u ltic a s t, que será tratado en el C apítulo 6. La Figura 2.2 ilustra el concepto de estos dos tip o s de IPC. U nidifusión M u ltid ifu sió n F ig u ra 2 2 . U n ica st y m u ltica st. Los sistem as operativos actuales, com o UNIX y W indow s proporcionan funcionalidades para la com unicación entre procesos. Llamaremos a estas funcionalidades m ecanism os de com unicación entre procesos a nivel de sistem a operativo, para distinguirlos de los m ecanism os de com unicación de alto nivel. Los mecanism os de com unicación a nivel de sistem a operativo incluyen colas de mensajes, sem áforos, y regiones de m em oria com partida. (Si el lector no ha realizado un curso de sistem as operativos, no se preocupe si no le resultan familiares estos térm inos; no van a ser casos de estudio en este libro). Es posible desarrollar softw are de red usando directam ente estas funcionalidades a nivel de sistem a operativo. Ejemplos de estos program as son los manejadores (drivers) de red y los program as de evaluación de prestaciones. Se pueden desarrollar tam bién aplicaciones distribuidas muy rudim entarias aunque norm alm ente no se hace, d e b id o a que la com plejidad típica de estas aplicaciones requiere el uso de algún tip o de abstracción para separar al program ador de los detalles a nivel de sistem a operativo. El lector puede encontrar más inform ación sobre m ecanism os de com unicación a nivel de sistem a operativo en libros sobre dichos sistem as operativos. www.FreeLibros.org IPC - C om unicación entre procesos 2 .1 . UN A R Q U E T IP O DE IN TE R F A Z DE PR O G R A M A C IÓ N PARA C O M U N IC A C IÓ N E N TR E PRO CESO S A continuación se va a presentar una interfaz de programación que proporciona el mí­ nimo nivel de abstracción para facilitar la comunicación entre procesos. Para ello se necesitan cuatro operaciones primitivas básicas. Los detalles acerca de estas opera­ ciones (tales como los argumentos y los valores devueltos) se verán cuando se co­ menten herramientas y funcionalidades específicas a lo largo de los siguientes capí­ tulos. Estas operaciones son: • Enviar. Esta operación se invoca por el proceso emisor con el propósito de transmitir datos al proceso receptor. La operación debe permitir al proceso em i­ sor identificar al proceso receptor y especificar los datos a transmitir • Recibir Esta operación es invocada por e l proceso receptor con el objetivo de aceptar datos de un proceso emisor. La operación debe permitir al proceso re­ ceptor identificar al proceso em isor así como especificar e l área de memoria que permitirá alm acenar e l mensaje, que posteriormente será accedida por el receptor. • C on ecte. Para mecanismos de comunicación orientados a conexión deben exis­ tir operaciones que permitan establecer una conexión lógica entre el proceso que lo invoca y otro proceso determinado: un proceso invoca una operación de so- B c ite canedón (denominada conectar en adelante) mientras que e l otro pro­ ceso solicita la operación de acepte-conerión. • D esconecte. Para mecanismos d e comunicación orientados a conexión, esta operación permite que una conexión lógica, previamente establecida, sea libe­ rada en am bos extremos de la comunicación. Un proceso involucrado en un mecanismo de comunicación invoca estas operaciones en un orden determinado. La invocación d e cada operación implica la ocurrencia de un evento. Por ejemplo, una operación de enviar solicitada por el proceso emisor de­ semboca en el evento de transmisión de datos hacia el proceso receptor, mientras tan­ to la invocación de la operación recibir por parte del proceso receptor implica que di­ chos datos sean entregados al proceso. Es necesario indicar que los procesos participantes invocan operaciones de forma independiente, y a que no hay forma de conocer el estado del otro proceso. Todos los paradigmas de sistem as distribuidos que se van a ver en este libro propor­ cionan, implícita o explícitamente, operaciones de comunicación entre procesos. El si­ guiente capítulo (Capítulo 3) presentarán una jerarquía de los paradigmas de sistemas distribuidos. En los siguientes capítulos, se verán ejemplos de cómo se utilizan estos paradigmas en protocolos, herramientas y funcionalidades. Los protocolos de servicio de red pueden ser implementados usando operaciones de comunicación entre procesos primitivas. Por ejemplo, en e l protocolo HTTP bási­ co (HyperText Transfer Protocol, protocolo de transferencia de hipertexto, usado de forma extensiva en el entorno web, que será estudiado en próximos capítulos) un pro­ ceso, el navegador web, invoca una operación conectar para establecer una conexión lógica con otro proceso, el servidor web, seguido de una operación enviar hacia el servidor web, para transmitir los datos que representan una solicitud. El servidor web como respuesta invoca una operación enviar para transmitir los datos solicitados por el navegador web. Al finalizar la comunicación, cada proceso invoca su operación des­ conectar para finalizar con la conexión. La Figura 2.3 ilustra la sequencia de opera- www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones dones. Se verán protocolos de servicio de red como HTTP más adelante en este y otros capítulos. |_____| Un proceso O un a operación Flujo d e da tos S ervidor Web ® ® k @ @ Petición HTTP Respuesta HTTP © © © i r@ Navegador Web O p e ra c io n e s : S I : ace ptar conexión S2: recibir {petición) S3: enviar (respuesta) S4: d esco n ecta r C1: realizar conexión C2: enviar (petición) C3: recibir (respuesta) C4: d esco n ecta r F ig u ra 2 .3 . C o m u n ica ció n e n tre p ro c e s o s e n HTTP básico. En el resto de este capítulo se van a tratar determinados aspectos clave de estas operaciones de comunicación entre procesos. 2 .2 . S IN C R O N IZ A C IÓ N DE EVEN TO S Una de las mayores dificultades cuando se trabaja con mecanismos de comunicación entre procesos es que cada proceso involucrado ejecuta de forma independiente sin que ninguno de ellos sepa qué ocurre en el proceso en el otro extremo. S i tenem os en cuenta e l caso del protocolo básico HTTP, tal y como lo hemos descrito antes, como se puede observar, los dos extrem os involucrados en el pro­ tocolo invocan operaciones de com unicación en un orden determ inado. Por ejem ­ plo, el proceso del navegador w eb no debe invocar ninguna operación enviar an ­ tes de haber com pletado la operación conectar. Tam bién es im portante que el servidor w eb no em piece a transm itir datos antes d e que e l proceso del navegador w eb esté preparado. Aún más, el proceso navegador necesita conocer cuándo los datos solicitados se han transm itido, d e tal m anera que el subsiguiente procesa­ miento de los m ism os tenga lugar, incluyendo el d ar formato y m ostrar los conte­ nidos al usuario. La forma más sencilla que tiene un mecanismo de comunicación de procesos para proporcionar sincronización d e eventos es por medio de peticiones M oqueantes, que es la supresión de la ejecución del proceso hasta que la operación invocada haya fi­ nalizado. Para ilustrar el uso de las llamadas bloqueantes en la sincronización de eventos, se va a considerar de nuevo el caso del protocolo HTTP básico. Un proceso de na­ www.FreeLibros.org IPC - C om unicación entre procesos vegador web invoca una operación bloqueante para conectar, que bloquea su poste­ rior ejecución hasta que la conexión haya sido aceptada por el lado servidor. Poste­ riormente, el proceso navegador invoca una operación recibir bloqueante, la cual sus­ pende la ejecución del proceso hasta que la operación se haya completado (con éxito o no). La opción bloqueante o no bloqueante se realiza a nivel del sistema operativo y se inicia por medio d e las funcionalidades proporcionadas por el mecanismo de co­ municación entre procesos, no por e l programador. Los programas de los dos proce­ sos se muestran en la Figura 2.4. Program a del nave ga do r W e b Program a del servidor W e b conectarse c o n el servidor ace ptar una conexión enviar (servidor w eb, petición) recibir (proceso navegador web) procesar los d a to s recibidos enviar (proceso navegador web) recibir (servidor web) desconectar procesar los d a to s recibidos F ig u ra 2 .4 . R u jo d e e je c u c ió n d e d o s p ro gra m as q u e in te rvie n e n e n un a c o m u n ic a c ió n entre p ro ceso s. Durante su ejecución, el proceso se suspende después de que se invoque cada llamada bloqueante. Cada vez que se ejecuta una invocación a una operación blo­ queante, la condición de bloqueo se inicia por las funcionalidades de comunicación entre procesos en conjunto con el sistem a operativo sobre el que se apoya. La con­ dición de bloqueo term ina posteriorm ente cuando la operación ha sido completada, en dicho instante se dice que e l proceso se encuentra desbloqueado. Un proceso des­ bloqueado transita a l estado de listo y en su m om ento continuará la ejecución. En el caso de que la operación no pueda ser completada, un proceso bloqueado sufri­ rá un bloqueo indefinido, durante el cual e l proceso perm anecerá en el estado de bloqueado indefinidamente, a m enos que se tom en las m edidas de intervención apro­ piadas. Las operaciones bloqueantes a menudo se llaman o p ta cio n es síncronas Como alternativa, las operaciones de comunicación entre procesos también pueden ser asin­ cronas o no bloqueantes. Una operación asincrona invocada por un proceso no cau­ sará bloqueo, y por consiguiente e l proceso es libre de continuar con su ejecución una vez que se invoca al mecanismo de comunicación para realizar la operación asincro­ na. Se informará posteriormente a l proceso si la operación se ha completado y si lo ha sido con éxito o no. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Un proceso puede invocar una operación no bloqueante cuando el proceso puede continuar sin esperar a que se complete el evento iniciado por la operación. Por ejem ­ plo, la operación recibir invocada por el navegador web debe esperar a la respuesta del servidor para poder continuar con el procesamiento. Por e l contrario, la operación enviar invocada por el servidor w eb puede ser no bloqueante, porque el servidor web no necesita esperar a que la operación se haya completado antes de proceder con la siguiente operación (la operación desconectar), de forma que puede continuar sirviendo a otros procesos navegadores. Es responsabilidad del programador reconocer la necesidad de sincronización y de cuándo una llamada es bloqueante. Por ejemplo, si se invoca una operación recibir no bloqueante en el código del navegador web, debido a un programador descuidado, se asume que los datos se reciben inmediatamente después de que se invoque la opera­ ción, e l procesamiento posterior puede mostrar datos que no sean válidos o, peor aún, generar errores. Debido a que el uso de operaciones enviar y recibir es fundamental para los sis­ tem as distribuidos vamos a ver diferentes escenarios en los cuales se usan diferentes combinaciones de estos modos. E n via r síncrono y re c ib ir síncrono La Figura 2.5 es un diagrama, que a lo largo de este libro vamos a denominar dia- gpama d e evadas, que ilustra la sincronización de los eventos para una sesión de un protocolo implementada por medio de una operación enviar y una recibir síncronas. En este escenario, la invocación de la operación recibir causa la suspensión del pro­ ceso que la invoca (proceso 2) hasta que se reciben los datos y se completa la ope­ ración. De la misma forma, la operación enviar invocada causa que el proceso em i­ sor (proceso 1) se suspenda. Cuando se reciben los datos enviados al proceso 2, el P ro c e s o 1 P ro c e s o 2 ejecutando en co m p u ta d o r 1 ejecutando en co m p u ta d o r 2 com ienza* enviar bloqueante retorna— enviar bloqueante Asentim iento transparente proporcionado por la librería IPC i-com ienza recibir bloqueante -te rm in a recibir bloqueante Una operación Flujo d e ejecución Período suspendido F ig u ra 2 .5 . E n via r y re c ib ir síncron os. www.FreeLibros.org IPC - C om unicación entre procesos mecanismo de comunicación entre procesos en e l ordenador 2 envía un asentimiento al mecanismo de comunicación análogo del ordenador 1, y el proceso 1 puede poste­ riormente desbloquearse. Es necesario remarcar que el asentimiento se gestiona por medio de los mecanismos de comunicación de ambos computadores y que es trans­ parente para el proceso. El uso de un enviar síncrono y un recibir síncrono es aconsejable cuando la lógi­ ca de la aplicación de ambos procesos necesita que los datos enviados se reciban an­ tes de continuar con el procesamiento. Dependiendo de la implementación de las funcionalidades de comunicación entre procesos, la operación recibir síncrona puede no completarse hasta que la cantidad de datos esperada por el receptor haya llegado. Por ejemplo, si el proceso 2 invoca una operación de recibir para 300 bytes de datos, y la operación enviar sólo transmite 200 bytes, es posible que el bloqueo del proceso 2 continúe incluso después d e haberse entregado los primeros 200 bytes; en este caso, el proceso 2 no se desbloqueará has­ ta que el proceso 1 transmita posteriormente los 100 bytes de datos restantes. E nviar asincrono y re c ib ir síncrono En la Figura 2.6 se ilustra un diagrama de eventos para una sesión de protocolo im- plementada usando una operación d e enviar asincrona y una operación de recibir sín­ crona. Como antes, la operación recibir bloquea al proceso que la invoca hasta que lleguen datos para completar la operación. Sin embargo, la operación enviar invoca­ da no va a causar que el proceso emisor se suspenda. En este caso, como e l proceso emisor no se bloquea no resulta necesario un asentimiento por parte del mecanismo de comunicación en el ordenador del proceso 2. Este uso de una operación de enviar asincrona y una de recibir síncrona es apropiado cuando la lógica de la aplicación emisora no depende de la recepción de los datos por parte del otro extremo. Sin em- P roceso 1 Proceso 2 T comienza recibir bloqueante • — enviar no bloqueante — retornar recibir bloqueante F ig u ra 2 .6 . E n via r a s in c ro n o y re c ib ir síncrono. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones bargo, dependiendo de la implementación del mecanismo de comunicación, no se ga­ rantiza que los datos enviados, realmente sean entregados a l receptor. Por ejemplo, si la operación enviar es ejecutada antes de que la correspondiente de recibir sea invo­ cada en el otro extremo, es posible que los datos no se entreguen al proceso recep­ tor, a menos que el mecanismo de comunicación proporcione espacio para almacenar datos enviados de forma prematura. E n via r síncrono y re c ib ir asincrono La Figura 2.7 ilustra los diferentes escenarios de un protocolo de sesión que emplee operaciones de enviar síncrono y de recibir asincrono. Escenario 1: enviar síncrono y recibir asincrono Proceso 1 i-Invocado enviar bloqueante Asentimiento transparente proporcionado por la librería IPC J G Proceso 2 I-Invocado recibir no bloqueante Escenario 2: enviar síncrono y recibir asincrono Proceso 1 1 - Invocado enviar bloqueante Bloqueo indefinido Proceso 2 f Invocado recibir no bloqueante y retorno inmediato Escenario 3: enviar síncrono y recibir asincrono Proceso 1 Proceso 2 i í-In v o c a d o recibir no bloqueante y A - Invocado retorno enviar inmediato bloqueante al procesóse le notif ica de la legada de los datos Asentamiento transparente proporcionado f por la librería IPC Una operación Flujo de ejecución Periodo suspendido F ig u ra 2 .7 . E n via r s ín c ro n o y re c ib ir asincro no. www.FreeLibros.org IPC - C om unicación entre procesos Una operación de recibir asincrono causa que e l proceso que la invoca no se blo­ quee, y e l comportamiento dependerá mucho de cómo se encuentre implementado el mecanismo de comunicación. La operación recibir, en todos los casos, retomará in­ mediatamente, existiendo tres posibles escenarios de qué ocurriría a continuación: • Escenario 1. Los datos solicitados por la operación del receptor ya han llegado en el momento que la operación recibir se invoca. En este caso los datos se en­ tregan a l proceso 2 inmediatamente, y el proceso 1 se desbloqueará por medio de un asentamiento transmitido por el mecanismo de comunicación del orde­ nador 2. • Escenario 2. Los datos solicitados por la operación recibir no han llegado to ­ davía; el proceso receptor no recoge ningún dato. Es responsabilidad del pro­ ceso receptor cerciorarse d e que los datos se han recibido, si es necesario, re­ petir el proceso hasta que los datos hayan llegado. (Nótese que es común que el programa utilice un bucle para invocar a la operación recibir repetidas veces hasta que el dato esperado llegue. Este técnica de repetir intentos se denomina muestreo, en inglés polling.) El proceso 1 se queda bloqueado de forma inde­ finida hasta que e l proceso 2 vuelve a invocar a recibir y e l asentimiento fi­ nalmente le llega por parte del mecanismo de comunicación del ordenador 2. • Escenario 3. Los datos solicitados por la operación recibir no han llegado aún. El mecanismo de comunicación del ordenador 2 notificará a dicho proceso cuan­ do los datos solicitados hayan llegado, en dicho instante el proceso 2 puede pa­ sar a procesarlos. Este escenario requiere que el proceso 2 proporcione un ma- nejador de evento que puede invocarse por parte del mecanismo de comunicación para notificar al proceso que los datos esperados han llegado. E nviar asincrono y re c ib ir asincrono Sin ningún bloqueo en cualquiera de los dos lados, la única forma en que los datos puede entregarse al receptor es que el mecanismo de comunicación pueda almacenar los datos recibidos. El proceso receptor puede ser notificado de la llegada de los da­ tos (véase la Figura 2.8). Otra alternativa es, que el proceso receptor haga muestreo en busca de la llegada de datos, para su posterior procesamiento. Proceso 1 Proceso 2 O -Invocado enviar no bloqueante ^ - I n v o c a d o recibir no bloqueante y retornando inmediatam ente Al proceso se le notifica d e la llegada d e da tos y los d a to s ya le pueden ser entregados Una operación Rujo d e ejecución Fteriodo suspendido Fig u ra 2 .8 . E n via r a s in c ro n o y re c ib ir asincro no. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones 2 .3 . T E M P O R IZ A D O R E S E H ILO S DE EJE C U C IÓ N Aunque e l bloqueo proporciona la sincronización necesaria para los mecanismos de comunicación, es por lo general inaceptable que un proceso se quede suspendido de forma indefinida. Existen dos medidas para solucionar este problema. L a primera es el uso de tanporizadores (timeouts), que se pueden utilizar para fijar el tiempo má­ ximo d e bloqueo. Los temporizadores los proporciona el propio mecanismo de co­ municación y pueden ser fijados desde e l programa por medio de una operación. En segundo lugar, un proceso puede lanzar otro proceso h ijo o un faOo d e ejecución (thread) independiente para invocar la operación bloqueante, permitiendo de esta ma­ nera al hilo de ejecución principal o al proceso padre del programa seguir ejecutan­ do otras tareas de procesamiento mientras el hilo de ejecución o proceso hijo se sus­ pende. La Figura 2.9 ilustra este uso de los hilos de ejecución. T ie m p o P roce so Hilo principal \\ Una operación Hilo en ejecución Hilo bloqueado El hilo principal continúa su propia ejecución Y Nuevo hilo qu e invoca a la IPC bloqueante Hilo bloqueado Hilo desbloqueado una vez que la operación se ha com pletado F ig u ra 2 .9 . U tilización d e un h ilo d e e je c u c ió n para una o p e ra ció n b lo q u e a n te . Los temporizadores son importantes si la ejecución de operaciones síncronas pue­ de potenciaímente dar como resultado un bloqueo indefinido. Por ejemplo, una ope­ ración bloqueante de conectar puede causar que el proceso que la solicita se quede suspendido d e forma indefinida si la conexión no está establecida y no se puede es­ tablecer debido a una caída en la red de interconexión entre ambos ordenadores. En esta situación, es típicamente inaceptable para el proceso solicitante quedarse «colga­ do» de forma indefinida. Los bloqueos indefinidos pueden resolverse usando tempo­ rizadores. Por ejemplo, se puede fijar un temporizador de 30 segundos para la opera­ ción de conectar. Si la petición no se completa en aproximadamente 30 segundos, el mecanismo d e comunicación la abortará, en dicho instante el proceso que la solicitó se desbloqueará, pudiendo así continuar con su procesamiento. 2 .4 . IN TE R B L O Q U E O S Y T E M P O R IZ A D O R E S Otra causa para sufrir un bloqueo indefinido son los intcrbloqueos (deadlocks). En comunicación entre procesos, un interbloqueo puede causarse por una operación in­ www.FreeLibros.org IPC - C om unicación entre procesos 55 vocada d e forma no apropiada, quizás por culpa de una mala interpretación del pro­ tocolo o por errores de programación. La Figura 2.10 muestra este caso. El proceso 1 h a invocado una operación de recibir para recoger datos del proceso 2. A la vez, el proceso 2 ha invocado otro recibir bloqueante cuando debería ser una operación de enviar lo apropiado. Como resultado, ambos procesos se encuentran bloqueados a es­ peras de datos del otro, cosa que nunca puede ocurrir (debido a que cada proceso se encuentra bloqueado). En resumen, cada proceso por su parte se encontrará suspendi­ do indefinidamente hasta que salte un temporizador o hasta que el sistem a operativo aborte el proceso. Proceso 1 Proceso 2 Invocado \"recibird e l proceso 2 \"; El proceso I queda bloqueado a espera de datos del proceso 2 Una operación Proceso ejecutando Proceso bloqueado i Invocado \"recibirdel proceso I\"; El proceso 2 queda bloqueado a espera de datos del proceso I F ig u ra 2 .1 0 . Un in te rb lo q u e o c a u s a d o p o r o p e ra c io n e s bloq u e a n te s. 2 .5 . R EPR ESEN TA C IÓ N DE DATOS En el nivel físico de una arquitectura de red (que es el nivel más bajo, en oposición al nivel de aplicación que es el más alto), los datos se transmiten como señales an a- ló ^ c a s las cuales representan un flu jo b i n a i o En el nivel de aplicación, se necesi­ ta una representación más compleja de los datos transmitidos con el objeto de dar so­ porte a la representación de tipos de datos y estructuras proporcionadas por los lenguajes de programación, tales como cadenas de caracteres, enteros, valores en coma flotante, vectores, registros y objetos. Si consideramos el caso simple de dos procesos, proceso 1 en el ordenador A y proceso 2 en el ordenador B, que participan en un protocolo que implica el inter­ cambio de un valor entero durante su ejecución. El proceso 1 calcula el valor e in­ voca una operación enviar para mandar e l valor al proceso 2, el cual invoca una ope­ ra c ió n r e c ib ir p ara re c o g e r d ic h o valor, p ara que e l p ro ceso 2 re a lic e las correspondientes operaciones con dicho valor, todo de acuerdo al protocolo estable - cido. Si nos centramos en el valor entero que el proceso 1 tiene que enviar. El valor en­ tero se encuentra representado en e l formato de representación del ordenador A, que e s una máquina de 32-bits que utiliza representación big-endian para tipos de datos d e varios bytes. (Los térm inos big-endian y little-endian indican cuál es el byte más significativo en representaciones de valores de varios bytes de tamaño. En arquitec­ Analógico es lo opuesto a digital: hace referencia a algo mecánico, en oposición a algo que representa datos. El procesamiento de señales analógicas es un área de trabajo dentro de redes de computadores. Un flujo binario es un flujo de bits (0 y 1), tal como 00101...1010111. www.FreeLibros.org 5 6 C om putación distribuida. Fundam entos y aplicaciones Se denominan computadores heterogéneos a aquellos computadores que dsponen de diferente hardware y por tanto de diferentes representaciones de datos. ASCII son las siglas de American Standard Code for Information Interchange pódigo estándar americano para intercambio de información), y es un esquema de codificación usado para caracteres del alfabeto inglés usando un rango de \\elores de 0 a 127. Unicode es un esquema de codificación complejo que permite traducir caracteres, no sólo del alfabeto inglés, a valores numéricos entre 0 y 65535. Para una definición más precisa, véase http://www.unicode.org. turas de tipo big-endian, e l byte más a la izquierda [el de menor dirección) es el más significativo. En arquitecturas, little-endian es el byte más a la derecha el más signi­ ficativo) . El computador B, por su parte, es una máquina de 16-bits con representación de datos little-endian. Supóngase que el dato de 32 bits es transmitido directamente des­ de el espacio de almacenamiento del proceso 1 al espacio reservado por el proceso 2. Entonces (1) 16 bits d e los 32 enviados van a ser truncados ya que el tamaño de un entero en el computador B es de sólo 16 bits y (2) el orden de los bytes de la repre­ sentación de los enteros debe ser intercambiado de forma que se interprete correcta­ mente el mismo valor por parte del proceso receptor. Como se ha visto en el ejemplo, cuando computadores heterogéneos participan en una comunicación entre procesos, no basta con transmitir los valores d e los datos o las estructuras usando flujos de bits en crudo a menos que los procesos participantes tomen las medidas oportunas para empaquetar e interpretar los datos d e forma apro­ piada. Para nuestro ejemplo hay tres esquemas para hacer esto: 1. Antes de invocar a la operación enviar, el proceso 1 convierte el valor entero a 16-bits en formato little-endian para el proceso 2. 2. El proceso 1 envía los datos en 32-bits y representación big-endian. Tras re­ cibir los datos, el proceso 2 convierte el valor a su formato, 16-bits y little- endian. 3. Un tercer esquema es que los procesos cuando intercambien datos lo hagan en una refresoitad ón «tern a: los datos se van a enviar transformados a esa re­ presentación y los datos recibidos se van a interpretar con esa representación y se van a traducir a la representación nativa. Tomando otro ejemplo, supongamos que el proceso 1, ejecutándose en el ordenador A, desea enviar un simple carácter a al proceso 2, ejecutándose en e l ordenador B. El programa para el proceso 1 usa ASCII como representación de caracteres, mien­ tras que el programa del proceso 2 usa Unicode. El esquema 1 obligará al proceso 1 a convertir el carácter a a Unicode antes de enviarlo. El esquema 2 requerirá que el proceso 2 reciba el dato, y lo convierta d e ASCII a la representación Unicode co­ rrespondiente. El esquema 3 exigirá que ambos extremos se pongan d e acuerdo en una representación externa, digam os ASN. 1 (Abstract Syntax Notation Number 1), de forma que el proceso 1 convierta el carácter a a ASN. 1 antes de mandarlo, y e l pro­ ceso 2 convierta e l dato recibido de ASN. 1 a la representación Unicode. (La repre­ sentación A S N .l se explicará en la Sección 2.6.) S i se considera otro caso más cuando se transmite una estructura de datos, como por ejemplo una lista de valores, adem ás de lo necesario d e representación externa de los valores de datos, existe en este caso la necesidad de «aplanar» o señalizar la es­ tructura d e datos en el extrem o del emisor y deshacer el cambio en el otro extremo, para así reconstruir los datos. El término de enqraquetamiento d e datos (data marshaling) se usa en el con­ texto de los mecanismos de comunicación entre procesos para referirse a las trans­ formaciones necesarias para transmitir valores de datos o estructuras. El empaqueta­ miento de datos se necesita para todos los mecanismos de comunicación e incluye los pasos necesarios para acondicionar los datos para ser transmitidos: (1) serialización de las estructuras de datos, y (2) conversión de los valores de datos a las representa­ ciones externas. La Figura 2.11 muestra el concepto d e empaquetamiento de datos. Para aplicaciones de red escritas en lenguajes orientados a objetos como Java, unas estructuras de datos que requieren especial atención en lo referente al empaquetamiento www.FreeLibros.org IPC - C om unicación entre procesos «Esto es una prueba» 1.2 | 7.3 | -1.5 C o m p u ta d o r A 110011 . .. 1 0 0 0 0 1 0 0 ... U n m a rs h a lin g 1. Aplanado d e los cam p os d e la estructura d e datos. 2. C onversión d e los d a to s a la representación exte rn a (de red). 1. Conversión d e los d a to s a la representación interna. 2. R econstrucción d e las estructuras d e datos. La conversión d e representación interna a externa, y viceversa no es necesaria si: -los d o s extrem o s s o n el m ism o tip o d e com p utad ora ; o -s i los d o s extrem o s negocian una conexión. C o m p u ta d o r B F ig u ra 2 .1 1 . E m p a q u e ta m ie n to d e d a to s. de datos son los propios objetos. A diferencia de estructuras de datos estáticas como vectores o registros, un objeto encapsula tantos datos (representando el estado del ob­ jeto), como métodos (representando el comportamiento del objeto). Si se va a trans­ mitir un objeto usando un mecanismo de comunicación entre procesos es necesario que el proceso de empaquetamiento (de nuevo aplanado y codificación) cubra tanto a los datos como a la representación de métodos, incluyendo e l estado de ejecución, de forma que el objeto una vez desempaquetado por el proceso receptor pueda funcio­ nar como un objeto ejecutando en el espacio de dicho proceso. Debido a la comple­ jidad existente, el empaquetado de objetos implica un mayor reto que el del resto de estru c tu ra s, se le ha d ad o un n o m b re e sp e c ífic o : se ñ a liz a c ió n d e o b jeto s (java.sun.com, 11]. En Java, «La señalización de objetos soporta la codificación de objetos, y de los objetos alcanzables desde ellos, en un flujo d e bytes, así como el soporte complementario para su reconstrucción en un objeto ... desde el flujo de by­ tes» [Harold,12]. 2 .6 . C O D IF IC A C IÓ N D E DATOS Aunque determinados programas especializados puedan escribirse para realizar la co­ municación entre procesos usando un esquema de representación determinado de mu­ tuo acuerdo, las aplicaciones distribuidas de propósito general necesitan un esquema universal, e independiente de plataforma, para codificar el intercambio de datos. Por esto se han definido estándares de red para la codificación de datos. Como se muestra en la Figura 2.12, hay estándares para la codificación d e datos disponibles a diferentes niveles d e abstracción. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Nivel de abstra cción Esquem as de codificación de datos Estándares de ejem plo X M L (£xtensible M arkup Language) ASN.1 [Abstract Syntax Notation) Sun XDR (Extema/ Data R epresentation) F ig u ra 2 .1 2 . Estándares d e re p re se n ta ció n d e d a to s d e red. Al nivel más simple, un esquema de codificación como X D R (External Data Re­ presentation) [ietf.org, 1] permite que un conjunto de tipos de datos determinado y unas estructuras específicas se puedan codificar para usarse con mecanismos de co­ municación entre procesos. El empaquetamiento y desempaquetamiento de datos se realizan automáticamente por las funcionalidades de comunicación entre procesos en los dos extremos, de forma transparente al programador. A un nivel d e abstracción más alto (esto es, ocultando más detalles; se entrará en este concepto con más detalle en el próximo capítulo), existen estándares como A SN .l (Abstraet Syntax Notation Number 1) [oss.com, 2]. ASN. 1 es un estándar de OSI (Open Systems Interconnection) que especifica la sintaxis de transferencia para datos sobre una red. El estándar cubre un amplio rango de estructuras (como conjuntos y se­ cuencias) y tipos de datos (enteros, booleanos y caracteres) y soporta el concepto de etiquetado de datos. Cada elemento de datos transmitido se codifica usando una sin­ taxis que indica el tipo, la longitud, el valor y opcionalmente una etiqueta que iden­ tifica una forma específica de interpretar esta sintaxis. A un nivel aún más alto de abstracción ha emergido X M L (Extensible Markup Language) [w3.org, 9] como lenguaje de descripción de datos entre aplicaciones que comparten información, principalmente aplicaciones en Internet, usando una sintaxis similar a HTML ( HyperText Markup Language), que es e l lenguaje usado para com­ poner páginas web. XM L va un poco más allá que ASN. 1 en e l sentido que permite al usuario usar etiquetas configurables (tales como <mensaje>, <de> o <para> en el ejemplo de la Figura 2.13) para especificar una unidad de contenido de datos. XML se utiliza para facilitar intercambio de datos entre sistemas heterogéneos, para sepa­ rar e l contenido de una página web (escrito en XML) de la sintaxis para mostrarlo (escrita en HTML), y para permitir que los datos se compartan entre aplicaciones. Desde su aparición en 1998, XML ha ganado una atención considerable y en la ac­ tualidad se utiliza en un amplio rango de aplicaciones. <anensaje> < a> M aryJ @ B ig U . e d u < /a > < d e > Jo h n L 0 O p e n ü . e d iK /d e > < s o b re > C o m u n ic a c ió n e n t r e p r o c e s o s < / s o b r o <texto> La e s p i n a d o r s a l d e l o s s i s t e m a s d i s t r i b u i d o s s o n l o s . . . </texto> </mensaje> F ig u ra 2 .1 3 . Un fic h e ro X M L d e e je m p lo . Lenguaje d e co d ifica ció n específico d e la aplicación Lenguaje general d e co d ifica ció n d e da tos r Estándar d e co d ifica ció n d e da tos d e red www.FreeLibros.org IPC - C om unicación entre procesos 2 .7 . PR O TO C O LO S BASADOS EN T E X T O El em paquetam iento d e datos es, en e l caso m ás simple, cuando se intercam bian cadenas de caracteres o texto codificado en una representación de tipo ASCII. El intercambio de datos en texto tiene la ventaja adicional d e que puede ser fácilmente analizado por un program a y m ostrado a un usuario humano. Por eso es relativa­ mente habitual en varios protocolos intercam biar peticiones y respuestas en forma de cadenas d e caracteres. Estos protocolos se denom inan b a sa d o s <m t a t o . M u­ chos protocolos habituales son basados en texto, incluyendo FTP (File Transfer Protocol, protocolo de transferencia d e ficheros), HTTP y SM TP (Simple M ail Transfer Protocol, protocolo sim ple de transferencia de correo). El lector tendrá la oportunidad de investigar y experim entar con estos protocolos en ejercicios al fi­ nal de este capítulo, y se estudiarán varios de estos protocolos en detalle en pos­ teriores capítulos. 2 .8 . PR O TO C O LO S DE S O L IC IT U D -R E S P U E S T A Un tipo importante de protocolos son los protocolas d e sofiatud-respuesta En es­ tos protocolos un lado invoca una petición y espera una respuesta del otro extremo. Posteriormente, puede ser enviada otra solicitud, esperándose de nuevo respuesta. El protocolo se desarrolla basándose en interacciones de este tipo hasta que la tarea so­ licitada se ha cumplido. FTP, HTTP y SM TP son protocolos habituales del tipo soli­ citud-respuesta. 2 .9 . D IA G R AM A DE EVENTOS Y D IA G R AM A DE SEC U E N C IA Un diagram a de eventos, ya presentado en la sección 2.2, es un diagram a que se pue­ de utilizar para documentar la secuencia detallada de eventos y bloqueos durante la ejecución de un protocolo. La Figura 2.14 es un diagrama de eventos para un pro­ tocolo solicitud-respuesta en e l que participan dos procesos concurrentes, A y B. La ejecución de cada proceso respecto del tiempo se representa usando una línea verti­ cal, que avanza hacia abajo. Un intervalo de línea continua durante la línea d e eje­ cución representa un periodo de tiempo en el cual el proceso estaba activo. Un in­ tervalo de línea discontinua representa cuándo el proceso está bloqueado. En el ejemplo, ambos procesos están inicialmente activos. El proceso B invoca un recibir bloqueante con antelación a la solicitud 1 del proceso A. El proceso A mientras tan­ to lanza la solicitud 1 que se estaba esperando, usando para ello un enviar no blo­ queante y acto seguido un recibir bloqueante a la espera de la respuesta de B. La llegada de la solicitud 1 reactiva al proceso B que inicia e l procesamiento de la so ­ licitud antes de invocar una operación de enviar con respuesta 1 para el proceso A. El proceso B invoca luego un recibir bloqueante para la solicitud 2. La llegada de la respuesta 1 desbloquea al proceso A, que reanuda su ejecución para trabajar con la respuesta y preparar la petición 2, que desbloquea a l proceso B. Una secuencia si­ m ilar de eventos se sigue. Cabe resaltar que cada tum o de solicitud-respuesta enlaza una pareja de operacio­ nes enviar y recibir para intercambiar dos mensajes. El protocolo se puede extender hasta cualquier número de turnos de intercambios con este patrón. www.FreeLibros.org 6 0 C om putación distribuida. Fundam entos y aplicaciones Proceso B Proceso A Tiem po i petición 1 I I respuesta 1 r petición 2 ► Comunicación entre procesos — Flujo de ejecución Proceso bloqueado r respuesta 2 F ig u ra 2 .1 4 . Un d ia g ra m a d e e ve n to s. También es necesario indicar que es esencial que los programas que implementan el protocolo deben estar escritos para invocar las operaciones de enviar y recibir en el orden preestablecido, d e otra forma uno o los dos procesos participantes puede quedarse esperando por una solicitud o una respuesta que nunca llega y los procesos pueden quedarse bloqueados d e forma indefinida. La Figura 2.15 presenta, por medio de un diagrama de eventos un protocolo HTTP. En su forma más básica, HTTP es un protocolo basado en texto del tipo petición-res­ puesta que utiliza sólo un turno de intercambio de mensajes. Un servidor web es un proceso que escucha constantemente peticiones realizadas desde procesos navegado­ res. Un navegador w eb establece una conexión con el servidor, tras ello invoca una Servidor w e b Navegador w e b La petición es un mensaje con tres partes: — < m andatoxdirección del d o cu m en to xversió n de HTTP> — Una cabecera opcional — Datos opcionales para CGI cuando se usa el m étod o post La respuesta es o tro mensaje con tres partes: — Una línea de estado con el form ato < protocoloxcódigo estadoxdescripc¡ón> — Inform ación de cabecera, qu e se puede exte nde r en varias líneas — El docum ento propiam ente dicho Fig u ra 2 .1 5 . D iagram a d e e v e n to s d e un a sesión HTTP. www.FreeLibros.org IPC - C om unicación entre procesos petición en el formato dictado por el protocolo. El servidor procesa la petición y res­ ponde con una línea de estado, una cabecera de información y el documento solicita­ do por el navegador. Tras recibir la respuesta, el navegador analiza el documento y lo presenta en pantalla. (Se estudiará el modelo cliente-servidor y el protocolo HTTP con más detalle en el Capítulo 5.) Un diagrama de eventos es una herramienta m uy útil para ilustrar la sincroniza­ ción entre eventos. Pero es, sin embargo, demasiado detallado para documentar pro­ tocolos que sean complejos. Una forma simplificada de este diagrama, denominada diagrama de secuencia y parte de la notación UML, se usa más habitualmente para denotar la comunicación entre procesos. En un diagrama de secuencia, el flujo de ejecución de cada participante del pro­ tocolo se representa por una línea discontinua y no se diferencia entre estados de blo­ queo y ejecución. Cada mensaje intercambiado entre dos elementos se representa con una línea dirigida que va entre las dos líneas discontinuas de em isor y receptor sobre la que se añade una etiqueta descriptiva del mensaje, tal y como se ilustra en la Fi­ gura 2.16. Proceso A Comunicación entre procesos petición 1 respuesta 1 petición 2 respuesta 2 Proceso B F ig u ra 2 .1 6 . Un d ia g ra m a d e se cu e n cia . Tiempo El diagrama de secuencia de una sesión HTTP básica se muestra en la Figura 2.17. N avegador w e b Servidor w e b F ig u ra 2 .1 7 . El d ia g ra m a d e s e c u e n c ia para un a sesión HTTP. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones La Figura 2.18 muestra el texto de los mensajes intercambiados durante una se­ sión HTTP de ejemplo. Por medio de un cliente t d a e t {telnet es un protocolo utili­ zado normalmente para una sesión de terminal sobre una máquina remota), se puede conectar a un servidor web e introducir el texto de una petición HTTP a mano. (La utilización de telnet para comunicarse con un proceso de la forma aquí indicada per­ mite hacer pruebas con procesos vía IPC sin necesidad de escribir el programa, pero es necesario avisar de que ésta no es la forma normal de interactuar con estos proce­ sos. En los siguientes capítulos se aprenderá a programar estas interacciones). En este caso, el servidor web se ejecuta sobre el puerto 80 de la máquina www.csc.calpoly.edu. La petición GET /-m liu / HTTP/1.0 se teclea y envía. La respuesta del servidor web se remite a continuación. En el Capítulo 9 se estudiará el significado de las peticio­ nes y respuestas cuando se exponga e l protocolo HTTP en detalle. S c r i p t s t a r t e d on T u e O c t 10 2 1 : 4 9 : 2 8 200 0 9 : 49pm t e l n e t w w w .c s c .c a l p o l y .e d u 80 T r y in g 1 2 9 . 6 5 . 2 4 1 . 2 0 . . . C o n n e c te d t o t i e d y e 2 - s r v . c s c . c a ] p o l y . e d u . E s c a p e c h a r a c t e r i s ' A ] ' . GET / - m l i u / H T T P/1 . 0 * ^ ------------------------------------ P etición H T T P HTTP/1 . 1 2 0 0 OK D a te : W ed, 11 O c t 2 0 0 0 0 4 : 5 1 : 1 8 GMT ---------------- Lín ea d e e sta d o H T T P S e r v e r : A p a c h e / 1 .3 .9 ( U n ix ) A p a c h e J S e r v / 1 . 0 C a b e c e ra d e re s p u e s ta H T T P L a s t - M o d i f i e d : T u e , 10 O c t 200 0 1 6 : 5 1 : 5 4 GMT E T ag: \" I d d l e - e 2 7 - 3 9 e 3 4 9 2 a \" A c c e p t- R a n g e s : b y t e s C o n t e n t - L e n g t h : 362 3 C o n n e c ti o n : c i ó s e C o n te n t - T y p e : t e x t / h t m l <HTML> <HEAD> <TITLE> M e i- L in g L . L i u ' s Home P a g e </TTTLE> </HEAD> <BODY b g c o l o r = # f f f f f f > F ig u ra 2 .1 8 . B d iá lo g o d u ra n te un a s e sió n HTTP. C o n te n id o d e l d o c u m e n to 2 .1 0 . C O M U N IC A C IÓ N EN TR E PR O C ESO S O R IENTADA Y NO O R IEN TA D A A C O N E X IÓ N En el Capítulo 1 se introdujo la distinción entre comunicaciones orientadas y no orien­ tadas a conexión. Vamos a aplicar esta distinción a los mecanismos de IPC. Por medio de un mecanismo de IPC orientado a conexión, dos procesos estable­ cen una conexión (la cual, como recordatorio, decíamos que podía ser lógica, es de­ cir, implementada por software en lugar de verdaderamente física), y posteriormente insertan datos en o extraen datos desde dicha conexión. Una vez que la conexión está establecida, no es necesaria la identificación de emisor y receptor. www.FreeLibros.org IPC - C om unicación entre procesos 63 Para el caso de una IPC no orientada a conexión, los datos son intercambiados por medio de paquetes independientes cada uno de los cuales necesita explícitamente la dirección del receptor. Cuando se estudie el A PI de s o c k e ts en el Capítulo 4, se verá cómo los mecanis­ mos de IPC orientados y no orientados a conexión se proporcionan al nivel d e apli­ cación. 2 .1 1 . EVOLUCIÓN DE LOS RARADIGMAS DE COM UNICACIÓN EN TR E PR O C ESO S Una vez expuesto e l concepto de comunicaciones entre procesos (IPC), verem os di­ ferentes modelos, o paradigmas, por medio de los cuales la comunicación entre pro­ cesos se proporciona al programador que quiere utilizar una IPC en su programa. Al comienzo de este capítulo se vio que los esquemas de codificación de datos se dan a diferentes niveles de abstracción. Lo mismo se puede decir de los paradigmas de co­ municación entre procesos, tal y como muestra la Figura 2.19. En el nivel m enos abstracto, la comunicación entre procesos implica la transm i­ sión de ristras binarias sobre una conexión, utilizando una transferencia de datos de bajo nivel, serie o paralelo. Este paradigma d e comunicación entre procesos puede ser válido para el desarrollo del software de un driver de red, por ejemplo. Una IPC de esta forma cae dentro del dom inio de programación de red o d e sistema operativo y no lo va a cubrir este libro. El siguiente nivel es un paradigma bien conocido, denom inado interfaz de pro­ fa n a c ió n d e aplicaciones d e sockeés (el A PI de sodeeé^. Por medio del para­ digma de s o c k e t s, dos procesos intercam bian datos por medio d e una estructura ló ­ gica denom inada s o t k e t habiendo uno de cada tipo en cada extremo. Los datos a transm itir se escriben sobre el s o c k e t. En e l otro extremo, un receptor lee o extrae datos del s o c k e t. Se estudiará el A P I de s o c k e t s del lenguaje Java en el próximo ca­ pítulo. Los paradigmas de llam adas a procedimientos ranotos o de invocación d e m é­ todos rem otos proporcionan una mayor abstracción, permitiendo al proceso realizar llamadas a procedimientos o la invocación de métodos de un proceso remoto, con la transmisión de datos como argumentos o valores de resultado. S e estudiará una im- plementación de este paradigma, la invocación de métodos remotos en Java, en el Ca­ pítulo 8. Transferencia de datos serie se refiere a la transmisión de datos bit a bit. Lo opuesto a transferencia de datos serie es tansferencia de datos en paralelo, en la cual varios bits se transmiten concurrentemente.______ S o cket es un término tomado de los primeros días de las comunicaciones telefónicas, cuando un operador tenía que establecer manualmente una conexión entre dos partes insertando los dos extremos de un cable en sendos sockets'. N ive l d e a b s tra c c ió n P a ra d ig m a s d e IPC E je m plo s d e im p le m e n ta c io n e s d e IPC R e m ó te P rocedure Cali (RPC), Java R e m ó te M e th o d Invocation (RMI) API d e s o c k e ts d e UNIX, W insock C om unicación serie/paralelo Invocación d e m étodos/procedim ientos rem otos API de S o c k e t Transm isión d e da tos F ig u ra 2 .1 9 . P a ra d ig m a s d e c o m u n ic a c ió n e n tre p ro ceso s. ' {N. del 73: Socket en hglés significa enchufe.) www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones R ESU M EN La comunicación entre procesos (IPC) conforma el eje central de la computación dis­ tribuida. En este capítulo se han visto los principios de los mecanismos de IPC, in­ cluyendo lo siguiente: • Comunicación entre procesos (IPC). La posibilidad de que procesos indepen­ dientes, y separados se comuniquen entre ellos para colaborar en una tarea. Cuan­ do una comunicación se realiza únicamente de un proceso a otro, el mecanis­ mo IPC se denomina unidifusión. Cuando la comunicación se realiza entre un proceso y un grupo de procesos, el mecanismo IPC es multidifusión. • Una API básica de funcionalidades para IPC debe proporcionar: — Primitivas de operación: enviar, recibir, conectarse, y desconectarse. — La sincronización de eventos permite que procesos relacionados se ejecuten independientemente, sin conocimiento de lo que ocurre en el otro extremo. La forma más sencilla para que un mecanismo de comunicación permita sin­ cronización es por medio de bloqueos. Las operaciones que son bloqueantes se denominan a menudo operaciones síncronas, mientras que las que no son bloqueantes se llaman tam bién operaciones asincronas. Los interbloqueos pue­ den aparecer debido al uso de operaciones bloqueantes. L a utilización de hi­ los de ejecución (threads) o procesos permiten la realización de otras tareas a un proceso que aún espera que una operación bloqueante se complete. — El empaquetamiento de datos (data marshaling) necesario para preparar los datos para su transmisión por red, está compuesto por los siguientes pasos: (i) señalización de las estructuras de datos, y (ii) conversión d e los valores de datos a una representación externa o de red. • Existen diferentes esquemas de representación de datos de red a diferentes ni­ veles de abstracción. Algunos de los más conocidos son Sun X D R (External Data Representaron), A SN .l (Abstraet Syntax Notation Number 1) and XML (Ex- tensible Markup Language). • El empaquetamiento de datos es más sencillo cuando los datos a transmitir son una secuencia de caracteres o texto representado por medio de una codificación de tipo ASCII. Los protocolos que utilizan texto se denominan protocolos ba­ sados en texto. • Los protocolos del tipo solicitud-respuesta son protocolos que envían iterativa­ mente mensajes de solicitud y de respuesta hasta que se completen las tareas. • Un diagrama d e eventos se utiliza para documentar la secuencia detallada de eventos y bloqueos en un protocolo. Un segmento continuo a lo largo de la lí­ nea de ejecución representa el periodo de tiempo durante e l cual el proceso está activo. Una línea discontinua representa que el proceso está bloqueado. • Un diagrama de secuencia es parte de la notación UML y se utiliza para docu­ mentar iteraciones entre procesos que son complejas. En un diagrama de se­ cuencia, el flujo de ejecución de cada participante del protocolo se representa por una línea discontinua y no se diferencia entre estados de bloqueo y ejecu­ ción. • Las funcionalidades de comunicación entre procesos pueden ser orientadas o no orientadas a conexión: www.FreeLibros.org IPC - C om unicación entre procesos — Por medio de los mecanismos orientados a conexión, dos procesos estable­ cen una conexión lógica, para posteriormente intercambiar datos insertándo­ los y extrayéndolos de la conexión. Una vez que la conexión se ha estable­ cido no es necesario identificar a emisor y receptor. — En e l caso de mecanismos no orientados a la conexión, los datos se inter­ cambian por medio de paquetes independientes, cada uno de los cuales ne­ cesita identificar al receptor. • Las funcionalidades d e tipo IPC pueden clasificarse de acuerdo a sus niveles de abstracción, yendo desde transferencia de datos serie/paralelo, al nivel más bajo, pasando por el API de sockets al siguiente nivel, hasta llamadas a procedimientos o métodos remotos, a l nivel más alto. E J E R C IC IO S 1. Teniendo en cuenta el caso de la comunicación entre humanos: a. Clasifique cada uno de los siguientes escenarios en términos de um difii- saón o n —MMMnalfln: i. Un estudiante hablando con un amigo por medio de un teléfono ina­ lámbrico. ii. Un ejecutivo hablando vía conferencia telefónica con empresarios en varias ciudades. iii. Un profesor dando clase en un aula. iv. Un niño jugando con otro usando un walkie-íalkie. v. Un presidente dirigiéndose a la nación en televisión. b. ¿Cómo se realiza la sincronización de eventos y la representación de datos durante una sesión de una conversación cara a cara, tal y como se hace cuando se habla con alguien sentado a su lado? c. ¿Cómo se realiza la sincronización de eventos y la representación de datos durante una sesión de conversación a distancia, tal y como se hace cuando se habla con alguien por teléfono? d. ¿Cómo se realiza la sincronización de eventos y la representación de datos durante una reunión entre dos representantes de dos naciones que hablan idiomas diferentes? 2. El proceso A manda un mensaje sencillo al proceso B usando una llamada IPC no orientada a conexión. Para hacerlo, A invoca una operación enviar (espe­ cificando un mensaje como argumento) en algún instante durante su ejecución, y B invoca una operación recibir. Suponga que la operación enviar es asin­ crona (no bloqueante) y la operación de recibir es síncrona (bloqueante). D i­ buje un diagrama de eventos (no un diagrama d e secuencia) para cada uno de los siguientes escenarios. a. El proceso A invoca la operación enviar antes de que el proceso B invo­ que la operación recibir. b. El proceso B invoca la operación recibir antes de que el proceso A invo­ que la operación enviar. 3. Repita la última pregunta. Esta vez ambas operaciones (enviar y recibir) son bloqueantes. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones 4. Considere el A PI de comunicación entre procesos siguiente: Esta A PI envía y recibe los mensajes de buzones. Un proceso puede comuni­ carse con otro proceso usando un buzón compartido por esos dos procesos. Por ejemplo, s i el proceso A desea comunicarse con los procesos B y C, debe compartir el buzón 1 con el proceso B, y otro buzón, e l buzón 2, con C. Los mensajes entre A y B se depositan y recogen del buzón 1, mientras que los mensajes entre A y C se depositan y recogen del buzón 2. Obsérvese la Figu­ ra 2.20. Las operaciones enviar y recibir se definen como: — enviar (n, mensaje): Envía un mensaje al buzón n, bloqueante (es decir, que el emisor quedará suspendido hasta que llegue una respuesta al buzón com­ partido). — recibir (n, mensaje): Examina el buzón n con antelación a la recepción de un mensaje; es tam bién una operación bloqueante, que significa que el pro­ ceso receptor quedará suspendido hasta que llegue un mensaje al citado buzón. Un proceso que se encuentre bloqueado a la espera de un mensaje en un de­ terminado buzón no podrá recibir ningún mensaje por otro buzón. a. Suponga que un proceso P espera recibir dos mensajes, uno por el buzón 1 y otro por el buzón 2. No se conoce a priori ni el instante ni el orden en el que van a llegar los mensajes. ¿Qué secuencia de enviar y recibir, si existe, se puede ejecutar para asegurarse que el proceso P no se bloquea permanentemente? b. ¿Qué secuencia de enviar y recibir, si existe, debe ejecutar el proceso P si quiere esperar por un solo mensaje bien por el buzón 1 o por e l buzón 2 (o incluso) por am bos? De nuevo, no se conoce por adelantado qué men­ saje llegará primero. Asimismo, la secuencia propuesta no debe causar un bloqueo indefinido. (Nota: Su respuesta debe utilizar únicamente las operaciones dadas en el ca­ pítulo; no utilice hilos (threading) u otras funcionalidades del sistema opera­ tivo.) 5. ¿Se puede dar un interbloqueo durante la comunicación entre procesos (utili­ zando enviar/recibir). a. en un sistem a de comunicaciones que proporciona una operación de enviar bloqueante y de recibir bloqueante? b. en un sistema de comunicaciones que proporciona una operación de enviar no bloqueante y de recibir bloqueante? Justifique su respuesta. Si la respuesta es afirmativa, proporcione un ejemplo. Si la respuesta es negativa, dé una breve argumentación. 6. Considere el desarrollo d e una API de multidifusión sobre una API existente de tipo unidifusión. El API de unidifusión proporciona operaciones enviar y recibir entre dos procesos. El API de multidifusión debe proporcionar opera­ ciones para (1) enviar a un grupo de procesos, y (2) recibir de un proceso de multidifusión. Describa cómo proporcionaría las operaciones de multidifusión usando las operaciones de unidifusión únicamente. (Nota: Su respuesta debe utilizar únicam ente las operaciones dadas en el capítulo; no utilice hilos (threading) u otras funcionalidades del sistem a operativo). www.FreeLibros.org IPC - C om unicación entre procesos 6 7 R oceso A R oceso B F ig u ra 2 .2 0 . Una in te rfa z d e p ro g ra m a ció n d e a p lic a c io n e s IPC para e l E je rcicio 4. 7. En un sistem a distribuido, tres procesos P l, P2, y P3 participan en una co­ municación entre procesos. Suponga que sucede la siguiente secuencia de eventos: En el instante 1, P3 invoca un recibir para P2. En el instante 2, P1 envía el mensaje m i hacia P2. En el instante 3, P2 invoca un recibir para P l. En el instante 4, P2 recibe el mensaje m i. En el instante 5, P2 envía el mensaje m i hacia P3. En el instante 6, P3 recibe el mensaje m i. P l invoca un recibir para P2. En el instante 7, P2 invoca un recibir para P3. En el instante 8, P3 envía el mensaje m 2 hacia P2. En el instante 9, P2 recibe el mensaje m2. En el instante 10, P2 envía e l mensaje m 2 hacia Pl. En el instante 11, P l recibe el mensaje m2. a. Para cada uno de los siguientes escenarios, dibuje un diagrama de eventos para mostrar la secuencia de eventos y los bloqueos y desbloqueos d e cada proceso: i. en un sistema de comunicaciones que proporciona una operación d e en­ viar bloqueante y de recibir bloqueante, ii. en un sistema de comunicaciones que proporciona una operación d e en­ viar no bloqueante y de recibir bloqueante. b. Dibuje un diagrama de secuencia para documentar la comunicación entre los procesos P l, P2, y P3. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones 8. Este es un ejercicio sobre empaquetamiento de datos (data marshaling). a. En el contexto de IPC: i. ¿Qué es el empaquetamiento d e datos? H ay dos pasos dentro del em ­ paquetamiento de datos, nómbrelos y describa cada uno. ¿Por qué es necesario e l empaquetamiento de datos? ii. ¿Qué es la señalización de objetos? iii. ¿Cómo se aplican los dos pasos del empaquetamiento d e datos a (i) un vector de enteros, y (ii) un objeto? Describa en términos generales qué es necesario realizar con los datos. b. El proceso A envía a l proceso B un único dato, una fecha. El proceso A usa e l formato americano de fecha: <mes>/<día>/<año> (por ejemplo, 01/31/2001). El proceso B usa e l formato europeo: <día>/<mes >/<año> (por ejemplo, 31/01/2001). i. Suponga que no se ha acordado una representación externa de datos. a. ¿Cómo A enviaría la fecha a B para que A no necesite hacer nin­ guna conversión? b. ¿Cómo A enviaría la fecha a B para que B no necesite hacer nin­ guna conversión? ii. Suponga que la misma fecha se comunica al proceso C, que utiliza un formato de fecha del tipo: <año>-<mes>-<día> (por ejemplo, 2001- 31-01). ¿Cómo puede A enviar la fecha a B y C a la vez de forma que A no tenga que realizar conversión alguna? iii. Describa una representación externa de datos para la fecha de forma que cualquier proceso emisor convierta la fecha del formato de repre­ sentación local al formato de representación externo antes de enviarla, y que cualquier proceso receptor convierta la fecha recibida del for­ mato de representación externo al suyo propio. Puede resultarle de interés la consulta de la referencia [saqqara.demon.co.uk, 10]. 9. Utilice telnet para interactuar con un servidor Daytime [RFC 867, 4] sobre una máquina a la que tenga acceso. Los servidores Daytime escuchan el puerto 13. Desde una ventana d e consola sobre el símbolo de sistema teclee: t e l n e t < e s p a c io > c n a n b r e o d i r e c c i ó n IP d e l a m á q u i n a x e s p a c i o 13 E je m p lo : t e l n e t m a q u in a .u n iv e r s i d a d .e d u 13 Recopile una traza de la sesión y describa sus observaciones. 10. Dibuje un diagrama d e secuencia para el protocolo Daytime. 11. ¿Es posible para un cliente Daytime que se quede bloqueado de forma indefi­ nida? Explíquelo. 12. Utilice telnet para interactuar con un servidor echo [RFC 862, 6] sobre una máquina a la que tenga acceso. Los servidores echo escuchan el puerto 7. a. Dibuje un diagrama de eventos para el protocolo echo. b. ¿Es posible para un cliente Daytime que se quede bloqueado de forma in­ definida? Explíquelo. 13. Considere el protocolo FTP (File Transfer Protocol, Protocolo de Transferen­ cia de Ficheros) [RFC 959, 5]. www.FreeLibros.org IPC - C om unicación entre procesos Nótese que este protocolo utiliza dos conexiones: una para transmitir las peti­ ciones y respuestas y otro para transmitir los ficheros para ser enviados/reci­ bidos. a. Utilice telnet para conectarse a un servidor FTP al que tenga acceso. Lue­ go solicite un mandato para listar el contenido del directorio raíz del ser­ vidor. b. Utilice un diagrama de eventos para describir las interacciones entre los pro­ cesos participantes. c. ¿Cuál es el formato de cada petición? d. ¿Cuál es el formato de cada respuesta? e. Considere e l mandato MODE del protocolo: permite especificar e l tipo de fichero (texto o binario) a transmitir. ¿Cuál es la representación d e datos para cada uno de los diferentes modos de fichero? 14. Considere el protocolo SMTP (Simple M ail Transfer Protocol, Protocolo Sim ­ ple de Transferencia de Correo) [RFC 821, 3]. Un extracto de la RFC de este protocolo proporciona la siguiente sesión d e ejemplo: R: 2 2 0 U S C -IS I .ARPA S im p le M a i l T r a n s f e r S e r v i c e R e a d y S : HELO LBL-UNIX. ARPA R: 2 5 0 U S C -IS I.A R P A S : MAIL FRCM: <mo@ LBL-UNIX. ARPA> R : 2 5 0 OK S: RCPT TO:<Jones@USC-ISI.ARPA> R : OK S : DATA R: 3 5 4 S t a r t m a i l i n p u t ; e n d w i t h <CRLF>. <CRLF> S : B l a b l a b l a . . . S : . . . e t c . e t c . e t c . S : . R : 2 5 0 OK S : QUIT R: 221 USC-ISI.ARPA Service closing transmission channel a. Utilice un diagrama de secuencia para describir las interacciones entre los procesos participantes. b. ¿Cuál es el formato de cada petición? c. ¿Cuál es el formato de cada respuesta? d. Utilice telnet para conectarse a un sistem a donde usted tenga una cuenta SMTP, y envíese a sí mismo un correo. Conéctese luego al sistema y veri­ fique que el correo ha llegado. Recopile una traza de la sesión y describa sus observaciones. R E FER EN C IA S (Nota: Todos los RFC (Requests fo r Comments) se pueden consultar en línea en la página: IETF RFC Page, http://www.ietf.org/rfc.html.) 1. RFC 1014, Extemal Data Representation. 2. « A S N .l O verV iew », http://www.oss.com/asnIloverview.html. 3. R FC 82 1 , SM TP. 4. R FC 867, P rotocolo D aytim e. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones 5. R F C 959, Protocolo FTP. 6. R F C 862, Protocolo Echo. 7. Jo h n S h a p le y Gray. Interprocess Communications in UNIX. U p p er S a d d le P rentice Hall, 1997. 8. R F C 742, F inger protocol. 9. E xtensible M arkup L anguage (X M L), http:llwww.w3.org/XMLJ 10. International D ate F orm at C am paign, http://www.saqqara.demon.co.uk/ 11. Ja v a O b je ct S erializatio n , http://java.sun.eom/j2se/l.3/docs/guide/serialization/ 12. E lliotte R u sty H arold. Java 1/0, S ebastopol, CA: O ’R eilly Press, 1999. www.FreeLibros.org CAPITULO P a r a d ig m a s d e c o m p u t a c ió n d is t r ib u id a La com putación d istrib u ida es una de las más vibrantes áreas en el cam po de la informática. Hay una continua evolución hacia nuevas tecnologías que den so p orte a las aplicaciones distribuidas, trayendo consigo nuevos m odelos conceptuales y term inologías. Aparentem ente nueva jerga, otro acrónim o, o una nueva tecnología rom pedora aparece cada día. Para un observador inexperto o para un estudiante que com ienza, ord en a r esta term inología y sus tecnologías es una ardua tarea. Este capítulo presenta una clasificación de varios paradigmas para aplicaciones distribuidas, así com o una introducción a algunas de las herramientas ya existentes y los protocolos basados en estos paradigmas. En los siguientes capítulos se explorarán algunos de estos paradigmas, herram ientas y protocolos en detalle. 3 .1 . PA R A D IG M A S Y A B S T R A C C IÓ N Los términos p a r a d in a s y abstracción se han usado ya en previos capítulos, pero aquí se examinarán más de cerca. Abstracción Con diferencia el concepto más fundamental dentro de la informática, la abstracción es la idea de cncapsulación, o de oaittain en to d e detalles. Citando a David J. Bar- nes [Bames, 1]: «Habitualmente usamos la abstracción cuando no es necesario conocer los detalles exactos de cómo algo funciona o se representa, porque podem os utili­ zarlo en su form a simplificada. A menudo entrar dentro del detalle tiende a os- www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones curecer lo que estamos intentando entender en lugar d e iluminarlo... la abs­ tracción juega un papel m uy importante en la programación porque lo que a menudo queremos modelar, en software, es una versión simplificada de las co­ sas que existen en el mundo real... sin necesidad de construir cosas reales». En ingeniería del software, la abstracción se materializa en proporcionar herra­ mientas o funcionalidades que permitan el desarrollo de software sin que el progra­ mador tenga que conocer las complejidades subyacentes. No se trata de sobrestimar cuando se dice que las herramientas de abstracción son el em puje detrás del desarro­ llo moderno de software, y que ellas existen detrás de cada aspecto del desarrollo de una aplicación. Por ejemplo, se utilizan compiladores para abstraerse del detalle de los lenguajes máquina, y los programadores de Java utilizan e l paquete AWT (Abs- tract Window Toolkit) para desarrollar rápidamente interfaces gráficas. En e l área de aplicaciones distribuidas, ha habido una explosión de herramientas y funcionalidades basadas en una amplia variedad de paradigmas que ofrecen dife­ rentes grados de abstracción. Paradigm as El diccionario Webster define la palabra paradigma como «un patrón, ejemplo, o mo­ delo». En el estudio de cualquier materia de gran complejidad, es útil identificar los patrones o modelos básicos y clasificar los detalles de acuerdo con estos modelos. Este capítulo busca presentar una clasificación de los paradigmas sobre aplicaciones distribuidas. Los paradigmas se van a presentar ordenados basándose en su nivel de abstracción, como se muestra en la Figura 3.1. En el nivel más bajo de abstracción se encuentra el paso d e mensajes» que encapsula e l menos nivel de detalle. Los es­ pacios d e objetos ocupan el extrem o opuesto del espectro, y a que se trata del para­ digma más abstracto. N ive l d e a b s tra c c ió n Alto Espacios d e ob je to s, aplicaciones colaborativas Servicios d e red, (ORB) o b je c t re q u e s t broker; agentes móviles Llamada a procedim ientos rem otos, invocación d e m étodos rem otos Cliente-servidor, p eer-to -p e e r Fbso d e mensajes Bajo F ig u ra 3 .1 . Los p a ra d ig m a s d e c o m p u ta c ió n d is trib u id a y s u nivel d e a b s tra c c ió n . 3 .2 . U N A A P L IC A C IÓ N DE EJEM PLO A través del resto del capítulo, se usará una misma aplicación para ilustrar cómo se aplica cada uno de los paradigmas. La aplicación de ejemplo se trata de un sistem a de subastas on-line. (Nótese que las implementaciones descritas en este capítulo intencionadamente ignoran detalles www.FreeLibros.org Paradigm as d e com p u ta ció n distribu ida [como la interfaz con el usuario y el almacenamiento d e datos] de la aplicación real. Las implementaciones de ejem plo se han pensado para que sirvan como hilo común de este capítulo. Por medio del uso de estas implementaciones, se podrá comparar y contrastar las diferencias y efectos de las abstracciones proporcionadas por los dife­ rentes paradigmas.) Se simplificará el sistem a hasta el punto de tratar sólo un objeto a subastar en cada sesión. Durante cada sesión de subasta, un objeto está abierto a pujas emitidas por los participantes en la subasta. Al final de la sesión, el subastador anuncia e l resultado. En la descripción de las diferentes implementaciones, se va a centrar la atención en los aspectos de computación distribuida de la capa de servicio (esto es, dentro de la arquitectura de tres niveles para aplicaciones distribuidas, en el nivel de servicio subyacente que da soporte al resto de niveles superiores) de la ar­ quitectura de la aplicación. 3 .3 . PA R A D IG M A S PARA A P L IC A C IO N E S D IS T R IB U ID A S Paso de m ensajes La aproximación más básica a la comunicación entre procesos es e l paso de m ensa­ je * En este paradigma, los datos que representan mensajes se intercambian entre dos procesos, un em isor y un receptor. El paso de mensajes es el paradigma fundamental para aplicaciones distribuidas. Un proceso envía un mensaje que representa una petición. El mensaje se entrega a un receptor, que procesa la petición y envía un mensaje como respuesta. En secuencia, la réplica puede disparar posteriores peticiones, que lleven a sucesivas respuestas, y así en adelante. La Figura 3.2 ilustra el paradigma d e paso de mensajes. P ro ce so A P ro ce so B Proceso A envía el m ensaje m , al proceso B, luego Proceso B envía el m ensaje m2 al proceso A, y finalm ente Un m ensa¡e Proceso A envía el m ensaje m3 al proceso B. F ig u ra 3 .2 . El p a ra d ig m a d e pa so d e m en sajes. Las operaciones básicas necesarias para dar soporte a l paradigma de paso de men­ sajes son enviar y recibir. Para comunicaciones orientadas a conexión, también se ne­ cesitan las operaciones conectar y desconectar. (Los detalles sobre las operaciones, www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones tales como argumentos o valores de retomo, se darán junto a las respectivas herra­ mientas y funcionalidades en los capítulos posteriores.) Por medio del grado de abs­ tracción proporcionado por este modelo, los procesos ínter conectados realizan la en­ trada y la salida hacia e l otro proceso, de una forma sim ilar a la utilizada en la entrada/salida (E/S) de ficheros. Como en el caso de la E/S de ficheros, las opera­ ciones sirven para encapsular el detalle de la comunicación a nivel del sistema ope­ rativo, de forma que el programador puede hacer uso de operaciones para enviar y re­ cibir mensajes sin preocuparse por el detalle subyacente. La interfaz de programación de aplicaciones de sodeeés (que se estudiará en e l Ca­ pítulo 4) se basa en este paradigma. Usando un socket, una construcción lógica, dos procesos pueden intercambiarse datos de la siguiente forma: un emisor escribe o in­ serta un mensaje en el socket', en el otro extremo, un receptor lee o extrae un men­ saje del socket. La implementación de nuestro sistema de subastas usando paso de mensajes y el paradigma cliente-servidor se describirá en la próxima sección. Paradigm a cliente-servidor Quizás el más conocido de los paradigmas para aplicaciones de red, el m odelo d ien ­ te-servidor [Comer y Stevens, 2] asigna roles diferentes a los dos procesos que co­ laboran. Un proceso, el servidor interpreta el papel de proveedor de servicio, espe­ rando de forma pasiva la llegada de peticiones. El otro, el cliente, invoca determinadas peticiones al servidor y aguarda sus respuestas. La Figura 3.3 ilustra este paradigma. U na petición d e servicio [ ] Un proceso cliente 1 | Un proceso servidor ( ^ ) Un servicio C o m p u ta d o r s e rv id o r C o m p u ta d o r c lie n te F ig u ra 3 .3 . El p a ra d ig m a clie n te -se rvid o r. De una concepción simple, el modelo cliente-servidor proporciona una abstracción eficiente para facilitar servicios de red. Las operaciones necesarias incluyen aquellas que permiten a un proceso servidor escuchar y aceptar peticiones, y a un cliente so­ licitar dichas peticiones y aceptar las respuestas. Al asignar dos papeles diferentes a www.FreeLibros.org Paradigm as d e com p u ta ció n distribu ida ambos extremos la sincronización de eventos se simplifica: el proceso servidor espe­ ra peticiones, y el cliente en su tum o espera las respuestas. Muchos servicios de Internet dan soporte a aplicaciones cliente-servidor. Estos ser­ vicios se conocen por el protocolo que implementa la aplicación. Conocidos servicios de Internet son HTTP, FTP, DNS, finger, gopher y otros, algunos de los cuales ya se han presentado en el Capítulo 2. Los dos modelos básicos que hemos visto hasta el momento, cliente-servidor y paso de mensajes, son suficiente como base para la implementación de nuestro siste­ ma de subastas. Cada participante, así como el programa de subastas, asumen a la vez el papel de cliente y servidor, de la siguiente forma: Para el control de la sesión: • Como servidor, un participante espera escuchar el anuncio del subastador (1) cuando comience la sesión, (2) en el momento en el que se produzca un cam­ bio en la puja máxima, y (3) cuando la sesión termine. • Como servidor, el subastador envía una petición que anuncia los tres tipos de eventos antes comentados. Para la aceptación de pujas: • Como servidor, un participante envía una nueva puja a un servidor. • Como cliente, un subastador acepta nuevas pujas y actualiza la puja máxima. El paradigm a cliente-servidor es inherente a m uchas aplicaciones distribuidas. El A PI de sockets orientados a conexión proporciona operaciones diseñadas específi­ camente para servidores y clientes, asimismo, e l API de l l a n a d a a procedim ientos re m o to s [Remóte Procedure Calt) y el API de J a v a d e invocación d e m é to d o s r e ­ m o to s (.Remóte M ethod lnvocation) (algo más sobre éste último se verá a lo largo de este capítulo) tam bién se refiere a los procesos participantes com o clientes y ser­ vidores. Paradigm a de igual a igual p e e r-to -p e e r En el paradigma cliente-servidor, los procesos participantes juegan diferentes roles: los procesos cliente solicitan peticiones mientras que los procesos servidores escuchan de forma pasiva para servir dichas peticiones y proporcionar los servicios solicitados en respuesta. En particular, el paradigma no da soporte para que el proceso servidor inicie la comunicación. En el p a r a d i n a peer-to-peer (Figura 3.4), los procesos participantes interpretan los mismos papeles, con idénticas capacidades y responsabilidades (de ahí el término peer, en inglés par). Cada participante puede solicitar una petición a cualquier otro participante y recibir una respuesta. Un ejem plo bien conocido de un servicio de trans­ ferencia de ficheros peer-to-peer es Napster.com’, servicios similares permiten la com­ partición de ficheros (primordialmente ficheros multimedia) entre ordenadores a tra­ vés de Internet. Mientras el paradigma cliente-servidor es un modelo ideal para servicios centrali­ zados de red (donde el proceso servidor proporciona el servicio y los procesos clien­ te acceden a dicho servicio mediante el citado servidor), e l paradigma peer-to-peer re­ sulta más apropiado para aplicaciones como mensajería instantánea, transferencia de ficheros, vídeo-conferencia, y trabajo colaborativo. También es posible que una apli­ cación se base en ambos modelos, cliente-servidor y peer-to-peer, Napster.com utili­ za un servidor como directorio además de la comunicación peer-to-peer. www.FreeLibros.org 7 6 C om putación distribuida. Fundam entos y aplicaciones En el contexto de la mensajería instantánea, la presencia representa el estado de un participante, tal como si está presente (on-line) o desconectado, así como otros indicadores de estatus. Middleware hace referencia al software que actúa como intermediario entre procesos independientes. Los sistemas de mensajes 9 )n unos de los tipos de middleware, tos ORB o broker de peticiones son otros. B uso de un intermediario es una técnica común en computación distribuida. P ro ce so 1 petición n petición respuesta 1' r respuesta P ro ce so 2 F ig u ra 3 .4 . El P a ra d ig m a p e e r-to -p e e r. El paradigm a peer-to-peer se puede implementar por medio de bibliotecas que proporcionen herram ientas de paso d e mensajes. Para aplicaciones complejas, como m ensajería instantánea o compartición d e recursos, se está trabajando en protocolos de alto nivel y en herramientas para su desarrollo. Ejemplos de estos protocolos y sus correspondientes herram ientas son el proyecto JX T A [jxta.org, 29] y J a b b e r [jabber.org, 30], un protocolo abierto basado en X M L para m ensajería y presencia instantánea. La implementación de nuestro sistema de subastas puede simplificarse sustancial­ mente con la disponibilidad de una herramienta que dé soporte al paradigma peer-to- peer. Un participante puede conectarse al subastador directamente para registrarse en la subasta. El subastador posteriormente contacta con cada uno de los participantes para iniciar la sesión de subasta, durante la cual cada uno de los participantes indivi­ dualmente pueden obtener el estado y realizar pujas. Al concluir la subasta, el subas­ tador notifica a l ganador, y el resto de participantes pueden conocer e l resultado con­ tactando con el propio subastador. Paradigm a de sistem a de m ensajes El paradigma de « sto n a de m en a jes o M iddlew are Orientado a M ensajes (Mes- sage-Oriented Middleware-MOM), (véase la Figura 3.5) es una elaboración del para­ digma básico de paso de mensajes. En este paradigma, un sistema de mensajes sirve de intermediario entre procesos separados e independientes. El sistema de mensajes actúa como un conmutador para mensajes, a través del cual los procesos intercambian mensajes asincronamente, de una forma desacoplada. (Asincronamente, como recordará del Capítulo 2, indica una comunicación sin bloqueo.) Un emisor deposita un mensaje en el sistema de mensa­ jes, el cual redirige el mismo a la cola d e mensajes asociada a dicho receptor. Una vez que se ha enviado, el emisor queda liberado para que realice cualquier otra tarea. H ay dos subtipos de modelos de sistem a de mensajes: el modelo de mensajes pun­ to a punto y el modelo de mensajes publicación/suscripción. www.FreeLibros.org Paradigm as d e com p u ta ció n distribu ida El fu tu ro d e peer-to-peer__________________________ p o r M a tth e w Fordhal, c o la b o ra d o r d e A s s o c ia te d Press. (h ttp ://w w w .h o lla n d s e n tin e l.c o m /s to rie s /0 2 1 8 0 1 /b u s _ N a p s te r.s h tm l, p u b lic a d o en w e b el d o m in g o 1 8 d e fe b re ro d e 2 0 0 1 .) R e im pre so c o n p e rm is o d e A s s o c ia te d Press. El futuro de peer-to-peer La tecnología de intercambio de ficheros popularizada por Napster conocida como conexión peer-to-peer, está a punto de cambiar cómo las personas y empresas utilizan Internet. En lugar de apoyarse en servidores centrales para procesar y remitir información, nuevas aplicaciones se desarrollarán que permitirán que los usuarios conviertan cualquier dispositivo de computación en un servidor. Una sala d e reuniones virtual Los usuarios se conectan a Internet usando un programa que se parece a una sala de chat on-line Un fichero se coloca en un «espacio compartido» dentro de la sala de reuniones virtual, la cual permite a tos usuarios trabajar sobre ficheros de datos al mismo tiempo. Los usuarios trabajan en tiempo real y pueden mandarse mensajes de forma instantánea de unos a otros. En el futuro, esto se podría realizar por medio de dispositivos portátiles y teléfonos móviles. ¿Qué es lo q u e h a y en la pan ta lla? Rchero sobre el que se está trabajando Intercambio de mensajes instantáneos Groove Networks, recopilado porA P wire reports. www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Emisor F ig u ra 3 .5 . El p a ra d ig m a d e sis te m a d e m ensajes. M o d e lo de m e n s a je s p u n to a punto En este modelo, un sistema d e mensajes redirige un mensaje desde el emisor hasta la cola de mensajes del receptor. A diferencia del modelo básico de paso de mensajes, el middleware proporciona un depósito de los mensajes que permite que e l envío y la recepción estén desacoplados. Por medio del middleware, un em isor deposita el men­ saje en la cola de mensajes del receptor. Un proceso receptor extrae los mensajes de su cola de mensajes y procesa cada mensaje de forma correspondiente. Comparado con el modelo básico de paso de mensajes, el paradigma de mensajes punto a punto proporciona una abstracción adicional para operaciones asincronas. Para conseguir el mismo efecto con el paso de mensajes básico, un programador debe ha­ cer uso de hilos (threads) o de procesos hijos. La implementación de nuestro sistema de subastas usando el modelo de mensajes punto a punto es la misma que con el modelo básico de paso de mensajes. La única diferencia es que los mensajes se canalizan por medio del middleware, y el envío y la recepción están desacoplados. M o d e lo de m e n s a je s publicación/suscripción En este modelo, cada mensaje se asocia con un determinado tem a o evento. Las apli­ caciones interesadas en el suceso de un específico evento se pueden suscribir a los mensajes de dicho evento. Cuando el evento que se aguarda ocurre, el proceso pu­ blica un mensaje anunciando el evento o asunto. El middleware del sistem a de men­ sajes distribuye el mensaje a todos los suscriptores. El modelo de mensajes publicación/suscripción ofrece una potente abstracción para multidifusión o comunicación en grupo. La operación publicar permite al proceso di­ fundir a un grupo de procesos, y la operación suscribir permite a un proceso escu­ char dicha difusión d e mensajes. Utilizando e l modelo de mensajes publicación/suscripción, la implementación de nuestro sistema de subastas se realizaría de la siguiente forma: • Cada participante se suscribe a los mensajes del evento comienzo-subasta. • El subastador anuncia el comienzo de la sesión de subasta enviando un mensa­ je de evento comienzo-subasta. • Tras recibir el evento de comienzo-subasta, cada participante se suscribe a los mensajes del evento fin-subasta. www.FreeLibros.org Paradigm as d e com p u ta ció n d istrib u id a 7 9 • El subastador se suscribe a los mensajes del evento nueva-puja. • Un participante que desee realizar una nueva puja lanzará e l evento nueva-puja, que será reenviado al subastador. Al final de la sesión, el subastador lanzará en mensaje fin-subasta para informar a to ­ dos los participantes del resultado. S i se desea, se pueden añadir otros mensajes adi­ cionales que permitan a los participantes conocer el estado de la subasta. El paradigma MOM ha tenido una larga historia en las aplicaciones distribuidas. Los Message Queue Services (MQS) se llevan utilizando desde los 80. El MQ*Series de IBM [ibm.com, 6] es un ejemplo de dicho servicio. Otros soportes existentes para este paradigma son Microsoft's M essage Queue (MSMQ) [Dickman,5; lotus.com, 21] y el Ja v a s M essage Service (JMS) [Wetherill, 7]. M odelo de llam adas a procedim ientos rem otos El modelo de paso de mensajes funciona bien para protocolos básicos de red y para aplicaciones de red básicas. Pero, cuando las aplicaciones crecen en complejidad, re­ sulta necesario un nivel de abstracción mayor para la programación distribuida. En particular, resultaría deseable tener un paradigma que permitiera que el software dis­ tribuido se programase de una manera similar a las aplicaciones convencionales que se ejecutan sobre un único procesador. El modelo de llamada a procedimientos re­ motos (RPC, Rem óte Procedure Calí) proporciona dicha abstracción. Utilizando este modelo, la comunicación entre dos procesos se realiza utilizando un concepto similar al de una llamada a un procedimiento local, que resulta familiar a los programadores de aplicaciones. En un programa que sólo implica a un único proceso, una llamada a un procedi­ miento del tipo func(argl, arg2) implica un salto en el flujo de ejecución al código de dicho procedimiento. (Véase la Figura 3.6). Los argumentos se mandan al proce­ dimiento como parámetros de su ejecución. ► Flujo d e ejecución ] Un procedim iento local Fig u ra 3 .6 . Llam ada a un p ro c e d im ie n to local. En lenguajes procedimentales como C, una llamada a procedimiento es una invocación a un procedimiento (función que no devuelve nada) o a una función (una verdadera función, que devuelve un valor).______ www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Una llamada a un procedimiento remoto implica dos procesos independientes, que pueden residir en máquinas diferentes. Un proceso, A que quiere realizar una petición a otro proceso, B invoca a un procedimiento de B, pasando junto a la llamada una lista de valores d e argumentos. Como en el caso de la llam ada a procedimientos lo­ cales, una llamada a un procedimiento remoto dispara una acción predefinida en un procedimiento proporcionado por B. Al finalizar el procedimientos, el proceso B de­ vuelve un valor al proceso A. La Figura 3.7 muestra el paradigma RPC. Una llamada a un procedimiento se hace desde un proceso al otro, con los datos pasados como argumentos. Después de recibir una llamada, como resultado se ejecutan las acciones codificadas en el procedimiento. P roce so A P ro ce so B proc 1 (arg 1,a rg 2 ) return valor Un procedim iento rem oto __________________ — ► Rujo d e ejecución conceptual F ig u ra 3 .7 . El p a rad igm a d e llam ad a a p ro c e d im ie n to s rem o to s. RPC permite a los programadores construir aplicaciones de red usando una cons­ trucción de programación sim ilar a una llam ada a procedimiento local, proporciona­ do un nivel de abstracción conveniente tanto para la comunicación entre procesos como para la sincronización de eventos. Desde su aparición a principios de los 80, e l modelo de llamadas a procedimien­ tos remotos ha sido ampliamente utilizado en las aplicaciones de red. Existen dos API relevantes para RPC: Una es la Open Network Computing Remóte Procedure Cali (ONC RPC), evolucionado a partir del API de RPC desarrollada por Sun Microsys­ tem s en el comienzo de los 80. Detalles sobre esta API se pueden encontrar en [ietf.org, 8]. La otra API más conocida es la RPC del Distributed Computing Environment (DCE) de Open Group [opennc.org, 9]. Además, existe el Simple Object Access Protocol (SOAP), que se estudiará en el Capítulo 11, y sus implementaciones que dan sopor­ te a las llamadas a procedimientos remotos basadas en web. Para utilizar RPC para implementar nuestro sistem a de subastas procederemos de la siguiente forma: • El programa de subastas proporciona un procedimiento remoto para que cada participante se registre y otro procedimiento para que éstos hagan pujas. • Cada programa participante proporciona los siguientes procedimientos remotos: (1) el que permite al subastador llamar al participante para anunciar el comien­ zo de una sesión, (2) el que permite al subastador informar al participante de la puja más alta, y (3) el que permite que el subastador anuncie el final d e la sesión. www.FreeLibros.org Paradigm as d e com p u ta ció n distribu ida Paradigm as de objetos distribuidos La idea de aplicar la orientación a objetos a las aplicaciones distribuidas es una ex­ tensión del desarrollo software orientado a objetos. Las aplicaciones acceden a obje­ tos distribuidos sobre una red. Los objetos proporcionan métodos, a través de cuya invocación una aplicación obtiene acceso a los servicios. Varios paradigmas, descri­ tos en los siguiente párrafos, se basan en la idea de objetos distribuidos. Invocación de m é to d o s rem o to s La invocación de métodos remotos (Remóte M ethod Invocation RMI) (Figura 3.8) es el equivalente en orientación a objetos de las llamadas a procedimientos remotos. En este modelo, un proceso invoca métodos de un objeto, el cual reside en un ordenador remoto. Como en RPC, los argumentos se pueden pasar con la invocación, y se puede de­ volver un valor cuando el método ha concluido. L a implementación de nuestro sistema de subastas es esencialmente la misma que con RPC, la excepción es que los métodos de los objetos reemplazan los procedi­ mientos: • El programa de subastas proporciona un método remoto para que cada partici­ pante se registre y otro método para que éstos hagan pujas. • Cada programa participante proporciona los siguientes métodos remotos: (1) el que permite al subastador llamar al participante para anunciar el comienzo de una sesión, (2) el que permite al subastador informar al participante de la puja más alta, y (3) el que permite que el subastador anuncie el final de la sesión. F ig u ra 3 .8 . B p a ra d ig m a d e in v o c a c ió n d e m é to d o s rem o to s. P aradigm a b a s a d o en O bject Request B roker En el paradigma basado en Object Request Broker* (Figura 3.9), un proceso solicita una petición a un ORB (Object Request Broker), el cual redirige la petición al obje- * N. del T. La traducción correcta de Object Request Broker serla «agente o intermecfiario de peticiones de objetos». Se ha optado por usar el término inglés debido, por un lado, a su uso extendido (incluso en la literatura en español) y por otro porque la traducción está sujeta a confusión (especialmente con terminología similar dentro de la tecnología de agentes). www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones S olicitante d e l objeto O bjeto (ORB) O bject R e q u e st B roker Figura 3 .9 . El p a ra d ig m a b a s a d o e n O b je c t R e q u e s t Broker. to apropiado que proporciona dicho servicio. El paradigma se parece bastante a l mo­ delo de invocación de métodos remotos en su soporte para acceso remoto a objetos. La diferencia es que el ORB en este paradigma funciona como middleware, permi­ tiendo a una aplicación, como solicitante de un objeto, acceder potencialmente a va­ rios objetos remotos (o locales). El ORB puede funcionar también como mediador para objetos heterogéneos, permitiendo la interacción entre objetos implementados usando diferentes A PI y/o ejecutando sobre diferentes plataformas. La implementación del sistema de subastas usando un ORB es similar a la que usa RMI. Con la excepción de que cada objeto (subastador y participantes) deben registrar­ se en el ORB y son, en realidad, invocados por este mismo. Cada participante solicita peticiones al objeto subastador para registrarse para la sesión y hacer pujas. A través del ORB, el subastador invoca los métodos de cada participante para anunciar el comienzo de la sesión, actualizar el estado de las pujas, y anunciar el final de la sesión. Este paradigma es la base de la arquitectura CO RBA {Conmnon O bjectR equest Bro- her A n tite d u r é j de OMG (Object Management Group) que está desarrollada en el Ca­ pítulo 10. Herramientas basadas en esta arquitectura son Visibroker de Inspire, Java IDL (Java ¡nterface Definition Language), Orbix de IONA, y TAO de Object Computing, Inc. Las tecnologías basadas en componentes, com o M icrosoft COM, M icrosoft DCOM, Java Beans, y Enterprise Java Beans, tam bién se basan en los paradigmas de objetos distribuidos, ya que los componentes son esencialmente objetos empaquetados y especializados que se han diseñado para interactuar con otros por medio de inter­ faces estándar. Además, los servidores d e aplicaciones, populares para aplicaciones empresariales, son herramientas de tipo middleware que proporcionan acceso a obje­ tos o componentes. Espacio de objetos Quizás el más abstracto de los paradigmas orientados a objetos, el paradigma de Es­ pacio de Objetos asume la existencia de entidades lógicas conocidas como espacias d e objetas Los participantes en una aplicación convergen en un espacio de objetos común. Un suministrador coloca objetos como entidades dentro de un espacio de ob­ jetos, y los solicitantes que se subscriben al espacio pueden acceder a dichas entida­ des. La Figura 3.10 ilustra este paradigma. Además del grado de abstracción proporcionado por los otros paradigmas, el pa­ radigma del espacio de objetos proporciona un espacio virtual o sala de reunión en­ tre suministradores y solicitantes de recursos de red, como objetos. Esta abstracción oculta los detalles implicados en la búsqueda de recursos u objetos que son necesa­ rios en paradigmas como la invocación de métodos remotos, ORB, o servicios de red. Además, la exclusión mutua es inherente al paradigma, debido a que un objeto en el espacio puede sólo ser usado por un participante a la vez. www.FreeLibros.org Paradigm as d e com p u ta ció n distribu ida S o lic ita n te S um inistra dor Un e s p a c io d e o b je to s F ig u ra 3 .1 0 . El p a ra d ig m a d e E s p a c io d e O b je to s. Para el sistem a d e subastas, todos los participantes así como el suministrador de servicios se suscribirían al mismo espacio de objetos. Cada participante depositaría un objeto en el espacio de objetos para registrarse en la sesión y para ser notificado del comienzo de la misma. A l comienzo d e la sesión, el subastador deposita otro objeto en el espacio de objetos. El objeto contiene información sobre el elem ento a subastar así como el histórico de las pujas. Un participante que desee realizar una puja tom a­ rá el objeto del espacio y, si así lo quiere, añadirá una nueva puja en el objeto antes de devolverlo al espacio de objetos. Al final de la sesión el subastador retirará el ob­ jeto del espacio y contactará con e l participante con la mayor puja. U n c o n ju n to d e h e rra m ie n ta s b asa d o en e s te p arad ig m a es Ja v a S p a c e s [java.sun.com, 15]. Paradigm a de agentes móviles Un ag en te móvO es un programa u objeto transportable. En este paradigma, un agen­ te se lanza desde un determinado ordenador. El agente entonces viaja de forma autó­ noma de un ordenador a otro de acuerdo con un itinerario que posee. En cada para­ da, e l agente accede a los recursos o servicios necesarios y realiza las tareas correspondientes para completar su misión. El paradigma se ilustra en la Figura 3.11. El paradigma ofrece la abstracción de pro^ am a u objeto transportable En lu­ gar de intercambio de mensajes, los datos son transportados por el programa/objeto mientras e l propio objeto se transfiere entre los participantes. El paradigma de agentes móviles proporciona una novedosa forma de implemen- tar nuestro sistema d e subastas. En comienzo, cada participante lanza un agente mó­ vil hacia el subastador. El agente transporta la identidad, incluyendo la dirección de red, del participante al que representa. Una vez que la sesión ha comenzado el su ­ bastador lanza un agente móvil que transporta e l itinerario de los participantes, así como la mayor puja. El agente móvil circula entre los participantes y el subastador hasta que finalice la sesión, en cuyo instante el subastador lanza el agente para dar un recorrido más entre todos los participantes para comunicar el resultado. Paquetes comerciales que den soporte al paradigma de agentes móviles son el sis­ tem a concordia [meitca.com, 16], y el sistem a Aglet [trl.ibm.co.jp, 17]. H ay también m uchos sistem as experim entales basados en este paradigma, incluyendo D ’agent [agent.cs.dartmouth.edu, 13] y el proyecto Tacoma [tacoma.cs.uit.no, 14]. www.FreeLibros.org 8 4 C om putación distribuida. Fundam entos y aplicaciones Un método de callback es un método proporcionado por quien solicita un servicio de forma que el proveedor del servicio pueda iniciar una llamada a un solicitante particular. Los métodos de callback se utilizan también en el paradigma de objetos distribuidos. El Capítulo 8 cubre el tratamiento de callbacks en Java RMI. C om putador 3 F ig u ra 3 .1 1 . P aradigm a d e a g e n te s m óviles. Paradigm a de servicios de red En el paradigma mostrado en la Figura 3.12, los proveedores de servicios se registran en los servidores de directorio de una red. Un proceso que desee un servicio particu­ lar contacta con el servidor de directorio en tiempo de ejecución, y, si el servicio está disponible, al proceso se le dará una referencia a dicho servicio. Usando esta refe­ rencia, el proceso interactuará con el servicio. El paradigma es esencialmente una extensión del paradigma de invocación de mé­ todos remotos. La diferencia es que los objetos de servicio se registran en un direc­ torio global, permitiéndoles ser localizados y accedidos por solicitantes de servicios dentro de una red federada. Idealmente, los servicios se pueden registrar y localizar usando un identificador único global, en cuyo caso el paradigma ofrece un nivel de abstracción extra: transparencia d e localización La trasparencia de localización per­ mite a los desarrolladores de software acceder a un objeto o servicio sin tener que ser consciente de la localización del objeto o servicio. La implementación d e nuestro sistema de subastas es la misma que bajo el para­ digma RMI excepto que el subastador se registra en el servicio de directorio, permi­ tiendo que los participantes lo localicen y, una vez que la sesión ha comenzado ha­ cer las pujas. Los participantes proporcionan un método callback que permite que el subastador anuncie e l comienzo y el final de la sesión y que actualice e l estado de la misma. La tecnología Jini de Java [jini.org, 4] se basa en este paradigma. El protocolo SOAP (Simple Object Access Pro toco l), que se estudiará en el Capítulo 11, aplica este paradigma a los servicios accesibles en la web. www.FreeLibros.org Paradigm as d e com p u ta ció n distribu ida Servicio d e directorio O bjeto d e servicio S olicita nte d e l servicio F ig u ra 3 .1 2 . El p a ra d ig m a d e s e rv ic io s d e red. Paradigm a de aplicaciones colaborativas (g ro u p w a re ) En este modelo para trabajo cooperativo basado en ordenador, los procesos participan en grupo en una sesión colaborativa. Cada proceso participante puede hacer contri­ buciones a todos o parte del grupo. Los procesos pueden hacer eso, usando multidi­ fusión para enviar los datos o usar pizarras o tablones virtuales, los cuales permiten a cada participante leer y escribir datos sobre una visualización compartida. Los dos paradigmas de groupware se muestran en la Figura 3.13. Fferadigma d e groupw are basado en mensajes Paradigm a d e groupw are basado en pizarra F ig u ra 3 .1 3 . B p a ra d ig m a d e a p lic a c io n e s co la b o ra tiv a s . Para implementar el sistem a de subastas usando e l paradigma de groupware basa­ do en mensajes, el subastador iniciará un grupo, al que se incorporarán los partici­ pantes interesados. Al comienzo de la sesión, el subastador difundirá un mensaje de multidifusión anunciando el comienzo. Durante la sesión, cada puja es un mensaje de multidifusión a todos los participantes de forma que cada uno puede independien­ temente acceder al estado de la subasta. Finalmente, el subastador termina la sesión por medio de un mensaje de multidifusión anunciando e l resultado. No es complicado ver cómo el paradigma basado en pizarra se puede utilizar en nuestro sistem a d e subastas. El subastador y los participantes comparten una pizarra www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones virtual. El subastador comienza e l proceso de puja escribiendo e l anuncio sobre la pi­ zarra. Posteriormente, cada participante puede realizar una puja escribiéndola en la pizarra. Finalmente, el subastador term ina la sesión escribiendo el anuncio final. El paradigma colaborativo es la base de un gran número de programas groupware como Lotus QuickPlace [lotus.com, 21]. Interfaces d e programación de aplicaciones para la comparición vía intercambio de mensajes incluye e l API d e Java de multidifusión y el Java Shared Data Toolkit (JSDT) [java.sun.com, 18]. El paradigma basado en pi­ zarra es la base de un número de aplicaciones como SMART Board [smarttech.com, 19], NetMeeting [Microsoft.com, 20], y Groove [groove.com, 27]. Se ha propuesto al protocolo NSTP (Notification Service Transfer Protocoí) como «una infraestructura para construir aplicaciones groupware síncronas. Se basa en la idea d e un servidor de notificación coordinado, que es independiente de cualquier aplicación groupware es­ pecífica. Se ha intentado que NSTP sea de alguna manera el equivalente síncrono de HTTP ( Hypertext Transfer Protocoí)» [Day, Patterson, y Mitchell, 28]. 3 .4 . COMPARATIVA Como se ha mostrado en nuestra discusión, una misma aplicación se puede imple- mentar usando cualquiera de los paradigmas. Dado el gran número de paradigmas y herramientas disponibles, ¿cómo un desarrollador de software puede decidir la más apropiada para una tarea dada? Nivel de abstracción Alto Espacios d e o b je to s, aplicaciones colaborativas Servicios d e red, (ORB) o b je c t req u est broker, agentes m óviles Llam ada a procedim ientos rem otos, invocación d e m étodos rem otos C lie n te-serv id o r peer-to -p eer Paso d e mensajes Bajoy F ig u ra 3 .1 4 . Lo s p a ra d ig m a s y lo s niveles d e a b s tra c c ió n . Para responder a esta pregunta, uno debe tener cuidado con lo que ofrece cada una de las diferentes alternativas. Es suficiente decir que cada paradigma o herramienta tiene alguna ventaja sobre los otros. Cada ventaja, sin embargo, puede ser anulada por una desventaja. En los siguiente párrafos se verán algunas d e las cuestiones que se deben considerar. Nivel de abstracción fren te a sobrecarga La Figura 3.14 muestra los paradigmas que se han visto y sus niveles de abstracción correspondientes. En el nivel más bajo se encuentran los paradigmas más básicos: paso de mensajes, y cliente-servidor. En el nivel más alto están los espacios de objetos o la computación colaborativa, que proporciona el nivel más alto de abstracción. El www.FreeLibros.org Paradigm as d e com p u ta ció n distribu ida desarrollo de una aplicación altamente compleja se puede ver m uy ayudado por una herramienta que ofrece un gran nivel de abstracción. Pero la abstracción tiene un pre­ cio: sobrecarga. Considérese el paradigma de invocación de métodos remotos, por ejemplo. Como se podrá ver en el Capítulo 8, para poder proporcionar la abstracción de un método remoto, es necesaria la presencia de unos módulos, conocidos como resguardo (stub) y esqueleto (skeleton), en tiempo de ejecución para manejar detalles de la comunica­ ción entre procesos. El soporte en tiempo de ejecución y la existencia de módulos adi­ cionales requieren recursos extra del sistema así como tiempo de ejecución. Así, en el caso de que todo lo demás fuese igual, una aplicación escrita usando RMI reque­ rirá más recursos del sistem a y tardará más en ejecutar que otra igual que se comu­ nicase por medio del A PI d e sockets. Por esta razón, e l API de sockets puede ser la más apropiada para una aplicación que requiere un tiempo de respuesta rápido y unos recursos mínimos d e sistema. Por otro lado, RMI y otras herramientas que propor­ cionan mayor nivel de abstracción permiten que una aplicación se desarrolle más rá­ pidamente, y por tanto es más apropiada si el tiempo de respuesta y el consumo de recursos no es una pega. Escalabilidad La complejidad de una aplicación distribuida se incrementa significativamente, posi­ blem ente de forma exponencial, cuando e l núm ero de participantes (procesos u ob­ jetos) se incrementa. Considérese la aplicación de ejemplo, el sistem a de subastas. Tal y como se ha descrito, el subastador debe manejar las direcciones de los parti­ cipantes d e forma que pueda anunciar el comienzo y final de la sesión. Además, el subastador tiene que contactar repetidas veces con los participantes, de forma indi­ vidual, para notificarles la puja más alta. Utilizando paso de mensajes, el programa­ dor debe codificar la gestión d e direcciones y la forma de contactar individualmen­ te con cada uno d e ellos. La com plejidad crece cuando crece e l núm ero de participantes. Con un conjunto de herramientas de un paradigma de alto nivel, como espacios de objetos o un sistema de mensajes de tipo public ación/suscripción, la complejidad de gestionar los participantes la realiza el sistema. Una aplicación así implementada se puede acomodar a un incremento en el número de participantes sin una compleji­ dad adicional. Los agentes móviles son otro paradigma que permite a una aplicación escalar bue­ na, mientras que el número de ordenadores participantes puede incrementarse sin un impacto significativo en la complejidad del programa basado en este paradigma. Soporte m ulti-plataform a Los paradigmas, al ser modelos abstractos, son inherentemente independientes de pla­ taforma. Las herramientas basadas en los paradigmas, por otro lado, pueden ser de­ pendientes de plataforma, y muchas de ellas lo son. Con el objeto de proporcionar generalidad, una herramienta que soporte plataformas heterogéneas necesariamente incrementa la complejidad, si se compara con una que soporte una única plataforma. Por esta razón, la sintaxis de programación tam bién tiende a ser más pesada. M uchas de las tecnologías Java, incluida e l API Java RMI y los JavaSpaces, por omisión sólo ejecutan sobre máquinas virtuales Java. Como resultado, si se utilizan www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones estas tecnologías, todos los participantes en una aplicación deben estar escritos en len­ guaje Java. De la misma forma, las tecnologías COM/DCOM sólo son desplegables sobre plataformas Microsoft. Por contraste, CORBA es una arquitectura diseñada para dar soporte multi-plata- forma; d e forma que las herramientas basadas en esta tecnología pueden soportar pro­ gramas escritos en diversos lenguajes y también procesos ejecutando sobre distintas plataformas. Más allá de estas ventajas e inconvenientes, hay consideraciones de ingeniería de software que se deben considerar cuando se selecciona una herramienta. Algunas de ellas son: • La madurez y estabilidad de la herramienta. • L a tolerancia a fallos ofrecida por la herramienta. • La disponibilidad de herramientas de desarrollo. • La mantenibilidad. • L a reutilización de código. Este capítulo ha repasado una am plia gam a de paradigmas para aplicaciones distri­ buidas. Los paradigmas que se han presentado son: • Paso d e mensajes. • Cliente-servidor. • Peer-to-peer. • Sistemas de mensajes: — Punto a punto. — Publicación/suscripción. • Llamada a procedimientos remotos. • Objetos distribuidos: — Invocación de métodos remotos. — Object request brokers. — Espacio de objetos. • Agentes móviles • Servicios de red • Aplicaciones colaborativas A varios niveles, estos paradigmas proporcionan abstracción que aísla a los progra­ madores de los detalles de comunicación entre procesos y la sincronización de even­ tos, permitiendo a quien desarrolla, concentrarse en la visión general de la aplicación completa. En la elección de un paradigma o de una herramienta para una aplicación, existen ventajas e inconvenientes que se deben considerar, incluyendo la sobrecarga, escala- bilidad, soporte multi-plataforma y consideraciones de ingeniería del software. www.FreeLibros.org Paradigm as d e com p u ta ció n distribu ida E J E R C IC IO S 1. Considere la implementación de una sala de chat sencilla donde los partici­ pantes acuden a un lugar de reunión virtual e intercambian mensajes entre to­ dos los que están presentes en la sala. Explique cómo se podría aplicar cada uno de los paradigmas vistos en el capítulo en su implementación. Compare la adecuación d e los paradigmas para esta aplicación. Desde el punto de vista del programador, ¿cuál o cuáles de los paradigmas parecen los más naturales? ¿Cuál o cuáles los menos naturales? 2. Considere las ventajas e inconvenientes que hemos visto: a ¿Se le ocurre alguna comparativa adicional? b. Compare y contraste las fortalezas y debilidades d e cada paradigma que se han visto, en términos de estas ventajas e inconvenientes adicionales. 3. Considere los paradigmas vistos. Para cada uno, describa una aplicación para la cual el paradigma es más apropiado. Explíquelas. 4. En muchos de los paradigmas que se han tratado hay implicado un m iddle­ ware, un módulo software que sirve de intermediario entre los participantes de una aplicación: a C onsidere e l m odelo d e sistem a de m ensajes publicación/suscripción. ¿Cómo e l middleware en este paradigma permite publicar y suscribir? b. ¿Cómo puede el middleware permitir el soporte multi-plataforma? c. ¿Cóm o puede el middleware proporcionar comunicación asincrona entre procesos? d. ¿Cuáles de los paradigmas necesitan un middleware? Explíquelo. 5. Suponga que está contruyendo un sistem a software para tratar los registros de gastos. Usando el sistema, cada em pleado puede transmitir una petición On­ line de gasto, y posteriormente recibe una aprobación o denegación, también on-line. Un em pleado puede también enviar un registro para un gasto una vez que éste ha sido cursado. Sin entrar en aspectos m uy específicos, elija un pa­ radigma para el sistema, justifique su elección, y describa cómo aplicaría di­ cho paradigma en la aplicación. R E FER EN C IA S 1. D avid J. B a m e s. Object-Oriented Programming. U pper S a d d le R iver, NJ: P rentice Hall, 1999. 2. D ouglas E. C om er a n d D avid L. S tevens. Intemetworking with TCP/IP, Vol. 3: Client-Ser- ver Programming and Applications. U pper S a d d le R iver, NJ: P rentice H all, 2001. 3. E lliotte R usty H arold. Java Network Programming. S ebastopol, C A : O ’Reilly, 1997. 4. W elcom e to Jin i.o rg t, http://www.jini.org/ 5. A la n D ickm an. Designing Applications with Msmq: Message Queuing fo r Developers. Re- a d in g , M A: A ddison-W esley, 1998. 6. IB M M Q S eries F am ily h o m e page, http://www-4.ibm.com/soJtware/ts/mqseries/ 7. Jo h n W etherill, M essaging S y ste m s a n d th e Java™ M essage S erv ice, http://developer.java. sun.com/developer/technicalArticles/Networking/messaging/ www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones 8. R F C 1831: E specificación d e l Protocolo R F C , R em óte Procedure C a li P rotocol Specifica- tio n V ersión 2, A ugust 1995, http://www.ietf.org/rfc/rfcl831 .txt 9. D C E 1.1; R em óte Procedure C ali, O pen G roup S tan d ard , D ocum ent N um ber C 706 A ugust 1997, http://www.opennc.org/public/pubs/catalog/c706.htm 10. T h e O bject M anagem ent G roup hom epage, http://www.corba.org/ 11. T h o m a s J . M o w bray a n d R o n Z ah a v i. The Essential CORBA. N ew Y ork, NY: W iley, 1995. 12. T h e C o m m unity R esource for Jini T echnology, http://jini.org/ 13. D ’A gents: M obile A g e n ts a t D artm outh C ollege, http://agent.cs.dartmouth.edu/ 14. T A C O M A — O peratin g system su p p o rt for agents, http://www.tacoma.cs.uit.no/ 15. JavaS paces™ T echnology, http://java.sun.com/products/javaspaces/ 16. C o n c o rd ia s w e lco m e page, http://www.meitca.com/HSL/Projects/Concordia/Welcome.html 17. IB M A glets S o ftw are D ev elo p m en t Kit, http://www.trl.ibm.co.jp/aglets/ 18. Ja v a S h a re d D ata T oolkit U ser G uide, http:Hjava.sun.com/products/java-medialjsdtl2.0ljsdt- guide/introduction.doc.htmW 15891 a n d http:lljava.sun.com/productsljava-medialjsdtl2.0/ jsdt-guidefjsdtTOC.fm.html 19. S M A R T B oard In teractive W hiteboard, S o ftw are Features, http://www.smarttech.com/pro- ducts/smartboard/software.asp 20. N etM eeting H om e, http://www.microsoft.com/windows/netmeeting/ 21. IB M L o tu s S o ftw are— Q uickPlace, http:lllotus.com/ 22. M i c r o s o f t M e s s a g e Q u e u e i n g , h ttp : /lm sd n .m ic r o s o ft.c o m /lib r a r y lp s d k /m s m q / msmq_overview_4ilh.htm 23. Ja v a so ck et API, http://java.sun.eom/producsts/jdk/l.2/docs/api/index.html 24. W insock D ev elo p m en t Inform ation, http://www.sockets.com/ 25. T h e W o rld W id e W eb C o n so rtiu m (W 3 C ), S im p le O b je c t A c c e ss P ro to c o l (S O A P ), http://www.w3.org/TR/SOAP/ 26. T h e X N S O R G hom epage, http://wwwjins.org/ 27. G roove hom epage, http://www.groove.net/ 28. M ark Day, Jo h n F. P atterson, D avid M itchell, T h e N otification S erv ice T ransfer Protocol (N S T P ): In fra s tru c tu re fo r S y n c h ro n o u s G ro u p w a re , L o tu s T e c h n ic a l R e p o rt 96-13, http:ffwww.scope.gmd.de/infolwww6ltechnical/paper080/paper80.html 29. jx ta .o rg , http://www.jxta.org/, P ro je ct JX T A hom e site. 30. Jab b er S o ftw are Foundation, http://www.jabber.org/, Jab b er S o ftw are F o u n d atio n hom e site. www.FreeLibros.org CAPITULO El A P I d e s o c k e ts Este capítulo introduce la prim era herramienta de program ación para im plem entar com unicaciones entre procesos: el API de sockets. Com o el lector p o drá recordar del C apítulo 2, el API de sockets es un m ecanism o que proporciona un nivel bajo de abstracción para IPC. Se presenta en este punto por su sim plicidad. Aunque los program adores de aplicaciones apenas tienen que c o d ifica r en este nivel, la com prensión del API de sockets es im portante al menos por dos razones. En prim er lugar, los mecanism os de com unicación proprocionados en estratos superiores se construyen sobre el API de sockets; o sea, se im plem entan utilizando las operaciones proporcionadas por el API de sockets. En segundo lugar, para aquellas aplicaciones en las que es prim ordial el tiem po de respuesta o que se ejecutan sobre una plataform a con recursos lim itados, el API de sockets puede s e r el m ecanism o de IPC más apropiado, o incluso el único disponible. 4 .1 . A N T E C E D E N T E S El API de sockets aparece por primera vez a principios de la década de los 80 como una biblioteca de programación que proporcionaba la funcionalidad de IPC en una versión del sistema operativo UNIX conocida como U n ix d e B o k d e y (BSD 4.2). A c­ tualmente los principales sistem as operativos dan soporte a l API de sockets. En los sistemas basados en UNIX tales como BSD o Linux, e l API es parte del núcleo, o kernel, del sistema operativo. En los sistemas operativos de computadores personales tales como MS-DOS, Windows N T (y sus variantes), Mac-OS y OS/2, el API se pro­ porciona como bibliotecas d e programación. (En los sistem as Windows, a esta API se www.FreeLibros.org 92 C om putación distribuida. Fundam entos y aplicaciones En la terminología de las redes de datos, un paquete es una unidad de datos transmitida por la red. Cada paquete contiene los datos (la carga, en inglés paytoad) y alguna información de control (la cabecera), que incluye la dirección de destino. la conoce como W n so cb Java, un lenguaje diseñado teniendo en cuenta la progra­ mación d e aplicaciones en red, proporciona el API de sockets como parte de las cla­ ses básicas del lenguaje. Todas estas interfaces de programación de sockets compar­ ten e l mismo modelo de paso de mensajes y una sintaxis muy similar. En este capítulo, se usará como caso representativo el API de sockets de Java. Socket (en castellano, enchufe) es un término tomado del campo de las comuni­ caciones telefónicas. En los primeros días de la telefonía (anteriores al siglo xx), cuan­ do una persona quería hacer una llamada a otra tenía que ser a través de un opera­ dor, e l cual manualmente establecía una conexión introduciendo los dos extremos de un cable dentro de dos receptáculos específicos, cada uno asignado a uno de los dos interlocutores, sobre un panel de sockets (enchufes). L a desconexión también la rea­ lizaba el operador manualmente. Esta metáfora fue la base del API de sockets para comunicación entre procesos. 4 .2 . LA M E TÁ FO R A DEL SO C KET EN IP C Inspirándose en la terminología de la telefonía, el diseñador del API de sockets ha proporcionado una construcción d e programación denominada socket. Cuando un pro­ ceso desea comunicarse con otro, debe crear una instancia d e tal construcción (véase la Figura 4.1). Sin embargo, a diferencia de la telefonía primitiva, la comunicación entre los interlocutores puede ser orientada a conexión o sin conexión. Por claridad, primero se presentará el API de sockets sin conexión. P ro ce so A Proceso B 1 1 Un so c k e t 1 F ig u ra 4 .1 . El m o d e lo c o n c e p tu a l d e l API d e s o c k e ts . 4 .3 . EL A P I DE SOCKETS DATAGRAMA Como e l lector podrá recordar del Capítulo 1 de este libro o de cualquier otro sitio, hay dos protocolos fundamentales en el nivel de transporte de la arquitectura de In­ ternet: el protocolo de datagrama de usuario (UDP, User Datagram Protocoí) y el protocolo de control de transmisión (TCP, Transmission Control Protocoí). El protocolo d e d a tag p a m a d e u s u a rio (UDP) permite que un paquete se trans­ porte (es decir, se envíe o se reciba en el nivel de transporte) utilizando comunica­ ciones sin conexión. El paquete d e datos transportado de esta manera se denomina d a tag y a n ia Conforme a la comunicación sin conexión, cada datagrama transportado es dirigido y encaminado individualmente y puede llegar al receptor en cualquier or­ den. Por ejemplo, si el proceso 1 en la máquina A envía sucesivamente mensajes trans­ portados en los datagramas m¡ y m i a l proceso 2 en la máquina B, los datagramas www.FreeLibros.org El API d e sockets 93 pueden transportarse sobre la red por diferentes rutas, y pueden llegar al proceso re­ ceptor en cualquiera de los dos órdenes posibles: mi-mi o mi-rm. El protocolo d e control d e tra ra a m a ó n (TCP) está orientado a conexión y trans­ porta un flujo de datos sobre una conexión lógica establecida entre el emisor y el re­ ceptor. Gracias a la conexión, se garantiza que los datos mandados desde un emisor a un receptor van a ser recibidos en el mismo orden que se enviaron. Por ejemplo, si el proceso 1 en la máquina A manda sucesivamente mensajes transportados en m ¡, y mi al proceso 2 que ejecuta en la máquina B, e l proceso receptor puede asumir que los mensajes se le entregarán en el orden mi-nu y no mi-mi. El API de sockets de Java, como el resto de interfaces de programación de sockets, proporciona construcciones de programación de sockets que hacen uso tanto del protoco­ lo UDP como TCP. Los sockets que utilizan UDP para el transporte son conocidos como jocle& datagpam a, mientras que los que usan TCP se denominan so d a ets tséw m a Debi­ do a su relativa simplicidad, en primer lugar se presentarán los sockets datagrama. El s o c k e t datagram a sin conexión Puede parecer sorprendente, pero los sockets datagrama pueden dar soporte tanto a una comunicación sin conexión como a una orientada a conexión en el nivel de apli­ cación (véase la Figura 4.2). Esto se debe a que, aunque los datagramas se envían o reciben sin la noción de conexiones en e l nivel de transporte, el soporte en tiempo de ejecución del API de sockets puede crear y mantener conexiones lógicas para los da­ tagramas intercambiados entre dos procesos, como se mostrará en la próxima sección. En Java, el A PI de sockets datagrama proporciona dos clases: 1. La clase DatagramSocket para los sockets. 2. La clase DatagramPacket para los datagramas intercambiados. Un proceso que quiera mandar o recibir datos utilizando esta API debe instanciar un objeto DatagramSocket, o un socket para abreviar. S e dice que cada socket está a l ­ i s a d o a un puerto UDP de la máquina que es local al proceso (es decir, la máquina en la que se está ejecutando e l proceso). Recuérdese del Capítulo 1 que en IPv4 los números de puerto válidos van desde el 0 al 65.535, estando reservados desde e l 0 al 1023 para los servicios de carácter estándar, denominados «bien conocidos» (well- h w w n ) en la terminología d e Internet. Para mandar un datagrama a otro proceso (que ha instanciado presumiblemente su socket en una dirección local de, por ejemplo, la máquina m y el puerto p), un pro­ ceso debe crear un objeto que representa el datagrama en sí mismo. Este objeto pue­ de crearse instanciando un objeto DatagramPacket que englobe (1) una referencia a un vector de octetos que contenga los datos de la carga, y (2) la dirección de desti­ no (el ID de la máquina y el número de puerto al que el socket del receptor está en­ lazado, en este caso, m y p, respectivamente). Una vez que se crea el objeto Data­ gramPacket y en él se incluyen los datos de la carga y del destino, el proceso emisor realiza una llamada al método send del objeto DatagramSocket, especificando una re­ ferencia al objeto DatagramPacket como argumento. En el proceso receptor, también se debe instanciar un objeto DatagramSocket y enlazarlo a un puerto local; e l número de puerto debe coincidir con el especificado en el paquete datagrama del emisor. Para recibir los datagramas enviados al socket, e l proceso crea un objeto DatagramPacket que hace referencia a un vector de octe­ tos y llama a un método receive de su objeto DatagramSocket, especificando como argumento una referencia al objeto DatagramPacket. El soporte en tiem po de ejecución de una API es un conjunto de software que está enlazado al programa durante su ejecución para dar soporte al API._________ Es muy recomendable que se desarrolle el hábito de consultar la documentación en línea del API de Java ¡ava.sun.com, 1) para obtener la definición más actualizada de cada dase Java presentada. Se debería comprobar también en el API en línea cuál es la definición exacta y actual de un método o constructor. Los datos de la carga se denominan de esta manera para diferenciarlos de los datos de control, que incluyen la dirección de destino y se transportan también en un datagrama.___________ www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones Soporte en t, ejecución del API de sockets Proceso A ^ ^ Proceso B Soporte en t, ejecución del API de sockets Software de nivel de transporte Software de nivel de transporte --------- ------------ ► S o c k e t datagram a sin conexión Soporte en t, ejecución del API de sockets Pr A 1 F .... - ......- .... ^ Proceso B Soporte en t, Proceso A de sockets Software de nivel de transporte Software de nivel de transporte S o c k e t datagram a orientado a conexión Un datagrama ; Una conexión lógica creada y m antenida p o r el soporte en tiem po de ejecución del API de sockets datagrama F ig u ra 4 .2 . S o c k e t d a ta g ra m a s in c o n e x ió n y o rie n ta d o a co n e xió n . La Figura 4.3 ilustra las estructuras de datos usadas en los programas de los dos procesos, mientras que la Figura 4.4 ilustra el flujo de programa de los dos procesos. Program a emisor Program a receptor ► Referencia a un objeto ► Flujo de datos F ig u ra 4 .3 . La s e s tru c tu ra s d e d a to s e n e l p ro gra m a e m is o r y en e l receptor. www.FreeLibros.org El API d e sockets 95 P ro g ra m a re c e p to r Crea un s o c k e t d a ta g ra m a y lo e n la za a un p u e rto lo c a l e sp e cífico ; crea un v e c to r de o c te to s pa ra re c ib ir lo s d a to s; crea un p a q u e te d a ta g ra m a , e s p e c ific a n d o el v e c to r d e d a to s; in v o c a el m é to d o re c e p to r del s o c k e t con u n a re fe re n c ia al p a q u e te d a ta g ra m a . F ig u ra 4 .4 . El flu jo d e p ro gra m a en e l p ro c e s o e m is o r y e n el receptor. Con los sockets sin conexión, un socket enlazado a un proceso puede utilizarse para mandar datagramas a diferentes destinos. Es también posible que múltiples pro­ cesos manden simultáneamente datagramas al mismo socket enlazado a un proceso re­ ceptor, en cuyo caso el orden de llegada de estos mensajes será impredecible, de acuer­ do con el protocolo UDP subyacente. La Figura 4.5a ilustra un escenario donde un proceso, A utiliza un único socket sin conexión para comunicarse con otros dos pro­ cesos en una sesión. Por ejemplo, A puede recibir un datagrama ñu de B, seguido por un datagrama m i d e C, después na y d e B, seguidos de m sáe C, y así sucesiva­ mente. Alternativamente, es también posible que A abra un socket separado para cada proceso B y C, de manera que los datagramas de los dos procesos se puedan dirigir y recibir por los dos sockets separados (véase la Figura 4.5b). La Tabla 4.1 resume los métodos principales y los constructores de la clase Da- tagramPacket, mientras que la Tabla 4.2 recopila los de la clase DatagramSocket. Re­ cuerde que hay muchos más métodos de los que se presentan en esta tabla. | Un s o c k e t d a ta g ra m a sin c o n e x ió n F ig u ra 4 .5 . S o c k e t s d a ta g ra m a s in c o n e x ió n . (a) P ro g ra m a e m is o r Crea u n s o c k e t d a ta g ra m a y lo en la za a c u a lq u ie r p u e rto lo ca l; s itú a d a to s en v e c to r de o c te to s ; crea un p a q u e te d a ta g ra m a , e s p e c ific a n d o el v e c to r de d a to s y la d ire c c ió n d e l re c e p to r; in v o c a el m é to d o re c e p to r del s o c k e t con un a re fe re n c ia al p a q u e te d a ta g ra m a . www.FreeLibros.org T a b la 4 .1 . M é to d o s p rin cip a le s d e la c la s e D a tagram P acket. C om putación distribuida. Fundam entos y aplicaciones M éto d o /C o n stru cto r D escripción DatagramPacket(byte¡] almacén, int longitud) DatagramPacketf by te [¡almacén, int longitud, InetAddress dirección, int puerto) (Nota: La clase InetAddress representa una dirección IP.) DatagramSocket() Construye un paquete datagrama para recibir paquetes de longitud longitud; los datos recibidos se almacenarán en e l vector de octetos asociado a almacén. Construye un paquete datagrama para enviar paquetes de longitud longitud al socket enlazado al número de puerto y a la máquina especificados; los datos se almacenan en el vector de octetos asociado a almacén. Construye un socket datagrama y lo enlaza a cualquier puerto disponible en la máquina local; este constructor lo puede utilizar un proceso que manda datos y no necesita recibirlos. T a b la 4 .2 . M é to d o s p rin cip a le s d e la c la s e D a ta g ra m S o cket. M éto d o /C o n stru cto r D escripción DatagramSocket(int puerto) void close( ) void rece ive( DatagramPacket p) void send(DatagramPacket p) void setSoTimeout(int plazo) Construye un socket datagrama y lo enlaza al puerto especificado en la máquina local; este número de puerto se puede especificar después en un paquete datagrama destinado a este socket. Cierra este objeto datagramSocket. Recibe un paquete datagrama utilizando este socket. Envía un paquete datagrama utilizando este socket. Fija un plazo máximo de espera en milisegundos para las operaciones de recepción bloqueantes realizadas con este socket. La Figura 4.6 ilustra la sintaxis básica mediante un par de programas que se co­ munican utilizando sockets datagrama. / /E x tr a c to d e un p ro g ra m a re c e p to r D a ta gra m S ocket d s = n e w D a ta g ra m S o cke t(2 3 4 5 ); D a ta g ra m P a cke t d p = n e w D a ta g ra m P a cke t (b u ffe r, MAXLO N); d s.re ce ive (d p ); lo n = d p .g e tL e n g th (); S y s te m .o u t.P rin tln (Ion + \"o c te to s re c ib id o s \"); S trin g s = n e w S trin g (d p .g e tD a ta ( ),0 ,lo n ); S y s te m .o u t.p ri n tln (d p .g e tA d d re s s ( )+ \"en el p u e rto \" + d p .g e t P o r t( ) + \"d ice \" + s / /E x t r a c t o de un p ro c e s o e m is o r In e tA d d re ss m a q u in a R eceptora= Ine t A dd ress.ge tB yN am e C 'loca lH o st\"); D a ta g ra m S o cke te l S o cke t= n e w D atag ram SocketO ; S trin g m e n sa je = \"¡H o la ,m u n d o !\"; b y te [ ] d a to s = m e n s a je .g e tB y te s (); d a ta = th e L in e .g e tB y te s (); D a ta g ra m P a cke t elP aquete= n e w D a ta g ra m P a cke t (da to s, d a to s , le n g th , m aq ui naR e cepto ra ,2 345); el S ocke t.se nd ( el Paquete); F ig u ra 4 .6 . U so d e l API d e s o c k e ts d a ta g ra m a s in c o n e x ió n e n program as. www.FreeLibros.org El API d e sockets 97 S in cro n iza ción de e ven tos en los sockets datagram a En las interfaces de programación d e sockets básicas, ya sean orientadas a conexión o sin conexión, las operaciones send son n o M oqueantes, mientras que las operacio­ nes receive son M oqueantes Un proceso continuará con su ejecución después de re­ alizar una llamada al método send. Sin embargo, una llamada al método receive, una vez invocada por un proceso, causará que el proceso se suspenda hasta que se reciba realmente un datagrama. Para evitar un bloqueo indefinido, el proceso receptor pue­ de utilizar el método setSoTimeout para fyar un plazo máximo de tiempo de bloqueo, por ejemplo, 50 segundos. Si no se recibe ningún dato durante este plazo de tiempo, se activará una excepción Java (específicamente, ocurrirá una java.io.InterruptedlO- Exception) que puede capturarse en el código para manejar la situación de manera apropiada. La Figura 4.7 es un diagrama d e eventos que muestra una sesión de un protoco­ lo petición-respuesta utilizando sockets datagrama. Servidor Cliente receive ( ^ ) send send ( J ) receive Bloqueado — Desbloqueado F ig u ra 4 .7 . S in cro n iza ció n d e e v e n to s c o n s o c k e t s sin c o n e x ió n . E j o q i l o 1. Las Figuras 4.8 y 4.9 ilustran el código de dos programas que utili­ zan sockets datagrama para intercambiar una única cadena de datos. Por diseño, la ló ­ gica de los programas es la más sencilla posible para subrayar la sintaxis básica de las comunicaciones entre procesos. Nótese que el em isor crea un paquete datagrama que contiene una dirección d e destino (véanse las líneas desde la 31 a la 33 en la Fi­ gura 4.8), mientras que el paquete datagrama del receptor no incluye una dirección de destino (véanse las líneas 31 y 32 en la Figura 4.9). Nótese tam bién que el socket del emisor se enlaza a un número de puerto no especificado (véase la línea 28 de la Figura 4.8), mientras que el socket del receptor se enlaza a un número de puerto es­ pecificado (véase la línea 28 en la Figura 4.9) para que el emisor pueda especificar este número de puerto en su datagrama (véase la línea 33 en la Figura 4.8) como des- www.FreeLibros.org C om putación distribuida. Fundam entos y aplicaciones tino. Se debería mencionar también que por simplicidad los programas de ejem plo uti­ lizan una sintaxis rudimentaria (líneas 37-39 en Ejemplo 1 Emisor y 38-40 en Ejem­ plo ¡Receptor) para manejar excepciones. En una aplicación real, es necesario a me­ nudo manejar las excepciones utilizando un código más refinado. Figura 4.8. EjempblEmisorjava. 1 inport java.net.*; 2 ■j inport java.io.*; o 4 /** 5 * Este ejemplo ilustra las llamadas de método básicas para sockets 6 * datagrama sin conexión 7 * 0author M. L. Liu 8 */ 9 public class EjemplolEmisor { 10 11 // Una aplicación que manda un mensaje utilizando un socket datagrama 12 // sin conexión. 13 // Se esperan tres argumentos de línea de mandato, en orden: 14 // cnoirbre del dominio o dirección IP del receptor> 15 // <número del puerto del socket del receptor> 16 // cmensaje, una cadena, para mandar> 17 18 public static void main(String[ ] args) { 19 if (args. length != 3) 20 System.out.println 21 (\"Este programa requiere 3 argumentos de linea de mandato\"); 22 else { 23 try { 24 InetAddress maquinaReceptora = InetAddress. getByName (args [ 0 ]) ; 25 int puertoReceptor = Integer.parselnt(args[1]); 26 String mensaje = args[2]; 27 28 // instancia un socket datagrama para mandar los datos 29 DatagramSocket miSocket = new DatagramSocket ( ); 30 byte[ ] almacén = mensaje.getBytes( ); 31 DatagramPacket datagrama = 32 new DatagramPacket(almacén, almacén.length, 33 maquinaReceptora, puertoReceptor); 34 miSocket.send(datagrama); 35 miSocket.cióse( ); 36 } // fin de try 37 catch (Exception ex) { 38 ex.printStackTrace( ) ; 39 } // fin de catch 40 } // fin de else 41 } // fin de main 42 > // fin de class www.FreeLibros.org El API d e sockets 99 F ig u ra 4 .9 . E jem p lo IR ecep to r.ja va . 1 i m p o r t j a v a . n e t . * ; 2 i m p o r t j a v a . i o . * ; 3 4 /* * 5 * E s te e je m p lo i l u s t r a l a s lla m a d a s d e m étodo b á s i c a s p a r a s o c k e t s 6 * d a ta g r a m a s i n c o n e x i ó n . 7 * G a u th o r M. L . L i u 8 */ 9 p u b l i c c l a s s E j e m p l o I R e c e p t o r { 10 11 / / Una a p li c a c ió n q u e r e c i b e un m e n sa je u t i l i z a n d o un s o c k e t datag ram a 12 / / s i n c o n e x i ó n . 13 / / S e e s p e r a u n a r g u m e n to d e l í n e a d e m a n d a to : 14 / / e n u m e ro d e p u e r t o d e l s o c k e t d e l r e c e p t o r > 15 / / N o ta : s e d e b e r í a e s p e c i f i c a r e l m ism o n ú m ero d e p u e r t o 16 / / e n l o s a r g u m e n to s d e l í n e a d e m a n d a to d e l e m i s o r . 17 18 public static void main(String[ ] args) { 19 if (args. length != 1) 20 System.out.println 21 (\"Este programa requiere un argumento de línea de mandato.\"); 22 else { 23 int puerto = Integer.parselnt(args[0 ]); 24 final int MAX_LON = 1 0 ; 25 // Esta es la longitud máxima asumida en octetos 26 // del datagrama que se va a recibir. 27 try { 28 DatagramSocket miSocket = new DatagrairSocket (puerto); 29 // instancia un socket datagrama para recibir los datos 30 b y t e [ ] a lm a c é n = new b y t e [ MAX_L0N ] ; 31 DatagramPacket datagrama = 32 new DatagramPacket (almacén, MAX_LON ); 33 miSocket. receive (datagrama); 34 String mensaje = new String(almacén); 35 System. out.println(mensaje); 36 miSocket.cióse( ); 37 > // fin de try 38 catch (Exception ex) { 39 ex.printStackTrace( ); 40 > // fin de catch 41 } // fin de else 42 } // fin de main 43 } / / f i n d e c l a s s Dado que los datos se m andan en paquetes discretos en un m odo sin conexión, hay algunas anom alías en el com portam iento de lo s sockets datagram a sin co­ nexión: • Si se manda un datagrama a un socket que el receptor todavía no ha creado, es posible que el datagrama sea desechado. En otras palabras, puede que el meca- www.FreeLibros.org 100 C om putación distribuida. Fundam entos y aplicaciones nismo de IPC no salve el datagrama para que se entregue al receptor cuando éste realice finalmente una llamada receive. En este caso, se pierden los datos y la llamada receive puede resultar bloqueada indefinidamente. Se puede expe­ rimentar con este comportamiento arrancando Ejemplo 1 Emisor antes de ejecu­ tar Ejemplo ¡Receptor. • S i el receptor especifica una zona de almacenamiento para el datagrama (esto es, el vector de octetos asociado al objeto DatagramPacket) con un tamaño n, un mensaje recibido con un tamaño en octetos mayor que n se truncará. Por ejemplo, si Ejemplo ¡Em isor manda un mensaje de 11 octetos, el último octeto en el mensaje (correspondiente al último carácter) no se mostrará en la salida d e Ejemplo ¡Receptor, ya que el tam año de la zona de almacenamiento para el datagrama del receptor es sólo de 10 octetos. E j e n f l o 2. En el ejemplo 1, la comunicación es simplex', o sea, unidireccional, des­ de el emisor a l receptor. Es posible hacer la comunicación dúplex o bidireccional. Para hacerlo así, Ejemplo 1 Emisor necesitará enlazar su socket a una dirección específica para que Ejemplo ¡Receptor pueda mandar datagramas a esa dirección. El código de ejemplo en las Figuras 4.10, 4.11 y 4.12 ilustra cómo puede llevar­ se a cabo la comunicación dúplex. En aras de la modularidad del código, se crea una clase llamada MiSocketDatagrama (Figura 4.10) como una subclase de Datagram- Socket, con dos métodos de instancia para mandar y recibir un mensaje, respectiva­ mente. El programa Ejemplo2EmisorReceptor (Figura 4.11) instancia un objeto M i­ SocketDatagrama, a continuación, llama a su método enviaMensaje, seguido por una llamada a su método recibeMensaje. El programa Ejemplo2ReceptorEmisor (Figura 4.12) instancia un objeto MiSocketDatagrama, a continuación, llama a su método re­ cibeMensaje, seguido por una llamada a su método enviaMensaje. Figura 4.10. M iSocketD atagram a.¡ava. 1 i n p o r t j a v a . n e t . * ; 2 *3 i m p o r t j a v a . i o . * ; J 4 /* * 5 * U na s u b c l a s e d e D a ta g r a m S o c k e t q u e c o n t i e n e 6 * m é to d o s p a r a m a n d a r y r e c i b i r m e n s a j e s . 7 * 0 a u t h o r M. L . L i u 8 * / 9 p u b l i c c l a s s M iS o c k e tD a ta g r a m a e x t e n d s D a ta g r a m S o c k e t { 10 s t a t i c f i n a l i n t MAX_LON = 1 0 ; 11 M iS o c k e tD a ta g r a m a ( i n t n u m P u e r to ) t h r o w s S o c k e t E x c e p t i o n { 12 s u p e r ( n u m P u e r to ) ; 13 > 14 p u b l i c v o i d e n v i a M e n s a j e ( I n e t A d d r e s s m a q u i n a R e c e p to r a , 15 i n t p u e r t o R e c e p t o r , S t r i n g m e n s a je ) th r o w s I O E x c e p tio n 16 17 b y t e [ ] a lm a c e n E n v io = m e n s a j e . g e t B y t e s ( ) ; 18 D a ta g r a m P a c k e t d a t a g r a m a = 19 new D a ta g r a m P a c k e t( a lm a c e n E n v i o , a l m a c e n E n v i o . l e n g t h , 20 m a q u i n a R e c e p to r a , p u e r t o R e c e p t o r ) ; ( continúa) www.FreeLibros.org 21 22 23 24 25 26 27 28 29 30 31 32 33 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 El API d e sockets 101 t h i s . s e n d ( d a t a g r a m a ) ; } / / f i n d e e n v ia M e n s a j e p u b l i c S t r i n g r e c i b e M e n s a j e ( ) th r o w s I O E x c e p ti o n { b y t e [ ] a lm a c e n R e c e p c io n = new byte[MAX_LON] ; D a ta g r a m P a c k e t d a ta g r a m a = new D a ta g r a m P a c k e t ( a l m a c e n R e c e p c io n , MAX_LON) ; t h i s . r e c e i v e ( d a t a g r a m a ) ; S t r i n g m e n s a je = new S t r i n g ( a lm a c e n R e c e p c io n ) ; r e t u m m e n s a j e ; } / / f i n d e r e c i b e M e n s a j e } / / f i n d e c l a s s F ig u ra 4 .1 1 . E jem p lo 2 E m iso rfíecep to r.ja va . i m p o r t j a v a . n e t . * ; /** * E s t e e je m p lo i l u s t r a u n p r o c e s o q u e e n v í a y d e s p u é s r e c i b e * u t i l i z a n d o un s o c k e t d a t a g r a m a . * G a u th o r M. L . L i u * / p u b l i c c l a s s E je m p lo 2 E m is o r R e c e p to r { / / Una a p l i c a c i ó n q u e manda y q u e d e s p u é s r e c i b e un m e n s a je u t i l i z a n d o / / u n s o c k e t d a ta g r a m a s i n c o n e x i ó n . / / S e e s p e r a n c u a t r o a r g u m e n to s d e l í n e a d e m a n d a to , e n o r d e n : / / c n a n b r e d e d o m in io o d i r e c c i ó n I P d e l r e c e p t o r > / / e n u m e ro d e p u e r t o d e l s o c k e t d a ta g r a m a d e l r e c e p t o r > / / e n u m e ro d e p u e r t o d e l s o c k e t d a ta g r a m a d e e s t e p r o c e s o / / e m e n s a j e , u n a c a d e n a , p a r a m a n d a r> p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { i f ( a r g s . l e n g t h != 4 ) S y s te m , o u t . p r i n t l n ( \"E fete p ro g r a m a r e q u i e r e 4 a rg u m e n to s d e l í n e a d e m a n d a t o \" ) ; e l s e { t r y { In e tA d d re s s m aq u in aR ecep to ra = In etA d d ress.g etB y N am e (arg s[ 0 ] ) ; i n t p u e r to R e c e p to r = I n t e g e r . p a r s e l n t ( a r g s [ 1 ] ) ; i n t m iP u e r to = I n t e g e r . p a r s e l n t ( a r g s [2 ] ) ; S t r i n g m e n s a je = a r g s [ 3 ] ; M iS o c k e tD a ta g ra m a m iS o c k e t = new M iS o c k e tD a ta g ra m a (m i P u e r t o ) ; / / i n s t a n c i a u n s o c k e t d a ta g r a m a p a r a e n v i a r (continúa) www.FreeLibros.org 102 C om putación distribuida. Fundam entos y aplicaciones 30 / / y r e c i b i r d a t o s 31 m i S o c k e t .e n v i a M e n s a j e ( m a q u i n a R e c e p to r a , p u e r t o R e c e p t o r , m e n s a j e ) ; 32 / / a h o r a e s p e r a r e c i b i r u n d a ta g r a m a p o r e l s o c k e t 33 S y s t e m . o u t . p r i n t l n ( m i S o c k e t . r e c i b e M e n s a j e ( ) ) ; 34 m i S o c k e t . c i ó s e ( ) ; 35 } / / f i n d e t r y 36 c a t c h ( E x c e p t i o n e x ) { 37 e x . p r i n t S t a c k T r a c e ( ) ; 38 > / / f i n d e c a t c h 39 > / / f i n d e e l s e 40 > / / f i n d e m a in 41 42 } / / f i n d e c l a s s F ig u ra 4 .1 2 . E jem plo2R eceptorE m isor.java. 1 2 •3 i m p o r t j a v a . n e t . * ; o 4 /* * 5 * E s t e e je m p lo i l u s t r a u n p r o c e s o q u e r e c i b e u n m e n s a je y 6 * d e s p u é s l o e n v í a u t i l i z a n d o u n s o c k e t d a t a g r a m a . 7 * G a u th o r M. L . L i u 8 * / 9 p u b l i c c l a s s E je m p lo 2 R e c e p to r E m is o r { 10 / / Una a p l i c a c i ó n q u e r e c i b e u n m e n s a je y d e s p u é s l o m anda u t i l i z a n d o 11 / / u n s o c k e t d a ta g r a m a s i n c o n e x i ó n . 12 / / S e e s p e r a n c u a t r o a r g u m e n to s d e l í n e a d e m a n d a to , e n o r d e n : 13 / / c n o m b re d e d o m in io o d i r e c c i ó n I P d e l r e c e p t o r > 14 / / e n u m e ro d e p u e r t o d e l s o c k e t d a ta g r a m a d e l r e c e p t o r > 15 / / e n u m e ro d e p u e r t o d e l s o c k e t d a ta g r a m a d e e s t e p r o c e s o 16 / / e m e n s a j e , u n a c a d e n a , p a r a m a n d a r> 17 18 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 19 i f ( a r g s . l e n g t h 1= 4 ) 20 S y s te m . o u t . p r i n t l n 21 ( \" E s t e p ro g ra m a r e q u i e r e 4 a rg u m e n to s d e l í n e a d e m a n d a to \" ) ; 22 e l s e { 23 t r y { 24 I n e tA d d r e s s m a q u in a R e c e p to ra = I n e tA d d r e s s .g e tB y N a m e ( a rg s [0 ]) ; 25 i n t p u e r t ó R e c e p t o r = I n t e g e r . p a r s e l n t ( a r g s [ 1 ] ) ; 26 i n t m i P u e r t o = I n t e g e r . p a r s e l n t ( a r g s [ 2 ] ) ; ( continúa) www.FreeLibros.org El API d e sockets 1 0 3 27 S t r i n g m e n s a je = a r g s [ 3 ] ; 28 / / i n s t a n c i a u n s o c k e t d a ta g r a m a p a r a e n v i a r 29 / / y r e c i b i r d a t o s 30 M iS o ck etD atag ram a m iS o c k e t = new M iS o ck etD atag ram a (m iP u e r to ) ; 31 / / P r i m e r o e s p e r a a r e c i b i r u n d a ta g r a m a p o r e l s o c k e t 32 S y s te m . o u t . p r i n t l n ( m i S o c k e t . r e c i b e M e n s a j e ( ) ) ; 33 / / A h o ra e n v í a u n m e n s a je a l o t r o p r o c e s o . 34 m iS o c k e t.e n v ia M e n s a je (m a q u in a R e c e p to ra , p u e r to R e c e p to r , m e n s a je ) ; 35 m i S o c k e t . c i ó s e ( ) ; 36 } / / f i n d e t r y 37 c a t c h ( E x c e p t i o n e x ) { 38 e x . p r i n t S t a c k T r a c e ( ) ; 39 > / / f i n d e c a t c h 40 } / / f i n d e e l s e 41 } / / f i n d e m a in 42 43 } / / f i n d e c l a s s Es tam bién posible que múltiples procesos entablen una comunicación sin cone­ xión de esta manera; es decir, se puede añadir un tercer proceso que también tenga un socket datagrama, de forma que pueda también mandar y recibir de los otros pro­ cesos. En los ejercicios se tendrá la oportunidad d e experimentar con el código de ejem ­ plo para mejorar la comprensión del API de sockets datagrama. El API de so cke ts datagram a orientados a conexión A continuación se estudiará cómo usar los sockets datagramas para comunicaciones orientadas a conexión. S e debería mencionar aquí que es poco común emplear sockets datagrama para comunicaciones orientadas a conexión; la conexión proporcionada por esta API es rudimentaria y típicamente insuficiente para las aplicaciones. Los sockets en modo stream, que se presentarán más tarde en este capítulo, son más típicos y apropiados para la comunicación orientada a conexión. La Tabla 4.3 describe dos métodos de la clase DatagramSocket que permiten crear y term inar una conexión. Para realizar una conexión con un socket, se especifica la dirección de un socket remoto. Una vez hecha tal conexión, el socket se utiliza para intercambiar paquetes de datagrama con el socket remoto. En una operación send, si la dirección del datagrama no coincide con la dirección del socket en el otro extre­ mo, se activará IllegalArgumentException. Si se mandan los datos a l socket desde una fuente que no corresponde con el socket remoto conectado, los datos se ignorarán. Así, una vez que se asocia una conexión a un socket datagrama, ese socket no estará disponible para comunicarse con otro socket hasta que la conexión se termine. Nóte­ se que la conexión es unilateral; esto es, sólo se impone en un extremo. El socket en el otro lado está disponible para mandar y recibir datos a otros sockets, a menos que se realice una conexión con este socket. www.FreeLibros.org 104 C om putación distribuida. Fundam entos y aplicaciones T a b la 4 .3 . L lam a das d e m é to d o para un s o c k e t d a ta g ra m a o rie n ta d o a c o n e x ió n . M é to d o / C o n s tru c to r D e s c rip c ió n v o id c o n n ec tf In e lA d d re ss d irecció n , in t p u e r to ) v o id d is c o n n e c tf ) C re a u n a c o n e x ió n ló g ic a e n tre e ste s o c k e t y u n so c k e t e n la d ire c c ió n y p u e rto rem otos. T e rm in a la c o n e x ió n a c tu a l, s i ex iste, d e e s te socket. E jem p lo a El código de Ejemplo3, mostrado en las Figuras 4.13 y 4.14, ilustra la sintaxis de uso de los sockets datagrama orientados a conexión. En la Figura 4.13, Ejemplo3Emisorjava, se crea una conexión entre el socket datagrama del proceso em i­ sor y el del proceso receptor. Nótese que la conexión se hace en ambos lados. Una vez que se establece mutuamente una conexión, cada proceso está obligado a utilizar su socket para la IPC con otro proceso. (Sin embargo, esto no prohíbe a cada proce­ so crear otra conexión utilizando otro socket). En el ejemplo, el emisor manda suce­ sivamente por la conexión 10 copias del mismo mensaje. En e l proceso receptor, se visualiza inmediatamente cada uno d e los diez mensajes recibidos. El proceso recep­ tor después manda un único mensaje de vuelta al proceso emisor para ilustrar que la conexión permite una comunicación bidireccional. F ig u ra 4 .1 3 . E jem plo3E m isor.java. 1 2 i m p o r t j a v a . n e t . * ; 3 4 /* * 5 * E s t e e je m p lo i l u s t r a l a s i n t a x i s b á s i c a d e l o s s o c k e t s d a ta g ra m a 6 * o r i e n t a d o s a c o n e x i ó n . 7 * G a u th o r M. L . L i u 8 * / 9 p u b l i c c l a s s E je m p lo 3 E m is o r { 10 11 / / U na a p l i c a c i ó n q u e u t i l i z a u n s o c k e t d a ta g r a m a o r i e n t a d o a 12 / / c o n e x ió n p a r a m a n d a r m ú l t i p l e s m e n s a j e s , d e s p u é s r e c i b e u n o . 13 / / S e e s p e r a n c u a t r o a r g u m e n to s d e l í n e a d e m a n d a to , e n o r d e n : 14 / / c n o m b re d e d a n i n i o o d i r e c c i ó n I P d e l r e c e p t o r > 15 / / e n u m e ro d e p u e r t o d e l s o c k e t d a ta g r a m a d e l o t r o p r o c e s o 16 / / e n u m e ro d e p u e r t o d e l s o c k e t d a ta g r a m a d e e s t e p r o c e s o 17 / / e m e n s a j e , u n a c a d e n a , p a r a m a n d a r> 18 19 p u b l i c s t a t i c v o i d r a a i n ( S t r i n g [ ] a r g s ) { 20 i f ( a r g s . l e n g t h != 4 ) 21 S y s te m . o u t . p r i n t l n 22 ( \" E s t e p ro g r a m a r e q u i e r e 4 a rg u m e n to s d e l í n e a d e m a n d a t o \" ) ; 23 e l s e { 24 t r y { 25 In e tA d d r e s s m a q u in a R e c e p to ra = I n e t A d d r e s s . getByN am e(a r g s [ 0 ] ) ; 26 i n t p u e r t o R e c e p t o r = I n t e g e r . p a r s e l n t ( a r g s [ 1 ] ) ; 27 i n t m i P u e r t o = I n t e g e r . p a r s e l n t ( a r g s [ 2 ] ) ; ( continúa) www.FreeLibros.org 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 2 0 2 1 22 El API d e sockets 105 i n t m i P u e r t o = I n t e g e r . p a r s e l n t ( a r g s [ 2 ] ) ; S t r i n g m e n s a je = a r g s [ 3 ] ; / / i n s t a n c i a u n a s o c k e t d a ta g r a m a p a r a l a c o n e x ió n M iS ocketD a t a gram a m iS o c k e t = new M iS o c k e tD a ta g ra m a (m i P u e r t o ) ; / / h a c e l a c o n e x ió n m i S o c k e t . c o n n e c t ( m a q u i n a R e c e p t o r a , p u e r t o R e c e p t o r ) ; f o r ( i n t i = 0 ; i < 1 0 ; i+ + ) m i S o c k e t . e n v ia M e n s a j e ( m a q u in a R e c e p to r a , p u e r t o R e c e p t o r , m e n s a j e ) ; / / a h o r a r e c i b e u n m e n s a je d e s d e e l o t r o e x tr e m o S y s t e m . o u t . p r i n t l n ( m i S o c k e t . r e c i b e M e n s a j e ( ) ) ; / / t e r m i n a l a c o n e x i ó n , d e s p u é s c i e r r a e l s o c k e t m i S o c k e t . d i s c o n n e c t ( ) ; m i S o c k e t . c i ó s e ( ) ; } / / f i n d e t r y c a t c h ( E x c e p t i o n e x ) { e x . p r i n t S t a c k T r a c e ( ) ; } / / f i n d e c a t c h } / / f i n d e e l s e } / / f i n d e m a in } / / f i n d e c l a s s F ig u ra 4 .1 4 . Q e m plo3 R ece ptor.ja va. i m p o r t j a v a . n e t . * ; /** * E s t e e je m p lo i l u s t r a l a s i n t a x i s b á s i c a d e l o s s o c k e t s d a ta g ra m a * o r i e n t a d o s a c o n e x i ó n . * G a u th o r M. L . L i u */ p u b l i c c l a s s E je m p lo 3 R e c e p to r { / / U na a p l i c a c i ó n q u e u t i l i z a u n s o c k e t d a ta g r a m a o r i e n t a d o a / / c o n e x ió n p a r a r e c i b i r m ú l t i p l e s m e n s a j e s , d e s p u é s e n v í a u n o . / / S e e s p e r a n c u a t r o a r g u m e n to s d e l í n e a d e m a n d a to , e n o r d e n : / / c n o ir b r e d e d o m in io o d i r e c c i ó n IP d e l e m is o r > / / < n ú m ero d e p u e r t o d e l s o c k e t d a ta g r a m a d e l e m is o r > / / e n u m e ro d e p u e r t o d e l s o c k e t d a ta g r a m a d e e s t e p r o c e s o / / < m e n s a je , u n a c a d e n a , p a r a m a n d a r> p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { i f ( a r g s . l e n g t h != 4 ) S y s t e m . o u t . p r i n t l n ( \" E s t e p ro g r a m a r e q u i e r e 4 a rg u m e n to s d e l í n e a d e m a n d a t o \" ) ; (continúa) www.FreeLibros.org 106 C om putación distribuida. Fundam entos y aplicaciones 23 e l s e { 24 t r y { 25 In e tA d d r e s s m a q u in a E m iso ra = I n e t f t d d r e s s . getByName ( a r g s [ 0 ] ) ; 26 i n t p u e r t o E m i s o r = I n t e g e r . p a r s e l n t ( a r g s [ 1 ] ) ; 27 i n t m i P u e r t o = I n t e g e r . p a r s e l n t ( a r g s [ 2 ] ) ; 28 S t r i n g m e n s a je = a r g s [ 3 ] ? 29 / / i n s t a n c i a u n s o c k e t d a ta g r a m a p a r a r e c i b i r l o s d a t o s 30 M iS o c k e tD a ta g r a m a m i S o c k e t = new M iS o c k e tD a ta g r a m a (m i P u e r t o ) ; 31 / / h a c e u n a c o n e x ió n c o n e l s o c k e t d e l e m i s o r 32 m i S o c k e t.c o n n e c t ( m a q u in a E m i s o r a , p u e r t o E m i s o r ) ; 33 f o r ( i n t i = 0 ; i < 1 0 ; i+ + ) 34 S y s t e m . o u t . p r i n t l n (m i S o c k e t . r e c i b e M e n s a j e ( ) ) ; 35 / / a h o r a m an d a un m e n s a je a l o t r o e x tr e m o 36 m iS o c k e t.e n v ia M e n s a je ( m a q u in a Q n is o ra , p u e r to E m is o r , m e n s a je ) ; 37 m i S o c k e t. c i ó s e ( ) ; 38 > / / f i n d e t r y 39 c a t c h ( E x c e p t i o n e x ) { 40 e x . p r i n t S t a c k T r a c e ( ) ; 41 } / / f i n d e c a t c h 42 } / / f i n d e e l s e 43 } / / f i n d e m a in 44 } // fin de class Esto concluye la introducción a los sockets datagrama. S e tendrá ocasión de vol­ ver a estudiarlos en capítulos posteriores, pero en este punto se centrará la atención en otro modelo de API de sockets: El API de sockets en modo stream. 4 .4 . EL A P I DE S O C K E TS EN M O D O S TR EA M Mientras que el API de sockets datagrama permite e l intercambio de unidades d is­ c re ta s de datos (es decir, datagramas), el API de sockets en modo stream proporcio­ na un modelo de transferencia de datos basado en la E /S e n m o d o jta e a m d e los sis­ tem as operativos Unix. Por definición, un socket en modo stream proporciona sólo comunicaciones orientadas a conexión. En la entrada-salida en modo stream, los datos se transfieren utilizando el con­ cepto de un flujo de datos continuo que fluye desde una fuente a un destino (también llamado sumidero). Los datos se insertan, o escriben, dentro de un flujo por un pro­ ceso que controla la fuente y los datos se extraen, o leen, del flujo por un proceso asociado al destino. Las Figuras 4.15 y 4.16 ilustran el concepto d e un flujo de da­ tos. Observe la naturaleza continua de un flujo que permite que los datos se inserten o extraigan del mismo a diferentes velocidades. El API de sockets en modo stream (Figura 4.17) es una extensión del modelo de E/S en modo stream. Usando el API, cada uno de los dos procesos crea individualmente un socket en modo stream. A continuación, se forma una conexión entre los sockets. Los da­ tos se escriben, como un flujo de caracteres, dentro del socket del emisor y, a continua­ ción, el receptor puede leerlos a través de su socket. Esto es similar al API de sockets www.FreeLibros.org El API d e sockets 107 Un f lu jo d e datos ] S ocke t de d a to s m o d o stre a m ____________ ] Proceso ► O p e ra ció n de e s c ritu ra O p e ra ció n de le c tu ra F ig u ra 4 .1 5 . U so d e un s o c k e t en m o d o stre a m para tra n sfe re n cia d e d a to s. Escribir Leer Un f lu jo d e da tos Las unidades d e d a to s escritas y leídas no necesitan coincidir. P or ejem plo, 100 bytes d e d a to s escritos utilizando una operación pueden leerse usando una operación d e lectura d e 20 bytes, seguida p o r o tra operación read d e 80 bytes. F ig u ra 4 .1 6 . E /S e n m o d o stream . Un servidor utiliza d o s sockets: uno para ace ptar las conexiones, o tro para send/receive. C lie n te 1 C lie n te 2 S ocke t de d a to s Servidor S ocke t de c o n e x ió n ► O peración d e conexión ► O peración send/receive F ig u ra 4 .1 7 . B API d e s o c k e t en m o d o stream . www.FreeLibros.org 108 C om putación distribuida. Fundam entos y aplicaciones datagrama orientados a conexión que ya se ha estudiado anteriormente, excepto por la diferencia en la naturaleza discreta de los datos transportados en sockets datagrama. En Java, las clases ServerSocket y Socket proporcionan el API de sockets en modo stream. El térm ino Server proviene del paradigma cliente-servidor, para el que se di­ señó el API (recuérdese que el paradigma cliente-servidor se presentó en e l Capítulo 3; y se estudiará en detalle en el Capítulo 5). La sintaxis del API está estrechamente vinculada con el paradigma cliente-servidor. Por ahora, se estudiará e l API de forma independiente al paradigma. H ay dos tipos de sockets en el API en modo stream: • La clase ServerSocket proporciona el primer tipo de socket y sirve para aceptar conexiones. Por claridad, en este capítulo se hará referencia a ellos como so c k e ts d e conerión. • La clase Socket proporciona el otro tipo d e socket que permite intercambiar da­ tos. Por claridad, se hará referencia a ellos como so c k e ts d e dalos. Utilizando esta API, un proceso conocido como e l serv id o r establece un socket de conexión y después se queda a la espera de las peticiones de conexión de otros pro­ cesos. Las peticiones de conexión se aceptan de una en una. A través del socket de datos, el proceso servidor puede leer y/o escribir del flujo de datos. Cuando se ter­ mina la sesión de comunicación entre los dos procesos, se cierra el socket de datos, y el servidor está preparado para aceptar la próxima petición de conexión a través del socket de conexión. A un proceso que desea comunicarse con el servidor se le conoce como un d i e n ­ t e Un cliente crea un socket', a continuación, a través del socket de conexión del ser­ vidor, solicita una conexión al servidor. Una vez que se acepta la petición, el socket del cliente se conecta a l socket de datos del servidor d e manera que el cliente pueda pasar a leer y/o escribir del flujo de datos. Cuando se completa la sesión de comuni­ cación entre los dos procesos, se cierran los sockets d e datos. O peraciones y sincronización de eventos Hay dos clases principales en el API d e sockets en modo stream: la clase ServerSoc­ ket y la clase Socket. La clase ServerSocket permite el establecimiento de conexiones, mientras que la clase Socket sirve para la transferencia de datos. En las Tablas 4.4 y 4.5 se listan los métodos principales y los constructores de las dos clases, respectiva­ mente. Tabla 4.4. M é to d o s principales y co n stru cto re s d e la clase S e rv e r S o c k e t (so c k e t d e conexión). M é to d o /C o n s tru c to r D e sc rip c ió n ServerSocket (int puerto) Socket acceptf) throw s IO Exception vo id c!ose() throws IOException vo id setSoTim eont(int plazo) throws SocketException C rea un socket de servidor en un puerto especificado. Espera que se solicite una conexión a este socket y la acepta. El método bloquea hasta que se haga una conexión. Cierra este socket. Fija un plazo máximo de tiempo de espera (en milisegundos), de manera que una llamada accept() sobre este socket bloquee durante sólo esta cantidad de tiempo. Si el plazo expira, se activa una java.io.interruptedlO Exception. www.FreeLibros.org El API d e sockets 109 T a b la 4 .5 . M é to d o s p rin cip a le s y c o n s tru c to re s d e la c la s e S o c k e t (s o c k e t d e datos). M éto d o /C o n stru cto r Descripción Socketf InetA ddress dirección, int puerto) void closet) throw s IO Exception InputStream getlnputStream f) throw s IOException OutputStream getOutputStream() throw s IOException Void setSoTimeout(int plazo) throw s SocketException Crea un socket stream y lo conecta al número de puerto y la direcdón IP especificados. Cierra este socket. Devuelve un flujo de entrada para que se puedan leer los datos de este socket. Devuelve un flujo de salida para que se puedan escribir los datos en este socket. Fija un periodo máximo de bloqueo de manera que una llamada read() en el InputStream asociado con este socket bloquee sólo durante esta cantidad de tiempo. Si el plazo de tiempo expira, se activa una Java.io.InterruptedIO Exception(). Con respecto a la sincronización de eventos, las siguientes operaciones son blo­ queantes: • Accept (aceptación de una conexión). Si no hay ninguna petición esperando, el proceso servidor se suspenderá hasta que llegue una petición de conexión. • La lectura de un flujo de entrada asociado a un socket de datos. Si la cantidad de datos pedida no está actualmente presente en e l flujo de datos, el proceso que solicita la lectura se bloqueará hasta que se haya escrito una cantidad de datos suficiente en el flujo de datos. Nótese que no se proporcionan métodos read y write específicos, puesto que se de­ ben utilizar los métodos asociados con las clases InputStream y OutputStream para re­ alizar estas operaciones, como se verá en breve. L a Figura 4.18 ilustra los flujos de ejecución de un programa que espera una pe­ tición de conexión y de otro que solicita la conexión. S o lic ita n te d e c o n e x ió n (C lie n te ) Crea un socket de datos y pide una conexión; obtiene un flu jo de salida para escribir en el socket, escribe en el flujo; obtiene un flu jo de entrada para leer del socket, lee del flujo; d e rra el socket de datos. ______ A c e p ta d o r d e c o n e x ió n (S e rvido r) Crea un socket de conexión y espera peticiones de conexión; acepta una conexión; crea un socket de datos para leer o e s c rib ir en el socket stre a m ; obtiene flu jo de entrada para le er de socket; lee del flujo; obtiene flu jo de salida para escribir en socket; escribe en el flu jo ; cierra el socket de datos; cierra el socket de conexión. F ig u ra 4 .1 8 . F lujos d e e je c u c ió n d e un p ro gra m a q u e e s p e ra una p e tic ió n d e c o n e x ió n y d e o tro q u e la s o lic ita . www.FreeLibros.org 110 C om putación distribuida. Fundam entos y aplicaciones E jem p lo 4 Las Figuras 4.19 y 4.20 ilustran la sintaxis básica para los sockets en m odo stream . E jem plo4A ceptadorC onexion, com o su nom bre im plica, acepta conexiones estableciendo un objeto ServerSocket en un puerto especificado (por ejem ­ plo, 12345). Ejemplo4SolicitanteConexion crea un objeto Socket, especificando como argumentos el nombre de la máquina y el número de puerto (en este caso, 12345) del aceptador. Una vez que e l aceptador ha aceptado la conexión, escribe un mensaje en el flujo de datos del socket. En el solicitante, el mensaje se lee del flujo de datos y se visualiza. F ig u ra 4 .1 9 . E jem p lo 4 A cep ta d o rC o n exio n .ja va . 1 import java.net.*? 2 inport java.io.*; 3 4 /** 5 * Este ejemplo ilustra la sintaxis básica del socket 6 * en modo stream. 7 * Gauthor M. L. Liu 8 */ 9 public class Ejemplo4AceptadorConexion { 10 11 // Una aplicación que acepta una conexión y recibe un mensaje utilizando un socket en modo stream. 12 // Se esperan dos argumentos de línea de mandato, en orden: 13 // enumero de puerto del socket de servidor utilizado en este proceso> 14 // <mensaje, una cadena, para mandar> 15 16 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 17 i f ( a r g s . l e n g t h 1= 2 ) 18 S y s t e m . o u t . p r i n t l n 19 ( \" E s t e p ro g ra m a r e q u i e r e d o s a rg u m e n to s d e l i n e a d e m a n d a to \" ) ; 20 e l s e { 21 t r y { 22 i n t n u m P u e r to = l n t e g e r . p a r s e l n t ( a r g s [ 0 ] ) ; 23 S t r i n g m e n s a je = a r g s f l ] ; 24 / / i n s t a n c i a u n s o c k e t p a r a a c e p t a r l a c o n e x ió n 25 S e r v e r S o c k e t s o c k e t C o n e x i o n = new S e r v e r S o c k e t ( n u m P u e r to ) ; 26 / * * / S y s t e m . o u t . p r i n t l n ( \" p r e p a r a d o p a r a a c e p t a r u n a c o n e x i ó n \" ) ; 27 / / e s p e r a u n a p e t i c i ó n d e c o n e x i ó n , i n s t a n t e e n e l c u a l 28 / / s e c r e a u n s o c k e t d e d a t o s 29 S o c k e t s o c k e t D a t o s = s o c k e t C o n e x i o n . a c c e p t ( ) ; 30 / * * / S y s t e m . o u t . p r i n t l n ( \" c o n e x i ó n a c e p t a d a \" ) ; 31 / / o b t i e n e u n f l u j o d e s a l i d a p a r a e s c r i b i r e n e l s o c k e t de d a t o s 32 O u tp u tS t r e a m f l u j o S a l i d a = s o c k e t D a t o s . g e t O u t p u t S t r e a m ( )? 33 / / c r e a u n o b j e t o P r i n t W r i t e r p a r a l a s a l i d a e n modo c a r á c t e r 34 P r i n t W r i t e r s a l i d a S o c k e t = 35 new P r i n t W r i t e r (n e w O u tp u t S t r e a m W r i t e r ( f l u j o S a l i d a ) ) ? 36 / / e s c r i b e u n m e n s a je e n e l f l u j o d e d a t o s 37 s a l i d a S o c k e t . p r i n t l n ( m e n s a j e )? ( continúa) www.FreeLibros.org 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 2 0 2 1 22 23 24 25 El API d e sockets 1 1 1 / / L a s u b s i g u i e n t e ll a m a d a a l m é to d o f l u s h e s n e c e s a r i a / / p a r a q u e l o s d a t o s s e e s c r i b a n e n e l f l u j o d e d a t o s / / d e l s o c k e t a n t e s d e q u e s e c i e r r e e l s o c k e t . s a l i d a S o c k e t . f l u s h ( ) ; / * * / S y s t e m . o u t . p r i n t l n ( \" m e n s a j e e n v i a d o \" ) ; s o c k e t D a t o s . c i ó s e ( ) ; / * * / S y s t e m . o u t . p r i n t l n ( \" s o c k e t d e d a t o s c e r r a d o \" ) ; s o c k e t C o n e x i o n . c i ó s e ( ) ; / * * / S y s t e m . o u t . p r i n t l n ( \" s o c k e t d e c o n e x ió n c e r r a d o \" ) ; } / / e n d t r y c a t c h ( E x c e p t i o n e x ) { e x . p r i n t S t a c k T r a c e ( ) ; > / / f i n d e c a t c h } / / f i n d e e l s e } / / f i n d e m a in } / / f i n d e c l a s s F ig u ra 4 .2 0 . E jem p lo 4 S o licita n teC o n exio n .ja va . i m p o r t j a v a . n e t . * ; i m p o r t j a v a . i o . * ; /** * E s t e e je m p lo i l u s t r a l a s i n t a x i s b á s i c a d e l s o c k e t * e n m odo s t r e a m . * G a u th o r M. L . L i u */ p u b l i c c l a s s E j e m p l o 4 S o l i c i t a n t e C o n e x i o n { / / Una a p l i c a c i ó n q u e s o l i c i t a u n a c o n e x ió n y manda un m en sa je u t i l i z a n d o u n s o c k e t e n n o d o s t r e a m / / S e e s p e r a n d o s a r g u m e n to s d e l i n e a d e m a n d a to , e n o r d e n : / / c n a n b r e d e l a m á q u in a d e l a c e p t a d o r d e l a c o n e x ió n > / / < n ú m ero d e p u e r t o d e l a c e p t a d o r d e l a c o n e x ió n > p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { i f ( a r g s . l e n g t h ! = 2 ) S y s te m , o u t . p r i n t l n ( \" E s t e p ro g ra m a r e q u i e r e d o s a rg u m e n to s d e l i n e a d e m a n d a to \" ) ; e l s e { t r y { I n e tA d d r e s s m a q u in a A c e p ta d o ra = I n e t A d d r e s s . getByN am e(a r g s [ 0 ] ) ; i n t p u e r t o A c e p t a d o r = I n t e g e r . p a r s e l n t ( a r g s [ 1 ] ) ; / / i n s t a n c i a un s o c k e t d e d a t o s S o c k e t m iS o c k e t = new S o c k e t ( m a q u in a A c e p ta d o r a , p u e r t o A c e p t a d o r ) ; / * * / S y s t e m . o u t . p r i n t l n ( \" S o l i c i t u d d e c o n e x ió n c o n c e d i d a \" ) ; (continúa) www.FreeLibros.org 112 C om putación distribuida. Fundam entos y aplicaciones 26 / / o b tie n e un f l u j o d e e n tr a d a p a r a l e e r d e l s o c k e t d e d a to s 27 I n p u tS tre a m f l u j o E n t r a d a = m iS o c k e t.g e tI n p u tS tr e a m ( ) ; 28 / / c r e a un o b j e t o B u f f e r e d R e a d e r p a r a l a e n t r a d a e n modo c a r á c t e r 29 B u f fe re d R e a d e r s o c k e t I n p u t = 30 new B u ffe re d R e a d e r(n e w I n p u tS tre a m R e a d e r ( f l u j o E n t r a d a ) ) ; 31 /* * / S y ste m . o u t . p r i n t l n ( \" e s p e r a n d o l e e r \" ) ; 32 / / l e e u na l í n e a d e l f l u j o d e d a t o s 33 S t r i n g m e n s a je = s o c k e t l n p u t . r e a d L i n e ( ) ; 34 /* * / S y s t e m .o u t . p r i n t l n ( \" M e n s a j e r e c i b i d o : \" ) ; 35 S y s t e m . o u t . p r i n t l n ( \" \\ t \" + m e n s a je ) ; 36 m iS o c k e t. c i ó s e ( ) ; 37 /* * / S y s t e m . o u t . p r i n t l n ( \" s o c k e t d e d a t o s c e r r a d o \" ) ; 38 > / / f i n d e t r y 39 c a t c h ( E x c e p tio n e x ) { 40 e x . p r i n t S t a c k T r a c e ( ) ; 41 > / / f i n d e c a t c h 42 } / / f i n d e e l s e 43 > / / f i n d e m ain 44 > / / f i n d e c l a s s Hay varios puntos reseñables en este ejemplo: 1. Debido a que se está tratando con un flujo de datos, se puede usar la clase PrintWriter de Java (línea 15 de la Figura 4.19) para escribir en un socket y BufferedReader (línea 29 de la Figura 4.20) para leer de un flujo. Los méto­ dos usados con estas clases son los mismos que para escribir una línea de tex­ to en la pantalla o leer una línea de texto del teclado. 2. Aunque e l ejemplo muestra como emisor de datos al Aceptador y como re­ ceptor al Solicitante, los papeles se pueden intercambiar fácilmente. En ese caso, el Solicitante usará getOutputStream para escribir en el socket, mientras que e l Aceptador utilizará getlnputStream para leer del socket. 3. De hecho, cada proceso puede leer y escribir del flujo invocando getlnputStream o getOutputStream, como se ilustra en el Ejemplo 5, que se verá más adelante en este capítulo. 4. Aunque el ejem plo lee y escribe una línea cada vez (utilizando los métodos readLine() y println(), respectivamente), es también posible leer y escribir par­ te de una línea en su lugar (usando read() y print() respectivamente). Sin em ­ bargo, para protocolos basados en texto donde los mensajes se intercambian como texto, lo habitual es leer y escribir una línea cada vez. 5. Cuando se utiliza PrintWriter para escribir en un socket stream, es necesario utilizar una llam ada a flu sh () para «limpiar el flujo», de manera que se ga­ rantice que todos los datos se escriben desde la zona d e almacenamiento de datos al flujo tan pronto como sea posible, antes de que e l socket sea súbita­ mente cerrado (véase la línea 41 en la Figura 4.19). La Figura 4.21 muestra el diagrama de eventos correspondiente a la ejecución de los programas del Ejemplo 4. www.FreeLibros.org El API d e sockets 1 1 3 T iem p o A c e p ta d o r c o n e x ió n S o lic ita n te c o n e x ió n a cce p t 0 p e tic ió n c o n n e c t (del c o n s tru c to r S o cket) O read ció se s o c k e t de c o n e x ió n cióse s o c k e t de datos w rite © Una o p e ra c ió n Proceso s u s p e n d id o Ejecución d e l p ro ce so F ig u ra 4 .2 1 . Diagram a d e e v e n to s d e ^ e m p l o 4 . El proceso AceptadorConexion comienza su ejecución en primer lugar. El proce­ so se suspende cuando se llama al método bloqueante accept, después se reanuda cuan­ do recibe la petición de conexión del Solicitante. Una vez reanudada la ejecución, el Aceptador escribe un mensaje en el socket antes de cerrar tanto e l socket d e datos como el de conexión. L a ejecución del SolicitanteConexion se realiza de la siguiente forma: se instancia un objeto Socket y se hace una petición connect implícita al Aceptador. Aunque la petición connect no es bloqueante, el intercambio de datos a través d e la conexión no puede llevarse a cabo hasta que el proceso en e l otro extremo acepta (accept) la co­ nexión. Una vez que se acepta la conexión, el proceso invoca una operación read para leer un mensaje del socket. Dado que la operación read es bloqueante, el proceso se suspende de nuevo hasta que se reciben los datos del mensaje, después d e lo cual el proceso cierra (cióse) el socket y procesa los datos. S e han insertado en los programas mensajes de diagnóstico (marcados con /**/), de manera que se pueda observar el progreso de la ejecución de los dos programas cuando se están ejecutando. Para permitir la separación de la lógica d e aplicación y la lógica de servicio en los programas, se emplea una subclase que esconde los detalles de los sockets de da­ tos. La Figura 4.22 muestra e l listado de código de la clase MiSocketStream, que pro­ porciona métodos para leer y escribir de un socket d e datos. F ig u ra 4 .2 2 . M iS o c k e tS tre a m .ja v a , una s u b c la s e d e riv a d a d e la c la s e S o c k e t de Java. 1 import java.net.*? 2 import java.i o .*; 3 4 /** 5 * Un a clase de envoltura de Socket que contiene 6 * métodos para mandar y recibir mensajes. (continúa) www.FreeLibros.org 114 C om putación distribuida. Fundam entos y aplicaciones 7 * Gauthor M. L. Liu 8 */ 9 public class Misocketstream extends Socket { 10 private Socket socket; 11 private BufferedReader entrada; 12 private PrintWriter salida; 13 14 Misocketstream (String maquinaAceptadora, 15 int puertoAceptador ) throws SocketException, 16 ICException{ 17 socket = n e w Socket (maquinaAceptadora, puertoAceptador ); 18 establecerFlujos( ); 19 } 20 21 Misocketstream(Socket socket) throws IOException { 2 2 this.socket = socket; 23 establecerFlujos( ); 24 } 25 26 private void establecerFlujos( ) throws IOException{ 27 // obtiene un flujo de salida para leer del socket de datos 28 InputStream flujoEntrada = socket.getInputStream(); 29 entrada = 30 new BufferedReader(new InputStreamReader(flujoEntrada)); 31 OitputStream flujoSalida = socket.getOutputStream(); 32 // crea un objeto PrintWriter para salida en modo carácter 33 salida = 34 new PrintWriter(ne w OutputStreamWriter(flujoSalida)); 35 } 36 37 public void enviaMensaje(String mensaje) 38 throws IOException { 39 salida.println(m e nsaje); 40 // L a subsiguiente llamada al método flush es necesaria para que 41 // los datos se escriban en el flujo de datos del socket 42 // antes de que se cierre el socket. 43 salida.flush(); 44 } // fin de enviaMensa je 45 46 public String recibeMensaje( ) 47 throws IOException { 48 // lee una linea del flujo de datos 49 String mensaje = entrada.readLine( ); 50 return mensaje; 51 } // fin de recibeMensaje 52 53 public void cióse ( ) 54 throws IOException { 55 socket.cióse( ); 56 } 57 } //fin de class www.FreeLibros.org El API d e sockets 1 1 5 E jfnqilo 5 Las Figuras 4.23 y 4.24 son revisiones de los ficheros de código fuen­ te presentados en las Figuras 4.19 (AceptadorConexion) y 4.20 (SolicitanteConexion), respectivamente, modificados para utilizar la clase M iSodaetStresun en vez de la cla­ se S o d a etd e Java. F ig u ra 4 .2 3 . E jem p b 5 A c e p ta d o rC o n e x io n .ja v a . 1 import java.net.*; 2 import java.io.*; 3 4 /** 5 * Este ejemplo ilustra la sintaxis básica del socket 6 * en modo stream. 7 * Gauthor M. L. Liu 8 */ 9 public class Ejemplo5AceptadorConexion { 10 11 // U n a aplicación que recibe u n mensaje usando u n socket en modo stream. 12 // Se esperan dos argumentos de linea de mandato, en orden: 13 // <número de puerto del socket de servidor utilizado en este proceso> 14 // cmensaje, una cadena, para mandar> 15 16 public static void main(String[] args) { 17 if (args. length ! = 2 ) 18 System.out.println 19 (\"Este programa requiere dos argumentos de linea de mandato\"); 20 else { 21 try { 22 int numPuerto = Integer.parselnt(a r g s [0]); 23 String mensaje = args[l]; 24 // instancia un socket para aceptar la conexión 25 ServerSocket socketConexion = new ServerSocket(numPuerto); 26 /**/ System.out.println(\"preparado para aceptar una conexión\"); 27 // espera una petición de conexión, instante en el cual 28 / / s e crea u n socket de datos 29 Misocketstream socketDatos = 30 new MiSocketStream (socketConexion. accept ()); 31 /**/ System.out.println(\"conexión aceptada\"); 32 socketDatos.enviaMensaje(mensaje); 33 34 /**/ System.out.println(\"mensaje enviado\"); 35 socketDatos.cióse( ); 36 /**/ System.cu t .p r intln(\"socket de datos cerrado\"); 37 socketConexion.c i ó s e ( ); 38 /**/ System.cxit.p r i n t l n (\"socket de conexión cerrado\"); 39 } // fin de try 40 catch (Exception ex) { 41 e x .printStackTrace( ); 42 } // fin de catch (continúa) www.FreeLibros.org 116 C om putación distribuida. Fundam entos y aplicaciones 43 } / / f i n d e e l s e 44 } / / f i n d e m a in 45 } / / f i n d e c l a s s F ig u ra 4 .2 4 . E jem p lo 5 S o licita n te C o n exio n .ja va . i i i r p o r t j a v a . n e t . * ? 2 *3 i m p o r t j a v a . i o . * ; O 4 / * * 5 * E s t e e je m p lo i l u s t r a l a s i n t a x i s b á s i c a d e l s o c k e t 6 * e n m odo s t r e a m . 7 * 0 a u t h o r M. L . L i u 8 * / 9 p u b l i c c l a s s E j e m p l o 5 S o l i c i t a n t e C o n e x i o n { 10 11 / / U na a p l i c a c i ó n q u e m an d a u n m e n s a je u s a n d o u n s o c k e t e n modo s t r e a m . 12 / / S e e s p e r a n d o s a r g u m e n to s d e l i n e a d e m a n d a to , e n o r d e n : 13 / / 14 / / < n o m b re d e l a m á q u in a d e l a c e p t a d o r d e l a c o n e x ió n > 15 / / e n u m e ro d e p u e r t o d e l a c e p t a d o r d e l a c o n e x ió n > 16 17 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 18 i f ( a r g s . l e n g t h ! = 2 ) 19 S y s te m . o u t . p r i n t l n 20 ( \" E s t e p ro g ra m a r e q u i e r e d o s a rg u m e n to s d e l i n e a d e m a n d a to \" ) ; 21 e l s e { 22 t r y { 23 S t r i n g m a q u in a A c e p ta d o r a = a r g s [ 0 ] ; 24 i n t p u e r t o A c e p t a d o r = I n t e g e r . p a r s e l n t ( a r g s [ 1 ] ) ? 25 / / i n s t a n c i a u n s o c k e t d e d a t o s 26 M iS o c k e tS tr e a m m i S o c k e t = 27 new M i S o c k e tS tr e a m (m a q u i n a A c e p ta d o r a , p u e r t o A c e p t a d o r ) ; 28 / * * / S y s t e m . o u t . p r i n t l n ( \" S o l i c i t u d d e c o n e x ió n c o n c e d i d a \" ) ; 29 S t r i n g m e n s a je = m i S o c k e t . r e c i b e M e n s a j e ( ) ; 30 / * * / S y s t e m . o u t . p r i n t l n ( \" M e n s a j e r e c i b i d o : \" ) ; 31 S y s t e m . o u t . p r i n t l n ( \" \\ t \" + m e n s a j e ) ; 32 m i S o c k e t . c i ó s e ( ) ; 33 / * * / S y s t e m . o u t . p r i n t l n ( \" s o c k e t d e d a t o s c e r r a d o \" ) ; 34 > / / f i n d e t r y 35 c a t c h ( E x c e p t i o n e x ) { 36 e x . p r i n t S t a c k T r a c e ( ) ; 37 > 38 } / / f i n d e e l s e 39 > / / f i n d e m a in 40 } / / f i n d e c l a s s www.FreeLibros.org El API d e sockets 1 1 7 Utilizando la subclase MiSocketStream, es mucho más cómodo realizar entrada y salida en e l socket, como se pedirá realizar en uno de los ejercicios al final de este capítulo. Con esto termina la introducción al API d e sockets en modo stream. En el próxi­ mo capítulo se volverá a estudiar este mecanismo d e comunicación. 4 .5 . SOCKETS CON OPERACIONES DE E /S NO BLOQUEANTES Como se m encionó anteriormente, las interfaces d e programación introducidas en este capítulo son las básicas, que proporcionan operaciones send (no-bloqueantes) asincronas y operaciones receive (bloqueantes) síncronas. Utilizando estas interfa­ ces, un proceso que lee de un socket es susceptible de bloquearse. Para maximizar la concurrencia, se pueden utilizar hilos (threads), de m anera que un hilo d e espe­ ra realiza una operación de lectura bloqueante, mientras que otro hilo permanece ac­ tivo para procesar otras tareas. Sin embargo, en algunas aplicaciones que requieren usar un elevado número de hilos, la sobrecarga incurrida puede ser perjudicial para el rendim iento o, peor todavía, para la viabilidad d e la aplicación. Como una alter­ nativa, hay interfaces de program ación de sockets que proporcionan operaciones de E/S no bloqueantes. Utilizando una A PI de este tipo, ni send ni receive resultarán bloqueantes y, como se explicó en el Capítulo 2, será necesario que e l proceso re­ ceptor utilice un m anejador de eventos para que se le notifique de la llegada de los datos. Los sockets asincronos están disponibles en W insock y, a partir de la versión 1.4, Java tam bién proporciona un nuevo paquete d e E/S, j a v a n i o (N IO ), que ofre­ ce sockets con operaciones de E/S no bloqueantes. La sintaxis del nuevo paquete es considerablemente m ás compleja que la del A P I básica. S e recom ienda a los lecto­ res interesados que exam inen [java.sun.com, 6]. 4 .6 . EL A P I DE SOCKETS SEG U R O S Aunque los detalles quedan fuera del ámbito de este libro, e l lector debería conocer la existencia de las interfaces de programación de sá ch ete seguiros, que son interfa­ ces de sockets mejoradas con medidas de seguridad de datos. Utilizando las interfaces de programación de sockets convencionales, los datos se transmiten com o flujos de bits sobre los enlaces d e la red. Estos flujos de bits, si se interceptan por medio de herramientas tales como analizadores de protocolos d e red, pueden ser descodificados por alguien que tenga conocimientos de la representación de los datos intercambiados. Por ello, el riesgo de utilizar sockets para transm itir da­ tos sensibles, como información d e crédito y datos de autenticación. Para tratar el problema, se han introducido protocolos que protegen los datos transm itidos usando sockets. En los siguientes párrafos se describirán algunos de los protocolos más co­ nocidos. El nivel de so cke ts seguros El n v d d e sa ch é is seguros (SSL, Secure Sockets Layer) [developer.netscape.com, 2] fue un protocolo desarrollado por Netscape Communications Corporation para trans­ mitir documentos privados sobre Internet. (Esta descripción de SSL se basa en la de- Un analizador de protocolos es una herramienta que permite capturar y analizar los paquetes de datos para resolver problemas en la red. www.FreeLibros.org 118 C om putación distribuida. Fundam entos y aplicaciones Las e x te n s io n e s d e so c k e ts se g u ro s d e J a v a Dr. D o b b ’s Jo u rn a l, fe b r e r o d e 2 0 0 1 Autenticación y cifrado de conexiones. P o r Kirby W. Angelí. Reimpreso con el perm iso del Dr. D o b b ’s Journal. Uno se sienta delante de su computador, maravillándose de su aplicación Java distri­ buida. El có dig o crea objetos S o c k e t y S er- ve rS o cke t co m o loco, m andando datos a través de Internet. Da g u sto verlo, hasta que uno se da cuenta de que cualquiera puede interceptar los datos que se están leyendo, suplantar una d e s us aplicaciones e inundar su sistema con datos falsos. Tan pronto co m o se empieza a investi­ gar sobre la autenticación y c ifra d o de las conexiones entre aplicaciones, uno se da cuenta de que ha e ntrado en una área c o m ­ pleja. Cuando uno trata co n e l cifrado, se tiene que preocupar p or m uchas co sa s y no só lo de qué algoritm o se pretende u tili­ zar. Los ataques al sistem a pueden involu­ cra r al algoritm o, al protocolo, a las c o n ­ tra se ñ a s y a o tro s fa c to re s q u e uno ni siquiera podría considerar. Afortunadamente, la m ayoría de los d e ­ talles liosos de la autenticación y e l cifra do del trá fico entre d o s aplicaciones basadas en so c k e ts se ha resuelto en la especifica­ ción del nivel de s o cke ts seguros (SSL, S e­ cura S o cke ts La yei). Sun M icrosystem s tie ­ ne u n a im p le m e n ta c ió n d e S S L en su paquete de extensión de so cke ts seguros de Java (JSSE, Java S e cu ra S o c k e ts E x­ te n s ió n -, h ttp ://ja v a .s u n .c o m /s e c u r ity /). JSSE y e l e ntorno en tiem p o de ejecución de Java (JRE, Java fíu n -T im e E nviron m ent) proporcionan la mayoría de las herram ien­ tas necesarias para im plem entar SSL d e n ­ tro de una aplicación Java en el ca so de que se trate de un cliente com unicándose con servidores HTTPS. Dado que la d o c u ­ mentación y las herram ientas JSSE están principalm ente o rientad as hacia este fin, cuesta a lg o m ás de trabajo averiguar có m o utilizar el co n ju nto de herram ientas dentro de una aplicación donde se necesitan crear ta n to el lado d e l clie n te d e la con e xión co m o el lado del servidor. finición proporcionada por http://webopedia.intemet.com). Una API de SSL tiene mé­ todos o funciones similares al A PI de sockets, excepto en que los datos son cifrad as antes de que se transmitan sobre una conexión SSL. Los navegadores modernos dan soporte a SSL. Cuando se ejecutan con e l protocolo SSL seleccionado, estos navega­ dores transmitirán los datos cifrados utilizando el API de sockets SSL. Muchos sitios web también utilizan el protocolo para obtener información confidencial del usuario, tal como números de tarjeta de crédito. Por convención, un URL de una página web que requiere una conexión SSL comienza con h ttp s: en vez de h ttp : La extensión de so cke ts seguros de Java La extensión de sockets seguros de Java (JSSE, Java Secure Socket Extensión) es un conjunto de paquetes de Java que posibilita las comunicaciones seguras en Internet. Implementa una versión de los protocolos SSL y TLS (Transpon Layer Security) [ietf.org, 5] e incluye herramientas para el cifrado de datos, autenticación del servi­ dor, integridad de m ensajes y autenticación de cliente opcional. Utilizando JSSE [java.sun.com, 3; Angelí, 4), los desarrolladores pueden proporcionar el tráfico de da­ tos seguro entre dos procesos. El API de JSSE se caracteriza por tener una sintaxis similar al API de sockets orientados a conexión presentada en este capítulo. www.FreeLibros.org En este capítulo, se introduce la interfaz básica de programación de aplicaciones de sockets para la comunicación entre procesos. El API de sockets está ampliamente dis­ ponible como una herramienta de programación para IPC en un nivel relativamente bajo d e abstracción. Utilizando las interfaces de sockets de Java, en el capítulo se han presentado dos tipos de sockets: • Los sockets datagrama, que utilizan el protocolo de datagrama d e usuario (UDP, User Datagram Protocoí) en el nivel de transporte para mandar y recibir pa­ quetes de datos discretos conocidos como datagramas. • El socket en modo stream, que utiliza el protocolo d e nivel de transporte (TCP, Transmissioti Control Protocoí) en el nivel de transporte para mandar y recibir datos utilizando un flujo de datos. Los aspectos fundamentales del API de sockets datagrama d e Java son los siguientes: • Permite tanto una comunicación sin conexión como una comunicación orienta­ da a conexión. • Cada proceso debe crear un objeto DatagramSocket. • Cada datagrama se encapsula en un objeto DatagramPacket. • En comunicación sin conexión, se puede utilizar un socket datagrama para man­ dar o recibir de cualquier otro socket datagrama; en comunicación orientada a conexión, un socket datagrama sólo puede usarse para mandar o recibir del socket datagrama asociado al otro extremo de la conexión. • Los datos de un datagrama se sitúan en un vector d e octetos; si un receptor pro­ porciona un vector de octetos de insuficiente longitud, los datos recibidos se truncan. • La operación receive es bloqueante; la operación send es no bloqueante. Los aspectos fundamentales del API de sockets en modo stream son los siguientes: • Soporta sólo una comunicación orientada a conexión. • Un proceso juega un papel d e aceptador de conexión y crea un socket de co­ nexión utilizando la clave ServerSocket. A continuación, acepta las peticiones de conexión de otros procesos. • Un proceso (un solicitante de conexión) crea un socket d e datos utilizando la clase Socket y se realiza implícitamente una petición de conexión al aceptador de conexión. • Cuando se concede una petición de conexión, el aceptador de conexión crea un socket de datos, de la clase Socket, para mandar y recibir datos del solicitante de conexión. El solicitante de conexión puede también mandar y recibir datos del aceptador de conexión utilizando su socket d e datos. • Las operaciones receive (leer) y accept (aceptar conexión) son bloqueantes; la operación send (escribir) es no bloqueante. • La lectura y la escritura de datos en el socket de datos stream están desacopla­ das: pueden realizarse usando diferentes unidades de datos. H ay interfaces de programación de sockets que proporcionan operaciones de E/S no bloqueantes, incluyendo Winsock y el NIOS de Java. L a sintaxis d e estas interfaces www.FreeLibros.org 120 C om putación distribuida. Fundam entos y aplicaciones Para ayudar a seguir la psta del resultado de la ejecución, se recomienda que se ejecute cada aplicación en una ventana separada en la pantalla, preferiblemente fijando el tamaño y situando las ventanas de manera que se pueda ver una junto a otra.________ es más compleja y requiere usar un manejador de eventos para gestionar las opera­ ciones bloqueantes. Los datos transmitidos por la red utilizando sockets son susceptibles a riesgos de seguridad. Para los datos sensibles, se recomienda emplear los sockets seguros. Entre las interfaces de sockets seguros disponibles se encuentran el nivel de sockets segu­ ros (SSL, Secure Sockets Layer) y la extensión de sockets seguros de Java (JSSE, Java Secure Sockets Extensión). Las interfaces de sockets seguros tienen métodos que son similares a las interfaces de sockets orientados a conexión. E JE R C IC IO S 1. Usando sus propias palabras, escriba algunas frases para explicar cada uno de los siguiente términos: a. A PI (interfaz de programador de aplicaciones). b. El API de sockets. c. Winsock. d. La comunicación orientada a conexión frente a la comunicación sin cone­ xión. 2. El proceso 1 manda sucesivamente 3 mensajes al proceso 2. ¿Cuál es el or­ den posible en e l que pueden llegar los mensajes si: a. se utiliza un socket sin conexión para mandar cada mensaje? b. se utiliza un socket orientado a conexión para mandar cada mensaje? 3. En el método setSoTimeout de DatagramSocket (y de otras clases de sockets), ¿qué sucede si el periodo de plazo se fija en 0? ¿Significa que el plazo ocu­ rre inmediatamente (ya que e l periodo es 0)? Consulte el A PI en línea de Java para encontrar la respuesta. 4. Escriba un fragmento de código Java, que podría aparecer dentro de un mé­ todo main, que abra un socket datagrama para recibir un datagram a d e hasta 100 octetos, en un plazo máximo de 5 segundos. Si el plazo expira, debería visualizarse en la pantalla el siguiente mensaje: «agotado el plazo para re­ cibir». 5. Este ejercicio guía al lector mediante experimentos con sockets datagrama sin conexión utilizando el código de Ejem plol. Para empezar, se recomienda que se ejecuten ambos programas en una má­ quina, usando «localhost» como nombre de la máquina. Por ejemplo, se pue­ de introducir el mandato «java Ejem plol Emisor localhost 12345 hola» para ejecutar E jem plol Emisor. Opcional mente, se podrían repetir los ejercicios eje­ cutando los programas en máquinas separadas, presuponiendo que se tiene acceso a tales máquinas. a. Compile los ficheros .java. A continuación, ejecute los dos programas (i) arrancando el receptor y, después, (ii) el emisor, teniendo cuidado de espe­ cificar los argumentos de línea de mandato apropiados en cada caso. El mensaje mandado no debería exceder la longitud máxima permitida en el receptor (esto es, 10 caracteres). Describa el resultado de la ejecución. N ota: Para ayudar a seguir la pista del resultado de la ejecución, se recomienda que se ejecute cada aplicación en una ventana separada en la pantalla, pre- www.FreeLibros.org El API d e sockets 121 feriblemente fijando el tamaño y las ventanas de manera que se pueda ver una junto a otra. b. Vuelva a ejecutar las aplicaciones del apartado a, esta vez cambiando el or­ den de los pasos (i) y (ii). Describa y explique el resultado. c. Repita el apartado a, esta vez mandando un mensaje de longitud más gran­ de que la máxima longitud permitida (por ejemplo, «01234567890»). Des­ criba y explique la salida producida. d. Añada código al proceso receptor de manera que el plazo máximo de blo­ queo del receive sea de 5 segundos. Arranque e l proceso receptor pero no el proceso emisor. ¿Cuál es e l resultado? Descríbalo y explíquelo. e. Modifique el código original de E jem plol de manera que el receptor eje­ cute indefinidamente un bucle que repetidamente reciba y después muestre los datos recibidos. Vuelva a compilarlo. A continuación, (i) arranque el re­ ceptor, (ii) ejecute el emisor, mandando un mensaje «mensaje 1», y (iii) en otra ventana, arranque otra instancia del emisor, mandando un mensaje «mensaje2». ¿El receptor recibe los dos mensajes? Capture el código y la salida. Describa y explique e l resultado. f . Modifique el código original de Ejem plol de manera que el em isor utilice el mismo socket para mandar el mismo mensaje a dos receptores diferen­ tes. Primero arranque los dos receptores, después el emisor. ¿Cada receptor recibe e l mensaje? Capture el código y la salida. Describa y explique el re­ sultado. g. Modifique el código original de E jem plol de manera que el emisor utilice dos sockets distintos para mandar el mismo mensaje a dos receptores dife­ rentes. En primer lugar, arranque los dos receptores y, después, e l emisor. ¿Recibe el mensaje cada receptor? Capture el código y la salida. Describa y explique el resultado. h. Modifique el código del último paso de modo que el emisor envíe repeti­ dam ente suspendiéndose el mismo durante 3 segundos entre cada envío. (Recuerde que en e l Capítulo 1 se vio cómo utilizar Thread.sleepf) para sus­ pender un proceso durante un intervalo de tiempo especificado). Modifique el receptor de manera que ejecute un bucle que repetidamente reciba datos y luego los muestre. Compile y ejecute los programas durante unos pocos minutos antes de terminarlos (tecleando la secuencia «control-c»). Descri­ ba y explique e l resultado. i. Modifique el código original de E jem plol de modo que el emisor también reciba un mensaje del receptor. Se debería necesitar sólo un socket en cada proceso. Compile, ejecute y entregue su código; asegúrese de modificar los comentarios en consecuencia. 6. Este ejercicio guía al lector mediante experimentos con socket datagramas sin conexión mediante el código Ejemplo2. a. Dibuje un diagrama de clases UML para ilustrar la relación entre las cla­ ses D atagram Socket, M iSocketD atagram a, Ejem plo2Em isorReceptor y Ejemplo2ReceptorEmisor. No se requiere especificar los atributos y méto­ dos de la clase DatagramSocket. b. Compile los ficheros java. A continuación, arranque Ejemplo2ReceptorEmisor, seguido de Ejemplo2EmisorReceptor. Un ejemplo de los mandatos necesa­ rios para ejecutar los programas es el siguiente: www.FreeLibros.org 122 C om putación distribuida. Fundam entos y aplicaciones j a v a E je m p lo 2 R e c e p to r E m is o r l o c a l h o s t 2 0 0 0 0 1 0 0 0 0 m s j l j a v a E je m p lo 2 E m is o r R e c e p to r l o c a l h o s t 10000 2 0 0 0 0 m s j2 Describa el resultado. ¿Por qué es importante el orden d e ejecución de los dos procesos? P2 c. Modifique el código de manera que el proceso EmisorReceptor envíe y des­ pués reciba repetidamente, suspendiéndose a sí mismo durante 3 segundos entre cada iteración. Vuelva a compilar y repita la ejecución. Haga lo mis­ mo con e l ReceptorEmisor. Compile y ejecute los programas durante unos pocos minutos antes de ponerles fin (tecleando la sentencia «control-c»). Describa y explique el resultado. 7. Este ejercicio guía al lector mediante experimentos con un socket datagrama orientado a conexión utilizando el código Ejemplo3. a. Compile y ejecute los ficheros de código fuente de Ejemplo3. Describa la salida d e la ejecución. Un ejemplo de los mandatos requeridos para ejecu­ tar los programas es el siguiente: j a v a E je m p lo 3 R e c e p to r l o c a l h o s t 2 0 0 0 0 1 0 0 0 0 m s j l j a v a E je m p lo 3 B n is o r l o c a l h o s t 1 0 0 0 0 2 0 0 0 0 m s j2 b. Modifique el código de Ejemplo3Emisorjava de modo que la llamada al mé­ todo connect especifique un número de puerto diferente del número de puer­ to del socket del receptor. (Se puede hacer simplemente añadiendo un 1 al número de puerto del receptor en la llamada al método de conexión). Cuan­ do se vuelvan a ejecutar los programas (después de volver a compilar los fi­ cheros de código fuente), el proceso emisor intentará ahora mandar datagra- mas cuya dirección de destino no coincide con la dirección especificada en la conexión del receptor. Describa y explique el resultado de la ejecución. c. Vuelva a ejecutar los programas originales. Esta vez arranque un segundo proceso emisor, especificándole la misma dirección del receptor. Un ejem ­ plo de los mandatos necesarios para arrancar el árbol de procesos es: j a v a E je m p lo 3 R e c e p to r l o c a l h o s t 1 000 2 0 0 0 m s j l j a v a E je m p lo 3 E m is o r l o c a l h o s t 2 000 100 0 m s j2 j a v a E je m p lo 3 E m is o r l o c a l h o s t 2 000 3 0 0 0 m s j3 www.FreeLibros.org El API d e sockets 1 2 3 P2 Arranque los tres procesos en una sucesión rápida d e manera que el se­ gundo proceso emisor intente establecer una conexión con e l proceso re­ ceptor cuando e l socket de este último ya esté conectado al del primer pro­ ceso emisor. Describa y explique e l resultado de la ejecución. 8. Este ejercicio guía al lector mediante experimentos con un socket en modo stream orientado a conexión utilizando los códigos Ejemplo4 y EjemploS. a. Compile y ejecute Ejemplo4*.java (Nota: S e utiliza * como un carácter co­ modín, de modo que Ejemplo4*.java hace referencia a los ficheros cuyos nombres comienzan con «Ejemplo4» y terminan con «.java»). Arranque en primer lugar el Aceptador y, después, el Solicitante. Un ejemplo de los man­ datos necesarios para ello es: j a v a E je m p lo 4 A c e p ta d o r C o n e x io n l o c a l h o s t 12345 iB u e n o s d i a s ! j a v a E j e m p l o 4 S o l i c i t a n t e C o n e x i o n l o c a l h o s t 12345 Describa y explique el resultado. b. Repita el último apartado pero cambie el orden de ejecución de los pro­ gramas: j a v a E j e m p l o 4 S o l i c i t a n t e C o n e x i o n l o c a l h o s t 12345 j a v a E je m p lo 4 A c e p ta d o r C o n e x io n l o c a l h o s t 12345 iB u e n o s d i a s ! Describa y explique el resultado c Añada un tiempo de retraso de 5 segundos en el proceso AceptadorConexión justo antes de que el mensaje se escriba en el socket, después repita el apar­ tado a. Esto producirá el efecto de mantener al Solicitante bloqueado en la lectura durante 5 segundos adicionales de manera que se pueda observar v i­ sualmente el bloqueo. M uestre una traza de la salida d e los procesos. ¿Es­ tán de acuerdo los mensajes de diagnóstico mostrados en la pantalla con el diagrama de eventos de la Figura 4.21? d. Modifique Ejemplo4*.java de manera que AceptadorConexión utilice print() para escribir un solo carácter cada vez en el socket antes de llevar a cabo un println() para escribir un final de línea. Vuelva a compilar y ejecutar los programas. ¿Se recibe e l mensaje en su totalidad? Explíquelo. e. Compile y ejecute Ejemplo5*.java. Arranque en primer lugar el Aceptador y, después, el Solicitante. Un ejemplo de los mandatos necesarios para ello es: j a v a E je m p lo 5 A c e p ta d o r C o n e x io n l o c a l h o s t 1 2 3 4 5 iB u e n o s d i a s ! j a v a E j e m p l o 5 S o l i c i t a n t e C o n e x i o n l o c a l h o s t 12345 Debido a que el código es lógicamente equivalente a Ejemplo4*, el re­ sultado debería ser e l mismo que e l d el apartado a. M odifique Ejem ­ plo s* Java de modo que el proceso AceptadorConexión se convierta en el www.FreeLibros.org 124 C om putación distribuida. Fundam entos y aplicaciones emisor del mensaje y el SolicitanteConexión en el receptor del mensaje. (El lector podría querer borrar los mensajes de diagnóstico). Presente un diagra­ ma de eventos, los listados de los programas y el resultado de la ejecución. f. Modifique el Ejemplo5*.java de modo que el SolicitanteConexión mande un mensaje de respuesta al AceptadorConexión después d e recibir un men­ saje del Aceptador. El Aceptador debería visualizar el mensaje de respues­ ta. Presente un diagrama d e eventos, los listados de los programas y el re­ sultado de la ejecución. 9. ¿H ay interfaces de programación de sockets que proporcionen operaciones de E/S (lectura y escritura) no bloqueantes? Nombre alguno. ¿Cuáles son las ven­ tajas de utilizar una API d e este tipo en vez de las interfaces presentadas en este capítulo? 10. Examine el NIOS de Java en el JDK1.4. Escriba un informe describiendo cómo puede utilizarse la E/S de sockets no bloqueante en un programa de Java. Pro­ porcione ejemplos de código para ilustrar la descripción. 11. ¿Qué es una API de sockets seguros? Nombre alguno de los protocolos d e soc­ kets seguros y una API que proporcione sockets seguros. Escriba un informe describiendo cómo puede utilizarse un socket seguro en un programa de Java. Proporcione ejemplos de código para ilustrar la descripción. R EFER EN C IA S 1. E s p e c ific a c ió n d e l A P I d e J a v a 2 p la ta fo rm a v l . 4 , http://java.sun.eom /j2se/l.4/docs /api/index.html 2. Introducción a S S L , http://developer.netscape.com/docs/manuaIs/security/sslin/contents.htm. 3. E x ten sió n d e sockets seg u ro s d e Ja v a (TM ), http://java.sun.com./products/jsse/ 4. K irby W . A ngelí, « T h e Ja v a S o c k e t S e c u re E xtensions», Dr. D obb's Journal, febrero de 2001. http://www.ddj.com/articles/2001/OI02l0102all0102a.htm?topic=security 5. E l protocolo T L S , R FC 2246, http://www.ietf.org/rfc/rfc2246.txt 6. N ew I/O A P Is, http://java.sun.eom/j2se/l.4/docs/guide/nio/index.html, java.sun.com www.FreeLibros.org CAPÍTULO El p a r a d ig m a c l i e n t e - s e r v i d o r En este capítulo se explorará en detalle el paradigm a cliente- servidor. Se hará tam bién uso del conocim iento de las interfaces de program ación de sockets para exam inar la im plem entación de las aplicaciones cliente-servidor que se m uestran en este capítulo. 5 .1 . A N T E C E D E N T E S El término cliente-servidor tiene múltiples significados en informática. Puede referir­ se a una arqintectura d e red donde los computadores en una red realizan diferentes papeles para compartir recursos. En una v q u ite d ir a diente-servidor, a un compu­ tador se le denomina servidor si se dedica a gestionar recursos como impresoras o fi­ cheros de manera que otros computadores, llamados clientes, puedan acceder a estos recursos a través del servidor. La arquitectura cliente-servidor, aunque relacionada con el paradigma cliente-servidor, no es el tem a de este capítulo. En la informática distribuida, e l paradigma cliente-servidor se refiere a un mode­ lo de aplicaciones de red donde los procesos juegan uno de dos diferentes papeles: un proceso servidor, tam bién llamado servidor para abreviar, se dedica a gestionar el acceso a algunos servicios de la red, mientras que los procesos dkmte; llamados dientes para abreviar, acceden a l servidor para obtener un servicio de red. Nótese que en la arquitectura cliente-servidor, los términos cliente y servidor están referidos a los confutadores, mientras que en el paradigma de computación distribuida cliente-ser­ vidor, los términos se refieren a los procesos En este libro, cuando se utiliza el tér­ mino cliente-servidor, se usa para referirse al paradigma de computación distribuida. La Figura 5.1 ilustra el concepto del modelo cliente-servidor. Un proceso servi­ dor ejecuta en un computador conectado a la red, al cual nos referiremos como m á­ quina servidora, para gestionar un servicio de red proporcionado por esa máquina. Nótese que es posible que una máquina servidora proporcione otros servicios de red que son gestionados por otros procesos. Un usuario, uno que típicamente esté usando otro computador, al que se llam ará m áquina cliente utiliza un proceso cliente para acceder a un servicio particular. Es posible que otros procesos clientes (posiblemente Arquitectura de red se refiere a cómo se conectan los computadores en una red. El término no se debe confundir con los modelos abstractos de arquitectura de red (el modelo OSI y el modelo de Internet), que se examinaron en el Capítulo 1.____________ www.FreeLibros.org 126 C om putación distribuida. Fundam entos y aplicaciones de otros servicios) ejecuten en la máquina cliente a la vez, pero debe usarse el pro­ ceso cliente apropiado para acceder a un servicio particular. a Una petición de servicio [ ] Un proceso cliente | Un proceso servido r ( ^ ) Un servicio M á q u in a d e s e rv id o r M á q u in a s d e c lie n te s F ig u ra 5 .1 . B paradigm a de com putación distribuida cliente-servidor. El modelo cliente-servidor está diseñado para proporcionar servicios de red, los cuales fueron, y todavía son, la aplicación más popular de la computación distribui­ da. Por servicio de red se entiende un servicio proporcionado para permitir a los usua­ rios de la red compartir recursos. Tales recursos pueden ser tan triviales como la hora del día o tan complejos como ficheros en un sistem a de ficheros de la máquina ser­ vidora o datos de un sistema de base de datos. A lo largo de los años, muchos de es­ tos servicios de red se han estandarizado en Internet: telnet, que permite entrar (fo­ gón) de forma remota en una máquina servidora; ftp , para mandar y recibir ficheros de una máquina servidora; Daytime, que proporciona una marca de tiempo obtenida de una máquina servidora; y el World Wide Web, para buscar contenidos web en una máquina servidora. 5 .2 . CUESTIONES SOBRE EL PARADIGMA CUENTE-SERVIDO R Mientras que e l concepto del paradigma es sencillo, en la in ^ l e m a i t a d ó i i real hay un número de cuestiones que se deben afrontar. En esta sección se van a discutir es­ tas cuestiones. Una sesión de servicio En el contexto del modelo cliente-servidor, se utilizará el término sesión para referir­ se a la interacción entre el servidor y el cliente. Como se muestra en la Figura 5.1, el servicio gestionado por un servidor puede ser accesible a múltiples clientes que quieran utilizar el servicio, algunas veces concurrentemente. Cada cliente entabla una sesión separada e independiente con e l servidor, durante la cual el cliente conduce un diálogo con el servidor hasta que el cliente haya obtenido el servicio deseado. www.FreeLibros.org El paradigm a cliente-servidor 127 La Figura 5.2 ilustra el flujo de ejecución del proceso servidor. Una vez que ha comenzado, un proceso servidor de red se ejecuta indefinidamente, realiza un bucle continuo que acepta peticiones de las sesiones d e los clientes. Para cada cliente, el servidor conduce una sesión de servicio. F ig u ra 5 2 . El flu jo de ejecución del proceso servidor. El protocolo de un servicio Se necesita un protocolo para especificar las reglas que deben observar el cliente y el servidor durante una sesión de servicio. Dichas reglas incluyen especificaciones en cuestiones tales como (1) la manera de localizar e l servicio, (2) la secuencia de co­ municación entre los procesos, y (3) la representación e interpretación de los datos in­ tercambiados. Lo calización del se rvicio Debe existir un mecanismo que permita que un proceso cliente localice un servidor de un determinado servicio. En e l esquema más simple, la localización de un servi­ cio es estática y se puede identificar utilizando la dirección del proceso servidor, en términos del nombre d e la máquina y el número de puerto de protocolo asignado al proceso servidor. Este es e l esquema usado para los servicios de Internet, donde a cada servicio d e Internet se le asigna un número de puerto específico. En particular, a un servicio bien conocido, como FTP, HTTP, o telnet, se le asigna un número de puerto por defecto que se reserva en cada máquina d e Internet para ese servicio. Por ejemplo, al servicio FTP se le asignan dos números de puerto d e TCP: 20 y 21, y al HTTP el puerto de TCP 80. En un nivel más alto de abstracción, un servicio puede identificarse utilizando un nombre lógico registrado en un directorio o en un registro. El nombre lógico necesi­ tará traducirse a la ubicación física del proceso servidor. Si la traducción se realiza en tiempo de ejecución (es decir, cuando se ejecuta un proceso cliente), es posible que la localización del servicio sea dinámica, en cuyo caso se dice que el servicio es transparente de la ubicación En un sistem a UNIX s e puede consultar un fichero denominado sen/ices dentro del directorio /etc, o sea, /etc/services, para encontrar estas asignaciones d e puerto. www.FreeLibros.org 128 C om putación distribuida. Fundam entos y aplicaciones En el modelo cliente-servidor, la interacción d e los procesos sigue un patrón de peti­ ción-respuesta (véase la Figura 5.3). Durante una sesión de servicio, un cliente hace una petición al servidor, que contesta con una respuesta. El cliente puede hacer una petición subsiguiente, seguida por una respuesta del servidor. Este patrón se puede re­ petir indefinidamente hasta que concluya la sesión. Por cada petición realizada, e l cliente debe esperar por la respuesta del servidor antes de continuar. Por ejemplo, uno d e los servicios más simples de la red es el ser­ vicio Daytime, mediante el cual un proceso cliente simplemente obtiene una marca de tiempo (la hora del día en la máquina servidora) del proceso servidor. Traducido a una hipotética conversación en español, el diálogo durante una sesión de servicio de este protocolo se llevaría a cabo de la siguiente forma: E l diente: Hola, soy <dirección del cliente>. Por favor, ¿puede darme una marca de tiempo? E l servidor: Aquí la tiene: (en este punto estará la marca d e tiempo). De manera similar, el diálogo en una sesión web se realizaría de la siguiente manera: E l cliente Hola, soy <dirección del cliente>. E l servidor: Vale. Soy un servidor web y entiendo el protocolo HTTP 1.0. E l cliente Estupendo. Por favor, envíeme la página w eb index.html en la raíz de su árbol de documentos. E l servidor: Muy bien, aquí está lo que hay en la página (aquí aparecerá e l con­ tenido). C o m u n icacio n es entre procesos y sincronización de eventos C liente S ervido r Comunicación entre procesos ---------------------------------------------- > respuesta! p e tic ió n <=------ respuesta2 petición petición,, respuesta,, Tiempo F ig u ra 5 .3 . El p a tró n p e tic ió n -re s p u e s ta d e la s c o m u n ic a c io n e s e n tre p ro c e s o s en el m o d e lo clie n te -se rvid o r. www.FreeLibros.org El paradigm a cliente-servidor 129 El diálogo en cada sesión sigue un patrón descrito en el protocolo especificado para el servicio. Por ejemplo, e l servicio Daytime d e Internet soporta el protocolo es­ pecificado en e l RFC 867 de Internet [Postel, 1]. Cualquier implementación del pro­ grama cliente o servidor debe adherirse a la especificación del protocolo, incluyendo cómo debería proceder el diálogo de cada sesión. Entre otras cosas, la especificación define (1) la secuencia de intercomunicaciones entre el cliente y el servidor, (2) la sintaxis y la semántica de cada petición y respuesta, y (3) la acción esperada en cada lado a l recibir una petición o respuesta determinada. Utilizando nuevamente como ejem plo el sencillo servicio Daytime, el protocolo es­ pecifica lo siguiente: • No hay necesidad de ninguna sintaxis específica en las peticiones del cliente, puesto que contactar con el servidor ya supone automáticamente una solicitud de la hora del día. • La respuesta es una marca de tiempo formateada como una cadena de caracte­ res de acuerdo con la especificación d e protocolo. (Un toque humorístico: esta interacción no es muy diferente a la que ocurre cuando un padre, al recibir una llamada telefónica de un hijo que asiste a una universidad, responde inmediata­ mente, «Vale, el dinero y a está en camino»). Un diagrama de secuencia es una buena manera de documentar las comunicaciones entre procesos durante una sesión d e servicio. La Figura 5.4 muestra el diagrama de secuencia para una sesión del servicio Daytime. Nótese que e l único mensaje inter­ cambiado es la marca de tiempo. C lie n te S ervido r marca de tiem po F ig u ra 5 .4 . El p a ra d ig m a d e c o m p u ta c ió n d is trib u id a clie n te -se rvid o r. Representación de datos La elección de la representación d e datos depende de la naturaleza y la necesidad del protocolo. Para un servicio sencillo como el Daytime, es lógico utilizar una represen­ tación en modo texto, como se describe en el RFC 867 [Postel, 1]: S i n t a x i s d e D a y tim e fto h a y u n a s i n t a x i s e s p e c í f i c a p a r a d a y ti m e . S e re c o m ie n d a q u e s e l i m i t e a l o s c a r a c t e r e s A SC II i m p r i m i b l e s , e l e s p a c i o , e l r e t o m o d e c a r r o y e l s a l t o d e l í n e a . L a f e c h a y h o r a d e b e r í a n o c u p a r u n a s o l a l í n e a . Una s i n t a x i s p o p u l a r e s : D ía d e l a s e m a n a , m es d í a , a ñ o h o r a - z o n a h o r a r i a E je m p lo : M a r t e s , f e b r e r o 2 2 , 1 982 1 7 :3 7 :4 3 - P S T La sintaxis se refiere a la gramática y a la ortografía de un mensaje. La semántica corresponde con la interpretación y el significado de los mensajes._____________ www.FreeLibros.org 130 C om putación distribuida. Fundam entos y aplicaciones Cada com putador tiene in reloj y la mayoría de los lenguajes de programación proporcionan una API para obtener el valor del reloj._____________ En esta especificación, el formato, o sintaxis, de la marca de tiempo se deja a cri­ terio del implementador. Elegir una representación de datos en modo texto para un protocolo tiene la ven­ taja de permitir que el diálogo sea legible para todos, ya que se puede utilizar E/S en modo texto estándar para mostrar los datos intercambiados. 5 .3 . IN G E N IE R ÍA DE SO FTW A RE DE UN S E R V IC IO DE RED En este punto el lector ya está preparado para examinar cómo construir el software necesario para proporcionar un servicio de red. H ay dos conjuntos de software involucrados: uno para el proceso cliente y el otro para el proceso servidor. El conjunto de software que se necesita en la máquina clien­ te para proporcionar un servicio o aplicación, incluyendo el programa cliente y su en­ torno de apoyo en tiempo de ejecución, se denomina a veces software del lado d ien ­ te* en contraposición al software del lado servidor, que incluye al programa servidor y todos los entornos de apoyo en tiempo de ejecución que necesita. Suponiendo que el protocolo está bien definido y comprendido, es posible desarrollar separada e in­ dependientemente el software en ambos lados. S e usará nuevamente e l protocolo D aytim e como un ejem plo del proceso de desarrollo de un servicio de red. Arquitectura de softw are En e l Capítulo 1 se presentó una arquitectura de software de tres niveles para las apli­ caciones de red, de manera que las funcionalidades de cada aplicación puedan divi­ dirse en tres niveles: presentación, aplicación y servicio. Según esto, la arquitectura de software de una aplicación construida utilizando el modelo cliente-servidor, o una aplicación cliente-servidor, se puede describir de la siguiente manera: • N ivel d e presentación. En e l lado del servidor, se necesita una interfaz de usua­ rio (UI, User Interface) para permitir arrancar el proceso servidor; típicam en­ te, basta con la ejecución de una línea de mandato. En el lado cliente, se pre­ cisa que el cliente proporcione una interfaz de usuario. Mediante dicha interfaz, un usuario en la máquina cliente puede solicitar e l servicio y recibir la res­ puesta del servidor. En el código de ejemplo, se utilizará una interfaz de usua­ rio en modo texto por simplicidad, pero en su lugar puede utilizarse una in­ terfaz de usuario gráfica (GUI, Graphic User Interface) o una página web. En e l Capítulo 9 se examinará cómo construir una página w eb que acepte y v i­ sualice datos. • Nivel d e ló ^ ca d e aplicación. En e l lado del servidor, necesita obtenerse la hora del día del sistem a y mandarla a la máquina cliente. En el lado del clien­ te, hay que enviar al servidor la petición del usuario y mostrarle la respuesta del servidor. • Nivel d e s e v ic ia Los servicios requeridos para dar soporte a la aplicación son (1) en el lado del servidor, una lectura del reloj de la máquina servidora (para la marca de tiem po); y (2) en ambos lados, un mecanismo de IPC. www.FreeLibros.org El paradigm a cliente-servidor 131 Las funcionalidades de los tres niveles deben estar presentes en e l software conjunto. Algunas funcionalidades pertenecen al cliente y otras al servidor. Para aplicaciones de gran escala, es aconsejable diseñar e l software d e manera que las funcionalidades de los tres niveles se encapsulen en módulos de software separados. Véase la Figura 5.5. S o ftw a re d e l la d o c lie n te S o ftw a re d e l la d o se rvid o r Lógica de p re se n ta ció n Lógica de p re se n ta ció n L ó gica d e a p lic a c ió n L ó g ica de a p lic a c ió n L ó gica de s e rv ic io L ó g ica de s e rv ic io F ig u ra 5 .5 . A rq u ite c tu ra d e so ftw a re pa ra un a a p lic a c ió n c lie n te -s e rv id o r. M ecanism o de IPC Hay que considerar el mecanismo de IPC que se utilizará en la lógica de la aplica­ ción; el mecanismo seleccionado afectará en cómo las aplicaciones transmiten datos. Dado el repertorio limitado de mecanismos de IPC aprendido hasta ahora, se pre­ senta la posibilidad de elegir entre (1) un socket datagrama sin conexión, (2) un socket datagrama orientado a conexión, o (3) un socket en modo stream. Con la arquitectura de software apropiada, los detalles del mecanismo se escon­ derán completamente de la lógica de presentación y afectarán únicamente a la lógica de aplicación en la sintaxis d e los mandatos de IPC. Se comenzará examinando un código de ejemplo que utiliza el socket datagrama sin conexión. S e verá posteriormente cómo la arquitectura de software permite adap­ tar el software al API de socket en modo stream orientado a conexión. No hay que alarmarse por e l gran número de clases de Java utilizadas en el ejem ­ plo. Cada clase es simple y representa un módulo de software que implementa un ni­ vel de la lógica en la arquitectura d e software. Cliente-servidor D aytim e usando so cke ts datagram a sin conexión Softw are del lado cliente L ógica d e p re sc n ta d ó n . La Figura 5.6 presenta la clase Clie nteD ay time 1.ja va, que encapsula la lógica de presentación del lado cliente; esto es, proporciona la interfaz de usuario del proceso cliente. S e apreciará que el código en esta clase se ocupa me­ ramente de obtener la entrada (la dirección del servidor) del usuario y de mostrar la salida (la marca de tiempo) al mismo. Para obtener la marca d e tiempo, se realiza una llamada de método a una clase auxiliar, ClienteDaytimeAuxiliarl ja va . Este método esconde los detalles d e la lógica d e la aplicación y del servicio subyacente. Como re­ sultado, el programador de C líente Daytime 1 ja v a no necesita conocer qué tipos de soc­ kets se utilizan en la IPC. www.FreeLibros.org 132 C om putación distribuida. Fundam entos y aplicaciones L ó^ ca d e aplicación La clase ClienteDaytimeAuxiliarl.java (Figura 5.7) encap- sula la lógica de aplicación del lado cliente. Este módulo realiza la IPC para mandar una petición y recibir una respuesta utilizando una subclase d e DatagramSocket, Mi- SocketDatagramaCliente. Nótese que a este módulo se le esconden los detalles de la utilización de sockets datagrama. En particular, este módulo no necesita tratar con el vector de octetos que lleva los datos de la carga. Lógica de servicio. La clase M i SocketDatagramaCliente.java (Figura 5.8) pro­ porciona los detalles del servicio de IPC, en este caso utilizando el A PI de socket da­ tagrama. H ay al menos dos ventajas significativas en separar los tres niveles de la lógica de la aplicación en módulos de software diferentes: • Cada módulo pueden desarrollarlo personas que estén especialmente capacita­ das para centrarse en ese módulo. Los ingenieros d e software especializados en interfaces de usuario pueden concentrarse en el desarrollo de los módulos de la lógica de presentación, mientras que aquellos especializados en la lógica de apli­ cación y de servicio pueden dedicarse al desarrollo d e los otros módulos. • La separación permite que se hagan modificaciones en la lógica de un nivel sin requerir que se hagan cambios en otros niveles. Por ejemplo, se puede cambiar la interfaz de usuario de modo texto a modo gráfico sin necesitar cambios en la lógica de aplicación o la de servicio. De manera similar, los cambios hechos en la lógica de aplicación deberían ser transparentes al nivel de presentación. La Figura 5.9 es un diagrama de clases UML que describe las clases utilizadas en la implementación del programa ClienteDaytimel. Softw are del lado se rvid o r L ógica d e presentación. Típicamente, hay m uy poca lógica de presentación en el lado del servidor. En este caso, la única entrada de usuario corresponde con el puerto del servidor que, por simplificar, se maneja utilizando un argumento de línea de mandato. Lég^ca d e aplicación La clase ServidorD aytim el.java (Figura 5.10) encapsula la lógica de aplicación del lado servidor. Este módulo ejecuta un bucle infinito, espe­ rando una petición de un cliente y después dirige una sesión de servicio para ese clien­ te. El módulo realiza la IPC para recibir una petición y manda una respuesta utili­ zando una subclase de DatagramSocket, MiSocketDatagramaServidor. Nótese que a este módulo se le esconden los detalles de la utilización de los sockets datagrama. En particular, este módulo no necesita tratar con el vector de octetos que lleva los datos de la carga. Lógica de servido. La clase MiSocketDatagramaServidor (Figura 5.11) propor­ ciona los detalles del servicio de IPC, en este caso utilizando el API d e socket data- grama. Esta clase es similar a la clase MiSocketDatagramaClíente, con la excepción de que el método recibeMensaje devuelve un objeto de la clase MensajeDatagrama (Figura 5.12), que contiene la dirección del emisor, así como el mensaje en sí mis­ mo. El servidor necesita la dirección del emisor para mandar una petición al cliente, ésta es una idiosincrasia del socket sin conexión: el servidor no tiene manera de co­ nocer dónde mandar una respuesta en caso contrario. Los métodos empleados para obtener la dirección del emisor de un datagrama recibido son getAddress y getHost, cuyas descripciones se muestran en la Tabla 5.1. Estos dos métodos no se menciona­ ron en el último capítulo cuando se presentó e l API d e sockets datagrama. www.FreeLibros.org El paradigm a cliente-servidor 1 3 3 T a b la 5.1 . Los m é to d o s g e tA d d r e s s y g e tP o rt de la c la s e D atagram P acket. M étodo Descripción public InetA ddress getAddress() public int getP ortf) Devuelve la dirección IP de la máquina remota de un socket desde el que fue recibido el datagrama. Devuelve e l número de puerto en la máquina remota de un socket desde el que fue recibido el datagrama. F ig u ra 5 .6 . C lien teD a ytim el.ja va . 1 i m p o r t j a v a . i o . * ; 2 3 4 /* * 5 * E s t e m ód u lo c o n t i e n e l a l ó g i c a d e p r e s e n t a c i ó n d e u n C1 i e n teD a y t i m e . 6 * § a u t h o r M. L . L i u 7 * / 8 p u b l i c c l a s s C l i e n t e D a y t i m e l { 9 p u b l i c s t a t i c v o i d m a in ( S t r i n g [ ] a r g s ) { 10 I n p u t S tr e a m R e a d e r i s = new I n p u t S t r e a m R e a d e r ( S y s t e m . i n ) ; 11 B u f f e r e d R e a d e r b r = new B u f f e r e d R e a d e r ( i s ) ; 12 t r y { 13 S y s te m , o u t . p r i n t l n ( \" B ie n v e n id o a l c l i e n t e D a y tim e .X n \" + 14 \" ¿ C u á l e s e l n o m b re d e l a m á q u in a s e r v i d o r a ? \" ) ; 15 S t r i n g n o m b re M a q u in a = b r . r e a d L i n e ( ) ; 16 i f ( n o r r b r e M a q u i n a .l e n g t h ( ) == 0 ) / / s i e l u s u a r i o no / / i n t r o d u c e u n n o m b re 17 n o m b re M a q u in a = \" l o c a l h o s t \" ; / / u s a e l n o n b r e d e m á q u in a / / p o r d e f e c t o 18 S y s te m , o u t . p r i n t l n ( \" ¿ C u á l e s e l nfi d e p u e r t o d e l a m á q u in a s e r v i d o r a ? \" ) ; 19 S t r i n g n u m P u e r to = b r . r e a d L i n e ( ) ; 20 i f ( n u m P u e r to . l e n g t h ( ) == 0 ) 21 n u m P u e r to = \" 1 3 \" ? / / n ú m ero d e p u e r t o p o r d e f e c t o 22 S y s t e m . o u t . p r i n t l n ( \" M a r c a d e t i e m p o r e c i b i d a d e l s e r v i d o r \" 23 + C l i e n t e D a y t i m e A u x i l i a r 1 . o b t e n e r M a r c a t ie m p o ( n o n to re M a q u in a , n u m P u e r to ) ) ; 24 > / / f i n d e t r y 25 c a t c h ( E x c e p t i o n e x ) { 26 e x . p r i n t S t a c k T r a c e ( ) ; 27 } / / f i n d e c a t c h 28 } / / f i n d e m a in 29 > / / f i n d e c l a s s (continúa) www.FreeLibros.org 134 C om putación distribuida. Fundam entos y aplicaciones 1 2 i n p o r t j a v a . n e t . * ? 3 4 /* * 5 * E s t a c l a s e e s u n m ó d u lo q u e p r o p o r c i o n a l a l ó g i c a d e a p l i c a c i ó n 6 * d e u n c l i e n t e d e D a y tim e . 7 * G a u th o r M. L . L i u 8 * / 9 p u b l i c c l a s s C l i e n t e D a y t i m e A u x i l i a r l { F ig u ra 5 .7 . C lie n te D a ytim e A u xilia rl.ja va . 10 11 p u b l i c s t a t i c S t r i n g o b te n e r M a r c a tie n p o ( S t r i n g n a n b re M a q u in a , 12 S t r i n g n u m P u erto ) { 13 14 S t r i n g m arcaT iem po = 1111; 15 t r y { 16 I n e tA d d r e s s s e r v e r H o s t = I n e tM d r e s s .getB yN am e(nom breM aquina) ; 17 i n t s e r v e r P o r t = I n t e g e r . p a r s e l n t ( n u m P u e r t o ) ; 18 / / i n s t a n c i a u n s o c k e t d a ta g ra m a p a r a t a n t o l o s d a t o s d e 19 / / e m is ió n como l o s d e r e c e p c i ó n 20 M iS o c k e tD a ta g ra m a C lie n te m iS o c k e t = new M iS o c k e tD a ta g ra m a C lie n te ( ) ; 21 m iS o c k e t. en v iaM en sa j e ( s e r v e r H o s t , s e r v e r P o r t , \"\"); 22 / / a h o r a r e c i b e l a m a rc a d e tie m p o 23 m arcaT iem po = m iS o c k e t.r e c ib e M e n s a je ( ) ? 24 m i S o c k e t . c i ó s e ( ) ; 25 26 } / / f i n d e t r y 27 c a t c h ( E x c e p tio n e x ) { 28 e x . p r i n t S t a c k T r a c e ( ) ? 29 } / / f i n d e c a t c h 30 r e t u r n m arcaT iem po; 31 > / / f i n d e m ain 32 } / / f i n d e c l a s s • Es mejor técnica de desarrollo de software activar en este método una excepdón en caso de errores causados por llamadas de métodos; esta técnica no se ha utilizado aquí para evitar la complejidad de crear otra clase adidonal para las excepciones. F ig u ra 5 .8 . M iS o cketD a ta g ra m a C lien te.ja va 1 i n p o r t j a v a . n e t . * ; 2 i n p o r t j a v a . i o . * ; 3 4 / * * 5 * Una s u b c l a s e d e D a ta g r a m S o c k e t q u e c o n t i e n e 6 * m é to d o s p a r a m a n d a r y r e c i b i r m e n s a j e s 7 * O a u th o r M. L . L i u 8 */ 9 p u b l i c c l a s s M i S o c k e tD a ta g r a m a C li e n te e x t e n d s D a ta g r a m S o c k e t { 10 s t a t i c f i n a l i n t MAX_ION = 1 0 0 ; ( continúa) www.FreeLibros.org El paradigm a cliente-servidor 135 11 M i S o c k e tD a ta g r a m a C li e n te ( ) th r o w s S o c k e tE x c e p t io n { 12 s u p e r ( ) ; 13 > 14 15 M i S o c k e tD a ta g r a m a C li e n te ( i n t n u m P u e r to ) t h r o w s S o c k e t E x c e p t i o n { 16 s u p e r ( n u m P u e r to ) ; 17 } 18 19 p u b l i c v o i d e n v i a M e n s a j e ( I n e t A d d r e s s m a q u i n a R e c e p to r a , 20 i n t p u e r t o R e c e p t o r , S t r i n g m e n s a je ) th r o w s I O E x c e p ti o n { 21 b y t e [ ] a lm a c e n E n v io = m e n s a j e . g e t B y t e s ( ) ; 22 D a ta g r a m P a c k e t d a ta g r a m a = 23 new D a ta g r a m P a c k e t ( a l m a c e n E n v io , a l m a c e n E n v i o . l e n g t h , 24 m a q u i n a R e c e p to r a , p u e r t o R e c e p t o r ) ; 25 t h i s . s e n d ( d a t a g r a m a ) ; 26 } / / f i n d e e n v ia M e n s a j e 27 28 p u b l i c S t r i n g r e c i b e M e n s a j e ( ) 29 th r o w s I O E x c e p ti o n { 30 b y t e [ ] a lm a c e n R e c e p c io n = new byte[M A X_L0N] ; 31 D a ta g r a m P a c k e t d a ta g r a m = 32 new D a ta g r a m P a c k e t ( a l m a c e n R e c e p c io n , MAX_LON) ; 33 t h i s . r e c e i v e ( d a t a g r a m ) ; 34 S t r i n g m e n s a je = new S t r i n g ( a lm a c e n R e c e p c io n ) ; 35 r e t u m m e n s a j e ; 36 } / / f i n d e r e c i b e M e n s a j e 37 } / / f i n d e c l a s s Lógica de presentación F ig u ra 5.9. Diagram a d e cla ses U M L d e C lienteD aytim el (no se m uestran to d o s tos atributos). www.FreeLibros.org 136 C om putación distribuida. Fundam entos y aplicaciones F ig u ra 5 .1 0 . S e rv id o rD a y tim e l.ja v a . 1 i n p o r t j a v a . i o . * ; 2 \"i i n p o r t j a v a . ú t i l . D a t e ; / / p a r a o b t e n e r u n a m a r c a d e ti e m p o j 4 / ■ k * 5 * E s t e m ó dulo c o n t i e n e l a l ó g i c a d e a p l i c a c i ó n d e un s e r v i d o r D aytim e 6 * q u e u t i l i z a u n s o c k e t d a ta g r a m a p a r a l a c a n u n ic a c ió n e n t r e p r o c e s o s . 7 * S e r e q u i e r e u n a rg u m e n to d e l i n e a d e m a n d a to p a r a e l p u e r t o d e l s e r v i d o r . 8 * G a u th o r M. L . L i u 9 * i 10 p u b l i c c l a s s S e r v i d o r D a y t i m e l { 11 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 12 i n t p u e r t o S e r v i d o r = 1 3 ; / / p u e r t o p o r d e f e c t o 13 i f ( a r g s . l e n g t h == 1 ) 14 p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( a r g s [ 0 ] ) ; 15 t r y { 16 / / i n s t a n c i a u n s o c k e t d a ta g r a m a p a r a t a n t o m a n d a r como 17 / / r e c i b i r d a t o s 18 M iS o c k e tD a ta g r a m a S e r v id o r m i S o c k e t = new M i S o c k e tD a ta g r a m a S e r v i d o r ( p u e r t o S e r v i d o r ) ; 19 S y s t e m . o u t . p r i n t l n ( \" E l s e r v i d o r D a y tim e e s t á l i s t o . \" ) ; 20 w h i l e ( t r u e ) { / / b u c l e i n f i n i t o 21 M e n s a je D a ta g ra m a p e t i c i ó n = m i S o c k e t.r e c ib e M e n s a je Y E m is o r ( ) ; 22 S y s t e m . o u t . p r i n t l n ( \" P e t i c i ó n r e c i b i d a \" ) ; 23 / / n o e s i m p o r t a n t e e l m e n s a je r e c i b i d o ; e s l a d i r e c c i ó n 24 / / d e l e m i s o r l o q u e s e n e c e s i t a p a r a r e s p o n d e r . . 25 / / A h o ra o b t i e n e u n a m a r c a d e t i e m p o d e l s i s t e m a . 26 D a te m a rc a T ie ir p o = new D a te ( ) ; 27 S y s t e m . o u t . p r i n t l n ( \" m a r c a d e ti e m p o e n v i a d a : \" + m a rc a T ie m p o . t o S t r i n g ( ) ) ; 28 / / A h o ra m an d a l a r e s p u e s t a a l s o l i c i t a n t e . 29 m i S o c k e t. e n v i a M e n s a j e ( p e t i c i ó n . o b t i e n e D i r e c c i o n ( ) , 30 p e t i c i ó n . o b t i e n e P u e r t o ( ) , m a rc a T ie m p o . t o S t r i n g ( ) ) ; 31 > / / f i n d e w h i l e 32 > / / f i n d e t r y 33 c a t c h ( E x c e p t i o n e x ) { 34 e x . p r i n t S t a c k T r a c e ( ) ; 35 } / / f i n d e c a t c h 36 > / / f i n d e m a in 37 > / / f i n d e c l a s s F ig u ra 5 .1 1 . M iSocketD atagram aServidor.java. 1 i n p o r t j a v a . n e t . * ; 2 i n p o r t j a v a . i o . * ? 3 4 ( continúa) www.FreeLibros.org 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 El paradigm a cliente-servidor 137 /** * U na s u b c l a s e d e D a ta g r a m S o c k e t q u e c o n t i e n e * m é to d o s p a r a m a n d a r y r e c i b i r m e n s a je s * § a u t h o r M. L . L i u * / p u b l i c c l a s s M i S o c k e tD a ta g r a m a S e r v id o r e x t e n d s D a ta g r a m S o c k e t { s t a t i c f i n a l i n t MAX_L0N = 1 0 0 ; M i S o c k e tD a ta g r a m a S e r v i d o r ( i n t n u m P u e r to ) th r o w s S o c k e tE x c e p t io n { s u p e r ( n u m P u e r to ) ; > p u b l i c v o i d e n v i a M e n s a j e ( I n e t A d d r e s s m a q u i n a R e c e p to r a , i n t p u e r t o R e c e p t o r , S t r i n g m e n s a j e ) th r o w s I O E x c e p ti o n { b y t e [ ] a lm a c e n E n v io = m e n s a j e . g e t B y t e s ( ) ; D a ta g r a m P a c k e t d a ta g r a m a = new D a ta g r a m P a c k e t( a lm a c e n E n v i o , a l m a c e n E n v i o . l e n g t h , m a q u i n a R e c e p to r a , p u e r t o R e c e p t o r ) ; t h i s . s e n d ( d a t a g r a m a ) ; } / / f i n d e e n v ia M e n s a j e p u b l i c S t r i n g r e c i b e M e n s a j e ( ) th r o w s I O E x c e p ti o n { b y t e [ ] a lm a c e n R e c e p c io n = new b y t e [ MAX_LON ] ; D a ta g r a m P a c k e t d a ta g r a m a = new D a ta g r a m P a c k e t ( a lm a c e n R e c e p c io n , MAX_LON) ; t h i s . r e c e i v e ( d a t a g r a m a ) ; S t r i n g m e n s a je = new S t r i n g ( a lm a c e n R e c e p c io n ) ; r e t u m m e n s a j e ; } / / f i n d e r e c i b e M e n s a j e p u b l i c M e n s a je D a ta g ra m a r e c i b e M e n s a je Y E m is o r ( ) th r o w s I O E x c e p ti o n { b y t e [ ] a lm a c e n R e c e p c io n = new b y t e [ MAX_LON ] ; D a ta g r a m P a c k e t d a ta g r a m a = new D a ta g r a m P a c k e t ( a lm a c e n R e c e p c io n , MAX_LON) ; t h i s . r e c e i v e ( d a t a g r a m a ) ; / / c r e a u n o b j e t o M e n s a je D a ta g r a m a , p a r a c o n t e n e r / / e l m e n s a je r e c i b i d o y l a d i r e c c i ó n d e l e m i s o r M e n s a je D a ta g ra m a v a l o r D e v u e l t o = new M e n s a je D a ta g r a m a ( ) ; v a l o r D e v u e l t o . f i j a V a l o r ( n e w S t r i n g ( a l m a c e n R e c e p c i o n ) , d a t a g r a m a . g e t A d d r e s s ( ) , d a t a g r a m a . g e t P o r t ( ) ) ; r e t u r n v a l o r D e v u e l t o ; > / / f i n d e r e c i b e M e n s a j e } / / f i n d e c l a s s www.FreeLibros.org 138 C om putación distribuida. Fundam entos y aplicaciones F ig u ra 5 .1 2 . M ensajeD atagram a.java. 1 i m p o r t j a v a . n e t . * ; 2 /* * 3 * U na c l a s e p a r a u t i l i z a r c o n M iS o c k e tD a ta g r a m a S e r v id o r p a r a 4 * d e v o l v e r u n m e n s a je y l a d i r e c c i ó n d e l e m i s o r 5 * G a u th o r M. L . L i u 6 * / 7 p u b l i c c l a s s M e n s a je D a ta g ra m a { 8 p r i v a t e S t r i n g m e n s a j e ; 9 p r i v a t e I n e t A d d r e s s d i r e c c i o n E m i s o r ; 10 p r i v a t e i n t p u e r t o E m i s o r ; 11 p u b l i c v o i d f i j a V a l o r ( S t r i n g m e n s a je , I n e t A d d r e s s d i r , i n t p u e r t o ) { 12 t h i s . m e n s a j e = m e n s a j e ; 13 t h i s . d i r e c c i o n E m i s o r = d i r ; 14 t h i s . p u e r t o E m i s o r = p u e r t o ; 15 } 16 17 p u b l i c S t r i n g o b t i e n e M e n s a j e ( ) { 18 r e t u r n t h i s . m e n s a j e ; 19 } 20 21 p u b l i c I n e t A d d r e s s o b t i e n e D i r e c c i o n ( ) { 22 r e t u r n t h i s . d i r e c c i o n E m i s o r ; 23 > 24 25 p u b l i c i n t o b t i e n e P u e r t o ( ) { 26 r e t u r n t h i s . p u e r t o E m i s o r ; 27 > 28 } / / f i n d e c l a s s La Figura 5.13 es un diagrama de clases UML que describe las clases utilizadas en la implementación del programa ServidorDaytime 1. Cliente-servidor D aytim e usando so cke ts en m odo stre am En la sección previa se vio cómo el servicio Daytime puede implementarse utilizan­ do e l socket datagrama sin conexión para el mecanismo de IPC. Supóngase que se quiere implementar el mismo servicio utilizando en su lugar sockets orientados a conexión. Dado que este cambio sólo afecta básicamente a la ló­ gica de servicio, sólo se necesitarían hacer modificaciones importantes en las clases en el nivel de la lógica de servicio, como se mostrará en esta sección. La lógica de aplicación, específicamente la clase auxiliar, se necesitará ajustar en consecuencia. Softw are del lado cliente L ógica d e p re s c n ta d ó n L a Figura 5.14 presenta la clase ClienteDaytime2 que es la misma que ClienteDaytimel, excepto por un cambio en el nombre de la clase auxi­ liar, ClienteDaytimeAuxiliar2. (De hecho, ClienteDaytime2 puede ser exactamente igual que C lien teD a ytim el si sim plem ente se rem plaza e l cuerpo d e la clase www.FreeLibros.org El paradigm a cliente-servidor 139 F ig u ra 5 .1 3 . B d ia g ra m a d e c la s e s U M L d e S e rv id o rD a y tim e l (no m u e stra to d o s lo s a trib u to s). ClienteDaytimeAuxiliarl por el de ClienteDaytimeAuxiliar2.) El método obtenerMar- caTiempo en ClienteDaytimeAuxiliar2 ahora utiliza el API de sockets en modo stream, pero los detalles son transparentes a ClienteDaytime2. L ógfca d e a p lic a c ió n La clase C lienteD aytim eAuxiliar2 (Figura 5.15), que encapsula la lógica de aplicación d el lad o cliente, es sim ilar a la de la clase ClienteDaytimeAuxiliarl, excepto en que se utiliza un socket en modo stream en lu ­ gar de un socket datagrama. Nótese que ya no se requiere que el cliente envíe un men­ saje nulo (que transporte la dirección de respuesta) para una petición, ya que la di­ rección de respuesta está encapsulada en la conexión). L ógica d e s e r v i d a La clase MiSocketStream (Figura 5.17) proporciona los deta­ lles del servicio de IPC, en este caso utilizando el API de sockets en modo stream. La clase MiSocketStream es una clase d e envoltura, en e l sentido de que «envuelve» a la clase Socket (eso es, contiene una variable de instancia que es una referencia a un objeto Socket) y proporciona métodos para mandar un mensaje a un socket y re­ cibir un mensaje desde éste. Softw a re del lado se rvid o r Lógica d e presentación El código de ServidorDaytime2 es idéntico al de ServidorDaytimel. L a única entrada de usuario corresponde con el puerto servidor, el cual, para simpli­ ficar, se maneja utilizando un argumento d e línea de mandato. L ógica d e ap licación El código de Servidor Doy time2 (Figura 5.16) usa el API de sockets en modo stream para aceptar una conexión. La referencia d e socket devuelta www.FreeLibros.org 1 4 0 C om putación distribuida. Fundam entos y aplicaciones (que corresponde con el socket de datos) se utiliza después para instanciar un objeto MiSocketStream, cuyo método enviaM ensaje se em plea para transmitir una marca de tiempo a l cliente en e l otro extrem o de la conexión. L ó g ic a d e s e rv ic io . La m ism a clase de en v o ltu ra u tilizad a en e l cliente, MiSocketStream (Figura 5.17), se utiliza también en el servidor, ya que contiene los métodos necesarios para la IPC en modo stream. Nótese que es posible usar una cla­ se diferente, o incluso un mecanismo distinto, para proporcionar la lógica de servicio si el software de servidor se desarrollase independientemente del software de cliente. Para insistir en el tema, el cambio para pasar a utilizar el API de sockets en modo stream, requiere sólo modificaciones significativas en los módulos que proporcionan la lógica de servicio en cada lado. F ig u ra 5 .1 4 . C lienteD aytim e2.java. 1 i r a p o r t j a v a . i o . * ; 2 3 4 /* * 5 * E s t e m ó dulo c o n t i e n e l a l ó g i c a d e p r e s e n t a c i ó n d e un C1 ie n te D a y tim e . 6 * G a u th o r M. L . L i u 7 * / 8 p u b l i c c l a s s C li e n te D a y ti m e 2 { 9 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 10 I n p u t S tr e a m R e a d e r i s = new I n p u t S tr e a m R e a d e r ( S y s te m , i n ) ; 11 B u f f e r e d R e a d e r b r = new B u f f e r e d R e a d e r ( i s ) ; 12 t r y { 13 S y s t e m . o u t . p r i n t l n ( \" B ie n v e n id o a l c l i e n t e D a y tim e .X n \" + 14 \" ¿ C u á l e s e l n a n b r e d e l a m á q u in a s e r v i d o r a ? \" ) ; 15 S t r i n g nom breM aqu i n a = b r . r e a d L i n e ( ) ; 16 i f ( n o m b re M a q u in a . l e n g t h ( ) == 0 ) / / s i e l u s u a r i o no / / i n t r o d u c e un n o m b re 17 n a n b re M a q u in a = \" l o c a l h o s t \" ; / / u s a e l n o m b re d e m á q u in a / / p o r d e f e c t o 18 S y s t e m . o u t . p r i n t l n ( \" ¿ C u á l e s e l n c p u e r t o d e l a m á q u in a s e r v i d o r a ? \" ) ; 19 S t r i n g n u m P u e rto = b r . r e a d L i n e ( ) ; 20 i f ( n u m P u e r t o . l e n g t h ( ) == 0 ) 21 n u m P u e r to = \" 1 3 \" ; / / n ú m ero d e p u e r t o p o r d e f e c t o 22 S y s t e m . c x i t . p r i n t l n ( \" M a r c a d e ti e m p o r e c i b i d a d e l s e r v i d o r \" 23 + C l i e n t e D a y t i m e A u x i l i a r 2 .o b te n e r M a r c a T ie m p o ( n o m b re M a q u in a , n u m P u e r to ) ) ; 24 } / / f i n d e t r y 25 c a t c h ( E x c e p t i o n e x ) { 26 e x . p r i n t S t a c k T r a c e ( ) ; 27 } / / f i n d e c a t c h 28 > / / f i n d e m a in 29 } / / f i n d e c l a s s www.FreeLibros.org 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 El paradigm a cliente-servidor 141 F ig u ra 5 .1 5 . C lien te D a ytim eA u xilia r2.ja va. i m p o r t j a v a . n e t . * ; /** * E s t a c l a s e e s u n m ó d u lo q u e p r o p o r c i o n a l a l ó g i c a d e a p l i c a c i ó n * p a r a un c l i e n t e D a y tim e q u e u t i l i z a u n s o c k e t e n m odo s t r e a m p a r a IP C . * § a u t h o r M. L . L i u */ p u b l i c c l a s s C l i e n t e D a y t i m e A u x i l i a r 2 { p u b l i c s t a t i c S t r i n g o b te n e r M a r c a T ie m p o ( S t r i n g n o m b re M a q u in a , S t r i n g n u m P u e r to ) th r o w s E x c e p t i o n { S t r i n g m a rc a T ie m p o = \" \" ; i n t p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( n u m P u e r t o ) ; / / i n s t a n c i a u n s o c k e t e n n o d o s t r e a m y e s p e r a a q u e s e h a g a / / u n a c o n e x ió n a l p u e r t o s e r v i d o r / * * / S y s t e m . o u t . p r i n t l n ( \" P e t i c i ó n d e c o n e x ió n r e a l i z a d a \" ) ; M i S o c k e tS tr e a m m i S o c k e t = new M iS o c k e tS tre a m ( n o m b re M a q u in a , p u e r t o S e r v i d o r ) ; / / a h o r a e s p e r a h a s t a r e c i b i r l a m a r c a d e ti e m p o m a rc a T ie m p o = m i S o c k e t . r e c i b e M e n s a j e ( ) ; m i S o c k e t . c i ó s e ( ) ; / / i m p l i c a l a d e s c o n e x i ó n r e t u m m a rc a T ie m p o ; } / / f i n } / / f i n d e c l a s s F ig u ra 5 .1 6 . ServidorD aytim e2.java. i m p o r t j a v a . i o . * ; i m p o r t j a v a . n e t . * ; i m p o r t j a v a . ú t i l . D a t e ; / / p a r a o b t e n e r u n a m a r c a d e ti e m p o /** * E s t e m ó dulo c o n t i e n e l a l ó g i c a d e a p l i c a c i ó n d e un s e r v i d o r D ay tim e * q u e u t i l i z a un s o c k e t o r i e n t a d o a c o n e x ió n p a r a IP C . * S e r e q u i e r e u n a r g u m e n to d e l í n e a d e m a n d a to p a r a e l p u e r t o d e l s e r v i d o r . * G a u th o r M. L . L i u */ p u b l i c c l a s s S e r v i d o r D a y tim e 2 { p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { i n t p u e r t o S e r v i d o r = 1 3 ; / / p u e r t o p o r d e f e c t o i f ( a r g s . l e n g t h == 1 ) p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( a r g s [ 0 ] ) ; (continúa) www.FreeLibros.org 142 C om putación distribuida. Fundam entos y aplicaciones 16 t r y { 17 / / i n s t a n c i a u n s o c k e t s t r e a m p a r a a c e p t a r 18 / / l a s c o n e x i o n e s 19 S e r v e r S o c k e t m iS o c k e tC o n e x io n = 20 new S e r v e r S o c k e t (p u e r t o S e r v i d o r ) ; 21 S y s t e m . o u t . p r i n t l n ( \" E l s e r v i d o r D a y tim e e s t á l i s t o . \" ) ; 22 w h i l e ( t r u e ) { / / b u c l e i n f i n i t o 23 / / e s p e r a p a r a a c e p t a r u n a c o n e x ió n 24 / * * / S y s t e m . o u t . p r i n t l n ( \" E s p e r a u n a c o n e x i ó n . \" ) ; 25 M iS o c k e tS tr e a m m iS o c k e tD a to s = new M i S o c k e tS tr e a m 26 (m i S o c k e tC o n e x io n . a c c e p t ( ) ) ; 27 / / N o t a : n o h a y n e c e s i d a d d e l e e r u n a p e t i c i ó n - l a 28 / / p e t i c i ó n e s i m p l í c i t a . 29 / * * / S y s t e m . o u t . p r i n t l n ( \" U n c l i e n t e h a h e c h o u n a c o n e x i ó n . \" ) ; 30 D a te m a rc a T ie m p o = new D a te ( ) ; 31 / * * / S y s t e m . o u t . p r i n t l n ( \" m a rc a d e ti e m p o e n v i a d a : \" + m a r c a T i e m p o . t o S t r i n g ( ) ) ; 32 / / a h o r a m an d a l a r e s p u e s t a a l s o l i c i t a n t e . 33 m i S o c k e t D a t o s .e n v i a M e n s a j e (m a r c a T i e m p o .t o S t r i n g ( ) ) ; 34 m i S o c k e t D a t o s . c i ó s e ( ) ; 35 } / / f i n d e w h i l e 36 > / / f i n d e t r y 37 c a t c h ( E x c e p t i o n e x ) { 38 e x . p r i n t S t a c k T r a c e ( ) ; 39 } 40 } / / f i n d e m a in 41 } / / f i n d e c l a s s F ig u ra 5 .1 7 . M iS o c k e tS tre a m .ja v a . 1 i m p o r t j a v a . n e t . * ; 2 •3 i m p o r t j a v a . i o . * ; O 4 / * * 5 * U na c l a s e d e e n v o l t u r a d e S o c k e t q u e c o n t i e n e 6 * m é to d o s p a r a m a n d a r y r e c i b i r m e n s a j e s . 7 * G a u th o r M. L . L i u 8 * / 9 p u b l i c c l a s s M i S o c k e tS tr e a m e x t e n d s S o c k e t { 10 p r i v a t e S o c k e t s o c k e t ; 11 p r i v a t e B u f f e r e d R e a d e r e n t r a d a ; 12 p r i v a t e P r i n t W r i t e r s a l i d a ; 13 14 M iS o c k e tS tr e a m ( S t r i n g m a q u i n a A c e p ta d o r a , 15 i n t p u e r t o A c e p t a d o r ) th r o w s S o c k e t E x c e p t i o n , 16 I O E x c e p tio n { 17 s o c k e t = new S o c k e t( m a q u i n a A c e p t a d o r a , p u e r t o A c e p t a d o r 18 e s t a b l e c e r F l u j o s ( ) ; ( continúa) www.FreeLibros.org El paradigm a cliente-servidor 1 4 3 19 20 } 2 1 22 M i S o c k e tS tr e a m ( S o c k e t s o c k e t ) th r o w s I O E x c e p ti o n { 23 t h i s . s o c k e t = s o c k e t ; 24 e s t a b l e c e r F l u j o s ( ) ; 25 } 26 27 p r i v a t e v o i d e s t a b l e c e r F l u j o s ( ) t h r c w s I O E x c e p ti o n { 28 / / o b t i e n e u n f l u j o d e s a l i d a p a r a l e e r d e l s o c k e t d e d a t o s 29 I n p u t S t r e a m f l u j o E n t r a d a = s o c k e t . g e t I n p u t S t r e a m ( ) ; 30 e n t r a d a = 31 new B u f f e r e d R e a d e r ( n e w I n p u t S t r e a m R e a d e r ( f l u j o E n t r a d a ) ) ; 32 O u tp u tS t r e a m f l u j o S a l i d a = s o c k e t . g e t O u t p u t S t r e a m ( ) ; 33 / / c r e a u n o b j e t o P r i n t W r i t e r p a r a s a l i d a e n modo c a r á c t e r 34 s a l i d a = 35 new P r i n t W r i t e r ( new O u t p u t S t r e a m W r i t e r ( f l u j o S a l i d a ) ) ; 36 > 37 38 p u b l i c v o i d e n v i a M e n s a j e ( S t r i n g m e n s a je ) 39 th r o w s I O E x c e p ti o n { 40 s a l i d a . p r i n t l n ( m e n s a j e ) ; 41 / / L a s u b s i g u i e n t e lla m a d a a l m é to d o f l u s h e s n e c e s a r i a p a r a 42 / / q u e l o s d a t o s s e e s c r i b a n e n e l f l u j o d e d a t o s d e l s o c k e t 43 / / a n t e s d e q u e s e c i e r r e e l s o c k e t . 44 s a l i d a . f l u s h ( ) ; 45 } / / f i n d e e n v ia M e n s a j e 46 47 p u b l i c S t r i n g r e c i b e M e n s a j e ( ) 48 th r o w s I O E x c e p ti o n { 49 / / l e e u n a l i n e a d e l f l u j o d e d a t o s 50 S t r i n g m e n s a je = e n t r a d a . r e a d L i n e ( ) ; 51 r e t u r n m e n s a j e ; 52 } / / f i n d e r e c i b e M e n s a j e 53 54 } / / f i n d e c l a s s L as Figuras 5.18 y 5.19 son los diagramas de clases UML describiendo las rela­ ciones de clases entre ClienteDaytime2 y ServidorD aytim el, respectivamente. Se acaba de presentar un servicio de red basado en el protocolo Daytime imple- mentado de dos maneras diferentes, una (* Daytime 1) utilizando un mecanismo de IPC sin conexión, la otra (Daytime*2) utilizando un mecanismo orientado a conexión. Un servidor, como ServidorD aytim el, que utiliza un mecanismo de IPC sin conexión se llam a un se rv id o r s in conrairin, mientras que uno como ServidorD aytim el se deno­ mina se rv id o r o rien ta d o a conerión. www.FreeLibros.org ClienteAuxM ar2 D aytim e M ySocketStream Socket ervia M ersa ¡e() recibeM ensaje() 1 4 4 C om putación distribuida. Fundam entos y aplicaciones L ó g i c a d e a p l i c a c i ó n L ó g i c a d e s e r v i c i o F ig u ra 5.1 8 . D iagram a d e c la s e s U M L d e O ie n te D a y tim e 2 (no s e m ue stra n to d o s lo s atrib utos). L ó g i c a d e s e r v i c i o F ig u ra 5 .1 9 . D iagram a d e c la s e s U M L d e S ervid o rD a ytim e2 (no s e m ue stra n to d o s lo s atrib utos). www.FreeLibros.org El paradigm a cliente-servidor 145 Prueba de un servicio de red Debido a su complejidad inherente, es notoriamente difícil probar el buen funciona­ miento del software de red. Incluso un servicio de red sencillo como D aytim e plan­ tea un reto para los principiantes. Seguidamente se exponen algunos consejos que pue­ den ser útiles: • Utilice la arquitectura de software de tres niveles y organice en módulos cada nivel tanto en el lado del cliente como en el del servidor. Un resguardo (stub) es un método definido con un código mínimo que permite que el programa compile y ejecute inicialmente. • Utilice mensajes de diagnóstico (similares a los incluidos en el código de ejem ­ plo presentado en este capítulo) dentro del código fuente para informar del pro­ greso del programa durante su ejecución. • Compruebe el conjunto cliente-servidor en una única máquina antes de ejecutar los programas en máquinas separadas. Los ejemplos cliente-servidor de Daytime son útiles como una introducción al desa­ rrollo de un servicio de red. La simplicidad del protocolo es tal que la sesión de ser­ vicio involucra meramente una ronda de intercambio de mensajes entre los dos pro­ cesos. A continuación, se examinará un protocolo más complejo donde la noción de una sesión de servicio es más significativa. 5 .4 . SERVIDORES ORIENTADOS A CONEXIÓN Y SIN CONEXIÓN El protocolo Echo de Internet [Postel, 2] es la base del bien conocido servicio de In­ ternet con el mismo nombre. Este protocolo permite a un cliente simplemente man­ dar líneas d e texto al servidor, de una en una, recibiendo del servidor un eco d e cada una de ellas. En la práctica, el protocolo es útil ya que puede usarse e l servidor Echo por defecto (que ejecuta en el puerto 7) de cualquier máquina en Internet como un servidor sustituto temporal cuando un ingeniero de software está desarrollando un cliente para otro protocolo. Para objetivos pedagógicos, e l protocolo es interesante por­ que puede implicar múltiples rondas de intercambio de datos entre un cliente y un servidor. Una vez más, se examinarán dos implementaciones del servicio: una que uti­ liza un servidor sin conexión y otra que usa uno orientado a conexión. Cliente-servidor Echo sin conexión • Use una estrategia gradual o paso a paso en el desarrollo de cada módulo. Co­ mience con resguardos (stubs) para cada método, y compile y pruebe cada mó­ dulo después de introducir detalles adicionales. • Desarrolle en primer lugar el cliente. A veces es útil emplear un servidor de Echo (que se presentará en la siguiente sección), cuya corrección sea y a cono­ cida y que use un mecanismo de IPC compatible, para probar e l buen funcio­ namiento del cliente independientemente del servidor. Haciéndolo de esta ma­ nera, se puede desarrollar el cliente separadamente del servidor. Las Figuras 5.20, 5.21 y 5.22 presentan una implementación del servicio Echo utili­ zando el A PI de sockets datagrama sin conexión. www.FreeLibros.org 1 4 6 C om putación distribuida. Fundam entos y aplicaciones El cliente Echo La lógica de presentación del cliente se encapsula en la clase ClienteEchol (véase la Figura 5.20), que proporciona la interfaz de usuario que solicita, en primer lugar, la información del servidor y después, utilizando un bucle, las líneas de texto que se van a mandar al servidor Echo. El envío de una cadena de texto y la recepción del eco devuelto se maneja mediante un método, obtenerEco, de la clase ClienteEchoAuxiliarl (Figura 5.21). L a clase ClienteEchoAuxiliarl (Figura 5.21) proporciona la lógica de aplicación del cliente. Se crea una instancia de esta clase por cada proceso cliente (Fi­ gura 5.20), que mantiene la dirección de la máquina servidora, así como una referen­ cia al socket utilizado por el cliente de IPC. El método obtenerEco utiliza el socket para mandar una línea al servidor y después recibir una línea de éste. Finalmente, el método cióse cierra e l socket. El servidor E cho Servidor Echo 1.java (Figura 5.22) combina la lógica de presentación y la lógica de aplicación para el servidor. En cada iteración de un bucle infinito, el servidor lee una línea del socket y después escribe la línea de vuelta a l socket, dirigiendo la respues­ ta al emisor. Dado que no hay ninguna conexión involucrada, es posible que el ser­ vidor interaccione con diferentes clientes en iteraciones sucesivas, resultando sesiones de servicio concurrentes intercaladas. La Figura 5.23 ilustra un escenario en e l que dos clientes concurrentes de esta implementación, A y B, intercalan sus interacciones con una instancia de Servidor Echo 1. F ig u ra 5.2 0 . C lie n te E c h o l .java. 1 i m p o r t j a v a . i o . * ; 2 3 /* * 4 * E s t e m ó d u lo c o n t i e n e l a l ó g i c a d e p r e s e n t a c i ó n d e u n c l i e n t e E c h o . 5 * G a u th o r M. L . L i u 6 */ 7 p u b l i c c l a s s C l i e n t e E c h o l { 8 s t a t i c f i n a l S t r i n g m e n s a j e F i n = \" . \" ; 9 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 10 I n p u t S tr e a m R e a d e r i s = new I n p u t S tr e a m R e a d e r ( S y s te m , i n ) ; 11 B u f f e r e d R e a d e r b r = new B u f f e r e d R e a d e r ( i s ) ; 12 t r y { 13 S y s t e m . o u t . p r i n t l n ( \" B i e n v e n i d o a l c l i e n t e E c h o .\\ n \" + 14 \" ¿ C u á l e s e l n o ir b re d e l a m á q u in a s e r v i d o r a ? \" ) ; 15 S t r i n g n o m b re M a q u in a = b r . r e a d L i n e ( ) ; 16 i f ( n o m b re M a q u in a . l e n g t h ( ) = = 0 ) / / s i e l u s u a r i o no / / i n t r o d u j o u n n o m b re 17 n o n b re M a q u in a = \" l o c a l h o s t \" ; / / u s a e l n o m b re d e m á q u in a / / p o r d e f e c t o 18 S y s t e m . o u t . p r i n t l n ( \" I n t r o d u z c a e l nQ p u e r t o d e l a m á q u in a s e r v i d o r a . \" ) ; 19 S t r i n g n u m P u e rto = b r . r e a d L i n e ( ) ; 20 i f ( n u m P u e r t o . l e n g t h ( ) == 0 ) ( continúa) www.FreeLibros.org 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 2 0 El paradigm a cliente-servidor 147 n u m P u e r to = \" 7 \" ; / / n ú m ero d e p u e r t o p o r d e f e c t o C l i e n t e E c h o A u x i l i a r l a u x i l i a r = new C l i e n t e E c h o A u x i l i a r l ( n o m b r e M a q u i n a , n u m P u e r to ) ; b o o l e a n h e c h o = f a l s e ; S t r i n g m e n s a j e , e c o ; w h i l e ( ! h e c h o ) { S y s t e m . o u t . p r i n t l n ( \" I n t r o d u z c a u n a l i n e a p a r a r e c i b i r e l eco\" + \" e c o d e l s e r v i d o r , o u n ú n ic o p u n to p a r a t e r m i n a r . \" ) ; m e n s a je = b r . r e a d L i n e ( ) ; i f ( ( m e n s a j e . t r i m ( ) ) . e q u a l s ( m e n s a j e F i n ) ){ h e c h o = t r u e ; a u x i l i a r . h e c h o ( ) ; > e l s e { e c o = a u x i l i a r . o b t e n e r E c o ( m e n s a j e ) ; S y s te m , o u t . p r i n t l n ( e c o ) ; > } / / f i n d e w h i l e } / / f i n d e t r y c a t c h ( E x c e p t i o n e x ) { e x . p r i n t S t a c k T r a c e ( ) ; > } / / f i n d e m a in } / / f i n d e c l a s s F ig u ra 5 .2 1 . C lienteE choA uxiliarl .java. i m p o r t j a v a . n e t . * ; i m p o r t j a v a . i o . * ; /** * E s t a c l a s e e s u n m ó d u lo q u e p r o p o r c i o n a l a l ó g i c a d e a p l i c a c i ó n * p a r a un c l i e n t e E ch o u t i l i z a n d o u n s o c k e t d a ta g r a m a s i n c o n e x ió n . * @ a u th o r M. L . L i u */ p u b l i c c l a s s C l i e n t e E c h o A u x i l i a r l { p r i v a t e M i S o c k e tD a ta g r a m a C li e n te m i S o c k e t ; p r i v a t e I n e t A d d r e s s m a q u i n a S e r v i d o r a ; p r i v a t e i n t p u e r t o S e r v i d o r ; C l i e n t e E c h o A u x i l i a r l ( S t r i n g n a n b r e M a q u in a , S t r i n g n u m P u e r to ) th r o w s S o c k e t E x c e p t i o n , U n k n o w n H o s tE x c e p tio n { t h i s . m a q u i n a S e r v i d o r a = I n e t A d d r e s s . g etB yN am e( n o n fc re M a q u in a ) ; t h i s . p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( n u m P u e r t o ) ; / / i n s t a n c i a u n s o c k e t d a ta g r a m a p a r a m a n d a r / / y r e c i b i r d a t o s t h i s . m i S o c k e t = new M i S o c k e tD a ta g r a m a C li e n te ( ) ; (continúa) www.FreeLibros.org 1 4 8 C om putación distribuida. Fundam entos y aplicaciones 2 1 > 22 23 24 25 26 27 28 29 30 p u b l i c S t r i n g o b t e n e r E c o ( S t r i n g m e n s a j e ) m iS o c k e t.e n v ia M e n s a je ( m a q u in a S e r v id o r a , p u e r t o S e r v i d o r , m e n s a je ) ; / / a h o r a r e c i b e e l e c o e c o = m i S o c k e t . r e c i b e M e n s a j e ( ) ; r e t u r n e c o ; t h r o w s S o c k e t E x c e p t i o n , I O E x c e p ti o n { S t r i n g e c o = \"\" ; } / / f i n d e o b t e n e r E c o 31 32 p u b l i c v o i d h e c h o ( ) th r o w s S o c k e t E x c e p t i o n { 33 m i S o c k e t . c i ó s e ( ) ; 34 } / / f i n d e h e c h o 35 36 } / / f i n d e c l a s s 33 F ig u ra 5.2 2 . S ervid o rE ch o l.ja va . 1 i m p o r t j a v a . i o . * ; 2 3 4 /* * 5 * E s t e m ó d u lo c o n t i e n e l a l ó g i c a d e a p l i c a c i ó n d e u n s e r v i d o r E c h o 6 * q u e u t i l i z a un s o c k e t d a ta g r a m a s i n c o n e x ió n p a r a l a c a m m i c a c i ó n 7 * e n t r e p r o c e s o s . 8 * S e r e q u i e r e u n a rg u m e n to d e l i n e a d e m a n d a to p a r a e l p u e r t o d e l s e r v i d o r . 9 * 0 a u t h o r M. L . L i u 10 * / 11 p u b l i c c l a s s S e r v i d o r E c h o l { 12 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 13 i n t p u e r t o S e r v i d o r = 7 ; / / n ú m ero d e p u e r t o p o r d e f e c t o 14 i f ( a r g s . l e n g t h == 1 ) 15 p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( a r g s [ 0 ] ) ; 16 t r y { 17 / / i n s t a n c i a u n s o c k e t d a ta g r a m a p a r a m a n d a r 18 / / y r e c i b i r d a t o s 19 M i S o c k e tD a ta g r a m a S e r v id o r m i S o c k e t = 20 new M i S o c k e tD a ta g r a m a S e r v id o r ( p u e r t o S e r v i d o r ) ; 21 S y s t e m . c x i t . p r i n t l n ( \" S e r v i d o r E c h o l i s t o . \" ) ; 22 w h i l e ( t r u e ) { / / b u c l e i n f i n i t o 23 M e n s a je D a ta g ra m a p e t i c i ó n = m iS o c k e t.r e c ib e M e n s a je Y E m is o r ( ) ; 24 S y s t e m . < x i t . p r i n t l n ( \" P e t i c i ó n r e c i b i d a \" ) ; 25 S t r i n g m e n s a je = p e t i c i ó n . o b t i e n e M e n s a j e ( ) ; 26 S y s t e m . o u t . p r i n t l n ( \" m e n s a je r e c i b i d o : \"+ m e n s a j e ) ; 27 / / A h o ra m anda e l e c o a l s o l i c i t a d o r 28 m i S o c k e t .e n v i a M e n s a j e ( p e t i c i ó n . o b t i e n e D i r e c c i o n ( ) , ( continúa) www.FreeLibros.org El paradigm a cliente-servidor 149 29 p e t i c i o n . o b t i e n e P u e r t o ( ) , m e n s a j e ) ; 30 > / / f i n d e w h i l e 31 } / / f i n d e t r y 32 c a t c h ( E x c e p t i o n e x ) { 33 e x . p r i n t S t a c k T r a c e ( ) ; 34 } 35 > / / f i n d e m a in 36 > / / f i n d e c l a s s Cliente-servidor E cho orientado a conexión Las Figuras 5.24, 5.25 y 5.26 presentan una imple mentación de un cliente y un ser­ vidor del servicio Echo utilizando el API d e sockets en modo stream. De nuevo, la implementación de la lógica de presentación (en ClienteEcho2 y ServidorEcho2) es igual que *Echol. Sin embargo, la lógica de aplicación (en ClienteEchoAuxiliar2 y ServidorEcho2), así como la lógica de servicio (en MiSocketStream) son diferentes (ya que se utiliza un socket en modo stream en lugar de un socket datagram a). Nótese que en ClienteEchoAuxiliar2 la conexión a l servidor se realiza en el cons­ tructor, mientras que el método obtenerEco proporciona cada ronda de intercambio de mensajes. S e utiliza un método, hecho, para transmitir el mensaje d e fin de sesión (uno que contiene sólo un punto) al servidor antes de que se cierre el socket del lado cliente. S e rv id o rE c h o l C lle n te E c h o l A C lie n te E c h o l B m e n s a je e co m ensaje e co m ensaje e co m e nsaje eco m e nsaje eco F ig u ra 5 .2 3 . Un diagrama de secuencia que ilustra d o s sesiones intercaladas con S e r v id o r E c h o l. www.FreeLibros.org 150 C om putación distribuida. Fundam entos y aplicaciones En ServidorEcho2, se crea en primer lugar un socket de conexión para aceptar las conexiones. Por cada conexión aceptada, el servidor recibe continuamente un mensa­ je y hace eco del mismo por el socket de datos asociado a la conexión, hasta que se recibe el mensaje de fin de sesión. Al final de la sesión, se cierra el socket de datos del cliente actual y se termina la conexión. El servidor entonces espera hasta aceptar otra conexión. A lo largo d e una sesión, el servidor mantiene su conexión con el cliente e inter­ cambia datos con el mismo usando un socket de datos dedicado a ese cliente. Si otro cliente se conecta con el servidor mientras éste está todavía ocupado con una sesión, el cliente no será capaz de intercambiar datos con e l servidor hasta que el servidor haya completado la sesión actual. La Figura 5.27 muestra el diagrama de secuencia de dos sesiones cuando el cliente 2 intenta conectar con el servidor mientras que se le está sirviendo al cliente 1. Nótese que no hay intercalado de sesiones en este caso. 1 i n p o r t j a v a . i o . * ; 2 4 /* * 5 * E s t e m ó d u lo c o n t i e n e l a l ó g i c a d e p r e s e n t a c i ó n d e u n c l i e n t e E c h o . 6 * G a u th o r M. L . L i u 7 * / 8 p u b l i c c l a s s C l i e n t e E c h o 2 { 9 s t a t i c f i n a l S t r i n g m e n s a j e F i n = 11. \" ; 9 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 10 I n p u t S tr e a m R e a d e r i s = new I n p u t S t r e a m R e a d e r ( S y s t e m .i n ) ; 11 B u f f e r e d R e a d e r b r = new B u f f e r e d R e a d e r ( i s ) ; 12 t r y { 13 S y s t e m . o u t . p r i n t l n ( \" B ie n v e n id o a l c l i e n t e E c h o A n 11 + 14 \" ¿ C u á l e s e l n a n b r e d e l a m á q u in a s e r v i d o r a ? \" ) ; 15 S t r i n g n o m b reM aq u in a = b r . r e a d L i n e ( ) ; 16 i f ( n o m b re M a q u in a . l e n g t h ( ) == 0 ) / / s i e l u s u a r i o no F ig u ra 5 .2 4 . Q ie n teE ch o 2 .ja va . / / i n t r o d u j o un n o m b re 17 n a n b re M a q u in a = \" l o c a l h o s t \" ; / / u t i l i z a n a n b r e d e m á q u in a / / p o r d e f e c t o 19 20 2 1 22 23 24 25 26 27 28 29 30 31 18 S y s t e m . o u t . p r i n t l n ( \" ¿ C u á l e s e l no p u e r t o d e l a m á q u in a s e r v i d o r a ? \" ) ; S t r i n g n u m P u e rto = b r . r e a d L i n e ( ) ; i f ( n u m P u e r to . l e n g t h ( ) == 0) n u m P u e r to = \" 7 \" ; / / n ú m ero d e p u e r t o p o r d e f e c t o C l i e n t e E c h o A u x i l i a r 2 a u x i l i a r = new C l i e n t e E c h o A u x i l i a r 2 (n o m b re M a q u in a , n u m P u e r to ) ; b o o l e a n h e c h o = f a l s e ; S t r i n g m e n s a j e , e c o ; w h i l e ( ! h e c h o ) { S y s t e m .o u t .p r i n t l n ( \" I n t r o d u z c a u n a l í n e a p a r a r e c i b i r e l e c o \" + \" d e l s e r v i d o r , o u n ú n i c o p u n t o p a r a t e r m i n a r . \" ) ; m e n s a je = b r . r e a d L i n e ( ) ; i f ( ( m e n s a j e . t r i m ( ) ) . e q u a l s (\".\" )) { www.FreeLibros.org 32 33 34 35 36 37 38 39 40 41 42 43 44 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 2 1 22 23 24 25 26 27 28 29 30 31 El paradigm a cliente-servidor 151 a u x i l i a r . h e c h o ( ) ; > e l s e { e c o = a u x i l i a r . o b t e n e r E c o ( m e n s a j e ) ; S y s te m , o u t . p r i n t l n ( e c o ) ; > } / / f i n d e w h i l e } / / f i n d e t r y c a t c h ( E x c e p t i o n e x ) { e x . p r i n t S t a c k T r a c e ( ) ; } / / f i n d e c a t c h } / / f i n d e m a in } / / f i n d e c l a s s F ig u ra 5 .2 5 . O ienteE choA uxiliar2.java. i m p o r t j a v a . n e t . * ; i m p o r t j a v a . i o . * ? /** * E s t a c l a s e e s u n m ó d u lo q u e p r o p o r c i o n a l a l ó g i c a d e a p l i c a c i ó n * p a r a un c l i e n t e E c h o u t i l i z a n d o u n s o c k e t e n modo s t r e a m . * § a u t h o r M. L . L i u */ p u b l i c c l a s s C l i e n t e E c h o A u x i l i a r 2 { s t a t i c f i n a l S t r i n g m e n s a j e F i n = \" . \" ; p r i v a t e M i s o c k e t s t r e a m m i S o c k e t; p r i v a t e I n e t A d d r e s s m a q u i n a S e r v i d o r a ; p r i v a t e i n t p u e r t o S e r v i d o r ; C l i e n t e E c h o A u x i l i a r 2 ( S t r i n g n o m b re M a q u in a , S t r i n g n u m P u e r to ) th r o w s S o c k e t E x c e p t i o n , U n k n o w n H o s tE x c e p tio n , I O E x c e p tio n { t h i s . m a q u i n a S e r v i d o r a = I n e t A d d r e s s . g etB yN am e( n a n b r e M a q u in a ) ; t h i s . p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( n u m P u e r t o ) ; / / i n s t a n c i a un s o c k e t e n modo s t r e a m y e s p e r a p o r u n a / / c o n e x i ó n . t h i s . m i S o c k e t = new M i s o c k e ts tr e a m ( n o n b r e M a q u in a , t h i s . p u e r t o S e r v i d o r ) ; / * * / S y s t e m . o u t . p r i n t l n ( \" P e t i c i ó n d e c o n e x ió n h e c h a \" ) ; } / / f i n d e c o n s t r u c t o r p u b l i c S t r i n g o b t e n e r E c o ( S t r i n g m e n s a je ) t h r c w s S o c k e t E x c e p t i o n , I O E x c e p ti o n { S t r i n g e c o = \" \" ; (continúa) www.FreeLibros.org 152 C om putación distribuida. Fundam entos y aplicaciones 32 m i S o c k e t .e n v i a M e n s a j e ( m e n s a j e ) ; 33 / / a h o r a r e c i b e e l e c o 34 e c o = m i S o c k e t . r e c i b e M e n s a j e ( ) ; 35 r e t u r n e c o ; 36 > / / f i n d e o b t e n e r E c o 37 38 p u b l i c v o i d h e c h o ( ) th r o w s S o c k e t E x c e p t i o n , 39 I O E x c e p ti o n { 40 m i S o c k e t .e n v i a M e n s a j e (m e n s a j e F i n ) ; 41 m i S o c k e t . c i ó s e ( ) ; 42 } / / f i n d e h e c h o 43 } / / f i n d e c l a s s 39 F ig u ra 5 2 6 . ServidorE cho2.java. 1 i m p o r t j a v a . i o . * ; 2 i n p o r t j a v a . n e t . * ; 3 4 /* * 5 * E s t e m ó d u lo c o n t i e n e l a l ó g i c a d e a p l i c a c i ó n d e u n s e r v i d o r E c h o 6 * q u e u t i l i z a un s o c k e t e n modo s t r e a m p a r a c o m u n ic a rs e e n t r e p r o c e s o s . 7 * S e r e q u i e r e u n a rg u m e n to d e l i n e a d e m a n d a to p a r a e l p u e r t o d e l s e r v i d o r . 8 * G a u th o r M. L . L i u 9 * / 10 p u b l i c c l a s s S e r v i d o r E c h o 2 { 11 s t a t i c f i n a l S t r i n g m e n s a j e F i n = \" . \" ; 12 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 13 i n t p u e r t o S e r v i d o r = 7 ; / / p u e r t o p o r d e f e c t o 14 S t r i n g m e n s a j e ; 15 16 19 20 2 1 22 23 24 25 26 27 28 29 30 31 32 / * * / S y s t e m . o u t . p r i n t l n ( \" c o n e x i ó n a c e p t a d a \" ) ; b o o l e a n h e c h o = f a l s e ; / * * / S y s t e m . o u t . p r i n t l n ( \" E s p e r a u n a c o n e x i ó n . \" ) ; M i S o c k e tS tr e a m m iS o c k e tD a to s = new M i S o c k e tS tr e a m / ** / S y s te m . o u t . p r i n t l n ( \" S e r v i d o r E c h o l i s t o . \" ) ; t r y { / / i n s t a n c i a u n s o c k e t s t r e a m p a r a a c e p t a r / / l a s c o n e x i o n e s i f ( a r g s . l e n g t h == 1 ) p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( a r g s [ 0 ] ) ; w h i l e ( t r u e ) { / / b u c l e i n f i n i t o / / e s p e r a p a r a a c e p t a r u n a c o n e x ió n S e r v e r S o c k e t m iS o c k e tC o n e x io n = new S e r v e r S o c k e t ( p u e r t o S e r v i d o r ) ; (m i S o c k e tC o n e x io n . a c c e p t ( ) ) ; ( continúa) www.FreeLibros.org 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 51 El paradigm a cliente-servidor 1 5 3 w h i l e ( ! h e c h o ) { m e n s a je = m i S o c k e t D a t o s .r e c i b e M e n s a j e ( ) ; / * * / S y s t e m . o u t . p r i n t l n ( \" m e n s a j e r e c i b i d a : \"+ m e n s a j e ) ; i f ( (m e n s a j e . t r i m ( ) ) . e q u a l s ( m e n s a j e F i n ) ){ / / l a s e s i ó n s e t e r m i n a , c i e r r a e l s o c k e t d e d a t o s . / * * / S y s t e m . o u t . p r i n t l n ( \" F i n a l d e l a s e s i ó n . 1' ) ; m i S o c k e tD a to s . c i ó s e ( ) ; h e c h o = t r u e ; } / / f i n d e i f e l s e { / / A h o ra m an d a e l e c o a l s o l i c i t a n t e m i S o c k e t D a t o s .e n v i a M e n s a j e ( m e n s a j e ) ; } / / f i n d e e l s e } / / f i n d e w h i l e ! h e c h o > / / f i n d e w h i l e i n f i n i t o > / / f i n d e t r y c a t c h ( E x c e p t i o n e x ) { e x . p r i n t S t a c k T r a c e ( ) ; } / / f i n d e c a t c h } / / f i n d e m a in > / / f i n d e c l a s s S e rv id o rE c h o 2 C lie n te 1 C lie n te 2 m en saje e co m ensaje e co m ensaje e co m ensaje eco m ensaje eco F ig u ra 5 .2 7 . S e rvid o rE ch o 2 no p e rm itirá se sio n e s in te rcalada s. www.FreeLibros.org 154 C om putación distribuida. Fundam entos y aplicaciones Como s e examinó en el Capítulo 1, en un sistem a con un único procesador, la ejecución concurrente se lleva a cabo compartiendo el tiempo (time-sharing) del procesador y, por tanto, la concurrencia no es real. 5 .5 . S E R V ID O R ITER A TIVO Y S E R V ID O R C O N C U R R EN TE Como e l lector habrá podido apreciar, con un servidor orientado a conexión tal como ServidorDaytime2 y ServidorEcho2, no hay solapam iento de sesiones de cliente, ya que e l servidor se lim ita a intercambiar datos con un cliente cuya conexión ha acep­ tado (pero no ha desconectado). A este tipo de servidor se le denom ina servidor iterativa, y a que sirve a un cliente cada vez. Cuando se solicita un servicio a un servidor iterativo popular, un cliente se bloqueará hasta que se sirvan todos los clien­ tes precedentes. El resultado puede ser un tiem po de bloqueo significativo si las se­ siones de servicio son largas, tal com o en e l caso de un protocolo de transferencia de ficheros. Supóngase que cada sesión puede durar t unidades de tiempo, y que en un tiem po dado, ti clientes han pedido conexiones. Obviando otros retrasos en aras de la simplicidad, el próximo cliente que solicita conexión puede contar con que es­ tará bloqueado durante al m enos n* t unidades d e tiempo. S i t es largo, e l retraso será inaceptable. La solución a este problema es introducir concurrencia en el servidor, dando lu­ gar a un servidor concurrente Un servidor concurrente es capaz de gestionar múl­ tiples sesiones de cliente en paralelo. Para proporcionar un servidor concurrente, se pueden utilizar hilos o, alternativamente, operaciones de IPC asincronas. (La progra­ mación concurrente con hilos se trató en el Capítulo 1, y las operaciones de IPC asin­ cronas en el Capítulo 2). La utilización de hilos es la técnica convencional y tiene la virtud de ser relativamente sencilla. Sin embargo, los requisitos de escala y de rendi­ miento de las aplicaciones actuales han hecho necesaria, en algunos casos, la utiliza­ ción de una IPC asincrona. En esta presentación se tratará la técnica de utilizar hilos para construir un servi­ dor concurrente. De manera similar a los servidores iterativos, un servidor concurrente utiliza un único socket de conexión para escuchar las conexiones. Sin embargo, un servidor concurrente crea un nuevo hilo para aceptar cada conexión y dirigir una se­ sión de servicio con el cliente conectado; de manera que el hilo term ina cuando con­ cluye la sesión. Las Figuras 5.28 y 5.29 presentan el servidor concurrente y la clase que define el hilo que utiliza, respectivamente. El método run de la clase que define e l hilo lleva a cabo la lógica de una sesión de cliente. Nótese que no se necesita ningún cambio en el código del lado del cliente: puede utilizarse ClienteEcho2 para acceder a Servi­ dor Echo 3 sin ningún cambio. La Figura 5.30 muestra el diagrama de secuencia de dos sesiones concurrentes. Se estima d e interés que e l lector compare este diagrama de secuencia con los dos pre­ sentados anteriormente (Figuras 5.23 y 5.27). Con un servidor concurrente, un clien­ te no tendrá que esperar mucho tiempo hasta que se acepte su conexión; el único re­ traso que e l cliente experimentará será el resultante de su propia sesión d e servicio. Figura 5.28. ServidorEcho3.java. 1 i n p o r t j a v a . i o . * ; 2 i n p o r t j a v a . n e t . * ; 3 4 5 / * * ( continúa) www.FreeLibros.org 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 1 2 3 4 5 El paradigm a cliente-servidor 155 * E s t e m ó d u lo c o n t i e n e l a l ó g i c a d e a p l i c a c i ó n d e u n s e r v i d o r E ch o * q u e u t i l i z a un s o c k e t e n modo s tr e a m p a r a c a n u n ic a c ió n e n t r e p r o c e s o s . * A d i f e r e n c i a d e S e r v i d o r E c h o 2 , l o s c l i e n t e s s e s i r v e n c o n c u r r e n t e m e n t e . * S e r e q u i e r e un a r g u m e n to d e l i n e a d e m a n d a to p a r a e l p u e r t o d e l s e r v i d o r . * G a u th o r M. L . L i u */ p u b l i c c l a s s S e r v i d o r E c h o 3 { p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { i n t p u e r t o S e r v i d o r = 7 ? / / P u e r t o p o r d e f e c t o S t r i n g m e n s a j e ; i f ( a r g s . l e n g t h == 1 ) p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( a r g s [ 0 ] ) ; t r y { / / i n s t a n c i a u n s o c k e t s t r e a m p a r a a c e p t a r / / l a s c o n e x io n e s S e r v e r S o c k e t m iS o c k e tC o n e x io n = new S e r v e r S o c k e t ( p u e r t o S e r v i d o r ) ; / * * / S y s t e m . o u t . p r i n t l n ( \" S e r v i d o r E c h o l i s t o . \" ) ; w h i l e ( t r u e ) { / / b u c l e i n f i n i t o / / e s p e r a p a r a a c e p t a r u n a c o n e x ió n / * * / S y s t e m . o u t . p r i n t l n ( \" E s p e r a u n a c o n e x i ó n . \" ) ; M i s o c k e t s t r e a m m i S o c k e tD a to s = new M i s o c k e t s t r e a m (m i S o c k e tC o n e x io n . a c c e p t ( ) ) ; / * * / S y s te m . o u t . p r i n t l n ( \" c o n e x ió n a c e p t a d a \" ) ; / / A r r a n c a u n h i l o p a r a m a n e j a r l a s e s i ó n d e c l i e n t e T h r e a d e l H i l o = new T h re a d (n e w H i l o S e r v i d o r E c h o ( m i S o c k e t D a t o s ) ) ; e l H i l o . s t a r t ( ) ; / / y c o n t i n ú a c o n e l s i g u i e n t e c l i e n t e > / / f i n d e w h i l e i n f i n i t o > / / f i n d e t r y c a t c h ( E x c e p t i o n e x ) { e x . p r i n t S t a c k T r a c e ( ) ; } / / f i n d e c a t c h } / / f i n d e m a in } / / f i n d e c l a s s F ig u ra 5 .2 9 . H iloServidorE cho.java. i m p o r t j a v a . i o . * ; /** * E s t e m ó d u lo e s t á d i s e ñ a d o p a r a u s a r s e c o n u n s e r v i d o r E ch o c o n c u r r e n t e . * S u m é to d o r u n l l e v a a c a b o l a l ó g i c a d e u n a s e s i ó n d e c l i e n t e . (continúa) www.FreeLibros.org 156 C om putación distribuida. Fundam entos y aplicaciones 6 * G a u th o r M. L . L i u 7 * / 8 c l a s s H ilo S e r v id o r E c h o im p le m e n ts R u n n a b le { 9 s t a t i c f i n a l S t r i n g m e n s a j e F i n = 10 M iS o c k e tS tr e a m m i S o c k e tD a to s ; 11 12 H ilo S e r v id o r E c h o ( M iS o c k e tS tr e a m m i S o c k e tD a to s ) { 13 t h i s . m iS o c k e tD a to s = m i S o c k e tD a to s ; 14 } / / f i n d e c o n s t r u c t o r 15 16 p u b l i c v o i d r u n ( ) { 17 b o o l e a n h e c h o = f a l s e ; 18 S t r i n g m e n s a j e ; 19 t r y { 20 w h i l e ( ! h e c h o ) { 21 m e n s a je = m i S o c k e tD a to s . r e c i b e M e n s a j e ( ) ; 22 / * * / S y s t e m . o u t . p r i n t l n ( \" m e n s a je r e c i b i d o : \"+ m e n s a j e ) ; 23 i f ( ( m e n s a j e . t r i m ( ) ) . e q u a l s ( m e n s a j e F i n ) ){ 24 / / s e t e r m i n a l a s e s i ó n ; c i e r r a e l s o c k e t d e d a t o s 25 / * * / S y s t e m . o u t . p r i n t l n ( \" F i n a l d e l a s e s i ó n . \" ) ; 26 m i S o c k e t D a t o s . c i ó s e ( ) ; 27 h e c h o = t r u e ; 28 } / / f i n d e i f 29 e l s e { 30 / / A h o ra m an d a e l e c o a l s o l i c i t a n t e 31 m i S o c k e t D a t o s .e n v i a M e n s a j e ( m e n s a j e ) ; 32 } / / f i n d e e l s e 33 } / / f i n d e w h i l e ! h e c h o 34 } / / f i n d e t r y 35 c a t c h ( E x c e p t i o n e x ) { 36 Sy s t e m . o u t . p r i n t l n ( \" E x c e p c ió n c a p t u r a d a e n h i l o : \" + e x ) ; 37 } / / f i n d e c a t c h 38 } / / f i n d e r u n 39 } / / f i n d e c l a s s Los servidores concurrentes son los que se usan normalmente en los servicios de red modernos. Aunque los servidores iterativos son sólo aceptables para los protoco­ los más simples, el estudio de servidores de este tipo es todavía una buena experien­ cia pedagógica. 5 .6 . S E R V ID O R E S C O N ESTADO Tanto e l protocolo Daytime como e l Echo pertenecen a una categoría de protocolos conocida como protocolos sin estado, en contraste con los protocolos con estado. Un protocolo es sin estado cuando no necesita mantener ninguna información de es­ tado en el servidor. Tal es e l caso del protocolo Daytime, donde el servidor simple­ mente envía a cada cliente una marca de tiem po obtenida del sistema, así como del protocolo Echo, que sólo requiere que el servidor haga eco de cada mensaje que re- www.FreeLibros.org El paradigm a cliente-servidor 157 Serv¡dor£cho3 Q ienteE cho 1 C lienteE cho2 cibe. En ambos protocolos, la tarea realizada por e l servidor es independiente de su estado, de aspectos tales como, por ejemplo, cuánto tiempo lleva en servicio e l ser­ vidor o qué cliente está siendo servido. Un servidor sin estado es aquel que proporciona un servicio siguiendo un proto­ colo sin estado y por tanto no tiene que mantener ninguna información de estado, como en el caso del servidor Daytime o del servidor Echo. Un serv id o r c o n estado; como su nombre implica, es uno que debe mantener alguna información de estado para proporcionar su servicio. ¿Qué significa exactamente información de estado? Hay dos tipos: información de estado global e información de estado d e sesión. Inform ación de estado global El servidor mantiene este tipo de información para todos los clientes durante la vida del servidor. Por ejemplo, supóngase un protocolo, cuyo nombre sea contador (no se trata de un protocolo estándar de Internet), que requiere que un servidor mantenga un contador, iniciado a 0. Cada vez que un cliente contacta con el servidor, éste incre­ menta el contador en 1 y envía el valor actual del contador al cliente. Para propor­ cionar este servicio, el servidor debe tener el valor del contador situado en algún tipo de alm acenamiento de donde se pueda recuperar y actualizar durante la ejecución del servicio. Para un contador sencillo, el almacenamiento puede implementarse utilizan­ do una variable de un tipo de datos primitivo de Java. Para una información de esta­ do más compleja, e l almacenamiento puede implementarse utilizando un fichero, una base de datos u otros mecanismos. La Figura 5.31 muestra e l código de un servidor que implementa el protocolo contador. Nótese que se utiliza una variable estática para www.FreeLibros.org 1 5 8 C om putación distribuida. Fundam entos y aplicaciones mantener e l contador cuya actualización se sincroniza para asegurar exclusión mutua. Las Figuras 5.32 y 5.33 muestran el programa cliente. F ig u ra 5.3 1. S ervid o rC o n ta d o rl.ja va . 1 i m p o r t j a v a . i o . * ; 2 3 /* * 4 * E s t e m ó d u lo c o n t i e n e l a l ó g i c a d e a p l i c a c i ó n d e u n s e r v i d o r C b n ta d o r 5 * q u e u t i l i z a u n s o c k e t d a ta g r a m a p a r a l a c o m u n ic a c ió n e n t r e p r o c e s o s . 6 * S e r e q u i e r e u n a rg u m e n to d e l i n e a d e m a n d a to p a r a e l p u e r t o d e l s e r v i d o r . 7 * G a u th o r M. L . L i u 8 */ 9 p u b l i c c l a s s S e r v i d o r C o n t a d o r l { 10 11 /* i n f o r m a c i ó n d e e s t a d o * / 12 s t a t i c i n t c o n t a d o r = 0 ; 13 14 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 15 i n t p u e r t o S e r v i d o r = 1 2 3 4 5 ? / / p u e r t o p o r d e f e c t o 16 i f ( a r g s . l e n g t h == 1 ) 17 p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( a r g s [ 0 ] ) ? 18 t r y { 19 / / i n s t a n c i a u n s o c k e t d a ta g r a m a p a r a e n v i a r 20 / / y r e c i b i r 21 M iS o c k e tD a ta g r a m a S e r v id o r m i S o c k e t = 22 new M i S o c k e t D a t a g r a m a S e r v i d o r ( p u e r t o S e r v i d o r ) ; 23 / * * / S y s te m . o u t . p r i n t l n ( \" S e r v i d o r C o n ta d o r l i s t o . \" ) ; 24 w h i l e ( t r u e ) { / / b u c l e i n f i n i t o 25 M e n s a je D a ta g ra m a p e t i c i ó n = 26 m i S o c k e t. r e c ib e M e n s a je Y E m is o r ( ) ; 27 S y s t e m . o u t . p r i n t l n ( \" P e t i c i ó n r e c i b i d a \" ) ? 28 / / n o e s i m p o r t a n t e e l m e n s a je r e c i b i d o ; e s l a d i r e c c i ó n 29 / / d e l e m i s o r l o q u e s e n e c e s i t a p a r a r e s p o n d e r . 30 / / I n c r e m e n ta e l c o n t a d o r , d e s p u é s m anda s u v a l o r a l c l i e n t e 31 i n c r e m e n t o ( ) ; 32 / * * / S y s t e m . o u t . p r i n t l n ( \" c o n t a d o r e n v i a d o \"+ c o n t a d o r ) ; 33 / / A h o ra m anda l a r e s p u e s t a a l s o l i c i t a n t e 34 m i S o c k e t. e n v ia M e n s a j e ( p e t i c i ó n . o b t i e n e D i r e c c i o n ( ) , 35 p e t i c i ó n . o b t i e n e P u e r t o ( ) , S t r i n g . v a l u e O f ( c o n t a d o r ) ) ; 36 > / / f i n d e w h i l e 37 } / / f i n d e t r y 38 c a t c h ( E x c e p t i o n e x ) { 39 e x . p r i n t S t a c k T r a c e ( ) ; 40 } / / f i n d e c a t c h 41 > / / f i n d e m a in 42 (continúa) www.FreeLibros.org 43 44 45 46 47 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 2 1 22 23 24 25 26 27 28 29 1 2 El paradigm a cliente-servidor 159 s t a t i c p r i v a t e s y n c h r o n i z e d v o i d i n c r e m e n t o ( ) { c o n t a d o r + + ; > > / / f i n d e c l a s s F ig u ra 5.3 2 . C lie n teC o n ta d o rl.ja va . i m p o r t j a v a . i o . * ; /** * E s t e m ó d u lo c o n t i e n e l a l ó g i c a d e p r e s e n t a c i ó n d e u n c l i e n t e C o n t a d o r . * @ a u th o r M. L . L i u */ p u b l i c c l a s s C l i e n t e C o n t a d o r l { p u b l i c s t a t i c v o i d m a in ( S t r i n g [ ] a r g s ) { I n p u t S tr e a m R e a d e r i s = new I n p u t S t r e a m R e a d e r ( S y s t e m . i n ) ; B u f f e r e d R e a d e r b r = new B u f f e r e d R e a d e r ( i s ) ; t r y { S y s t e m . o u t . p r i n t l n ( \" B i e n v e n i d o a l c l i e n t e C o n t a d o r . \\ n \" + \" ¿ C u á l e s e l n o m b re d e l a m á q u in a s e r v i d o r a ? \" ) ? S t r i n g n o m b re M a q u in a = b r . r e a d L i n e ( ) ; i f ( n o n b re M a q u in a . l e n g t h ( ) == 0 ) / / s i e l u s u a r i o no / / i n t r o d u j o u n n o m b re n o m b re M a q u in a = \" l o c a l h o s t \" ; / / u t i l i z a n o m b re d e m á q u in a / / p o r d e f e c t o S y s te m , o u t . p r i n t l n ( \" ¿ C u á l e s e l n c d e p u e r t o d e l a m á q u in a s e r v i d o r a ? \" ) ; S t r i n g n u m P u e r to = b r . r e a d L i n e ( ) ; i f ( n u m P u e r to . l e n g t h ( ) == 0) n u m P u e r to = \" 1 2 3 4 5 \" ; / / n ú m e ro d e p u e r t o p o r d e f e c t o S y s t e m . o u t . p r i n t l n ( \" C b n ta d o r r e c i b i d o d e l s e r v i d o r : \" + C l i e n t e C o n t a d o r A u x i l i a r 1 . o b t e n e r C o n t a d o r ( n o m b re M a q u in a , r u m P u e r t o ) ) ; > / / f i n d e t r y c a t c h ( E x c e p t i o n e x ) { e x . p r i n t S t a c k T r a c e ( ) ; > } / / f i n d e m a in } / / f i n d e c l a s s F ig u ra 5 .3 3 . C lie n te C o n ta d o r A u x ilia n .java. i m p o r t j a v a . n e t . * ; (continúa) www.FreeLibros.org 1 6 0 C om putación distribuida. Fundam entos y aplicaciones 3 4 /* * 5 * E s t a c l a s e e s u n m ó d u lo q u e p r o p o r c i o n a l a l ó g i c a d e a p l i c a c i ó n 6 * p a r a u n c l i e n t e C o n t a d o r . 7 * 0 a u t h o r M. L . L i u 8 */ 9 p u b l i c c l a s s C l i e n t e C o n t a d o r A u x i l i a r 1 { 10 11 p u b l i c s t a t i c i n t o b t e n e r C o n t a d o r ( S t r i n g n o n b r e M a q u in a , 12 S t r i n g n u m P u e r to ) 13 { 14 i n t c o n t a d o r = 0 ; 15 S t r i n g m e n s a je = ; 16 t r y { 17 I n e t A d d r e s s m a q u i n a S e r v i d o r a = 18 I n e t A d d r e s s . g etB yN am e( n o n b re M a q u in a ) ; 19 i n t p u e r t o S e r v i d o r = I n t e g e r . p a r s e l n t ( n u m P u e r to ) ; 20 / / i n s t a n c i a u n s o c k e t d a ta g r a m a p a r a e n v i a r 21 / / y r e c i b i r d a t o s . 22 M i S o c k e tD a ta g r a m a C li e n te m i S o c k e t = new M i S o c k e tD a ta g r a m a C li e n te ( ) ; 23 m i S o c k e t. e n v ia M e n s a j e ( m a q u i n a S e r v i d o r a , p u e r t o S e r v i d o r , 11\" ) ; 24 / / a h o r a r e c i b e e l v a l o r d e l c o n t a d o r 25 m e n s a je = m i S o c k e t . r e c i b e M e n s a j e ( ) ; 26 / * * / S y s t e m . c u t . p r i n t l n ( \" M e n s a j e r e c i b i d o : 11 + m e n s a j e ) ; 27 c o n t a d o r = I n t e g e r . p a r s e l n t ( m e n s a j e . t r i m ( ) ) ; 28 m i S o c k e t . c i ó s e ( ) ; 29 } / / f i n d e t r y 30 c a t c h ( E x c e p t i o n e x ) { 31 e x . p r i n t S t a c k T r a c e ( ) ; 32 } / / f i n d e c a t c h 33 r e t u r n c o n t a d o r ; 34 } / / f i n d e m a in 35 } / / f i n d e c l a s s Inform ación de estado de sesión Algunos protocolos o aplicaciones, tienen la necesidad de mantener información es­ pecífica para una sesión de cliente. Considérese un servicio de red tal como ftp . Un fichero es típicamente transferi­ do en bloques, requiriéndose varias rondas d e intercambios de datos para completar la transferencia del fichero. La información de estado de cada sesión incluye: 1. El nombre del fichero con el que se está trabajando. 2. El número del bloque actual. 3. La acción (traer, llevar, etc.) que se está realizando sobre el fichero. Hay al menos dos esquemas para mantener los datos de estado de sesión. www.FreeLibros.org El paradigm a cliente-servidor Servidor sin estada En este esquema, e l cliente puede mantener la información de estado de sesión de manera que cada petición contenga la información de estado de sesión, permitiendo al servidor procesar cada petición de acuerdo con los datos de estado enviados en la petición. El diálogo d e una sesión se llevará a cabo aproxima­ damente de la siguiente forma: Cliente: Por favor, envíem e el bloque 0 del fichero arch del directorio dir. Servidor: Vale. Aquí tiene ese bloque del fichero. Cliente: Por favor, envíem e el bloque 1 del fichero arch del directorio dir. Servidor: Vale. Aquí tiene ese bloque del fichero. Cliente: Por favor, envíem e el bloque n del fichero arch del directorio dir. Servidor: Vale. Aquí tiene ese bloque del fichero. Al requerir que el cliente mantenga los datos de sesión, este esquema permite al servidor procesar cada petición d e la misma manera, y por eso reduce la complejidad de la lógica de aplicación. A tal tipo de servidor se le conoce como servidor sin e s­ tado. Servidor con estado. En el segundo esquema, el servidor debe mantener la in­ formación del estado de la sesión, en cuyo caso el diálogo de una sesión se llevará a cabo aproximadamente de la siguiente forma: Cliente: Por favor, envíem e el fichero arch del directorio dir. Servidor: Vale. Aquí tiene el bloque 0 del fichero arch. Cliente: Lo tengo. Servidor: Vale. Aquí tiene el bloque 1 del fichero arch. Cliente: Lo tengo. Servidor: Vale. Aquí tiene el bloque n del fichero arch. Cliente: Lo tengo. Con este esquema, el servidor controla el progreso de la sesión manteniendo e l es­ tado de la misma. A este tipo de servidor se le conoce como un servidor con esta­ d o La Figura 5.34 ilustra la diferencia entre un servidor con estado y uno sin estado. Los servidores con estado son más complejos de diseñar e implementar. Además de la lógica requerida para mantener los datos del estado, se debe prever la necesi­ dad d e salvaguardar la información de estado en el caso de que se interrumpa una se­ sión. S i la máquina donde ejecuta un servidor con estado falla temporalmente en me­ dio de una sesión, es importante que la sesión interrumpida se reanude en el estado correcto. En caso contrario, es posible que, en el ejemplo planteado, el cliente reciba un bloque erróneo del fichero después de que la sesión se recupere del fallo. Otro ejemplo de protocolo con estado corresponde con una aplicación del tipo «cesta de la compra». Cada sesión debe mantener los datos de estado que hacen el seguimiento de la identidad del comprador y de los contenidos acumulados en su ces­ ta de compras. En la implementación real, un servidor puede ser sin estado, con estado, o híbri­ do. En este último caso, los datos de estado pueden distribuirse entre el servidor y el cliente. El tipo de servidor que se utiliza es una cuestión de diseño. www.FreeLibros.org 162 C om putación distribuida. Fundam entos y aplicaciones S e rv id o r s in e s ta d o S e rv id o r FTP C lie n te FTP ID d e a rch ivo p o sició n d e a rch ivo O b te n e r n o m b r e d e a rc h iv o ID d e a rch ivo m a n d a < ID d e arch > , b lo q u e 0 d a to s d e l b lo q u e 0 d e a rch ivo m a n d a < ID d e arch > , b lo q u e 1 d a to s d e l b lo q u e 1 d e l a rch ivo S e rv id o r FTP C lie n te FTP S e rv id o r c o n e s ta d o ID arch p o s ic ió n arch O b te n e r n o m b r e d e a rc h iv o listo m a n d a el s ig u ie n te b lo q u e d a to s d e l b lo q u e 0 d e l a rch ivo m a n d a el s ig u ie n te b lo q u e d a to s d e l b lo q u e 1 d e l a rch ivo F ig u ra 5.3 4. La d ife re n cia e n tre un s e rv id o r sin e s ta d o y o tro c o n e s ta d o . La S o c ie d a d d e In te rn e t C o m u n ic a d o d e prensa (extracto). La «Estrella Polar» q u e d e fin ió In te rn e t. Fteim preso c o n el p e rm is o d e la s o c ie d a d d e In te rn e t (h ttp ://w w w .is o c .o rg /in te rn e t/). R eston, VA, 19 d e o c tu b re d e 1998. La c o ­ m u n id a d d e In te rn e t llora la p é rd id a d e un Id e r y d e l p rim e r m ie m b ro p a rtic u la r d e la S o c ie d a d d e Internet. Jo n a th a n B. PosteI fa lle c ió e l v ie rn e s 16 d e o c tu b re . D urante tre in ta a ñ o s, P o ste l s irv ió a to d o s lo s u s u a ­ rios d e In te rn e t en un a v a rie d a d d e p a p e ­ les fu n d a m e n ta le s, a u n q u e p o c o s fu e ra de la c o m u n id a d té c n ic a c o n o c e n s u nom bre. M u c h o a n te s d e q u e a p a re cie ra n lib ro s s o ­ bre In te rn e t, había s ó lo una s e rie d e d o c u ­ m e n to s té c n ic o s c o n o c id o s c o m o P e tició n de c o m e n ta rio s o R FC (R e q u e s t fo r C o m - m e n ts). J o n e d itó y o rg a n iz ó e s te m a te ria l qu e a y u d ó a e s ta b le c e r lo s p rim e ro s e s ­ tá n d a re s d e Internet. «Jon ha s id o n u e stra estrella p o la r d u ­ rante d é ca d a s, ilu m in a n d o b rilla n te e in c e ­ san tem en te , p ro p o rc io n a n d o c o n fo rt y un s e n tid o d e s e g u rid a d m ie ntras to d o lo d e ­ m á s e sta b a cam b ia ndo », d ijo V in t C erf, el p re sid e n te a c tu a l d e l c o m ité d e la S o cie d a d d e Internet. «Él fu e el B o s w e ll d e In te rn e t y s u c o n c ie n c ia técn ica. S u p é rd id a s e rá p ro ­ fu n d a m e n te sentida, n o só lo p o r su c a p a c i­ d a d , s in o po rq u e la c o m u n id a d ha p e rd id o un q u e rid o y m u y a p re c ia d o am igo». P ostel c o m e n z ó s u ca rre ra e n la re d en 1969 m ie n tra s se g ra d u a b a e n U C L A tr a ­ b a ja n d o e n el a c tu a lm e n te fa m o s o p ro y e c ­ t o A R PAN ET (p re cu rso r d e Intern et) c o m o un a y u d a n te in v e s tig a d o r d e l p ro fe s o r L e o - nard K le in ro c k qu ie n d ijo : «Las c o n trib u c io ­ nes fu n d a m e n ta le s d e J o n e n n u e s tro tr a ­ b a jo d u ra n te a q u e llo s c rític o s p rim e ro s d ía s d e A R P A N E T to d a v ía n o s o n s u fic ie n te ­ m e n te re c o n o c id a s . M ie n tra s e s tá b a m o s a b rie n d o n u e v o s h o riz o n te s c o n e l n a c i­ www.FreeLibros.org El paradigm a cliente-servidor 1 6 3 m ie n to d e In te rn e t e n 19 69 , re c u e rd o a J o n c o m o un jo v e n p ro g ra m a d o r d e n u e s tro e q u ip o , b rilla n te y p ro fu n d a m e n te d e d ic a ­ d o . En a q u e lla é p o c a había fro n te ra s y J o n era ve rd a d e ra m e n te un p io n e ro c o n v is ió n d e fu tu ro . En e s o s d ía s se c o n v irtió e n el e d ito r d e la serie P e tic ió n d e co m e n ta rio s , q u e a ú n c o n tin ú a en la a c tu a lid a d . La d e ­ d ic a c ió n d e J o n a l c re c im ie n to y al b ie n e s­ t a r d e In te rn e t c o n tin u ó d e s d e a q u e llo s tie m p o s e m b ria g a d o re s d u ra n te e l re s to d e s u v id a . Y p o r to d o e s to , é l n o b u s c a b a ni re c o n o c im ie n to ni a lab anza . La m u e rte d e J o n e s un a trá g ic a p é rd id a , q u e será s e n ­ tid a p o r to d o s a q u e llo s c u y a s v id a s tie n e n q u e v e r c o n In te rn e t, p e ro e s p e c ia lm e n te p o r a q u e llo s d e n o s o tro s q u e re c o rrim o s el c a m in o c o n e ste h o m b re g e n til y tra n q u ilo d u ra n te m u c h o s , m u c h o s años». D urante m u c h o tie m p o , P o ste l fu e la A u ­ to rid a d d e N ú m e ro s A s ig n a d o s d e In te rn e t (IANA, In tern et A s s ig n e d N u m b e r s A u th o - rity) q u e sup ervisa la rese rva y a s ig n a c ió n d e lo s n o m b re s d e d o m in io y d ire c c io n e s d e In te rn e t. F inalm ente, la ta re a c re c ió ta n ­ t o q u e h u b o qu e fo rm a r un p e q u e ñ o e q u i­ p o d e p e rso n a s pa ra a y u d a r en e ste tra b a ­ jo . S u te m p r a n o r e c o n o c im ie n to d e la im p o rta n c ia d e la d o c u m e n ta c ió n c u id a d o ­ sa pa re ce v e rd a d e ra m e n te cla riv id e n te c o n la re tro sp e ctiva d e h o y e n día . Todo e l tra ­ ba jo té c n ic o e n ARPAN ET y m á s ta rd e en Internet, a sí c o m o la teo ría y la p rá c tic a re ­ q u e rid a p o r la a d m in is tra c ió n d e n o m b re s y d ire c c io n e s , e s re co g id a a m p lia m e n te en la a c tu a lid a d p o r lo s h is to ria d o re s d e b id o a la d e d ic a c ió n d e Jo n . En la é p o c a e n qu e la re d e ra s ó lo un e x p e rim e n to e s tu v o p le ­ na m e n te c o m p ro m e tid o e n p ro p o rc io n a r un re fu g io se g u ro y a s a lv o para la in fo rm a c ió n q u e ha ce p o s ib le q u e fu n c io n e Internet. Él fu e d ire c ta m e n te re s p o n s a b le d e la g e s tió n d e l n o m b re d e d o m in io .US. A d e ­ m ás, s irv ió c o m o un m ie m b ro d e l c o m ité d e A rq u ite c tu ra d e In te rn e t (Internet A rch i- te c tu re B oard) d e s d e s u c re a c ió n e n 1983, c o n t in u a n d o h a s ta e l p r e s e n te . P o s te l d e s e m p e ñ ó m u c h o s o tro s p a p e le s in c lu ­ y e n d o e l s e r p a rte fu n d a m e n ta l e n la fu n ­ d a c ió n d e la S o c ie d a d d e In te rn e t. T am bién fu n d ó lo s s e rv ic io s d e re d L o s N e tto s e n el área d e L o s Angeles. P o ste l o fre c ió a lg o q u e d ifíc ilm e n te se pu e d e e n c o n tra re n c u a lq u ie r m o m e n to : c o ­ la b o ra ció n c o n tin u a , c o m p e te n te y d is c re ­ ta. C o n s id e ró s u s re s p o n s a b ilid a d e s c o m o una e s p e c ie d e re s p o n s a b ilid a d p ú b lic a . N u nca re c ib ió n ing ún b e n e fic io p e rson al d e l gran n e g o c io d e In te rn e t, p re firie n d o p e r­ m a n e ce r fu e ra d e l fre n e s í d e l n e g o c io , de la s O fe rta s P ú b lic a s In ic ia le s (IPO, Initlal P ublic O fferin g s) y d e to d a la pa ra fe m a lia de W all S tree t. S te p h e n D. Crocker, a m ig o y c o m p a ñ e ­ ro d e u n ive rsid a d d e P o ste l, lid e ró el d e s a ­ rro llo d e lo s p ro to c o lo s d e ARPAN ET e n tre m á q uinas fin a le s. C ro c k e r c o m e n z ó la s e ­ rie R FC y J o n in sta n tá n e a m e n te se o fre c ió vo lu n ta ria m e n te a e d ita rla s. «Lo im p e n sa b le ha s u c e d id o . T odos h e m o s p e rd id o a un gran a m ig o y a un p ila r p rin c ip a l d e a p o y o y c o rd u r a e n n u e s tro m u n d o p e c u lia r y surre alista », d ijo C rocker. «Para a q u e llo s de n o so tro s in vo lu c ra d o s en la re d h u m a n a de in ge nie ros q u e dise ñ a n y d e sa rro lla n In te r­ net, fu e un a persona fu n d a m e n ta l q u e h izo qu e la re d s ig u ie ra fu n c io n a n d o . T ra b a jó in ­ ca n sa b le y d e sin te re sa d a m e n te . Él sie m p re esta ba allí». «No p u e d o c re e r qu e haya fa lle c id o , Jon era un h é roe para m í y para m u c h o s o tro s en In te rn e t. Fue un g ra n m e d ia d o r: sie m p re so n rie n d o y p re p a ra d o pa ra c o n s id e ra r una nueva idea, sin n in g ú n plan p a rtic u la r e x ­ c e p to p ro m o v e r la s g ra n d e za s d e In te rn e t a lre d e d o r d e l m un do », d ijo J e a n A m o u r Polly, a n te rio r m ie m b ro d ire c tiv o (tru stee) de la S o c ie d a d d e In te rn e t. M ie n tr a s t r a b a ja b a e n A R P A N E T en U C LA , P o ste l s ig u ió un p ro g ra m a d e in ­ ve s tig a c ió n d e d o c to ra d o b a jo la d ire c c ió n de lo s p ro fe so re s D a v id F a b e r d e U C Irvi- ne y G e ra ld E strin d e UCLA. El p ro fe s o r F a­ b e r recu erd a: «Jon e ra m i s e g u n d o e s tu ­ d ia n te d e d o c to ra d o . Y o fu i el p rin c ip a l co n se je ro d e s u te s is ju n to c o n J e rry Estrin y re cu e rd o c o n c a riñ o lo s m ese s q u e tra ­ b a ja m o s h o m b r o c o n h o m b ro c o n J o n m ie n tra s s u im p a cie n te m e n te d e s a rro lla b a las id e a s en la s q u e s e ba só su te s is p io ­ nera q u e fu n d ó el á re a d e la v e rific a c ió n de p ro to co lo s. D a d o q u e y o e s ta b a e n U C Ir- vine y J o n e n U C L A s o lía m o s q u e d a r p o r la m añ an a, a n te s d e m i p a se o h a sta UCI, en una cre p e ría e n S a n ta M ó n ic a para d e ­ sa yu n a r y tra b a ja r d u ro d e s a rro lla n d o la t e ­ sis. Y o a d q u irí un g ra n re s p e to p o r Jo n , adem ás d e 10 lib ra s d e peso». www.FreeLibros.org 1 6 4 C om putación distribuida. Fundam entos y aplicaciones Je rry E strin recuerda a J o n P o ste l c o m o un se r h u m a n o sin e g o ís m o , g e n til y m a ra ­ v illo sa m e n te e n c a n ta d o r q u e s e p re o c u p a ­ ba re a lm e n te d e la g e n te y s u s c o n trib u ­ c io n e s p e rs o n a le s . «En lo s 70, n o tu v o m ie d o d e a p lic a r un m o d e lo d e g ra to s n o ­ v e d o s o para v e rific a r lo s p ro to c o lo s c o m ­ p le jo s d e ARPANET. N u nca o lv id a ré a Jon d m g ié n d o se a m í d u ra n te un s e m in a rio de g ra d u a c ió n y p re g u n tá n d o m e a m a b le m e n te si podía a b s te n e rm e d e fu m a r e n p ip a d u ­ rante la cla se. M o s tra b a la m is m a p re o c u ­ pa ció n c o n re s p e c to a lo s e fe c to s tó x ic o s d e l ta b a c o c o m o sob re e l p o te n c ia l im p a c ­ to p o s itiv o d e la s red es d e co m p u ta d o re s» . P ostel tra b a jó en m u c h o s p u e s to s d u ­ rante s u la rg o c o n ta c to c o n In te rn e t. T ra­ bajó c o n la le yen da in d u s tria l D oug E n g e l- ba rt en SRI In te rn a cio n a l e n M e n lo Park, CA, d o n d e p ro p o rc io n ó un im p o rta n te s o ­ p o rte a l o N L in e S yste m , e n m u c h o s a s ­ p e c to s un p re d e c e s o r d e la W o rld W id e V\\feb, in c lu y e n d o la c a ra c te rís tic a d e l h ip e r­ en la ce q u e a to d o s resu lta ta n fa m ilia r en la a c t u a lid a d . S e t r a s la d ó a l á re a d e W a sh in g to n para d a r a p o y o a la A g e n c ia de P r o y e c to s d e I n v e s tig a c ió n A v a n z a d a (A R P A , A d v a n c e d R e s e a r c h P r o j e c t s A g e n c y ) d u ra n te un tie m p o y d e sp u é s, fu e a l Inform ation S c ie n c e s In s titu te de U S C d o n d e se c o n v irtió e n un a e stre lla p e rm a ­ ne nte en e l p a ra íso d e In te rn e t, s irv ie n d o d e g u ía a to d o s lo s ¡n te m a u ta s c u a n d o e x ­ p lora ban e l e x te n s o o c é a n o e n e l q u e se ha c o n v e rtid o In te rn e t. P ostel fu e e le g id o pa ra el c o m ité d ire c ­ tiv o d e la S o c ie d a d d e In te rn e t e n 1 9 9 3 y re e le g id o para un s e g u n d o p e rio d o d e tre s a ñ o s en 19 96 . En lo s d o s ú ltim o s a ñ o s, tr a ­ b a jó sin d e s c a n s o a y u d a n d o a fa c ilita r la m ig ra ció n ta n to d e l IANA, fin a n c ia d o p o r el g o b ie rn o e sta d o u n id e n se , c o m o d e l s is te ­ m a g e n e ra l d e g e s tió n d e n o m b re s d e d o ­ m in io a un a e m p re sa in te rn a c io n a l d e l s e c ­ t o r p riva d o s in á n im o d e lu c ro . P o c o a n te s d e su fa lle c im ie n to , se c re ó la C o rp o ra c ió n d e In te rn e t pa ra N o m b re s y N ú m e ro s A s ig ­ n a d o s (ICANN , In te rn e t C orporation fo r A s - s i g n e d Ñ a m e s a n d N u m b e r s), q u e se ha p ro p u e s to c o m o su c e s o ra d e l sis te m a f i ­ n a n c ia d o p o r e l g o b ie rn o e s ta d o u n id e n s e q u e ha d a d o s e rv ic io d u ra n te c e rc a d e 30 a ñ o s a la c o m u n id a d d e In te rn e t. En e l s itio w e b d e la S o c ie d a d d e In te r­ n e t (ISOC) se pu ed en e n c o n tra r tr ib u to s a J o n P o ste l d e g e n te q u e le c o n o c ía , y a sea p e rs o n a lm e n te o a tra v é s d e s u tra b a jo , h ttp ://w w w . i s o c . o rg /p o s te I. e m n m Este capítulo ha presentado el paradigma cliente-servidor d e computación distribuida. Los tem as tratados incluyen: • La diferencia entre la arquitectura de sistema cliente-servidor y el paradigma de computación distribuida cliente-servidor. • Una definición del paradigma y una explicación de por qué motivo se ha utili­ zado ampliamente en los servicios y aplicaciones d e red. • Los tem as de sesiones de servicio, protocolos, localización de servicios, comu­ nicaciones entre procesos, representación de datos y sincronización de eventos en el contexto del paradigma cliente-servidor. • La arquitectura d e software de tres niveles d e las aplicaciones cliente-servidor: lógica d e presentación, lógica d e aplicación y lógica de servicios. • Servidor sin conexión frente a servidor orientado a conexión. • Servidor iterativo frente a servidor concurrente y el efecto que tiene sobre una sesión de cliente. • Servidor con estado frente a sin estado. www.FreeLibros.org El paradigm a cliente-servidor 165 • En el caso de un servidor con estado, la información de estado global frente a la información de estado de sesión. PH\" HHl ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ 1. En el contexto de la computación distribuida, describa e l paradigma cliente- servidor. ¿Por qué es especialmente apropiado este paradigma para los servi­ cios de red? 2. Describa la arquitectura de software de tres niveles para el software cliente- servidor. Explique brevemente las funcionalidades de cada nivel en cada lado. ¿Por qué es ventajoso encapsular la lógica de distintos niveles en módulos de software separados? 3. Este ejercicio trata con ServidorD aytim el y ClienteDaytimel, que usan sockets datagrama sin conexión. Durante este conjunto d e ejercicios, es suficiente con que ejecute los procesos cliente y servidor en una sola máquina y especifique el nombre de la máquina como localhost. a. ¿Por qué es necesario que el servidor use el método recibeMensajeYEmi- sor para aceptar las peticiones de cliente en vez del método recibeMensajé? b. Compile *Daytimel.java («javac * Doy time 1.java.»). Después ejecute los programas: i. Comenzando en primer lugar por el cliente y, a continuación, el servi­ dor (no olvide especificar un número de puerto como argumento de lí­ nea de mandato). ¿Qué sucede? Descríbalo y explíquelo. ii. Comenzando en primer lugar por e l servidor (no olvide especificar un número de puerto como argumento de línea de mandato y a continua­ ción, el cliente. ¿Qué sucede? Descríbalo y explíquelo. c. Modifique la constante M A X J O N en MiSocketDatagramaCliente.java para que valga 10. Vuelva a compilar y ejecute de nuevo los programas, co­ menzando primero por el servidor. Observe el mensaje recibido por el clien­ te. Describa y explique la salida. d. Restaure el valor original de MAX_LON. Vuelva a compilar y a ejecutar los programas, comenzado primero por el servidor. Arranque otro cliente, pre­ feriblemente en una máquina diferente. Describa y explique la salida. Di­ buje un diagrama de tiempo-eventos que describa la secuencia de eventos de las interacciones entre e l servidor y los dos clientes. 4. Este ejercicio incluye ServidorD aytim e2 y C lienteD aytim e2, que utilizan sockets stream. a. Describa con sus propias palabras la diferencia entre este conjunto de cla­ ses y las clases d e *DaytimeI. b. Compile *Daytime2.java (javac *Daytime2.java). Después ejecute los pro­ gramas: i. Comenzando primero por el cliente y a continuación, e l servidor (no olvide especificar un número de puerto como un argumento d e línea de mandato). ¿Qué sucede? Descríbalo y explíquelo. www.FreeLibros.org 166 C om putación distribuida. Fundam entos y aplicaciones ii. Comenzando primero por el servidor (no olvide especificar un núme­ ro de puerto como argumento de línea de mandato) y a continuación, e l cliente. ¿Qué sucede? Descríbalo y explíquelo. c. Para experimentar con el efecto de una conexión, añada un retraso (utili­ zando Thread.sleep(3000) en ServidorDaytime2.java después de aceptar una conexión y antes de obtener una marca de tiempo del sistema). Añadir el retraso tiene el efecto de aumentar artificialmente 3 segundos la duración d e cada sesión de servicio. Recompile y arranque el servidor, después arran­ que dos clientes en dos pantallas separadas de su sistema. ¿Cuánto tiempo tardó e l segundo cliente en hacer una conexión con el servidor? Descríba­ lo y explíquelo, teniendo en cuenta que el servidor es iterativo. 5. Asumiendo que la implementación es correcta, el lector debería ser capaz de utilizar cualquiera de los dos programas ClienteDaytime d e los ejemplos pre­ sentados (Figuras 5.6 y 5.14, respectivamente) para obtener una marca de tiem ­ po de cualquier máquina de Internet que proporcione e l servicio Daytime es­ tándar en e l puerto 13 de TCP/UDP. Trate de hacerlo con una m áquina conocida, utilizando tanto ClienteDaytime 1 como ClienteDaytime2. Tenga en cuenta que en algunos sistemas se rechazará el acceso al servicio Daytime en el puerto 13 por razones de seguridad. Describa e l experimento y la salida ge­ nerada, teniendo en cuenta que la mayoría de los servidores se implementaron hace tiempo utilizando el lenguaje C. 6 . Este ejercicio utiliza ServidorEchol y C lienteEchol, que utilizan sockets da­ tagrama para el servicio Echo. Compile * Echo 1.java (javac *Echol.java) y a continuación, realice las si­ guientes operaciones: a Ejecute los programas comenzando por el servidor (no olvide especificar el número de puerto como argumento de línea de mandato) y a continuación, el cliente. Realice una sesión y observe los mensajes de diagnóstico visualizados en ambos lados. Describa sus observaciones sobre la secuencia de eventos. b. Con el servidor en ejecución, arranque dos clientes en ventanas separadas. ¿Se pueden realizar las sesiones de los dos clientes en paralelo? Describa y explique sus observaciones. ¿Están d e acuerdo con el diagrama de se­ cuencia de la Figura 5.23? c. Puede sorprenderse de lo que sucede cuando un cliente manda datos a un servidor sin conexión que ya está ocupado sirviendo a otro cliente. Reali­ ce el siguiente experimento: añada un retraso de 1 0 segundos ( 1 0 . 0 0 0 mi- lisegundos) en el servidor antes de que se envíe el eco. A continuación, re­ pita el apartado b. Describa y explique sus observaciones. ¿El servidor recibe el dato del segundo cliente? 7. Este ejercicio trata con ServidorEcho2 y ClienteEcho2. Recuerde que Servi­ dorE chol es un servidor orientado a conexión e iterativo. Compile *Echo2java (javac *Echo2.java) y a continuación, realice las si­ guientes operaciones: a. Ejecute los programas comenzando por el servidor (no olvide especificar el número de puerto como argumento de línea de mandato) y a continuación, el cliente. Realice una sesión y observe los mensajes de diagnóstico visua­ lizados en ambos lados. Escriba sus observaciones sobre la secuencia de eventos. www.FreeLibros.org El paradigm a cliente-servidor 167 b. Con el servidor en ejecución, arranque dos clientes en ventanas separadas. ¿Se pueden realizar las dos sesiones en paralelo? Describa y explique sus obser­ vaciones. ¿Están de acuerdo con el diagrama de secuencia de la Figura 5.27? 8 . Este ejercicio trata con Servidor Echo 3. Recuerde que Servidor Echo3 es un ser­ vidor orientado a conexión y concurrente. Compile *Echo3.java y a continua­ ción, realice las siguientes operaciones: a. Ejecute los programas comenzando por el servidor ServidorEcho3 (no ol­ vide especificar el número de puerto como argumento de línea de manda­ to) y a continuación, el cliente ClienteEcho2. Realice una sesión y observe los mensajes de diagnóstico visualizados en ambos lados. Describa sus ob­ servaciones sobre la secuencia de eventos. b. Con el servidor en ejecución, arranque dos clientes en ventanas separadas. ¿Se pueden realizar las dos sesiones de cliente en paralelo? Describa y ex­ plique sus observaciones. ¿Están de acuerdo con e l diagrama de secuencia de la Figura 5.30? 9. Con sus propias palabras, describa las diferencias, desde el punto de vista del cliente, entre un servidor iterativo y un servidor concurrente para un servicio, tal como Echo , que involucre múltiples rondas de intercambio de mensajes. La descripción debería tratar aspectos tales como (i) la lógica del software (re­ cuerde la arquitectura de tres niveles) y (ii) e l rendimiento en tiempo de eje­ cución (en términos del retraso o dem ora experimentado por e l cliente). 10. Este ejercicio trata con servidores con estado que mantienen información de estado global. a. Compile ServidorContadorl .java y ClienteContadorl .java («javac* Conta­ d or 7.java»). Ejecute el servidor y a continuación, varias veces un cliente. ¿Se incrementa el contador con cada cliente? b. Modifique ServidorContadorl .java y ClienteContadorl.java de manera que el contador se incremente en 2 por cada cliente. Vuelva a ejecutar el clien­ te y el servidor y compruebe la salida resultante. c. Proporcione el código de un servidor orientado a conexión y un cliente para el protocolo contador. 11. Utilizando la arquitectura de software de tres niveles presentada en este capí­ tulo, diseñe e implemente un conjunto cliente-servidor para e l protocolo si­ guiente (no se trata d e un servicio conocido): cada cliente envía un nombre al servidor. El servidor acumula los nombres recibidos por sucesivos clientes (aña­ diendo cada uno, terminado con un carácter d e nueva línea, '\\n \\ a una cade­ na estática de caracteres). Al recibir un nombre, e l servidor envía los nombres que ha recogido al cliente. El cliente, a continuación, visualiza todos los nom­ bres que recibe del servidor. La Figura 5.35 ilustra e l diagrama d e secuencia del protocolo con tres sesiones de cliente concurrentes. a. ¿Se trata de un servidor con estado? Si es así, ¿qué tipo de información de estado mantiene (global o de sesión)? b. Cree una o más versiones del protocolo: i. Cliente y servidor sin conexión. ii. Cliente y servidor orientado a conexión e iterativo. iii. Cliente y servidor orientado a conexión y concurrente. www.FreeLibros.org 168 C om putación distribuida. Fundam entos y aplicaciones Por cada versión, debe entregar: (A) los listados d e los programas y (B) una descripción de cómo se realiza la arquitectura de tres niveles utilizan­ do módulos de software separados (las clases Java). S e rv id o r d e n o m b re s C lie n t e l C lie n te 2 C lie n te 3 M a rc o M a rc o A n a M a rc o \\n A n a Juan M arco\\nA na\\nJuan F ig u ra 5 .3 5 . Un diagram a de secuencia del p rotocolo que muestra tre s sesiones de cliente concurrentes. 12. Considere el siguiente protocolo, que se llamará protocolo CuentaAtrás. Cada cliente contacta con el servidor mediante un mensaje inicial que especifica un valor entero n. El cliente, a continuación, realiza un bucle para recibir n men­ sajes del servidor, tal que los mensajes contienen los valores n, n-1, n-2, 1 sucesivamente. a. ¿Se trata de un servidor con estado? Si es así, ¿qué tipo de información de estado mantiene (global o de sesión)? b. Cree una o más versiones del protocolo: i. Cliente y servidor sin conexión. ii. Cliente y servidor orientado a conexión e iterativo. iii. Cliente y servidor orientado a conexión y concurrente. Por cada versión, debe entregar: (A) los listados d e los programas y (B) una descripción de cómo se realiza la arquitectura de tres niveles utilizan­ do módulos de software separados (las clases Java). 13. Considere un servicio de red de las siguiente características: un cliente solici­ ta que el usuario introduzca mediante el teclado un entero n y lo envía al ser­ vidor. A continuación, recibe del servidor una cadena d e caracteres que con­ tiene el valor n+1. a. Escriba una especificación independiente d e la implementación para este protocolo, con la descripción de ( 1) la secuencia de eventos (utilizando un diagrama de secuencias) y la (2 ) representación de datos. b. Proporcione el código de las tres siguientes versiones del conjunto cliente- servidor: — Sin conexión (utilizando paquetes datagrama). www.FreeLibros.org El paradigm a cliente-servidor 1 6 9 — Orientado a conexión (utilizando sockets stream) y servidor iterativo. — Orientado a conexión (utilizando sockets stream) y servidor concurrente. 11111111 n i 1. Jon Postel, El protocolo DayTune, RFC 867, http://www.ief.org/rfcIrfc0867.txt?nunber=867 2. Jon Postel, El protocolo Echo, RFC 862, http://www.ietf\\org!rfdrfc0862.txt?number=862 www.FreeLibros.orgwww.FreeLibros.org CAPITULO C o m u n ic a c ió n d e g r u p o En los capítulos previos, se ha presentado la com unicación entre procesos (IPC, Interprocess C om m unication) com o el intercam bio de inform ación entre dos procesos. En este capítulo, se exam inará la IPC entre un grupo de procesos, o com unicación de grupo. 6 .1 . U N ID IF U S IÓ N FR E N TE A M U LTID IFU S IÓ N En la IPC que se ha presentado hasta ahora, los datos se mandan desde un proceso de origen, el emisor, a un proceso de destino, el receptor. Esta forma de IPC se de­ nomina u n id ifu aó n , el envío de información a un único receptor, en contraste con m d tid ifiis íó a , el envío de inform ación a m últiples receptores. La unidifusión proporciona una IPC de uno-a-uno, mientras que la multidifusión provee una IPC de uno-a-muchos. Véase la Figura 6 .1. Mientras que la mayoría de servicios y aplicaciones de red utilizan unidifusión para IPC, la multidifusión es útil para aplicaciones tales como mensajes inmediatos. E m isor R e ce p to r C o m u n ic a c ió n u n o -a -u n o o u n id ifu s ió n C o m u n ic a c ió n d e g ru p o o m u ltid ifu s ió n Figura 6.1. IPC d e u n id ifu sió n y d e m u ltid ifu s ió n . www.FreeLibros.org 172 C om putación distribuida. Fundam entos y aplicaciones La r e p l i c a c i ó n de un servicio consiste en mantener duplicados de ese sen/icio. Una técnica común para mejorar la dsponibilidad de un servicio ante la presencia de fallos es duplicar los datos y el sistema que proporciona ese servicio. La t o l e r a n c i a d e f a l l o s se refiere a la capacidad que tiene una aplicación para tolerar fallos hasta derto punto.___________ groupware, conferencias en línea y aprendizaje interactivo, y puede utilizarse para apli­ caciones tales como subastas en línea en tiempo real. La multidifusión es también útil para la replicación de servicios con el propósito de obtener tolerancia a fallos. En aplicaciones o servicios de red que hacen uso de multidifusión, un conjunto de procesos forma un grupo, llamado §pupo d e nmdtidifiisión. Cada proceso en un gru­ po puede m andar y recibir mensajes. Un mensaje enviado p o r cualquier proceso del grupo puede recibirlo cada proceso que forma parte del grupo. Un proceso puede tam­ bién decidir abandonar un grupo de multidifusión. En una aplicación como puede ser una conferencia en línea, un grupo de proce­ sos interaccionan utilizando multidifusión para intercambiar audio, vídeo y/o datos de texto. Como en ocasiones anteriores, la discusión se centrará en el nivel de servicio, es­ pecíficamente en el mecanismo de IPC, de la aplicación. 6 .2 . U N A A P I DE M U LTID IF U S IÓ N A R Q U E T ÍP IC A Una interfaz de programación de aplicaciones que provea m ultidifusión debe propor­ cionar las siguientes operaciones primitivas: • Incorporación. Esta operación permite a un proceso unirse a un ¿£'upo de imd- tidifuaón específico. Un proceso que se ha unido a un grupo de multidifusión es un miembro del grupo, lo que le da derecho a recibir todos los mensajes di­ rigidos al grupo. Un proceso puede ser miembro de uno o más grupos de m ul­ tidifusión en un momento dado. N ótese que para esta y otras operaciones de multidifusión se necesita un esquema de denominación que perm ita identificar de forma única un grupo de multidifusión. • Abandono. Esta operación permite que un proceso deje d e formar parte de un grupo de multidifusión. Un proceso que ha dejado un grupo de multidifusión ya no es miembro del mismo y p o r tanto, no tiene derecho a recibir ninguna mul­ tidifusión dirigida al grupo, aunque el proceso pueda seguir siendo miembro de otros grupos de multidifiisión. • Envió. Esta operación permite que un proceso mande un mensaje a todos los procesos que actualmente forman parte de un grupo de multidifusión. • Recepción. Esta operación permite que un proceso miembro reciba mensajes enviados a un grupo de multidifusión. En la Sección 6.5 se examinarán el API de multidifusión de Java y algunos progra­ mas de ejemplo que usan esta API. En ese momento se verá cómo se proporcionan estas operaciones primitivas utilizando la sintaxis d e Java. Antes de esto, sin embar­ go, se explorarán algunas d e las cuestiones interesantes específicas d e la multidifu­ sión, que surgen de la naturaleza uno-a-muchos de la multidifusión. 6 .3 . M U LTID IFUSIÓ N SIN C O N EXIÓ N FRENTE A ORIENTADA A C O N E X IÓ N El mecanismo de multidifusión básico es sin conexión. La razón es obvia si se con­ sidera la naturaleza uno-a-muchos de la multidifusión. En un grupo de n procesos, si se establece una conexión entre el em isor y cada uno de los otros procesos del gru­ www.FreeLibros.org C om unicación d e g ru po 1 7 3 po, se necesitará un total de n-1 conexiones. Además, cada uno de los n procesos pue­ de ser potencialmente un emisor, de manera que cada proceso debe mantener una co­ nexión con cada uno de los otros procesos, dando lugar a un total de n * (n-1) o re­ dondeando, n2 conexiones. Si n-1 es grande, e l número total de conexiones será prohibitivamente elevado. Además, la IPC sin conexión es apropiada para un tipo común de aplicaciones de multidifusión: aplicaciones donde se transmiten datos de audio y vídeo entre proce­ sos en tiempo real. (Que los datos se transmiten en tiempo real, significa que la la- tencia entre el em isor y el receptor debería ser cercana a cero). Cuando se transmiten los datos de audio o vídeo, la reducción en la la tc n c ia proporcionada por la comuni­ cación sin conexión prevalece sobre las ventajas ofrecidas por la comunicación orien­ tada a conexión. Cuando se envían datos para una animación, por ejemplo, es más aceptable que el receptor experimente una distorsión ocasional en la imagen d e un fo­ tograma (un acontecimiento probable con una comunicación sin conexión) que un re­ traso frecuente perceptible entre fotogramas consecutivos (un acontecimiento proba­ ble con una comunicación orientada a conexión). 6 .4 . M U LTID IF U S IÓ N FIAB LE FR EN TE A NO FIABLE Cuando un proceso envía un mensaje de multidifusión, el soporte en tiempo de eje­ cución del mecanismo de multidifusión es responsable de entregar los mensajes a cada proceso que pertenezca actualmente al grupo de multidifusión. Dado que cada proce­ so implicado puede residir en una máquina diferente, la entrega de los mensajes re­ quiere la cooperación de mecanismos que están ejecutando independientemente en esos sistemas. Debido a factores como fallos en enlaces de la red, defectos en las máqui­ nas de la red, dem oras en el encaminamiento y diferencias en el software y hardwa­ re, el tiempo desde que se manda un mensaje de multidifusión hasta que se recibe puede variar en los distintos procesos receptores. Mientras que las diferencias en la entrega del mensaje entre distintas máquinas puede ser insignificante si las máquinas están ubicadas geográficamente próximas, puede no ser así si las máquinas están dis­ tribuidas en una red de área amplia. Asimismo, puede ocurrir que uno o más procesos no reciban un mensaje, debido a errores y/o fallos en la red, en las máquinas o en el soporte en tiempo de ejecución. M ientras que algunas aplicaciones, tales com o conferencias d e vídeo, pueden to­ lerar un fallo ocasional o el desorden en los m ensajes recibidos, hay aplicaciones, como las aplicaciones de base de datos, en las que tales anom alías no son acep­ tables. Por tanto, cuando se emplea un mecanismo de multidifusión para una aplicación, es importante que se elija uno con las características apropiadas para dicha aplicación. En caso contrario, se necesitarán proporcionar medidas en la lógica de aplicación para m anejar las anomalías que pueden ocurrir en la entrega d e los mensajes. Por esta ra­ zón, es útil clasificar los mecanismos de multidifusión en términos de sus caracterís­ ticas de entrega de mensajes. M ultidifusión no fiable Básicamente, el sistema de multidifusión hará un intento bienintencionado de entre­ gar los mensajes a cada proceso que forma parte del grupo, pero no se garantiza la La l a t e r i c i a se refiere al retraso o demora en la transmisión de datos. www.FreeLibros.org 174 C om putación distribuida. Fundam entos y aplicaciones entrega del mensaje en su forma correcta a cada proceso. De esta manera, cualquier mensaje enviado por un proceso puede ser recibido por cero o más procesos. En el mejor d e los casos, todos los procesos reciben el mensaje en su forma correcta. En el peor de los casos, ningún proceso recibe correctamente el mensaje. En otros casos, algunos procesos pueden recibir el mensaje, pero otros procesos no, o algunos proce­ sos pueden recibir el mensaje corrupto, o más de una vez. Se dice que un sistema de este tipo proporciona m iltid iñ i9 Ó a n o fia b le M ultidifusión fiable Un sistema d e multidifusión que garantice que finalmente se entrega correctamente cada mensaje a cada proceso del grupo se dice que proporciona m u ltid ifu s k n fiable. En este sistema, se puede asumir que cada mensaje que envía un proceso va a ser fi­ nalmente entregado sin estar corrupto a todos los procesos del grupo. La definición d e multidifusión fiable requiere que cada proceso participante reci­ ba exactamente una copia de cada mensaje enviado. Sin embargo, la definición no es­ tablece ninguna restricción sobre el orden en que se entregan los mensajes a cada pro­ ceso individual: cada proceso puede recibir los m ensajes en una secuencia que corresponde con cualquier permutación del orden en que fueran mandados. En apli­ caciones donde el orden de entrega del mensaje es significativo, es útil clasificar a su vez a los sistemas de multidifusión fiable como se describe a continuación. Sin orden Un sistema de multidifusión fiable sin orden garantiza la entrega segura de cada men­ saje, pero no proporciona ninguna garantía sobre el orden de entrega de los mensajes. Por ejemplo, considere que tres procesos Pi, P2 y P3 han formado un grupo de m ul­ tidifusión. Además, supóngase que se envían tres mensajes, mi, rm y m», al grupo. En ese caso, un sistema de multidifusión fiable sin orden puede entregar los mensajes a cada uno de los tres procesos en cualquiera d e las 3! (factorial de 3)= 6 permutacio­ nes (mi-nu-m?, mi-nu-nu, nu-mi-nu, nu-nu-mi, nu-mi-nu o mj-mí-mi). N ótese que es posible que cada participante reciba los mensajes en un orden di­ ferente al de entrega d e los mensajes a otros participantes. En el ejemplo, es posible que a Pi se le entreguen los mensajes en el orden mi-mz-nu, mientras que que a P? se le entreguen en el orden nu-mi-im, y a P3 en el orden mi-nb-rm. Por supuesto, es tam­ bién posible que los mensajes se entreguen a Pi, P?y P3 en el mismo orden, rni-m?- ni3, pero no se puede hacer esta suposición en una aplicación si se emplea un meca­ nismo de multidifusión sin orden. M ultidifusión F IF O Un sistema que garantice que la entrega de los mensajes se adhiere a la siguiente con­ dición se dice que proporciona una multidifusión F I F O (primero en entrar-primero en salir, fir st in-first out), o en orden-de-envío: S i el proceso P manda los mensajes m, y m¡, en ese orden, a un grupo de multi­ difusión, entonces a cada proceso en el grupo de multidifusión se le entregarán los mensajes en ese orden. www.FreeLibros.org C om unicación d e g ru po 1 7 5 Para ilustrar esta definición, se exam inará un ejem plo. Supóngase q u e Pi manda los m ensajes mi, nu, y im , en este orden, a un grupo de m ultidifusión G. En este caso, con una m ultidifusión FIFO, se garantiza que a cada proceso de G se le entregarán los m ensajes en ese m ism o orden: m i, nu y a continuación, m¡. N ótese que esta d e ­ finición no establece ninguna restricción en el orden de entrega de los m ensajes m an­ dados p o r procesos diferentes. Para ilustrar este punto, se utilizará un ejem plo sim ­ plificado d e un grupo de m ultidifusión de dos procesos: Pi y P2 . Supóngase q u e Pi envía los m ensajes mu y después mi2 , m ientras q u e P 2 m anda los m ensaje 1 1 1 2 1 y, a continuación, 1 1 1 2 2. E n este caso, un sistem a de m ultidifusión FIFO puede entregar los m ensajes a cada uno de los procesos en cualquiera d e los siguientes órdenes: mn-m i2-m?i-m 2 2, mií-m n-m i2 -1 1 1 2 2, m n-m 2 i-m 2 2-mi2 , m2i-m n-mi2-ni22, rm i-m i 1- 11122-m i2, m2i-m22-mn-mi2. N ótese que m ientras que los m ensajes q u e m anda Pi se entregan a cada proceso en el orden de secuencia mn-m i2 , y los enviados p o r P2 se entregan en el orden de se­ cuencia m 2 i-m2 2, las dos secuencias pueden intercalarse de cualquier m anera. M ultidifusión en orden causal Un sistem a de m ultidifusión se dice que proporciona una m ultidifusión causal si la entrega de m ensajes satisface el siguiente criterio: Si un mensaje nu causa (tiene como consecuencia) la existencia del mensaje mh entonces m se entregará a cada proceso antes que nu. Los mensajes m y m i tie­ ne una relación llamada relación sucede-antes o causal, denotada como m->nu. La relación sucede-antes es transitiva: si m —>mj y nij—m u , entonces m —>mj—>mk. En este caso, un sistem a de m ultidifusión en orden causal garantiza que estos tres m ensajes se entreguen a cada proceso en el orden de mi, mj y a continuación, mk. C om o ilustración, supóngase q u e tres procesos (Pi, P2 y P 3) están en un grupo de m ultidifusión. Pi m anda un m ensaje mi, a l q u e P 2 responde con un m ensaje 1 1 1 2. Dado que m es desencadenado por mi, com parten una relación causal d e m i-nn?. Supón­ gase que la recepción de m? causa a su vez que P? envíe un m ensaje de m ultidifusión mi, es decir, n u - m u . Los tres m ensajes, p o r tanto, com parten la relación causal de mi-*m2-*m3. Un sistem a d e m ensajes d e m ultidifusión en orden causal garantiza que estos tres m ensajes se entregan a cada uno d e los tres procesos en el orden mi-m2-m3. N ótese que en este caso no habría ninguna restricción en el orden d e entrega de los m ensajes si el sistem a de m ultidifusión fuera FIFO en lugar de causal. H aciendo una variación del ejem plo anterior, supóngase q u e Pi m ultidifim de un m ensaje mi, al q u e P2 responde con un m ensaje de m ultidifusión nu y, d e form a in ­ dependiente, P3 contesta a mi con un m ensaje de m ultidifusión nu. L os tres m ensajes com parten ahora la relación causal: m i-m u y mi->ni3. U n sistem a d e m ultidifusión en orden causal puede entregar estos m ensajes a los procesos participantes en cualquie­ ra d e las dos siguientes órdenes: mi-mj-m? mi-ms-m? E n este ejem plo, no es posible q u e se entreguen los m ensajes a cualquiera de los procesos en cualquier otra perm utación de los tres m ensajes, tales com o nu-mi-ms o nu-m i-nu. La prim era de estas perm utaciones viola la relación causal nu—m u , m ien­ tras que la segunda lo hace con la relación causal m i—>m3. www.FreeLibros.org 1 7 6 C om putación distribuida. Fundam entos y aplicaciones M ultidifusión en orden a tó m ico En un sistema de m ulticfifiiskn a i orden atómico, se garantiza que todos los men­ sajes son entregados a cada participante exactamente en el mismo orden. N ótese que el orden de entrega no tiene porque ser FIFO o causal, pero debe ser el mismo para todo proceso. Ejemplo: P: manda mi, Pi manda mi, y Ps manda m¡. Un sistema atómico garantizará que los mensajes se entregarán a cada proceso en sólo uno de los seis siguientes órdenes: mi-mi-ms, mi-ms-mi, mi-mi-ms, mi-ms- mi, mj-mi-m 2, nu-nv-mi. Ejemplo: Pi manda mi y a continuación, m?. Pi responde a m¡ mandando m¡. Ps responde a m¡ enviando nu. Aunque la multidifusión atómica no impone ningún orden en estos mensajes, la secuencia de eventos dicta que Pi debe entregar mi antes de enviar im. De manera si­ milar, P2 debe recibir mi y a continuación, nu, mientras que P3 debe recibir nu antes de n u Por ello, cualquier orden de entrega atómica debe preservar el orden mi-tm- nu. El mensaje restante nu puede, sin embargo, intercalarse con estos mensajes de cualquier manera. Por tanto, una multidifusión atómica dará como resultado que los m ensajes se entreguen a cada uno de los procesos en uno de los siguientes órdenes: mi-m2-m!-m«, mi-nu-nu-m* o mi-nu-nu-m?. Por ejemplo, los mensajes pueden entre­ garse a cada proceso en este orden: mi-nu-m^im. 6 .5 . EL A P I DE M U LTID IF U S IÓ N B Á SIC A DE JAVA En el nivel de transporte, la multidifusión básica soportada por Java es una extensión del Protocolo Datagrama de Usuario (UDP, User Datagram Protocol). que, com o se recordará, es sin conexión y no fiable. En el nivel de red de la arquitectura de red, los paquetes de multidifusión se transmiten a través de la red utilizando el encami­ namiento de multidifusión de Internet [cisco.com, 5] proporcionado p o r encaminado- res (conocidos como mrouters) capaces de encaminar la multidifusión además de la unidifusión. La multidifusión en una red local (una interconectada sin un encamina- dor) se lleva a cabo utilizando la multidifusión proporcionada por el protocolo de red de área local (como la multidifusión de Ethernet). El encaminamiento y entrega de mensajes de multidifusión son temas fuera del ámbito de este libro. Afortunadamen­ te, tales asuntos son transparentes a un programador de aplicaciones que utiliza una API de multidifusión. El API d e multidifusión básica de Java proporciona un conjunto de clases que es­ tán estrechamente relacionadas con las clases del API de sockets de datagrama que se examinó en el Capítulo 4. Hay tres clases principales en el API, las dos primeras ya se han visto en el contexto de los sockets datagrama. 1. InetAddress. En el API de sockets datagrama, esta clase representa la dirección IP del emisor o del receptor. En la multidifusión, esta clase puede utilizarse para identificar un grupo de multidifusión (como se explicará en la próxima sección «Direcciones IP de multidifusión»). www.FreeLibros.org C om unicación d e g ru po 1 7 7 2. DatagramPacket. Como en el caso de los sockets datagrama, un objeto de esta clase representa un datagrama real; en multidifusión, un objeto de Datagram­ Packet representa un paquete de datos enviado a todos los participantes o re­ cibidos p o r cada participante de un grupo de multidifusión. 3. M ulticast Socket. La clase Muí ticas ¡Socket se deriva de la clase DatagramSoc­ ket, con capacidades adicionales para incorporarse o abandonar un grupo de multidifusión. Un objeto de las clase socket datagrama de multidifusión pue­ de utilizarse para mandar y recibir paquetes IP de multidifusión. Direcciones IP de m ultidifusión Recuérdese que en el API de socket de unidifusión de Java, un emisor identifica a un receptor especificando el nombre de la máquina del proceso receptor, así como el puer­ to del protocolo a l que está ligado dicho proceso. Considérese por un momento a quién necesita dirigirse un em isor de multidifu­ sión. En lugar de a un único proceso, un datagrama de multidifusión está destinado a ser recibido por todos los procesos que son miembros actuales de un grupo de multi­ difusión específico. P or tanto, cada datagram a necesita dirigirse a un grupo de multidifusión en vez de a un proceso individual. El API d e multidifusión de Java utiliza las direcciones de multidifusión del Pro­ tocolo de Internet (IP, Internet Protocoí) para identificar los grupos de multidifusión. En IPv4, un grupo de multidifusión se especifica mediante (1) una dirección IP de la clase D combinada con (2) un número de puerto estándar de UDP. (Nótese que en IPvó e l direccionam iento d e m ultidifusión es significativam ente diferente; véase [faqs.org, 4] para más detalles). Recuerde del Capítulo 1 que las direcciones IP de la clase D son aquellas que comienzan con la cadena de bits 1110 y p o r tanto, estas di­ recciones están en el rango desde el 224.0.0.0 al 239.255.255.255, inclusive. Exclu­ yendo los cuatro bits del prefijo, hay 32-4 = 28 bits restantes, lo que da lugar a un tamaño del espacio de direcciones de 2 a , es decir, están disponibles, aproximadamente, 268 millones d e direcciones de clase D, aunque se reserva la dirección 224.0.0.0 y no debería utilizarse p o r ninguna aplicación. Las direcciones de multidifusión IPv4 las gestiona y asigna la Autoridad de Números Asignados de Internet (IANA, Assigned Numbers Authority) [rfc-editor.org, 3]. Una aplicación que utiliza el API de multidifusión de Java debe especificar al me­ nos una dirección de multidifusión para la aplicación. A la hora de seleccionar una dirección de multidifusión para una aplicación, se presentan las siguientes opciones: 1. Obtener una dirección de multidifusión estática permanentemente asignada de IANA. Las direcciones permanentes están limitadas a aplicaciones de Internet globales y bien conocidas y su asignación está muy restringida. En IANA [iana.org, 2], se puede encontrar la lista de direcciones actualmente asignadas. A continuación, se presenta una muestra de algunas de las direcciones asigna­ das más interesantes: 224 . 0 . 0 . 1 Tocios l o s s i s t e m a s e n e s t a s u b r e d 2 2 4 . 0 . 0 . 1 1 A g e n te s m ó v i l e s 2 2 4 . 0 . 1 . 1 6 MUSIC-SERVICE 2 2 4 . 0 . 1 . 1 7 SEANET-TELEMETRY 2 2 4 . 0 . 1 . 1 8 SEANET-IMAGE 2 2 4 . 0 . 1 . 4 1 g a t e k e e p e r 2 2 4 . 0 . 1 . 8 4 j i n i - a n n o u n c e m e n t www.FreeLibros.org 1 7 8 C om putación distribuida. Fundam entos y aplicaciones 224.0.1.85 jini-request 2 2 4 . 0 . 1 . 1 1 5 M u l t i d i f u s i ó n s i m p l e 2 2 4 . 0 . 6 . 0 - 2 2 4 . 0 . 6 . 1 2 7 P r o y e c t o I S I S d e C o r n e l l 2 2 4 . 0 . 7 . 0 - 2 2 4 . 0 . 7 . 2 5 5 W h e re -A re -Y o u 224.0.8.0-224.0.8.255 INTV 2 2 4 . 0 . 9 . 0 - 2 2 4 . 0 . 9 . 2 5 5 I n v i s i b l e W o rld s 224.0.11.0-224.0.11.255 NCC.NET Audio 2 2 4 . 0 . 1 2 . 0 - 2 2 4 . 0 . 1 2 . 0 6 3 M i c r o s o f t y MSNBC 2 2 4 . 0 . 1 7 . 0 - 2 2 4 . 0 . 1 7 . 0 3 1 M e r c a n t i l e & C om m odity E x c h a n g e 224 . 0 . 1 7 . 0 6 4 -2 2 4 . 0 . 1 7 . 1 2 7 ODN-DTV 224.0.18.0-224.0.18.255 D o w Jones 2 2 4 . 0 . 1 9 . 0 - 2 2 4 . 0 . 1 9 . 0 6 3 W a lt D is n e y Company 224.0.22.0-224.0.22.255 WORLD MCAST 2 2 4 . 2 . 0 . 0 - 2 2 4 . 2 . 1 2 7 . 2 5 3 L la m a d a s d e c o n f e r e n c i a s m u l t i m e d i a 2 . Elegir una dirección arbitraria, suponiendo que la combinación d e la dirección y el número de puerto elegidos de manera aleatoria no estará probablemente en uso. 3. Obtener una dirección de multidifusión transitoria en tiempo de ejecución; esta dirección puede recibirla una aplicación mediante el Protocolo de Anuncio de Sesión (Session Announcement Protocoí) [faqs.org, 6 ]. La tercera opción queda fuera del ámbito de este capítulo. En los ejercicios y ejem­ plos se utilizará a menudo la dirección estática 224.0.0.1, con un nombre de dominio de ALL-SYSTEMS.MCAST.NET, para procesos que ejecutan en todas las máquinas de la red de área local, como las que tendrá el lector en su laboratorio. Alternativa­ mente, se puede utilizar una dirección arbitraria que presumiblemente no haya sido asignada, com o p o r ejemplo, un número en el rango de 239.*.*.* (por ejemplo, 239.1.2.3). En el API de Java, un objeto M ulticastSocket se asocia a una dirección de puerto como p o r ejemplo, 3456, y los métodos del objeto permiten unirse a una dirección de multidifusión com o por ejemplo, 239.1.2.3 y dejarla. Incorporación a un grupo de m ultidifusión Para incorporarse a un grupo de multidifusión en una dirección IP m y un puerto UDP p , se debe instanciar un objeto M ulticastSocket con p y a continuación, se puede in­ vocar el método joinGroup, especificando la dirección m : / / i n c o r p o r a c i ó n a u n g r u p o d e n u l t i d i f u s i ó n e n l a d i r e c c i ó n IP / / 2 2 4 . 0 . 0 . 1 y e n e l p u e r t o 345 6 I n e t A d d r e s s g r u p o = I n e t A d d r e s s . g etB y N am e( \" 2 2 4 . 0 . 0 . 1 \" ) ; M u l t i c a s t S o c k e t s = new M u l t i c a s t S o c k e t ( 3 4 5 6 ) ; s . j o i n G r o u p ( g r u p o ) ; Envío a un grupo de m ultidifusión Se puede mandar un mensaje de multidifusión utilizando una sintaxis similar a la del API de sockets datagrama. Concretamente, se debe crear un paquete datagrama con la especificación de una referencia a un vector de octetos que contenga los datos, la longitud del vector, la dirección de multidifusión y el número de puerto. A continua­ www.FreeLibros.org C om unicación d e g ru po 1 7 9 ción, se puede invocar el método send del objeto MulticastSocket (heredado d e la cla­ se DatagramSocket) para m andar los datos. N o es necesario que un proceso se una a un grupo de multidifusión para mandar mensajes al mismo, aunque debe hacerlo para poder recibir los mensajes. Cuando se manda un mensaje a un grupo de multidifusión, todos los procesos que se han unido al grupo de multidifusión, que puede incluir al emisor, deberían recibir e l mensaje, aunque no se garantiza. El siguiente segmento de código ilustra la sintaxis requerida para enviar un men­ saje a un grupo de multidifusión: S t r i n g m s j = \" E s t e e s u n m e n s a je d e n u l t i d i f u s i ó n . \" ; I n e t A d d r e s s g r u p o = I n e t A d d r e s s . g etB y N am e( \" 2 3 9 . 1 . 2 . 3 \" ) ; M u l t i c a s t S o c k e t s = new M u l t i c a s t S o c k e t ( 3 4 5 6 ) ; s . j o i n G r o u p ( g r u p o ) ? / / o p c i o n a l D a ta g ra m P a c k e t h o l a = new D a ta g r a m P a c k e t (ms j . g e t B y t e s ( ) , m s j . l e n g t h ( ) , g r u p o , 3 4 5 6 ) ; s . s e n d ( h o l a ) ; R e ce p ció n de m e nsajes m a n d a d o s a un gru p o de m ultidifusión Un proceso que se ha unido a un grupo de multidifusión puede recibir mensajes en­ viados al grupo utilizando una sintaxis sim ilar a la usada para recibir datos mediante una API de sockets datagrama. El siguiente segmento de código ilustra la sintaxis usa­ da para recibir mensajes enviados a un grupo de multidifusión. b y t e [ ] a lm a c é n = new b y t e [ 1 0 0 0 ] ; I n e t A d d r e s s g r u p o = I n e tA d d r e s s .g e tB y N a m e ( \" 2 3 9 . 1 . 2 . 3 \" ) ; M u l t i c a s t S o c k e t s = new M u l t i c a s t S o c k e t ( 3 4 5 6 ) ; s . j o i n G r o u p ( g r u p o ) ; D a ta g r a m P a c k e t r e c i b i d o = new D a ta g r a m P a c k e t( a lm a c é n , a lm a c é n . l e n g t h ) ; s . r e c e i v e ( r e c i b i d o ) ; A b a n d o n o de un g ru p o de m ultidifusión Un proceso puede dejar un grupo de multidifusión invocando el método leaveGroup de un objeto MulticastSocket, especificando la dirección d e multidifusión del grupo: s . l e a v e G r o u p ( g r u p o ) ; A juste del «tie m p o -d e -v id a » El soporte en tiempo de ejecución de una API de multidifusión a menudo emplea una técnica conocida como propagación de mensajes, en la que se propaga un paquete des­ de una máquina a una máquina vecina usando un algoritmo que, cuando se ejecuta apropiadamente, entregará finalmente el mensaje a todos los participantes. Sin em­ bargo, ante alguna circunstancia anómala, es posible que el algoritmo que controla la propagación de mensajes no termine apropiadamente, dando como resultado que un paquete circule por la red indefinidamente. Este fenómeno no es deseable, ya que cau­ sa una sobrecarga innecesaria en los sistemas y en la red. Para evitar que esto ocu­ rra, se recomienda que se fíje un parámetro «tiempo-de-vida» en cada datagrama de multidifusión. El parámetro de tiempo-de-vida (ttl, time-to-live), cuando se fija, limi- www.FreeLibros.org 1 8 0 C om putación distribuida. Fundam entos y aplicaciones ta el número de enlaces de red, o saltos, a través de los que se retransmitirá el pa­ quete en la red. En el API de Java, este parámetro se puede fijar invocando el método setTimeTo- Live del M ulticastSocket del emisor de la siguiente manera: S t r i n g m s j = \" ¡ H o la a t o d o s ! \" ; I n e t A d d r e s s g r u p o = I n e t A d d r e s s . getB yN am e ( \" 2 2 4 . 0 . 0 . 1 \" ) ; M u l t i c a s t S o c k e t s = new M u l t i c a s t S o c k e t ( 3 4 5 6 ) ; s .s e tT im e T O L iv e ( 1 ) ; / / a j u s t a t i m e - t o - l i v e a 1 s a l t o - u n v a l o r a p r o p i a d o / / p a r a m u l t i d i f u s i ó n e n m á q u in a s l o c a l e s D a ta g r a m P a c k e t h o l a = new D a t a g r a m P a c k e t ( m s j .g e t B y t e s ( ) , m s j . l e n g t h ( ) , g r u p o , 3 4 5 6 ) ; s . s e n d ( h o l a ) ; El valor especificado para el ttl debe estar en el rango 0 < ttl ^ 255; en caso con­ trario, se activará una IIlegalArgumentException. Las valores de ttl recomendados [Harold, 12] son: • 0 si la multidifusión está restringida a procesos en la misma máquina. • 1 si la multidifusión está restringida a procesos en la misma subred. • 32 si la multidifusión está restringida a procesos en la misma zona. • 64 si la multidifusión está restringida a procesos en la misma región. • 128 si la multidifusión está restringida a procesos en el mismo continente. • 255 si la multidifusión no está restringida. E jen q ilo L Las Figuras 6.2 y 6.3 ilustran el código de un ejemplo simple de aplica­ ción de multidifusión, que se presenta aquí básicamente para ilustrar la sintaxis del API. Cuando se ejecuta, cada proceso receptor (Figura 6.3) se subscribe al grupo de multidifusión 239.1.2.3 en el puerto 1234 y espera la llegada de un mensaje. El pro­ ceso emisor (Figura 6.2), por otro lado, no es un miembro del grupo de multidifusión (aunque podría serlo); dicho proceso m anda un único mensaje al grupo de multidifu­ sión 239.1.2.3 en el puerto 1234 antes de cerrar su socket de multidifusión. F ig u ra 6 .2 . E je m p b lE m iso r.ja v a . i i m p o r t j a v a . i o . * ; 2 ■3 i m p o r t j a v a . n e t . * ; O 4 / * * 5 * E s t e e je m p lo i l u s t r a l a s i n t a x i s d e l a m u l t i d i f u s i ó n b á s i c a . 6 * G a u th o r M. L . L i u 7 * / 8 q p u b l i c c l a s s E je m p lo l E m is o r { * 10 / / U na a p l i c a c i ó n q u e u s a u n s o c k e t d e m u l t i d i f u s i ó n p a r a e n v i a r 11 / / u n ú n i c o m e n s a je a u n g r u p o d e m u l t i d i f u s i ó n . 12 / / E l m e n s a je s e e s p e c i f i c a como u n a rg u m e n to d e l i n e a d e m a n d a to . 13 14 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 15 M u l t i c a s t S o c k e t s ; 16 I n e t A d d r e s s g r u p o ; (continúa) www.FreeLibros.org 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 C om unicación d e g ru po 181 i f ( a r g s . l e n g t h ! = 1 ) S y s te m , o u t . p r i n t l n ( \" E s t e p ro g ra m a r e q u i e r e u n a rg u m e n to d e l í n e a d e m a n d a to \" ) ; e l s e { t r y { / / c r e a e l s o c k e t d e n u l t i d i f u s i ó n g r u p o = I n e t A d d r e s s . g etB yN am e ( \" 2 3 9 . 1 . 2 . 3 \" ) ; s = new M u l t i c a s t S o c k e t ( 3 4 5 6 ) ; s . s e t T i m e T o L i v e ( 3 2 ) ; / / r e s t r i n g e m u l ti d if u s ió n a p r o c . que / / eje c u ta n en máquinas en l a misma zona. S t r i n g m s j = a r g s [ 0 ] ; D a ta g r a m P a c k e t p a q u e t e = new D a ta g r a m P a c k e t( m s j. g e t B y t e s ( ) , m s j . l e n g t h ( ) , g r u p o , 3 4 5 6 ) ; s . s e n d ( p a q u e t e ) ; s . c i ó s e ( ) ; > c a t c h ( E x c e p t i o n e x ) { / / l l e g a a q u í s i o c u r r e u n e r r o r e x . p r i n t S t a c k T r a c e ( ) ; } / / f i n d e c a t c h } / / f i n d e e l s e } / / f i n d e m a in } / / f i n d e c l a s s F ig u ra 6 .3 . E je m p lo l R ecep to r.ja va . i m p o r t j a v a . i o . * ; i m p o r t j a v a . n e t . * ; /** * E s t e e je m p lo i l u s t r a l a s i n t a x i s d e l a m u l t i d i f u s i ó n b á s i c a . * 0 a u t h o r M. L . L i u */ p u b l i c c l a s s E j e m p l o l R e c e p t o r { / / Una a p l i c a c i ó n q u e s e u n e a u n g r u p o d e m u l t i d i f u s i ó n y / / r e c i b e e l ú n i c o m e n s a je e n v ia d o a l g r u p o , p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { M u l t i c a s t S o c k e t s ; I n e t A d d r e s s g r u p o ; t r y { / / s e u n e a u n g r u p o d e m u l t i d i f u s i ó n y e s p e r a r e c i b i r un / / m e n s a je g r u p o = I n e tA d d r e s s .g e tB y N a m e ( \" 2 3 9 . 1 . 2 . 3 \" ) ; (continúa) www.FreeLibros.org 1 8 2 C om putación distribuida. Fundam entos y aplicaciones 19 20 21 22 s = new M u l t i c a s t S o c k e t ( 3 4 5 6 ) ; s . jo i n G r o u p ( g r u p o ) ; b y te [ ] a lm a c é n = new b y t e [ 1 0 0 ] ; D a ta g ra m P a c k e t r e c i b i d o = new D a ta g ra m P a c k e t( a lm a c é n , 23 24 25 26 27 28 29 30 a lm a c é n . l e n g t h ) ; s . r e c e i v e ( r e c i b i d o ) ; S y ste m , o u t . p r i n t l n ( new S t r i n g (a lm a c é n ) ) ; s . c i ó s e ( ) ; > c a t c h ( E x c e p tio n e x ) { / / l l e g a a q u í s i o c u r r e un e r r o r e x . p r i n t S t a c k T r a c e ( ) ; } / / f i n d e c a t c h } / / f i n d e m ain 31 } / / f i n d e c l a s s E je m p lo & Como otra ilustración del API de multidifusión de Java, se presenta un ejemplo donde cada proceso de un grupo de multidifusión m anda un mensaje, y, de forma independiente, cada proceso también visualiza todos los mensajes que reci­ be como miembro del grupo de multidifusión. Ejemplo2EmisorReceptor.java (Figura 6.4) es el código del ejemplo. En e l méto­ do main se crea un hilo para recibir y visualizar los mensajes (véase la línea 39). Para asegurarse de que cada proceso está listo para recibir, se realiza una pausa (véase las líneas desde la 40 a la 43) antes de que el proceso envíe su mensaje. 1 / / E s t e p ro g ra m a i l u s t r a e l e n v ío y r e c e p c i ó n u sa n d o m u l t i d i f u s i ó n 3 im p o r t j a v a . i o . * ; 4 im p o r t j a v a . n e t . * ; 5 /* * 6 * E s t e e je m p lo i l u s t r a e l u so d e m ú l t i p l e s h i l o s p a r a e n v i a r y 7 * r e c i b i r m u l t i d i f u s i ó n e n un p r o c e s o . 8 * @ author M. L . L iu 9 * / 10 p u b l i c c l a s s E je m p lo 2 E m iso rR e c e p to r{ 12 / / Una a p l i c a c i ó n q u e u s a un s o c k e t d e n u l t i d i f u s i ó n p a r a e n v i a r 13 / / un ú n ic o m e n s a je a un g ru p o d e m u l t i d i f u s i ó n , y u t i l i z a un h i l o 14 / / i n d e p e n d ie n te q u e u s a o t r o s o c k e t d e m u l t i d i f u s i ó n p a r a r e c i b i r 15 / / m e n s a je s e n v ia d o s a l mismo g r u p o . 16 / / S e r e q u i e r e n t r e s a rg u m e n to s d e l í n e a d e m a n d a to : 17 / / < d i r e c c i ó n IP d e m u l t i d i f u s i ó n > , < p u e r t o d e / / r r u lt id if u s ió n > ,< m e n s a je > 18 19 p u b l i c s t a t i c v o id m a in ( S tr in g [ ] a r g s ) { F ig u ra 6 .4 . E jem p lo 2 E m iso rfíecep to r.ja va . 2 11 2 0 21 I n e tA d d r e s s g ru p o = n u i l ; (continúa) www.FreeLibros.org 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 1 2 3 4 5 6 7 8 9 10 C om unicación d e g ru po 1 8 3 i n t p u e r t o = 0? M u l t i c a s t S o c k e t s o c k e t = n u i l ; S t r i n g c a r a c t e r e s ; b y t e [ ] d a t o s = n u i l ; i f ( a r g s . l e n g t h 1=3) S y s t e m . o u t . p r i n t l n ( \"S e r e q u i e r e n 3 a r g s . d e l i n e a d e m a n d a to \" ) ; e l s e { t r y { g r u p o = I n e t A d d r e s s . g etB yN am e( a r g s [ 0 ] ) ; p u e r t o = I n t e g e r . p a r s e l n t ( a r g s [ 1 ] ) ; c a r a c t e r e s = a r g s [ 2 ] ; d a t o s = c a r a c t e r e s . g e t B y t e s ( ) ; D a ta g r a m P a c k e t p a q u e t e = new D a t a g r a m P a c k e t ( d a t o s , d a t o s . l e n g t h , g r u p o , p u e r t o ) ; T h r e a d e l H i l o = new T h r e a d ( new H i l o L e c t o r ( g r u p o , p u e r t o ) ) ; e l H i l o . s t a r t ( ) ; S y s t e m . c x i t . p r i n t l n ( \" P u l s e I n t r o c u a n d o l i s t o p a r a e n v i a r : \" ) ; I n p u t S tr e a m R e a d e r i s = new I n p u t S t r e a m R e a d e r ( S y s t e m .i n ) ; B u f f e r e d R e a d e r b r = new B u f f e r e d R e a d e r ( i s ) ; b r . r e a d L i n e ( ) ; s o c k e t = new M u l t i c a s t S o c k e t (p u e r t o ) ; s o c k e t . s e t T i m e T o L iv e ( 1 ) ; s o c k e t . s e n d ( p a q u e t e ) ; s o c k e t . c i ó s e ( ) ; > c a t c h ( E x c e p t i o n s e ) { s e . p r i n t S t a c k T r a c e ( ) ; > / / f i n d e c a t c h } / / f i n d e e l s e } / / f i n d e m a in } / / f i n d e c l a s s F ig u ra 6 .5 . H iloLector.java. i m p o r t j a v a . n e t . * ; i m p o r t j a v a . i o . * ; /** * E s t a c l a s e e s u t i l i z a d a p o r E je m p lo 2 E m is o r R e c e p to r p a r a * l e e r m e n s a je s d e m u l t i d i f u s i ó n m i e n t r a s e l h i l o p r i n c i p a l e n v í a * u n m e n s a je d e m u l t i d i f u s i ó n . H ace e c o e n l a p a n t a l l a d e c a d a * m e n s a je l e í d o . * G a u th o r M. L . L i u */ c l a s s H i l o L e c t o r im p le m e n ts R u n n a b le { (continúa) www.FreeLibros.org 184 C om putación distribuida. Fundam entos y aplicaciones 11 12 s t a t i c f i n a l i n t MAX_LON = 3 0 ; 13 p r i v a t e I n e t A d d r e s s g r u p o ; 14 p r i v a t e i n t p u e r t o ; 15 16 p u b l i c H i l o L e c t o r ( I n e t A d d r e s s g r u p o , i n t p u e r t o ) { 17 t h i s . g r u p o = g r u p o ; 18 t h i s . p u e r t o = p u e r t o ; 19 } 20 21 p u b l i c v o i d r u n ( ) { 22 23 t r y { 24 25 M u l t i c a s t S o c k e t s o c k e t = new M u l t i c a s t S o c k e t ( p u e r t o ) ; 26 s o c k e t . j o i n G r o u p ( g r u p o ) ; 27 w h i l e ( t r u e ) { 28 b y t e [ ] d a t o s = new byte[MAX_LON] ; 29 D a ta g r a m P a c k e t p a q u e t e = 30 new D a ta g r a m P a c k e t( d a t o s , d a t o s . l e n g t h , g r u p o , p u e r t o ) ; 31 s o c k e t . r e c e i v e ( p a q u e t e ) ; 32 S t r i n g s = new S t r i n g ( p a q u e t e . g e t D a t a ( ) ) ; 33 S y s t e m . o u t . p r i n t l n ( s ) ; 34 } / / f i n d e w h i l e 35 } / / f i n d e t r y 36 c a t c h ( E x c e p t i o n e x c e p t i o n ) { 37 e x c e p t i o n . p r i n t S t a c k T r a c e ( ) ; 38 } / / f i n d e c a t c h 39 } / / f i n d e r u n 40 41 } / / f i n d e c l a s s E l API de m ultidifusión de Java y m ecanism os sim ilares pueden em plearse para d a r soporte a la lógica de servicio de una aplicación. N ótese que una aplicación p u e­ de utilizar una com binación de unidifusión y m ultidifusión para su IPC. Una aplicación q u e hace uso de la m ultidifusión a veces se denom ina aplicación catsriente de la iw iltid ifiigén (multicast-aware). Para los interesados en una sala de chai im plem entada utilizando m ultidifusión, consúltese la referencia [Hughes, 7]. 6 .6 . EL A P I DE M U LTID IF U S IÓ N FIABLE El API de m ultidifusión de Jav a q u e se ha explorado en este capítulo es una exten­ sión del API de sockets datagram a. Por ello, com parte una característica fundam ental de los datagram as: la entrega no fiable. En particular, no se garantiza q u e se entre­ guen los m ensajes a los procesos receptores. Por tanto, esta A PI proporciona una imd- tidifusión n o fiable Sin em bargo, el lector debe ten er en cuenta a la hora de reali­ za r los ejercicios que, si se ejecutan los procesos en una m áquina o en m áquinas de www.FreeLibros.org C om unicación d e g ru po 1 8 5 una subred, no se observará ninguna pérdida de mensajes o perturbación en el orden de entrega de los mismos. Estas anomalías son más probables cuando las máquinas involucradas están conectadas de forma remota, debido a los fallos en la red o a los retrasos en el encaminamiento. Como se m encionó previamente, hay aplicaciones para las que la multidifusión no fiable es inaceptable. Para tales aplicaciones, hay un número de paquetes disponibles que proporcionan una API de multidifusión fiable, entre los que se incluyen: • El servid o d e M idtidifuskin Fiable d e Java (Servido JRM, Java Reliable M ulticast Service) [Rosenzweig, Kandansky y Hanna, 8; Bischof, 9] es un pa­ quete que mejora el A PI de multidifusión básica de Java proporcionándole la capacidad de que un receptor pueda reparar los datos d e multidifusión que se hayan perdido o dañado, así como medidas de seguridad para proteger la pri­ vacidad de los datos. • El sistema T ó tem [alpha.ece.ucsb.edu, 10], desarrollado p o r la universidad de California, en Santa Bárbara, «proporciona una entrega de mensajes fiable y to­ talmente ordenada para procesos incluidos en grupos de procesos sobre una red de área local, o sobre múltiples redes d e área local interconectadas por pasa­ relas». • El Entorno d e M iritidifiidón Fiable (RMF, Reliable M ulticast Fram ework) de TASC [tascnets.com, 11] proporciona multidifusión fiable y en orden de en­ vío (FIFO). El uso de estos paquetes queda fuera del ám bito de este libro. Se anim a a los lecto­ res interesados a que consulten las referencias para detalles adicionales. Este capítulo proporciona una introducción al uso de la comunicación de grupo en la computación distribuida. • La multidifusión difiere de la unidifusión: la unidifusión es una comunicación uno-a-uno, mientras que la multidifusión es una comunicación uno-a-muchos. • Una API de multidifusión arquetípica debe proporcionar operaciones para in­ corporarse a un grupo de multidifiisión, abandonar un grupo de multidifusión, enviar a un grupo y recibir los mensajes de multidifusión enviados al grupo. • La multidifusión básica es sin conexión y no fiable: en un sistema de multidi- fúsión no fiable, no está garantizado que los mensajes se entreguen sin contra­ tiem pos a cada participante. • Un sistema de multidifusión fiable asegura que cada mensaje mandado a un gru­ po de multidifusión se entregue correctamente a cada participante. La m ultidi­ fusión fiable puede clasificarse a su vez por el orden de entrega de mensajes que proporciona distinguiéndose las siguientes categorías: — Multidifusión sin orden, que puede entregar los mensajes a cada participan­ te en cualquier orden. — Multidifusión FIFO, que mantiene el orden de los mensajes mandados por cada emisor. — Multidifusión causal, que preserva las relaciones causales entre los mensajes. www.FreeLibros.org 1 8 6 C om putación distribuida. Fundam entos y aplicaciones — Multidifusión atómica, que entrega los mensajes a cada participante en el mismo orden. • La dirección d e multidifusión utiliza una combinación de una dirección de cla­ se D y un número de puerto de UDP. Las direcciones IP de clase D las gestio­ na y asigna IANA. Una aplicación de multidifusión puede utilizar una dirección d e clase D estática, una dirección transitoria obtenida en tiempo de ejecución o una dirección arbitraria que no esté asignada. • El API de multidifusión básica de Java proporciona una multidifusión no fiable. Se crea un M ulticastSocket con la especificación de un número de puerto. Los m étodos joinG roup y leaveGroup de la clase M ulticastSocket se pueden invo­ car para unirse o abandonar un grupo de multidifusión específico. Los méto­ dos send y receive se pueden invocar para m andar y recibir un datagrama de multidifusión. Se necesita tam bién la clase DatagramPacket para crear los data- gramas. • Existen paquetes que proporcionan multidifusión fiable, incluyendo el servicio de Multidifúsión Fiable de Java (JRM, Java Reliable Multicast). E JE R C IC IO S 1. Supóngase que un grupo de m ultidifusión actualmente tiene dos procesos, Pi y Pz, que forman parte del mismo. Suponga que P> multidifúnde mu y, a con­ tinuación, miz; Pz multidifúnde mzi, y luego mzz. Además, suponga que no se pierde ningún mensaje en la entrega. a. Teóricamente, ¿en cuántas diferentes ordenaciones pueden entregarse los cuatro mensajes a cada proceso si los mensajes no están relacionados? b. Teóricamente, ¿en cuántas diferentes ordenaciones pueden entregarse los cuatro mensajes a cada proceso si los mensajes están relacionados de for­ ma causal de la siguiente manera mi i—>miz—>mzi—>mzz—> c. ¿Cuáles son los posibles órdenes de entrega de los mensajes a cada proce­ so si los mensajes no están relacionados y la multidifusión es FIFO, cau­ sal y atómica? d. ¿Cuáles son los posibles órdenes de entrega de los mensajes a cada proce­ so si los mensajes están relacionados de forma causal de la siguiente ma­ nera mu—>mzi—>miz—>mzz y la multidifusión es FIFO, causal y atómica? 2 . Supóngase que tienen lugar los siguientes eventos en orden cronológico en un grupo de multidifusión del que forman parte tres procesos Pi, P?, y Pj: P i multidifúnde mi. Pz responde a mi mediante la multidifúsión d e mz. P3 multidifúnde rm espontáneamente. Pi responde a irn mediante la multidifúsión d e nu. P3 responde a mz mediante la multidifúsión de ms. Pz multidifúnde nu espontáneamente. Para cada una de las siguientes situaciones, especifique en la entrada co­ rrespondiente de la tabla que aparece más adelante si el modo de multidifú­ sión perm ite o no esa situación: www.FreeLibros.org C om unicación d e g ru po 1 8 7 a. A todos los procesos se les entrega mi, nu, mi, nu, ms, nu, en ese orden. b. A Pi y P2 se les entrega mi, 1112, nu, m«, ms, m6. A Pb se le entrega nu, niB, m., im, ms, nié. c. A P . se le entrega m., nu, ms, m3, nu, m6. A P? se le entrega m., m 3, ms, rm, ni2, nu. A Pb se le entrega nu, m., im, m2, ms, nié. d. A P . se le entrega m., nu. ms. m4. ms, m6. A P? se le entrega m., im, nu, m 3, mé, ms. A Pb se le entrega m., mB, ni6, m4, nu, ms. e. A P . se le entrega m., nu. ms. m4. ms, m6. A P2 se le entrega mi, mí, m2, ms, m4, m6. A P b se le entrega m., nu, nu, ms, nu, m4. f. A P . se le entrega im, m>, ni6. A P2 se le entrega m., im, nu. A P b se le entrega IT16, nu, mi. g. No se entrega ningún mensaje a alguno de los procesos. S itu a ció n M u ltid ifu s ió n fiable M u ltid ifu s ió n F IF O M u ltid ifu s ió n ca u sa l M u ltid ifu s ió n a tó m ic a a b c d e f g 3. Este ejercicio se basa en E jem plol presentado en este capítulo. a. Compile los programas Ejemplol*.java. A continuación, ejecútelos en cada una d e las siguientes secuencias. Describa y explique cada una de las sali­ das resultantes: i. Arranque prim ero dos o más procesos receptores, después un proceso emisor con el mensaje que se desee. ii. Arranque primero un proceso em isor con el mensaje que se desee, des­ pués dos o más procesos receptores. b. Basado en el Ejem plol Receptor.java, cree un programa, E jem plol aRecep- torjava, que se una a un grupo de multidifusión con una dirección IP di­ ferente (por ejem plo, 239.1.2.4) pero con el m ism o puerto. Com pile E je m p lo la R e c e p to r .ja v a . A rra n q u e p rim e ro d o s o m ás p ro c e s o s Ejem plol Receptor, a continuación, un proceso Ejem plolaReceptor y por úl­ timo, un proceso em isor con el mensaje que se desee. ¿Recibe e l proceso Ejemplo laReceptor el mensaje? Describa y explique la salida. www.FreeLibros.org 188 C om putación distribuida. Fundam entos y aplicaciones c. Basado en el Ejemplo ¡Receptor.java, cree un programa, Ejemplo lbRecep- tor.java, que se una a un grupo de multidifusión con la misma dirección IP pero con un puerto diferente. Compile EjemploIbReceptor.java. Arranque prim ero dos o más procesos Ejemplo ¡Receptor, luego, un proceso Ejem­ p lo IbReceptor y, p o r último, un proceso emisor con el mensaje que se de­ see. ¿Recibe el proceso Ejemplo IbR eceptor el mensaje? Describa y expli­ que la salida. d. Basado en el Ejemplo!Emisor.java, cree un programa, Ejemplo1 EmisorRecep- tor.java, que se una al grupo de multidifusión, mande un mensaje, y después espere (reciba) un mensaje de multidifusión antes de cerrar el socket de mul- tidifusión y terminar. Compile el programa y, a continuación, arranque dos o más programas receptores antes de comenzar el proceso Emisor Receptor. Des­ criba la salida. Entregue el listado de EmisorReceptor.java. e. Basado en Ejemplo ¡Emisor.java, cree un programa, EjemploIbEmisor.java, que mande un mensaje a la dirección de multidifusión del programa Ejem­ plo IbReceptor.java. Compile el programa, y luego arranque un proceso E je m p lo ! R e c e p to r , un p r o c e s o E je m p lo lb R e c e p to r , un p ro c e s o Ejem plo!Em isor y, por último, un proceso EjemplolbEmisor. Describa y explique el mensaje o los mensajes recibidos p o r cada proceso. £ Basado en Ejemplol Receptor.java y Ejemplo IbReceptor.java, cree un pro­ grama, EjemplolcReceptor.java, que utilice dos hilos (incluyendo el hilo principal). Cada hilo se debe unir a uno de los dos grupos de multidifusión y recibir, y después visualizar, un mensaje antes de abandonar el grupo. Puede resultar útil el ejemplo HiloLector.java. Compile y ejecute Ejem plol cReceptor.java, y después arranque un proce­ so Ejemplo IbEm isor. ¿El proceso receptor visualiza ambos mensajes? En­ tregue el listado del programa Ejem plol cReceptor.java y su clase que defi­ ne el hilo de ejecución. 4 . Este ejercicio se basa en Ejemplo2 presentado en este capítulo. a. Compile Ejemplo2EmisorReceptor.java, y luego arranque dos o más proce­ sos del programa, especificando para cada uno un mensaje diferente. Un ejemplo de los mandatos necesarios para ello es: j a v a E j e n p l o 2 E m is o r R e c e p to r 2 3 9 . 1 . 2 . 3 1 234 m s j l j a v a E je m p lo 2 E m is o r R e c e p to r 2 3 9 . 1 . 2 . 3 1 234 m s j2 j a v a E je m p lo 2 E m is o r R e c e p to r 2 3 9 . 1 . 2 . 3 12 3 4 m s j3 En este ejemplo, cada uno de los tres procesos visualizaría en la pantalla los mensajes m sjl, msj2 y msj3. Asegúrese de arrancar todos los procesos antes de perm itir que cada uno mande su mensaje. Describa las salidas re­ sultantes. b. Modifique Ejemplo2EmisorReceptor.java de manera que cada proceso man­ de su mensaje diez veces. Compile y ejecute. Describa las salidas resul­ tantes y entregue los listados de programas. 5. Escriba su propia aplicación de multidifusión. Desarrolle una aplicación de ma­ nera que múltiples procesos utilicen comunicación de grupo para llevar a cabo una elección. Hay dos candidatos: Sánchez y Pérez. Cada proceso multidifún- de su voto en un mensaje que le identifica a sí mismo y su voto. Cada pro­ ceso lleva la cuenta de cuántos votos tiene cada candidato, incluyendo el pro­ pio. Al final de la elección (cuando todo el m undo en el grupo ha votado), www.FreeLibros.org C om unicación d e g ru po 189 cada proceso hace el recuento de votos de forma independiente y visualiza la salida en su pantalla (por ejemplo, Sánchez 10, Pérez 5). Entregue el listado de la aplicación y responda a estas preguntas: a. ¿De qué manera su diseño permite a los participantes unirse a un grupo de multidifusión? b. ¿Cómo se sincroniza en su diseño el principio de la elección de manera que cada proceso esté listo para recibir cualquier difusión de voto p o r parte de un miembro del grupo? c. Al ejecutar la aplicación, ¿han coincidido los recuentos de votos en todas las máquinas? ¿Puede asum ir que los recuentos siempre coincidirán en to­ das las máquinas? Explíquelo. R E FER EN C IA S 1. Java 2 Platform SE v i 3.1: C lase MulticastSocket, http:lljavasim.eom/j2se/13/docs/api/java/netI- MulticastSocket Jitni 2. D irecciones d e m ultidifiisión d e IA N A , http://mvw.iana.org/assignments/multicast-addresses 3. R F C 3 1 7 1 , IA N A G u id e lin e s f o r I P v 4 M u ltic a st A d d re ss A llo c a tio n , http://www.rfc- editor.org/rfc/rfc3171 .txt 4. R F C 2 3 7 5 -IP v 6 M u ltic a st A ddress A ssignm ents, http://www.faqs.org/rfcs/rfc2375.html 5. C isc o -M u ltic ast R o u tin g , http://www.cisco.com/warp/public/614/I7.html 6. R FC 2 9 7 4 -S e ssio n A nnouncem ent P rotocol, http://www.faqs.org/rfcs/rfc2974.html 1. M erlin H ughes, M ulticast th e C h a tw av e s - Ja v a W orld, O ctubre 1999, http.Hwwwjavaworld. com/javaworld/jw-10-1999/jw-10-step _p.html 8. P h il R osenzw eig, M iriam K ad an sk y y S te v e H a n n a, The Java Reliable Multicast Service: A Reliable Multicast Library, http://www.sun.com/research/techrep/1998/smli_tr-98-68.pdf 9. H an s-P eter B isch o f, JR M S T utorial, D epartm ent o f C o m p u te r S cien ce, R o ch ester Institute o f T echnology, http://www.cs.rit.edu/~hpb/JRMSITutorial/ 10. R o b u s t D is trib u te d S y s te m s fo r R e a l-T im e A p p lic a tio n s , http://alpha.ece.ucsb.edu/ p ro je e tjo te m . html 11. R eliable M u lticast F ram ew ork (R M F ), http://www.tascnets.com/newtascnets/Sofiware/RMF/ , L itton TASC. 12. E lliotte R usty H arold, Java Network Programming, S ebastopol, C A : O ’R eilly Press, 2000. www.FreeLibros.orgwww.FreeLibros.org CAPITULO O b je t o s d is t r ib u id o s Hasta ahora este libro se ha centrado en el uso del paradigm a de paso de mensajes en la com putación d istribuida. A través del paradigm a de paso de m ensajes, los procesos intercam bian datos y, m ediante el uso de determ inados protocolos, colaboran en la realización de tareas. Las interfaces de program ación de aplicaciones basadas en este paradigm a, tales com o el API de sockets de unidifusión y m ultidifusión de Java, proporcionan una abstracción que perm ite esconder los detalles de la com unicación de red a bajo nivel, así com o e scrib ir có d ig o de com unicación entre procesos (IPC), utilizando una sintaxis relativam ente sencilla. Este capítulo introduce un paradigm a que ofrece aún una mayor abstracción, los objetos d istribuidos. 7.1. raso DE MENSAJES FRENTE A O BJETOS DISTRIBUIDOS El paradigm a de paso de m ensajes es un modelo natural para la com putación dis­ tribuida, en e l sentido de que im ita la comunicación entre humanos. Se trata de un paradigma apropiado para los servicios de red, puesto que estos procesos interactú- an a través del intercambio de mensajes. Pero este paradigma no proporciona la abs­ tracción necesaria para algunas aplicaciones de red complejas, por los siguientes mo­ tivos: • El paso de mensaje básico requiere que los procesos participantes estén fu e rte ­ m e n te aco p lad o s A través de esta interacción, los procesos deben comunicar­ se directamente entre ellos. Si la comunicación se pierde entre los procesos (de­ bido a fallos en el enlace de comunicación, en el sistema o en uno de los procesos), la colaboración falla. Por ejemplo, considérese una sesión del proto­ colo E cho : si la comunicación entre e l cliente y el servidor es interrumpida, la sesión no puede continuar. www.FreeLibros.org 192 C om putación distribuida. Fundam entos y aplicaciones • El paradigma de paso de mensajes está orientado a datos. Cada mensaje con­ tiene datos con un formato mutuamente acordado, y se interpreta como una pe­ tición o respuesta de acuerdo al protocolo. La recepción de cada mensaje de­ sencadena una acción en el proceso receptor. Por ejemplo, en e l protocolo Echo , el receptor de un mensaje del proceso p solicita esta acción a l servidor Echo : un mensaje conteniendo los mismos datos se envía al proceso p. En el mismo protocolo, la recepción de un mensaje del servidor Echo por el proceso p desencadena esta acción: un nuevo mensaje es solicitado por el usuario y el mensaje se envía a l servidor Echo. Mientras que el hecho de que el paradigma sea orientado a datos es apro­ piado para los servicios de red y aplicaciones de red sencillas, no es adecuado para aplicaciones complejas que impliquen un gran número de peticiones y res­ puestas entremezcladas. En dichas aplicaciones, la interpretación de los mensa­ je s se puede convertir en una tarea inabordable. El p a r a J g n a d e objetos distribuidos es un paradigma que proporciona mayor abs­ tracción que el modelo de paso de mensajes. Como su nombre indica, este paradig­ ma está basado en objetos existentes en un sistema distribuido. En programación orien­ tada a objetos, basada en un lenguaje de programación orientado a objetos, tal como Java, los objetos se utilizan para representar entidades significativas para la aplica­ ción. Cada objeto encapsula • e l estado o datos de la entidad: en Java, dichos datos se encuentran en las va­ riables d e instancia d e cada objeto; • las operaciones de la entidad, a través d e las cuales se puede acceder o modi­ ficar el estado de la entidad: en Java, estas operaciones se denominan métodos. Para ilustrar estos conceptos, considérese los objetos de la clase MensajeDatagrama presentada en la Figura 5.12 (en e l Capítulo 5). Cada objeto instanciado de esta cla­ se contiene tres variables de estado: un mensaje, la dirección del emisor y e l núme­ ro de puerto del emisor. Además, cada objeto contiene tres operaciones: (1) un méto­ do fijaValor, que permite modificar los valores de las variables de estado, (2) un método obtieneMensaje, que permite obtener el valor actual del mensaje, y (3) un mé­ todo obtieneDireccion, que permite obtener la dirección del emisor. Aunque en este libro se han utilizado objetos en capítulos anteriores, tales como el objeto M ensajeDatagrama, se trata de objetos locales, en lugar de objetos distri­ buidas Los objetos locales son objetos cuyos métodos sólo se pueden invocar por un proceso local es decir, un proceso que se ejecuta en el mismo computador del obje­ to. Un objeto distribuido es aquel cuyos métodos pueden invocarse por un proceso remoto, es decir, un proceso que se ejecuta en un computador conectado a través de una red al computador en el cual se encuentra el objeto. En un paradigma de objetos distribuidos, los recursos de la red se representan como objetos distribuidos. Para so­ licitar un servicio d e un recurso de red, un proceso invoca uno de sus métodos u ope­ raciones, pasándole los datos como parámetros al método. El método se ejecuta en la máquina remota, y la respuesta es enviada a l proceso solicitante como un valor d e sa­ lida. Comparado con el paradigma de paso d e mensajes, e l paradigma de objetos dis­ tribuidos es orientado a acciones: hace hincapié en la invocación de las operaciones, mientras que los datos toman un papel secundario (como parámetros y valores de re­ tomo). Aunque es menos intuitivo para los seres humanos, el paradigma de objetos distribuidos es más natural para e l desarrollo de software orientado a objetos. La Figura 7.1 ilustra el paradigma. Un proceso que se ejecuta en la máquina A re­ aliza una llamada a un método de un objeto distribuido de la máquina B, pasando los www.FreeLibros.org O bjetos d istribu ido s 1 9 3 M á q u in a A M á q u in a B Variable d e instancia del objeto I I Operación del objeto Q O bjeto distribuido F ig u ra 7.1 . El p a ra d ig m a d e o b je to s d is trib u id o s . datos necesarios, en caso de existir, mediante argumentos. La llam ada al método in­ voca una acción realizada por el método en la máquina A, y un valor de salida, en caso de que exista, se pasa desde la máquina A a la máquina B. Un proceso que uti­ liza objetos distribuidos se dice que es un proceso diente de ese objeto, y los méto­ dos del objeto se denominan métodos remotos (por contraposición a los métodos lo ­ cales, o métodos pertenecientes a un objeto local) del proceso cliente. En el resto del capítulo se va a proceder a presentar una arquitectura genérica que da soporte al paradigma de objetos distribuidos; a continuación se explorará un ejem ­ plo de este tipo de arquitecturas: Java R M I (R e m ó te M e d ia d Im o ca tio t). 7 .2 . UNA ARQ UITECTURA TÍP IC A DE O B JETO S DISTRIBUIDOS La premisa d e todo sistem a de objetos distribuidos es minimizar las diferencias de programación entre las invocaciones de métodos remotos y las llamadas a métodos locales, de forma que los métodos remotos se puedan invocar en una aplicación uti­ lizando una sintaxis similar a la utilizada en la invocación de los métodos locales. Re­ almente existen diferencias, porque la invocación de métodos remotos implica una co­ municación entre procesos independientes, y por tanto deben tratarse aspectos tales como el empaquetamiento de los datos (marshaling), así como la sincronización de los eventos. Estas diferencias quedan ocultas en la arquitectura. La Figura 7.2 presenta una arquitectura típica de una utilidad que dé soporte al paradigma de objetos distribuidos. Al objeto distribuido proporcionado o exportado por un proceso se le denomina servidor de objeta Otra utilidad, denominada registro de objetos, o simplemente re­ gistro, debe existir en la arquitectura para registrar los objetos distribuidos. Para acceder a un objeto distribuido, un proceso, el diente de objeto, busca en el registro para encontrar una referencia al objeto. El cliente de objeto utiliza esta refe­ rencia para realizar llamadas a los métodos del objeto remoto, o métodos remotos. Ló­ gicamente, el cliente de objeto realiza una llamada directamente al método remoto. Re- www.FreeLibros.org 194 C om putación distribuida. Fundam entos y aplicaciones En un lenguaje de programación, una referencia e s un «manejador» d e un objeto; e s decir, la representación a través de la cual s e puede localizar dicho objeto en el com putador donde reside. B término proxy, en el contexto d e la com putación distribuida, se refiere a un com ponente software que sirve com o intermediario d e otros com ponentes software. ^R egistro de objetos Cliente de o b je to...... ••••►Servidor de objeto - Proxy del cliente Proxy del servidor Soporte en tiem p o real Soporte en tie m p o real ► Ruta de datos lógica ► Ruta de datos física Figura 7.2 . Un sistem a d e o b je to s d is trib u id o s típ ic o . almente, un componente software se encarga de gestionar esta llamada. Este compo­ nente se denomina /v m y d e diente y se encarga de interactuar con el software en la máquina cliente con el fin de proporcionar soporte en tien d o d e ejecución para el sistema de objetos distribuidos. De esta forma, se lleva a cabo la comunicación entre procesos necesaria para transmitir la llamada a la máquina remota, incluyendo el em ­ paquetamiento de los argumentos que se van a transmitir al objeto remoto. Una arquitectura similar es necesaria en la parte del servidor, donde el soporte en tiempo de ejecución para e l sistema de objetos distribuidos gestiona la recepción de los mensajes y el desempaquetado de los datos, enviando la llam ada a un componen­ te software denominado / n f f y d e s m i d < r El proxy de servidor invoca la llam ada al método local en el objeto distribuido, pasándole los datos desempaquetados como ar­ gumentos. La llamada al método activa la realización de determinadas tareas en el servidor. El resultado de la ejecución del método es empaquetado y enviado por el proxy de servidor al proxy de cliente, a través del soporte en tiempo de ejecución y el soporte de red de ambas partes de la arquitectura. 7 .3 . S IS T E M A S DE O B JE TO S D IS TR IB U ID O S El paradigma de objetos distribuidos se ha adoptado de forma extendida en las apli­ caciones distribuidas, para las cuales existe un gran número de herramientas disponi­ bles basadas en este paradigma. Entre las herramientas más conocidas se encuentran: • Java RMI (Remóte M ethod Invocation) , • sistem as basados en CORBA (Common Object Request Broker Architecture), • el modelo de objetos d e componentes distribuidos o DCOM (Distributed Com- ponent Object Modet), y • herramientas y API para el protocolo SOAP (Simple Object Access Protocol) . www.FreeLibros.org O bjetos d istribu ido s 1 9 5 De todas estas herramientas, la más sencilla es Java RMI [java.sun.com/products, 7; java.sun.com/doc, 8; developer.java.sun.com, 9; java.sun.com/marketing, 10], que se describe detalladamente en este capítulo. CORBA [corba.org, 1] y sus implemen­ taciones son detalladas en el Capítulo 9. SOAP [w3.org, 2] es un protocolo basado en la Web y se introducirá en el Capítulo 11, a l analizar las aplicaciones basadas en la Web. DCOM [microsoft.com, 3; G rimes, 4] se encuentra fuera del ám bito de este li­ bro; los lectores interesados en DCOM deben consultar las referencias. No es posible cubrir todas las utilidades de objetos distribuidos existentes, y ade­ más seguramente seguirán emergiendo nuevas herramientas que den soporte a este pa­ radigma. Familiarizarse con el API de Java RMI proporciona los fundamentos y pre­ para a l lector para aprender los detalles d e utilidades similares. 7 .4 . LLA M A D A S A P R O C E D IM IE N T O S R EM O TO S RMI tiene su origen en un paradigma denominado Llamada a procedim ientos re­ m otos o RPC [R em a te P m ce tk ire CaR}. L a programación procednnental precede a la programación orientada a objetos. En la programación procedimental, un procedimiento o función es una estructura de control que proporciona la abstracción correspondiente a una acción. La acción de una función se invoca a través d e una llamada a función. Para permitir usar diferentes va­ riables, una llamada a función puede ir acompañada de una lista de datos, conocidos como argumentos. El valor o la referencia de cada argumento se le pasa a la función, e incluso podría determinar la acción que realiza dicha función. La llamada a proce­ dimiento convencional es una llamada a un procedimiento que reside en el mismo sis­ tema que el que la invoca y por tanto, se denomina llam ada a procedimiento local En el modelo de llamada a procedimiento remoto, un proceso realiza una llama­ da a procedimiento de otro proceso, que posiblemente resida en un sistema remoto. Los datos se pasan a través de argumentos. Cuando un proceso recibe una llamada, se ejecuta la acción codificada en el procedimiento. A continuación, se notifica la fi­ nalización de la llamada al proceso que invoca la llamada y, si existe un valor de re­ torno o salida, se le envía a este último proceso desde el proceso invocado. La Figu­ ra 7.3 muestra el paradigma RPC. P roce so A P ro ce so B Proc1(arg1,arg2) Valor d e salida Un procedim iento rem oto — ► Un flujo d e ejecución con cep tu al F ig u ra 7.3 . El p a ra d ig m a d e llam ad a a p ro c e d im ie n to re m o to s. www.FreeLibros.org 196 C om putación distribuida. Fundam entos y aplicaciones Basándose en el modelo RPC, han aparecido un gran número de interfaces d e pro­ gramación d e aplicaciones. Estas API permiten realizar llamadas a procedimientos re­ motos utilizando una sintaxis y una semántica similar a las de las llamadas a proce­ dimientos locales. Para enmascarar los detalles de la comunicación entre procesos, cada llamada a procedimiento remoto se transforma mediante una herramienta deno­ minada rp c g e n en una llamada a procedimiento local dirigida a un módulo software comúnmente denominado re a& iard o ( s tu t) o, más formalmente, /r o x jr Los mensa­ je s que representan la llamada al procedimiento y sus argumentos se pasan a la má­ quina remota a través del proxy. En el otro extremo, un proxy recibe el mensaje y lo transforma en una llamada a procedimiento local al procedimiento remoto. La Figura 7.4 muestra paso a paso la transformación de una llamada a procedimiento remoto en una llam ada a procedi­ miento local y e l paso de mensajes necesario. Nodo A ► Flujo d e ejecución Llam ada a procedim iento local Nodo A Nodo B 1. p ro e l en el nodo A realiza una llam ada a proc2 en nodo B. 2. El sop orte en tiem p o real con vie rte la llam ada en una llam ada al p ro x y d e l nodo A. 3. El p ro xy em paqueta los datos y realiza una llam ada IPC al pro xy d e l nodo B. 7. El p ro xy recibe el valor d e salida, desem paqueta los d a tos y envía el valor d e salida a p ro c2 , qu e con tinú a s u flujo d e ejecución. Llam ada a procedim iento rem oto fao se m uestra la ruta de ejecución de vuelta) 4. El p ro xy en el nodo B desem paqueta los da tos recibidos y realiza una llamada a proc2. 5. S e ejecu ta el c ó d ig o de proc2 y se devuelve el resultado al p ro xy d e l nodo B. 6. El p ro xy em paqueta el va lo r d e salida y realiza una llamada IPC al pro xy d e l nodo A. F ig u ra 7A . Llam ada a p ro c e d im ie n to lo cal fre n te a lla m a d a a p ro c e d im ie n to rem o to . H ay que destacar que hay que em plear un proxy a cada lado de la comunicación para proporcionar el soporte en tiem po de ejecución necesario para la comunicación entre procesos, llevándose a cabo el correspondiente empaquetado y desempaquetado de datos, así como las llam adas a sockets necesarias. www.FreeLibros.org O bjetos d istribu ido s 1 9 7 Desde su introducción a principios de los años 80, el modelo RPC se ha utiliza­ do ampliamente en las aplicaciones de red. Existen dos API que prevalecen en este paradigma. La primera, el API O p a t N e tw m k C m p u tin g R ea tó te P n o cetkn e CaO [ietf.org, 5], es una evolución del API d e RPC que desarrolló originalmente Sun M i­ crosystems, Inc., a principios de los años 80. La otra API popular es O pea G roup D k tríb u te d C cnjM itm g E m iro n m en t (DCE) RPC [opennc.org, 6]. Ambas interfaces proporcionan una herramienta, rpcgm , para transformar las llamadas a procedimien­ tos remotos en llamadas a procedimientos locales al resguardo. A pesar d e su importancia histórica, este libro no analiza en detalle RPC, por los siguientes motivos: • RPC, como su nombre indica, es orientado a procedimiento. Las API de RPC emplean una sintaxis que permite realizar llam adas a procedimiento o función. Por tanto, son más adecuadas para programas escritos en un lenguaje procedi- mental, tal como C. Sin embargo, no son adecuadas para programas escritos en Java, el lenguaje orientado a objetos adoptado en este libro. • En lugar de RPC, Java proporciona el API RMI, que es orientado a objetos y tiene una sintaxis más accesible que RPC. 7 .5 . R M I (REM O TE M ETHOD INVOCATIO RMI es una implementación orientada a objetos del modelo de llamada a procedi­ mientos remotos. Se trata de una API exclusiva para programas Java, aunque debido a su relativa simplicidad, se trata de un buen comienzo para los estudiantes que es­ tén aprendiendo a utilizar objetos distribuidos en aplicaciones de red. En RMI, un servidor de objeto exporta un objeto remoto y lo registra en un ser­ vicio de directorios. El objeto proporciona métodos remotos, que pueden invocar los programas clientes. Sintácticamente, un objeto remoto se declara como una in to fa z rem ota una ex­ tensión de la interfaz Java. El servidor d e objeto implementa la interfaz remota. Un cliente de objeto accede al objeto mediante la invocación de sus métodos, utilizando una sintaxis similar a las invocaciones de los métodos locales. El resto del capítulo se encargará de explorar en detalle e l API de Java RMI. 7 .6 . LA A R Q U IT E C T U R A DE JAVA R M I La Figura 7.5 muestra la arquitectura del API de Java RMI. Al igual que las API de RPC, la arquitectura de Java RMI utiliza módulos de software proxy para dar el so ­ porte en tiempo de ejecución necesario para transformar la invocación del método re­ moto en una llamada a un método local y gestionar los detalles de la comunicación entre procesos subyacente. Cada uno de los extremos de la arquitectura, cliente y ser­ vidor, está formado por tres capas de abstracción. A continuación se describen los dos extremos d e la arquitectura. P arte cliente de la arquitectura 1. La capa r e f i a d o o stu b La invocación de un método remoto por parte de un proceso cliente es dirigida a un objeto proxy, conocido como resépanlo. www.FreeLibros.org 198 C om putación distribuida. Fundam entos y aplicaciones Ruta de da tos física F ig u ra 7 .5 . La a rq u ite c tu ra d e J a v a RMI. Esta capa se encuentra debajo de la capa de aplicación y sirve para intercep­ tar las invocaciones d e los métodos remotos hechas por los programas clien­ tes; una vez interceptada la invocación es enviada a la capa inmediatamente inferior, la capa de referencia remota. 2. La capa d e refm m cia remota interpreta y gestiona las referencias a los ob­ jetos de servicio remoto hechas por los clientes, e invoca las operaciones en­ tre procesos de la capa siguiente, la capa de transporte, a fin de transmitir las llamadas a los métodos a la máquina remota. 3. La capa d e transporte está basada en TCP y por tanto, es orientada a cone­ xión. Esta capa y el resto de la arquitectura se encargan de la conexión entre procesos, transmitiendo los datos que representan la llamada al método a la máquina remota. P arte servidora de la arquitectura B esqueleto, el proxy de la parte servidora e stá «deprecated», e s decir, no s e utiliza en las nuevas versiones, a partir de la versión Ja v a 1.2. Su funcionalidad queda reemplazada por el uso de una técnica conocida como «reflexión». Este libro continúa incluyendo el esqueleto en la arquitectura como concepto d e la misma. Conceptualmente, la parte servidora de la arquitectura también está formada por tres capas de abstracción, aunque la implementación varía dependiendo de la versión de Java. 1. La capa esqueleto o sk d e to n se encuentra justo debajo d e la capa de aplica­ ción y se utiliza para interactuar con la capa resguardo en la parte cliente. Como se cita en [java.sun.com/products, 7], «La capa esqueleto se encarga de conversar con la capa resguardo; lee los parámetros de la invocación al método del enlace, realiza la llamada al ob­ jeto que implemento el servicio remoto, acepta el valor de retorno, y a con­ tinuación devuelve dicho valor al resguardo». www.FreeLibros.org O bjetos d istribu ido s 199 2. La capa d e referencia rem ota Esta capa gestiona y transforma la referencia remota originada por el cliente en una referencia local, que es capaz de com­ prender la capa esqueleto. 3. La capa d e transporte Al igual que en la parte cliente, se trata de una capa de transporte orientada a conexión, es decir, TCP en la arquitectura de red TCP/IP. Registro de los objetos El API d e RMI hace posible el uso de diferentes servicios de directorios para regis­ trar un objeto distribuido. Uno de estos servicios de directorios es la in te ría z d e no m ­ b r a d o y directorios d e J a v a (JNDI, Java Naming and Directory Interface), que es más general que e l registro RMI que se utilizará en este capítulo, en e l sentido de que lo pueden utilizar aplicaciones que no usan el API RMI. El registro RMI, rmiregistry, es un servicio de directorios sencillo proporcionado por el k it de desarrollo de soft­ ware Java (SDK, Java Software Development Kit). El registro RMI es un servicio cuyo servidor, cuando está activo, se ejecuta en la m á q u in a d d servidor d d objeto. Por convención, utiliza e l puerto TCP 1099 por defecto. Lógicamente, desde e l punto de vista del desarrollador de software, las invoca­ ciones a métodos remotos realizadas en un programa cliente interactúan directamente con los objetos remotos en un programa servidor, d e la misma forma que una llama­ da a un método local interactúa con un objeto local. Físicamente, las invocaciones del método remoto se transforman en llamadas a los resguardos y esqueletos en tiempo de ejecución, dando lugar a la transmisión de datos a través de la red. La Figura 7.6 es un diagrama de tiempos y eventos que describe la interacción entre el resguardo y el esqueleto. T iem p o M étodo rem otoPrograma cliente Resguardo Esqueleto Llamada a m étodo rem oto 1 Empaqueta los parámetros; envía la petición 1 Desempaqueta los parámetros; invoca el m étodo Ii i Ejecuta el código y devuelve un valor Recibe el va lo r de retorno; em paqueta la respuesta; envía la respuesta Desempaqueta la respuesta; envía el va lo r de retorno B SDK de Java se puede instalar en una máquina local. Permite el uso de bibliotecas de clases Java y herramientas, lales com o el com pilador de Java javac.__________ F ig u ra 7 .6 . In te ra c c io n e s e n tre el re s g u a rd o R M I y el e s q u e le to R M I (b a sa d o e n un dia g ra m a d e O ava .su n.com /do cs, 8]). www.FreeLibros.org 2 0 0 C om putación distribuida. Fundam entos y aplicaciones 7 .7 . A P I DE JAVA R M I En esta sección se introduce un subconjunto del API de Java RMI. (Por simplicidad, la presentación d e este capítulo no cubre los gestores d e seguridad, que es m uy reco­ mendable utilizarlos en todas las aplicaciones RMI. Los gestores de seguridad se expli­ can en la Sección 8.3 del próximo capítulo.) Esta sección cubre las siguientes áreas: la in to fa z rem ota el software de la pórte servidora y el software d é la parte d im te La interfaz rem ota En el API de RMI, el punto inicial para crear un objeto distribuido es una interfaz rem ota Java. Una interfaz Java es una clase que se utiliza como plantilla para otras clases: contiene las declaraciones d e los métodos que deben implementar las clases que utilizan dicha interfaz. Una interfaz remota Java es una interfaz que hereda de la clase Java ranote* que permite implementar la interfaz utilizando sintaxis RMI. Aparte de la extensión que se hace de la clase remóte y de que todas las declaraciones de los métodos deben es­ pecificar la excepción RemoteException, una interfaz remota utiliza la misma sintaxis que una interfaz Java local. A fin de mostrar la sintaxis básica, la Figura 7.7 muestra un ejem plo de interfaz remota. Figura 7.7. Un ejemplo de interfaz remota Java. 1 / / f i c h e r o : I n t e r f a z E j e m p l o . j a v a 2 / / im p le m e n ta d a p o r u n a c l a s e s e r v i d o r J a v a RM I. 3 4 i n p o r t j a v a . r m i . * 5 6 p u b l i c i n t e r f a c e I n t e r f a z E j e m p l o e x t e n d s R e m ó te { 7 / / c a b e c e r a d e l p r i m e r m é to d o r e m o to 8 p u b l i c S t r i n g m e t o d o E j l ( ) 9 th r o w s j a v a .r m i .R e m o t e E x c e p t i o n ; 10 / / c a b e c e r a d e l s e g u n d o m é to d o r e m o to 1 1 p u b l i c i n t m e to d o E j2 ( f l o a t p a r á m e t r o ) 12 th r o w s j a v a .r m i .R e m o t e E x c e p t i o n ; 13 / / c a b e c e r a s d e o t r o s m é to d o s r e m o to s 14 } / / f i n i n t e r f a z En este ejemplo, se declara una interfaz denominada InterfazEjemplo. La interfaz extiende o hereda la clase Java remóte (línea 6), convirtiéndose de este modo en una interfaz remota. Dentro del bloque que se encuentra entre las llaves (líneas 6-14) se encuentran las declaraciones de los dos m étodos remotos, que se llaman m etodoEjl (líneas 8-9) y metodoEj2 (líneas 11-12), respectivamente. Como se puede observar, m etodoEjl no requiere argumentos (de ahí la lista de pa­ rámetros vacía detrás del nombre del método) y devuelve un objeto de tipo String. El método metodoEj2 requiere un argumento de tipo flo a t y devuelve un valor de tipo int. Obsérvese que un objeto serializable, tal como un objeto String o un objeto de otra clase, puede ser un argumento o puede ser devuelto por un método remoto. Al www.FreeLibros.org O bjetos d istribu ido s 2 0 1 método remoto se le pasa una copia del elemento (específicamente, una copia del ob­ jeto), sea éste un tipo primitivo o un objeto. El valor devuelto se gestiona de la mis­ ma forma, pero en la dirección contraria. Cada declaración de un método debe especificar la excepción java.rmi.RemoteEx­ ception en la sentencia throws (líneas 9 y 12). Cuando ocurre un error durante el pro­ cesamiento de la invocación del método remoto, se lanza una excepción de este tipo, que debe ser gestionada en el programa del método que lo invoca. Las causas que originan este tipo de excepción incluyen los errores que pueden ocurrir durante la co­ municación entre los procesos, tal como fallos de acceso y fallos de conexión, así como problemas asociados exclusivamente a la invocación de métodos remotos, como por ejemplo no encontrar el objeto, e l resguardo o el esqueleto. S oftw are de la parte servidora Un servidor de objeto es un objeto que proporciona los métodos y la interfaz de un objeto distribuido. Cada servidor de objeto debe (1) implementar cada uno de los mé­ todos remotos especificados en la interfaz, y (2) registrar en un servicio de directo­ rios un objeto que contiene la implementación. Se recomienda que las dos partes se realicen en clases separadas, como se ilustra a continuación. La im ple m en tación de la interfaz rem ota Se debe crear una clase que implemente la interfaz remota. La sintaxis es similar a una clase que implementa una interfaz local. La Figura 7.8 muestra un esquema o plantilla de la implementación. F ig u ra 7.8 . S in ta x is d e un e je m p lo d e im p le m e n ta c ió n d e in te rfa z rem ota. 1 i m p o r t j a v a . r m i . * ; 2 ■3 i m p o r t j a v a . r m i . s e r v e r . * ; O 4 /* * 5 E s t a c l a s e im p le m e n ta l a i n t e r f a z r e m o ta I n t e r f a z E j e m p l o . 6 7 * / 8 p u b l i c c l a s s I m p lE je m p lo e x t e n d s U n ic a s t R e m o te O b je c t 9 im p le m e n ts I n t e r f a z E j e m p l o { 10 11 p u b l i c I m p lE je m p lo ( ) th r o w s R e m o te E x c e p tio n { 12 s u p e r ( ) ; 13 } 14 15 p u b l i c m e to d o E j1 ( ) th r o w s R e m o te E x c e p tio n { 16 / / c ó d i g o d e l m é to d o 17 > 18 19 p u b l i c m e t o d o E j 2 ( ) t h r o w s R e m o te E x c e p tio n { 20 / / c ó d i g o d e l m é to d o 21 } 22 23 } / / f i n c l a s e Un objeto señalizable es un objeto d e una clase que puede «aplanarse», de forma que s e puede em paquetar para su transmisión a través de la red. www.FreeLibros.org 2 0 2 C om putación distribuida. Fundam entos y aplicaciones Las sentencias de importación (import) (líneas 1-2) son necesarias para que el có­ digo pueda utilizar las clases UnicastRemoteObject y RemoteException. La cabecera d e la clase (línea 8) debe especificar (1) que es una subclase de la clase Java UnicastRemoteObject, y (2) que implementa una interfaz remota específi­ ca, llamada InterfazEjemplo en la plantilla. (Nota: Un objeto UnicastRemoteObject da soporte a RMI unicast, es decir, RMI utilizando comunicación unidifusión entre pro­ cesos. Presumiblemente, se puede implementar una clase Muí ticas tRemoteObject, que dé soporte a RMI con comunicación multidifusión.) S e debe definir un constructor de la clase (líneas 11-13). La primera línea del có­ digo debe ser una sentencia (la llam ada super()) que invoque al constructor de la cla­ se base. Puede aparecer código adicional en el constructor si se necesita. A continuación, debe aparecer la implementación de cada método remoto (líneas 15-21). La cabecera d e cada método debe coincidir con la cabecera de dicho método en e l fichero de la interfaz. L a Figura 7.9 muestra un diagrama UML para la clase ImplEjemplo. F ig u ra 7.9. El d ia g ra m a d e c la s e s U M L pa ra Im plE jem plo. G e n e ració n del re sgu a rd o y del esqueleto En RMI, un objeto distribuido requiere un proxy por cada uno de los servidores y clientes de objeto, conocidos como esqueleto y resguardo del objeto, respectivamen­ te. Estos proxies se generan a partir d e la implementación de una interfaz remota uti­ lizando una herramienta del SDK de Java: e l compilador RMI m e Para utilizar esta herramienta, se debe ejecutar e l siguiente mandato en una interfaz de mandatos UNIX o Windows: r m ic < n o m b re d e l a c l a s e d e l a i n p l e m e n t a c i ó n d e l a i n t e r f a z re r o o ta > Por ejemplo: r m ic Im p lE je m p lo S i la compilación se realiza de forma correcta, se generan dos ficheros proxy, cada uno de ellos con el prefijo correspondiente al nombre de la clase d e la implementa­ ción. Por ejemplo, ImplEjemplo_skel. class y Impl Ejemplo_stub. class. www.FreeLibros.org O bjetos d istribu ido s 203 El fichero del resguardo para el objeto, así como el fichero de la interfaz remota deben compartirse con cada cliente de objeto: estos ficheros son imprescindibles para que el programa cliente pueda compilar correctamente. Una copia de cada fichero debe colocarse manualmente en la parte cliente (es decir, debe colocarse una copia del fi­ chero en un directorio apropiado del cliente). Adicionalmente, Java RMI dispone de una característica denominada d e s c a g a d e resguardo, que consiste en que e l clien­ te obtiene de forma dinámica e l fichero de resguardo. Esta característica se estudiará en el Capítulo 8, donde se analizan varios tem as avanzados de RMI. El s e rvid o r de objeto La clase del servidor de objeto instancia y exporta un objeto de la implementación de la interfaz remota. L a Figura 7.10 muestra una plantilla para la clase del servidor de objeto. F ig u ra 7.1 0. Sintaxis de un ejemplo de un servidor de objeto. 1 i m p o r t j a v a . r m i . * ; 2 i m p o r t j a v a . r m i . s e r v e r . * ; 3 i m p o r t j a v a . r m i . r e g i s t r y . R e g i s t r y ; 4 i m p o r t j a v a . r m i . r e g i s t r y . L o c a t e R e g i s t r y ; 5 i m p o r t j a v a . n e t . * ? 6 i m p o r t j a v a . i o . * ; 7 8 /** 9 * E s t a c l a s e r e p r e s e n t a e l s e r v i d o r d e u n o b j e t o 10 * d i s t r i b u i d o d e l a c l a s e I m p lE je m p lo , q u e im p le m e n ta l a 11 * i n t e r f a z r e m o ta I n t e r f a z E j e m p l o . 12 */ 13 14 p u b l i c c l a s s S e r v i d o r E j e m p l o { 15 p u b l i c s t a t i c v o i d m a i n ( S t r i n g a r g s [ ] ) { 16 S t r i n g num P u erto R M I, U R L R e g is tro ; 17 t r y { 18 / / c ó d ig o q u e p e r m i t e o b t e n e r e l v a l o r d e l n ú m ero d e p u e r t o 19 Im p lE je m p lo c b j E x p o r t a d o = new I n p l E j e m p l o ( ) ; 20 a r r a n c a r R e g i s t r o (n u m P u e rto R M I) ; 2 1 / / r e g i s t r a r e l o b j e t o b a j o e l n o m b re \" e je m p lo \" 22 U R L R e g is tro = \" r m i : / / l o c a l h o s t : \" + n u m P u e r to + \" / e j e m p l o \" ; 23 N a m in g .r e b in d ( U R L R e g is tr o , o b j E x p o r t a d o ) ; 24 S y s t e m . o u t . p r i n t l n ( \" S e r v i d o r e je m p lo p r e p a r a d o . \" ) ; 25 } / / f i n t r y 26 c a t c h ( E x c e p t i o n e x c r ) { 27 S y s t e m . o u t . p r i n t l ( 28 \" E x c e p c ió n e n S e r v i d o r E j e m p l o .m a i n : \" + e x c r ) ; 29 } / / f i n c a t c h 30 } / / f i n m a in 31 32 / / E s t e m é to d o a r r a n c a u n r e g i s t r o RMI e n l a m á q u in a 33 / / l o c a l , s i n o e x i s t e e n e l n ú m e ro d e p u e r t o e s p e c i f i c a d o (continúa) www.FreeLibros.org 2 0 4 C om putación distribuida. Fundam entos y aplicaciones Una colisión d e nombres se produce cuando s e intenta exportar un objeto cuyo nombre coincide con el nombre d e otro cbjeto ya existente en el registro.________________ 34 p r i v a t e s t a t i c v o i d a r r a n c a r R e g i s t r o ( i n t n u m P u erto R M I) 35 th r o w s R e m o te E x c e p tio n { 36 t r y { 37 R e g i s t r y r e g i s t r o = L o c a te R e g is try .g e tR e g is try (n u m P u e rtó R M I) ; 38 r e g i s t r o . l i s t ( ) ; 39 / / E l m é to d o a n t e r i o r l a n z a u n a e x c e p c i ó n 40 / / s i e l r e g i s t r o n o e x i s t e . 41 } 42 c a t c h (R e m o te E x c e p tio n e x c ) { 43 // N o e x i s t e u n r e g i s t r o v á l i d o e n e s t e p u e r t o . 44 S y s te m . o u t . p r i n t l n ( 45 \" E l r e g i s t r o RMI n o s e p u e d e l o c a l i z a r e n e l p u e r t o : 46 + R M IPortN um ) ; 47 R e g i s t r y r e g i s t r o = I o c a te R e g is t r y . c r e a t e R e g i s t r y (numPuertoRMI) ; 48 S y s te m . o u t . p r i n t l n ( 49 \" R e g i s t r o RMI c r e a d o e n e l p u e r t o \" + R M IP o rtN u m ); 50 > / / f i n c a t c h 51 } / / f i n a r r a n c a r R e g i s t r o 52 53 > / / f i n c l a s e En los siguientes párrafos se analizan las diferentes partes de esta plantilla. Creación d e un objeto d e la n t^ía n a É a ciÓ D d é l a interfaz ran ota En la línea 19, se crea un objeto de la clase que m ^ lo n e n É a la interfaz remota; a continuación, se « p o r t a r á la referencia a este objeto. Exportación d d objeto Las líneas 20-23 de la plantilla exportan el objeto. Para exportar el objeto, se debe registrar su referencia en un servicio de directorios. Como ya se ha mencionado anteriormente, en este capítulo se utilizará el servicio rmiregistry del SDK Java. Un servidor rmiregistry debe ejecutarse en e l nodo del servidor de ob­ jeto para poder registrar objetos RMI. Cada registro RMI mantiene una lista de objetos exportados y posee una interfaz para la búsqueda de estos objetos. Todos los servidores de objetos que se ejecutan en la misma máquina pueden compartir un mismo registro. Alternativamente, un proce­ so servidor individual puede crear y utilizar su propio registro si lo desea, en cuyo caso múltiples servidores rmiregistry pueden ejecutarse en diferentes números d e puer­ tos en la misma máquina, cada uno con una lista diferente de objetos exportados. En un sistema de producción, debería existir un servidor rmiregistry, ejecutando de forma continua, presumiblemente en el puerto por defecto 1099. Para los ejemplos de este libro, se supone que existe un registro RMI siem pre disponible, aunque se uti­ liza código para arrancar una copia del servidor bajo demanda en un puerto de la elec­ ción del lector, de forma que cada estudiante pueda utilizar una copia diferente del registro para sus experimentos y no existan colisiones d e nombres. En la plantilla del servidor de objeto, se imple menta el método estático arrancar Registro() (líneas 34-51), que arranca un servidor de registro RMI si no está actual­ mente en ejecución, en un número de puerto especificado por el usuario (línea 20): a r r a n c a r R e g i s t r o ( n u m P u erto R M I) ; En un sistema de producción donde se utilice el servidor de registro RMI por de­ fecto y esté ejecutando continuamente, la llamada arrancarRegistro y, por tanto, el método arrancarRegistro, puede omitirse. www.FreeLibros.org O bjetos d istribu ido s 2 0 5 En la plantilla del servidor de objeto, e l código para exportar un objeto (líneas 22- 23) se realiza del siguiente modo: / / r e g i s t r a r e l o b j e t o c o n e l n o m b re 11 e je m p lo \" t B L R e g i s t r o = \"m i : / / l o c a l h o s t : \" + n u m P u e r to + \" / e j e m p l o \" ; N am in g . r e b i n d ( U R L R e g is tro , o b j E x p o r t a d o ) ; L a clase Naming proporciona métodos para almacenar y obtener referencias del registro. En particular, el método rebind permite almacenar en el registro una refe­ rencia a un objeto con un URL de la forma: r m i: // < n o m b r e m á q u in a > : < n ú m ero p u e r t O > /< n a n b r e r e f e r e n c i a > El método rebind sobreescribe cualquier referencia en el registro asociada al nom­ bre de la referencia. S i no se desea sobreescribir, existe un método denominado bind. El nombre de la máquina debe corresponder con el nombre del servidor, o sim ­ plemente se puede utilizar «localhost». El nombre de la referencia es un nombre ele­ gido por el programador y debe ser único en el registro. El código del ejem plo comprueba primero si se está ejecutando actualmente un re­ gistro RMI en el puerto por defecto. S i no es así, se activa un registro RMI. Alternativamente, se puede activar un registro RMI manualmente utilizando la uti­ lidad rmiregistry, que se encuentra en e l SDK, a través de la ejecución del siguiente mandato en el intérprete de mandatos: r m i r e g i s t r y < n ú m ero p u e r t o donde el núm ero de puerto es un número de puerto TCR Si no se especifica ningún puerto, se utiliza el puerto por defecto 1099. Cuando se ejecuta un servidor de objeto, la exportación de los objetos distribui­ dos provoca que e l proceso servidor comience a escuchar por el puerto y espere a que los clientes se conecten y soliciten el servicio del objeto. Un servidor de objeto RMI es un servidor concurrente: cada solicitud de un cliente de objeto se procesa a través de un hilo independiente del servidor. Dado que las invocaciones de los métodos re­ motos se pueden ejecutar de forma concurrente, es importante que la implementación de un objeto rem oto sea thread-safe. Los lectores pueden revisar este tem a en «Pro­ gramación concurrente» en el Capítulo 1. S oftw are de la parte cliente La clase cliente es como cualquier otra clase Java. La sintaxis necesaria para hacer uso de RMI supone localizar el registro RMI en el nodo servidor y buscar la refe­ rencia remota para el servidor de objeto; a continuación se realizará un cast de la re­ ferencia a la clase de la interfaz remota y se invocarán los métodos remotos. La Fi­ gura 7.11 presenta una plantilla para el cliente d e objeto. F ig u ra 7.1 1 . P lantilla para un c lie n te d e o b je to . 1 i m p o r t j a v a . i o . * ; 2 i m p o r t j a v a . r m i . * ; 3 i m p o r t j a v a . r m i . r e g i s t r y . R e g i s t r y ; 4 i m p o r t j a v a . r m i . r e g i s t r y . L o c a t e R e g i s t r y ; 5 6 /** (continúa) www.FreeLibros.org 2 0 6 C om putación distribuida. Fundam entos y aplicaciones 7 * E s t a c l a s e r e p r e s e n t a e l c l i e n t e d e u n o b j e t o 8 * d i s t r i b u i d o d e l a c l a s e I m p lE je m p lo , q u e im p le m e n ta l a 9 * i n t e r f a z r e m o ta I n t e r f a z E j e m p l o . 10 */ 11 12 p u b l i c c l a s s C l i e n t e E j e m p l o { 13 p u b l i c s t a t i c v o i d m a i n ( S t r i n g a r g s [ ] ) { 14 t r y { 15 i n t p u e rto R M I; 16 S t r i n g n o m b reN o d o ; 17 S t r i n g n u m P u e r to ; 18 / / C ó d ig o q u e p e r m i t e o b t e n e r e l n a n b r e d e l n o d o y 19 e l n ú m ero d e p u e r t o d e l r e g i s t r o 20 21 / / B ú s q u e d a d e l o b j e t o r e m o to y c a s t d e l a 22 / / r e f e r e n c i a c o n l a c o r r e s p o n d i e n t e c l a s e 23 / / d e l a i n t e r f a z r e m o ta — r e e m p l a z a r \" l o c a l h o s t p o r e l nom bre d e l n o d o d e l o b j e t o r e m o t o . 24 S t r i n g U R L R e g is tro = 25 \" r m i : / / l o c a l h o s t : \" + n u m P u e r to + \" / e j e m p l o \" ; 26 I n t e r f a z E j e m p l o h = 27 ( I n t e r f a z E j e m p l o ) N a m in g .lo o k u p ( U R L R e g is tr o ) ; 28 / / i n v o c a r e l o l o s m é to d o s r e m o to s 29 S t r i n g m e n s a je = h . m e t o d o E j l ( ) ; 30 Sy s t e m . o u t . p r i n t l n ( m e n s a j e ) ; 31 / / e l m é to d o m e to d o E j2 p u e d e i n v o c a r s e d e l m ism o modo 32 > / / f i n t r y 33 c a t c h ( E x c e p t i o n e x c ) { 3 4 e x c . p r i n t S t a c k T r a c e ( ) ; 35 } / / f i n c a t c h 36 } / / f i n m a in 37 / / P o s i b l e d e f i n i c i ó n d e o t r o s m é to d o s d e l a c l a s e 38 } / / f i n c l a s e Las sentencias de inqwrtacién. Las sentencias d e importación (líneas 1-4) se ne­ cesitan para que el programa pueda compilar. Búsqueda d d objeto rem ota El código entre las líneas 24 y 27 permite buscar el objeto remoto en el registro. El método lookup de la clase Naming se utiliza para obtener la referencia al objeto, si existe, que previamente ha almacenado en el regis­ tro e l servidor de objeto. Obsérvese que se debe hacer un cast de la referencia obte­ nida a la clase de la interfaz rem ota (no a su implementación). S t r i n g U R L R e g is tro = \" m i : / / l o c a l h o s t : \" + n u m P u e r to + \" / e j e m p l o \" ; I n t e r f a z E j e m p l o h = ( I n t e r f a z E j e m p l o )N a m in g . l o o k u p ( U R L R e g is tro ) ; In v o cació n d d m é to d o re m o ta Se utiliza la referencia a la interfaz remota para invocar cualquiera de los métodos de dicha interfaz, como se muestra en las líneas 29-30 del ejemplo: S t r i n g m e n s a je = h . m e t o d o E j l ( ) ; S y s t e m . o u t . p r i n t l n ( m e n s a j e ) ; www.FreeLibros.org O bjetos d istribu ido s 2 0 7 Obsérvese que la sintaxis utilizada para la invocación de los métodos remotos es igual que la utilizada para invocar métodos locales. 7 .8 . U N A A P L IC A C IÓ N R M I DE E JE M P LO Desde la Figura 7.12 hasta la Figura 7.15 se muestra la lista completa de ficheros ne­ cesarios para crear la aplicación RMI HolaMundo. El servidor exporta un objeto que contiene un único método, denominado decirHola. Se recom ienda al lector identificar en el código las diferentes partes que se han descrito en la sección anterior. F ig u ra 7.1 2 . H olaM undoInt.java. 1 / / U n e je m p lo s e n c i l l o d e i n t e r f a z RMI - M. L i u 2 i m p o r t j a v a . r m i . * ; 3 4 / * * 5 * I n t e r f a z r e m o t a . 6 * 0 a u t h o r M. L . L i u 7 * / 8 9 p u b l i c i n t e r f a c e H o la M u n d o In t e x t e n d s R e m ó te { 10 / * * 11 * E s t e m é to d o r e m o to d e v u e l v e u n m e n s a j e . 12 * § p a r a ñam e — u n a c a d e n a d e c a r a c t e r e s c o n u n n o m b re . 13 * 0 r e t u r n - u n a c a d e n a d e c a r a c t e r e s . 14 * / 15 p u b l i c S t r i n g d e c i r H o l a ( S t r i n g n o m b re ) 16 th r o w s j a v a .r m i .R e m o t e E x c e p t i o n ; 17 18 } F ig u ra 7 .1 3 . H olaM undoIm pl.java. 1 import java.rmi.*; 2 import java.rmi.server.*; 3 4 / * * 5 * Esta clase implementa la interfaz remota 6 * HolaMundoInt. 7 * @author M. L. Liu 8 */ 9 10 public class HolaMundoInpl extends UnicastRemoteObject 11 implements HolaMundoInt { 12 13 public HolaMundoIirpl () throws RemoteException { 14 super(); 15 > 16 (continúa) www.FreeLibros.org 2 0 8 C om putación distribuida. Fundam entos y aplicaciones 17 p u b l i c S t r i n g d e c i r H o l a ( S t r i n g n o m b re ) 18 th r o w s R e m o te E x c e p tio n { 19 r e t u r n \" H o la m undo\" + n o m b re ; 20 } 21 } / / f i n c l a s e F ig u ra 7.1 4. H olaM undoServidor.java. 1 i m p o r t j a v a . r m i . * ; 2 i m p o r t j a v a . r m i . s e r v e r . * ; 3 i m p o r t j a v a . r m i . r e g i s t r y . R e g i s t r y ; 4 i m p o r t j a v a . r m i . r e g i s t r y . L o c a t e R e g i s t r y ; 5 i m p o r t j a v a . n e t . * ; 6 7 i m p o r t j a v a . i o . * ; / 8 /* * 9 * E s t a c l a s e r e p r e s e n t a e l s e r v i d o r d e u n o b j e t o 10 * d e l a c l a s e H o laM undo , q u e im p le m e n ta l a 11 * i n t e r f a z r e m o ta H o la M u n d o I n te r f a z . 12 * @ a u th o r M. L . L i u 13 * / 14 15 p u b l i c c l a s s H o la M u n d o S e r v id o r { 16 p u b l i c s t a t i c v o i d m a in ( S t r i n g a r g s [ ] ) { 17 I n p u t S tr e a m R e a d e r e n t = new I n p u t S t r e a m R e a d e r ( S y s t e m . i n ) ) ; 18 B u f f e r e d R e a d e r b u f = new B u f f e r e d R e a d e r ( e n t ) ; 19 S t r i n g n u m P u e r to , U R L R e g is tro ; 20 t r y { 21 S y s t e m . o u t . p r i n t l n ( \" I n t r o d u c i r e l n ú m ero d e p u e r t o d e l r e g i s t r o RM I: \" ) ; 22 n u m P u e rto = b u f . r e a d L i n e ( ) . t r i m ( ) ; 23 i n t num PuertóR M I = I n t e g e r . p a r s e l n t ( n u m P u e r to ) ; 24 a r r a n c a r R e g i s t r o ( n u m P u e r t ó R M I ) ; 25 H o la M u n d o In p l o b j E x p o r t a d o = new H o la M in d o Im p l( ) ; 26 U R L R e g istro = \" r m i : / / l o c a l h o s t : \"+ n u m P u e rto + \" /h o la M u n d o \" ; 27 N am in g . r e b i n d ( U R L R e g is tro , o b j E x p o r t a d o ) ; 28 / * * / S y s t e m . o u t . p r i n t l n 29 / * * / ( \" S e r v i d o r r e g i s t r a d o . E l r e g i s t r o c o n t i e n e a c t u a l m e n t e : \" ) ; 30 / * * / / / l i s t a d e l o s n o m b re s q u e s e e n c u e n t r a n e n e l r e g i s t r o a c t u a l m e n t e 31 / * * / l i s t a R e g i s t r o ( U R L R e g is tr o ) ; 32 S y s te m , o u t . p r i n t l n ( \" S e r v i d o r H olaM undo p r e p a r a d o . \" ) ; 33 } / / f i n t r y 34 c a t c h ( E x c e p t i o n e x c r ) { 35 S y s t e m . o u t . p r i n t l n ( \" E x c e p c i ó n e n H o la M u n d o S e r v id o r .m a in : \" + e x c r ) ; 36 > / / f i n c a t c h 37 } / / f i n m a in 38 ( continúa) www.FreeLibros.org 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 1 2 3 4 5 6 7 8 9 10 11 12 13 14 O bjetos d istribu ido s 2 0 9 / / E s t e m é to d o a r r a n c a u n r e g i s t r o RMI e n l a m á q u in a / / l o c a l , s i n o e x i s t e e n e l n ú m ero d e p u e r t o e s p e c i f i c a d o , p r i v a t e s t a t i c v o i d a r r a n c a r R e g i s t r o ( i n t n u m P u erto R M I) th r c w s R e m o te E x c e p tio n { t r y { R e g i s t r y r e g i s t r o = L o c a te R e g is try .g e tR e g is try (n u m P u e rto R M I) ; r e g i s t r o . l i s t ( ) ; / / E s t a l l a m a d a l a n z a / / u n a e x c e p c i ó n s i e l r e g i s t r o no e x i s t e > c a t c h ( R e m o te E x c e p tio n e ) { / / R e g i s t r o n o v á l i d o e n e s t e p u e r t o / * * / S y s te m , o u t . p r i n t l n / * * / ( \" E l r e g i s t r o RMI n o s e p u e d e l o c a l i z a r e n e l p u e r t o \" / * * / + n u m P u e rto R M I); R e g i s t r y r e g i s t r o = L o c a t e R e g i s t r y . c r e a t e R e g i s t r y ( n u m P u erto R M I) ; / * * / S y s te m , o u t . p r i n t l n ( / * * / \" R s g i s t r o RMI c r e a d o e n e l p u e r t o \" + n u m P u e rto R M I); } / / f i n c a t c h } / / f i n a r r a n c a r R e g i s t r o / / E s t e m é to d o l i s t a l o s n a n b r e s r e g i s t r a d o s co n u n o b j e t o R e g i s t r y p r i v a t e s t a t i c v o i d l i s t a R e g i s t r o (S t r i n g U R L R e g is tro ) th r o w s R e m o t e E x c e p t io n , M a lfo rm e d U R L E x c e p tio n { S y s te m , o u t . p r i n t l n ( \" R e g i s t r o \" + U R L R e g istro * \" c o n t i e n e : \" ) ; S t r i n g [ ] n o m b re s = N a m i n g . l i s t ( U R L R e g is tr o ) ; f o r ( i n t i = 0 ; i< n o m b r e s . l e n g t h ; i+ + ) S y s te m , o u t . p r i n t l n ( ñam es[ i ]) ; } / / f i n l i s t a R e g i s t r o } / / f i n c l a s e F ig u ra 7.1 5 . H olaM undoC liente.java. i m p o r t j a v a . i o . * ; i m p o r t j a v a . r m i . * ; /** * E s t a c l a s e r e p r e s e n t a e l c l i e n t e d e u n o b j e t o * d i s t r i b u i d o d e c l a s e H olaM undo, q u e i i r p l e m e n t a l a * i n t e r f a z r e m o ta H o la M u n d o I n te r f a z . * 0 a u t h o r M. L . L i u */ p u b l i c c l a s s H o la M u n d o C lie n te { p u b l i c s t a t i c v o i d m a i n ( S t r i n g a r g s [ ] ) { t r y { (continúa) www.FreeLibros.org 210 C om putación distribuida. Fundam entos y aplicaciones 15 i n t n u m P u erto R M I; 16 S t r i n g n o m b reN o d o ; 17 I n p u t S tr e a m R e a d e r e n t = new I n p u t S t r e a m R e a d e r ( S y s te m , i n ) ; 18 B u f f e r e d R e a d e r b u f = new B u f f e r e d R e a d e r ( e n t ) ; 19 S y s t e m . o u t . p r i n t l n ( \" I n t r o d u c i r e l n o m b re d e l n o d o d e l r e g i s t r o R M I :\" ) ; 20 n o n b re N o d o = b u f . r e a d L i n e ( ) ? 21 S y s t e m . o u t . p r i n t l n ( \" I n t r o d u c i r e l n u m ero d e p u e r t o d e l r e g i s t r o R M I :\" ) ; 22 S t r i n g n u m P u e rto = b u f . r e a d L i n e ( ) ; 23 num PuertoR M I = I n t e g e r . p a r s e l n t ( n u m P u e r t o ) ; 24 S t r i n g U R L R e g is tro = 25 \" m i : / / \" + nom breN odo + \" : \" + n u m P u e r to + \" /h o la M u n d o \" ; 26 / / B ú sq u e d a d e l o b j e t o re m o to y c a s t d e l o b j e t o d e l a i n t e r f a z 27 H o la M u n d o I n te r f a z h = 28 ( H o la M u n d o I n te r f a z ) N a m i n g .lo o k u p ( U R L R e g i s tr o ) ; 29 Sy s t e m . o u t . p r i n t l n ( \" B ú s q u e d a c o m p l e t a \" ) ; 30 / / I n v o c a r e l m é to d o r e m o to 31 S t r i n g m e n s a je = h . d e c i r H o l a ( \" P a t o D o n a l d \" ) ; 32 S y s t e m . o u t . p r i n t l n ( \" H o l a M u n d o C l i e n t e : \" + m e n s a j e ) ; 33 } / / f i n t r y 34 c a t c h ( E x c e p t i o n e ) { 35 S y s t e m . o u t . p r i n t l n ( \" E x c e p c ió n e n H o la M u n d o C lie n te : \" + e ) ; 36 > / / f i n c a t c h 37 } / / f i n m a in 38 } / / f i n c l a s e Una vez comprendida la estructura básica del ejemplo de aplicación RMI presen­ tado, el lector debería ser capaz de utilizar esta sintaxis como plantilla para construir cualquier aplicación RMI, modificando la presentación y la lógica de la aplicación; la lógica del servicio (utilizando RMI) queda inalterada. La tecnología RMI es un buen candidato como componente software en la capa de servicio. Un ejemplo de aplicación industrial es un sistem a de informe de gastos de una empresa, que se muestra en la Figura 7.16 y que se describe en [java.sun.com/ marketing, 8]. En la aplicación mostrada, el servidor de objeto proporciona métodos remotos que permiten a los clientes de objeto buscar o actualizar los datos en una base de datos de gastos. Los programas clientes del objeto proporcionan la lógica de aplicación o negocio necesaria para procesar los datos y la lógica de presentación para la interfaz de usuario. Java RMI posee un gran número de características. Este capítulo ha presentado un conjunto m uy básico de estas características, como ejem plo de un sistem a de objetos distribuidos. Algunas d e las características avanzadas de RMI más interesantes se des­ cribirán en el siguiente capítulo. 7 .9 . PASOS PARA C O N S TR U IR U N A A P L IC A C IÓ N R M I Una vez vistos algunos de los aspectos del API de RMI, se va a pasar a describir paso a paso e l procedimiento para construir una aplicación RMI, de forma que el lector www.FreeLibros.org O bjetos d istribu ido s 2 1 1 F ig u ra 7.1 6. Un e je m p lo d e a p lic a c ió n RMI. pueda experimentar con dicho paradigma. S e describe tanto la parte del servidor de objeto como del cliente de objeto. Hay que tener en cuenta que en un entorno de pro­ ducción es probable que el desarrollo de software de ambas partes sea independiente. El algoritmo es expresado en términos de una aplicación denominada Ejemplo. Los pasos se aplicarán para la construcción de cualquier aplicación, reemplazando el nom­ bre Ejemplo por el nombre de la aplicación. Algoritm o para desarrollar el softw are de la parte servidora 1. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 2. Especificar la interfaz remota del servidor en InterfazEjemplo.java. Compilar­ la y revisarla hasta que no exista ningún error d e sintaxis. 3. Implementar la interfaz en ¡mplEjemplo.java. Compilarla y revisarla hasta que no exista ningún error d e sintaxis. 4. Utilizar el compilador de RMI n n c para procesar la clase de la implementa­ ción y generar los ficheros de resguardo y esqueleto para e l objeto remoto: r m ic I m p lE je m p lo Los ficheros generados se encontrarán en el directorio como ImplEjemplo_SkeLclass e ImplEjemplo_Stub.class. Se deben repetir los pasos 3 y 4 cada vez que se reali­ ce un cambio a la implementación de la interfaz. 5. Crear el programa del servidor de objeto Servidor Ejemplo.java. Compilarlo y revisarlo hasta que no exista ningún error de sintaxis. 6. Activar el servidor de objeto, j a v a S e r v i d o r E j e m p l o www.FreeLibros.org 212 C om putación distribuida. Fundam entos y aplicaciones Algoritm o para desarrollar el softw are de la parte cliente 1. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 2. Obtener una copia del fichero class de la interfaz remota. Alternativamente, obtener una copia del fichero fuente d e la interfaz remota y compilarlo utili­ zando Ja va c para generar e l fichero class de la interfaz. 3. Obtener una copia del fichero de resguardo para la implementación de la in­ terfaz, ImplEjemplo_Stub. class. 4. Desarrollar el programa cliente ClienteEjemplo.java. Compilarlo y revisarlo hasta que no exista ningún error d e sintaxis. 5. Activar e l cliente, j a v a C l i e n t e E j e m p lo La Figura 7.17 muestra la colocación de los ficheros de una aplicación en las partes cliente y servidora. Los ficheros class de la interfaz remota y del resguardo para cada objeto remoto deben estar en la máquina donde se encuentra el cliente de objeto, ju n ­ to con la clase del cliente de objeto. En la parte servidora se deben encontrar los fi­ chero class d e la interfaz, del servidor de objeto, de la implementación de la interfaz y del esqueleto para e l objeto remoto. N o d o d e l c lie n te d e o b je to N o d o d e l se rv id o r d e o b je to D irectorio del cliente de objeto InterfazEjempIo.class ClienteEjempIo.class lmplEjemplo_Stub.class D irectorio del servidor de objeto InterfazEjempIo.class ServidorEjemplo. class ImplEjemplo.class lmplEjemplo_Stub.class F ig u ra 7.1 7 . C o lo c a c ió n d e lo s fic h e ro s e n un a a p lic a c ió n RMI. 7 .1 0 . PR UEB A S Y D EPU R A C IÓ N Como cualquier tipo de programación de red, las pruebas y depuración de los proce­ sos concurrentes no son triviales. Es recomendable utilizar los siguientes pasos incre­ méntales a la hora de desarrollar una aplicación RMI: 1. Construir una plantilla para un programa RMI básico. Empezar con una interfaz remota que sólo contenga la declaración de un método, su implementación uti­ www.FreeLibros.org O bjetos d istribu ido s 2 1 3 lizando un resguardo, un programa servidor que exporte el objeto y un progra­ ma cliente con código que sólo invoque al método remoto. Probar la plantilla en una máquina hasta que se pueda ejecutar correctamente el método remoto. 2. Añadir una declaración cada vez a la interfaz. Con cada adición, modificar el programa cliente para que invoque al método que se ha añadido. 3. Rellenar la definición de cada método remoto uno a uno. Probar y depurar de forma detallada cada método añadido antes d e incluir el siguiente. 4. Después de que todos los métodos remotos se han probado detalladamente, crear la aplicación cliente utilizando una técnica incremental. Con cada incre­ mento, probar y depurar los programas. 5. Distribuir los programas en máquinas separadas. Probarlos y depurarlos. 7 .1 1 . C O M PA R A C IÓ N EN TR E R M I Y EL A P I DE SOCKETS El API de RMI, como API representativa del paradigma d e objetos distribuidos, es una herramienta eficiente para construir aplicaciones de red. Puede utilizarse en lugar del API de sockets (que representa el paradigma de paso de mensajes) para construir una aplicación de red rápidamente. Sin embargo, debería tenerse en cuenta que ade­ más de ventajas, tam bién existen desventajas en esta opción. Algunas de estas ventajas y desventajas se enumeran a continuación: • El API de sockets está más cercano al sistem a operativo, por lo que tiene me­ nos sobrecarga de ejecución. RMI requiere soporte software adicional, inclu­ yendo los proxies y el servicio de directorio, que inevitablemente implican una sobrecarga en tiempo de ejecución. Para aplicaciones que requieran alto rendi­ miento, el API de sockets puede ser la única solución viable. • Por otro lado, e l API de RMI proporciona la abstracción necesaria para facili­ tar el desarrollo de software. Los programas desarrollados con un nivel más alto de abstracción son más comprensibles y por tanto más sencillos de depurar. • Debido a que el API d e sockets opera a más bajo nivel, se trata de una API tí­ picamente independiente de plataforma y lenguaje. Puede no ocurrir lo mismo con RMI. Java RMI, por ejemplo, requiere soportes de tiempo de ejecución es­ pecíficos de Java. Como resultado, una aplicación implementada con Java RMI debe escribirse en Java y sólo se puede ejecutar en plataformas Java. La elección d e un paradigma y una API apropiados es una decisión clave en el dise­ ño de una aplicación. Dependiendo d e las circunstancias, es posible que algunas par­ tes de la aplicación utilicen un paradigma o API y otras partes otro. Debido a la relativa facilidad con la que las aplicaciones de red pueden desarro­ llarse utilizando RMI, RMI es un buen candidato para el desarrollo rápido de un pro­ totipo de una aplicación. 7 .1 2 . PARA PENSAR El modelo de computación distribuida orientada a objetos presentado en este capítu­ lo está basado en la visión de que, desde el punto de vista del programador, no hay una distinción esencial entre los objetos locales y los objetos remotos. Aunque esta visión es ampliamente aceptada como la base de los sistemas de objetos distribuidos, En ingeniería d e software, un prototipo e s una versión inicial que se realiza d e form a rápida para m ostrar la interfaz de usuario y las funciones d e una aplicación propuesta. www.FreeLibros.org 214 C om putación distribuida. Fundam entos y aplicaciones existen detractores de la misma. Los autores de [research.sun.com, 11], por ejemplo, afirman que esta visión, aunque conveniente, es inapropiada porque ignora las dife­ rencias inherentes entre los objetos locales y remotos. El Ejercicio 11 al final del ca­ pítulo pide al lector profundizar más en el estudio de este argumento. Este capítulo ha introducido el paradigma de objetos distribuidos. A continuación se resumen algunos de los puntos claves: • El paradigma de objetos distribuidos posee un nivel de abstracción más alto que e l paradigma de paso de mensajes. • Mediante e l uso de este paradigma, un proceso invoca métodos de un objeto re­ moto, pasando los datos como argumentos y recibiendo un valor d e retom o con cada llamada, d e forma similar a las llamadas a los métodos locales. • En un sistema de objetos distribuidos, un servidor de objeto consiste en un ob­ je to distribuido que posee métodos que un cliente de objeto puede invocar. Cada extrem o de la comunicación requiere un proxy, que interactúa con el soporte en tiem po de ejecución del sistema para llevar a cabo la comunicación entre pro­ cesos necesaria. Adicionalmente, debe existir un registro de objetos que permi­ ta a los objetos distribuidos registrarse y poder hacer búsquedas. • Entre los protocolos de los sistemas de objetos distribuidos más conocidos se encuentran Java RMI (Remóte M ethod Invocation), e l modelo de objetos de com­ ponentes distribuidos DCOM, la arquitectura CORBA (Common O bject Request Broker Architecture), y el protocolo SOAP ( Simple Object Access Protocol). • Java RMI es un sistem a representativo d e los sistemas de objetos distribuidos. Algunos de los temas relacionados con RMI que se han tratado en este capítu­ lo son: — La arquitectura del API Java RMI incluye tres capas en am bos extremos, el cliente y e l servidor. En la parte cliente, la capa resguardo acepta una invo­ cación a un método remoto y la transforma en mensajes, que envía a la par­ te servidora. En la parte servidora, la capa esqueleto recibe los mensajes y los transforma en llamadas locales al método remoto. Para registrar un obje­ to, se debe utilizar un servicio de directorios, como JNDI o el registro RMI. — El software de una aplicación RMI incluye una interfaz remota, software en la parte servidora, y software en la parte cliente. Este capítulo presentó la sintaxis y los algoritmos recomendados para desarrollar este software. • S e analizaron las diferencias entre el API de sockets y el API de Java RMI. E JE R C IC IO S 1. Compare y contraste e l paradigma de paso de mensajes y el paradigma de ob­ jetos distribuidos. 2. Compare y contraste una llamada a procedimiento local y una llam ada a pro­ cedimiento remoto. 3. Describa la arquitectura de Java RMI. ¿Cuál es el papel del registro RMI? www.FreeLibros.org O bjetos distribuidos 215 4. Considérese una aplicación sencilla, donde un cliente envía dos valores ente­ ros a un servidor, que sum a los valores y devuelve el resultado al cliente. a. Describa cómo se implementaría la aplicación mediante el uso del API de sockets. Describa los mensajes intercambiados y las acciones correspon­ dientes a cada mensaje. b. Describa cómo se implementaría la aplicación mediante el uso del API RMI. Describa la interfaz, los métodos remotos, y la invocación de los métodos remotos en el programa cliente. 5. Este ejercicio utiliza e l ejemplo HolaMundo. a. Cree un directorio para este ejercicio. Coloque los ficheros fuente del ejem ­ plo HolaMundo en e l directorio. b. Compile HolaMundoInterfaz.java y HolaMundoImpl.java. c. Utilice rmic para compilar HolaMundo Impl. Mire la carpeta para compro­ bar que se han generado las clases del proxy. ¿Cuáles son sus nombres? d. Compile HolaM undoServidor java. Compruebe el contenido de la carpeta. e. Ejecute el servidor, especificando un número de puerto aleatorio para el registro RMI. Compruebe los mensajes que se muestran, incluyendo la lis­ ta de nombres actualmente registrados. ¿Se puede ver el nombre bajo el cual se ha registrado el objeto rem oto (tal y como se especifica en el pro­ grama)? f. Compile y ejecute HolaM undoClientejava. Cuando se solicite, especifique «localhost» como nombre de la máquina y el número de puerto RMI pre­ viamente introducido. ¿Qué sucede? Explíquelo. g. Ejecute el programa cliente en una máquina separada. ¿La ejecución fue correcta? 6. Cree una nueva carpeta. Copie todos los ficheros fuente del ejemplo HolaMun­ do a la carpeta. Añada código al método decirHola de HolaMundoImpl.java, de forma que haya un retardo de 5 segundos antes de que el método termine. Esto tiene el efecto de alargar artificialmente la latencia de cada invocación del méto­ do. Compile y arranque el servidor. En pantallas separadas, arranque dos o más clientes. Observe la secuencia de eventos en las pantallas. ¿Se puede afirmar s i el servidor de objeto ejecu­ ta las llamadas a los métodos concurrente o iterativamente? Explíquelo. 7. Cree una nueva carpeta. Copie todos los ficheros fuente del ejemplo Hola­ M undo a la carpeta. Modifique el método decirHola de forma que se le pase un argumento, una cadena de caracteres con un nombre, y que la cadena que devuelve sea la cadena «Hola Mundo» concatenada con e l nombre pasado como argumento. a. Muestre las modificaciones del código. b. Recompile y ejecute e l servidor y a continuación el cliente. Describa y ex­ plique lo que sucede. c. Ejecute rmic de nuevo para generar los nuevos proxies de la interfaz mo­ dificada, y a continuación ejecute e l servidor y el cliente. Entregue los listados fuentes y las salidas de la ejecución. 8. Utilice RMI para implementar un servidor y cliente Daytime. www.FreeLibros.org 216 C om putación distribuida. Fundam entos y aplicaciones 9. Utilizando RMI, escriba una aplicación para un prototipo de un sistema de consultas de opinión. Asúmase que sólo se va a encuestar un tema. Los en­ trevistados pueden responder sí, no o ns/nc. Escriba una aplicación servidora, que acepte los votos, guarde el recuento (en memoria), y proporcione el re­ cuento actual a aquellos que estén interesados. a. Escriba el fichero de interfaz primero. Debería proporcionar métodos re­ motos para aceptar una respuesta a la encuesta, proporcionando e l recuen­ to actual (ejemplo, 10 sí, 2 no, 5 ns/nc) sólo cuando e l cliente lo requie­ ra. b. Diseñe e implemente un servidor que (i) exporte los métodos remotos, y (ii) mantenga información de estado (los recuentos). Obsérvese que las ac­ tualizaciones de los recuentos deben protegerse con exclusión mutua. c. Diseñe e implemente una aplicación cliente que proporcione una interfaz de usuario para aceptar una respuesta y/o una petición, y para interactuar con e l servidor apropiadamente a través de la invocación de métodos remotos. d. Pruebe la aplicación ejecutando dos o más clientes en máquinas diferentes (preferiblemente en plataformas diferentes). e. Entregue los listados de los ficheros, que deben incluir los ficheros fuente (el fichero de interfaz, los ficheros del servidor y los ficheros del cliente), y un fichero LEEME que explique los contenidos y las interrelaciones de los ficheros fuente, así como el procedimiento para ejecutar el trabajo. 10. Cree una aplicación para gestionar unas elecciones. El servidor exporta dos métodos: — emitirVoío, que acepta como parámetro una cadena de caracteres que con­ tiene un nombre de candidato (Gore o Bush), y no devuelve nada, y — obtenerResultado, que devuelve, en un vector de enteros, el recuento actual para cada candidato. Pruebe la aplicación ejecutando todos los procesos en una máquina. A con­ tinuación pruebe la aplicación ejecutando el proceso cliente y servidor en má­ quinas separadas. Entregue el código fuente de la interfaz remota, el servidor y el cliente. 11. Lea la referencia [research.sun.com, 11]. Resuma las razones por las que los autores encuentran fallos en el modelo de objetos distribuidos, que minimiza las diferencias de programación entre las invocaciones local y remoto d e mé­ todos. ¿Está d e acuerdo con los autores? ¿Cuál podría ser un modelo alterna­ tivo para objetos distribuidos que resolviera los problemas identificados por los autores? (Pista: Busque información sobre la tecnología Jini [sun.com, 12].) R EFER EN C IA S 1. O bject Management Group. Website de O M G Corba, http://www.corba.org 2. W brld Wide Wfeb Consortium. SOAP versión 1.2 Parte 0: Primero, http://www.w3.org/TR/soapl2- partO/. 3. Modelo de Objetos de Componentes Distribuidos (DCOM) - Documentos, especificaciones, ejemplos y recursos de M icrosoft DCOM, http://www.micrcsoft.com/com/tech/DCOM.asp, M i­ crosoft. 4. Richard T. Grimes. Professional D C O M Progranuning. Chicago, IL : W rox Press, Inc., 1997. www.FreeLibros.org O bjetos d istribu ido s 217 5. R FC 1831: E sp ecificació n d e l protocolo L lam ada a P rocedim ientos R em otos, v ersión 2, A gosto 1995, h ttp ://w w w .ietf.org/rfc/rfcl831.txt 6. T h e O pen G roup, D C E 1.1: R em ó te P rocedure Cali, http://w w w .opennc.org/public/pubs/ catalog/c706.htm 7. Ja v a R em ó te M ethod Invocation, http://java.sun.com /products/jdk/rm i 8. R M I - T utorial d e Java, http://java.sun.com /docs/books/tutorial/rm i 9. In tro d u c c ió n a l a c o m p u ta c ió n d is trib u id a c o n R M I, h ttp ://d e v e lo p e r .ja v a .s u n .c o m / d e v e loper/onl ineTr aining/rm i/R M I. ht mi 10. Ja v a R em ó te M ethod Invocation - C o m p u ta c ió n d istribuida p a ra Java, h ttp://java.sun.com / m arketing/collateral/javarm i.htm l 11. Jim W aldo, G e o ff W yant, A n n W ollrath, a n d S a m K endall. «A Note on Distributed Com- puting», Inform e T R -94-29, S u n M icrosystem s L aboratories, 1994, http://research.sun.com / research/techrep/1994/sm li_tr-94-29.pdf 12. Jini N etw ork T echnology, «An Executive OverView», w h ite paper. S u n M icrosystem s, Inc., 2001, http://w w w .sun.eom /softw are/j ini/w hitepapers/jini-execoverview .pdf www.FreeLibros.orgwww.FreeLibros.org CAPITULO R M I a v a n z a d o En el últim o capítulo, Java RMI se describió com o ejem plo de un sistem a de objetos d istribuidos. En dich o capítulo sólo se m ostraron las características de diseño más básicas de RMI, aunque se m encionó que el API poseía un extenso conjunto de características. El lector puede ignorar este capítulo si no está interesado en explorar de form a más detallada RMI. Sin embargo, es m uy recom endable el uso de los gestores de seguridad (véase El g e sto r de seguridad de RMI) en todas las aplicaciones RMI. Este capítulo analizará algunas de las características avanzadas de RMI más interesantes, a saber, descarga de resguardo, gestores de seguridad, y ca llb a ck de cliente. Aunque no se trata de características inherentes del paradigm a de objetos distribuidos, se trata de mecanism os que pueden ser útiles para los desarrolladores de aplicaciones. Adicionalm ente, el e studio de estos tem as perm ite al lector reforzar su conocim iento del paradigm a de objetos d istribuidos en general, y del API de RMI en particular. 8 .1 . C A LLB A C K D E C L IE N T E Considérese una aplicación RMI donde un servidor de objeto debe notificar a los pro­ cesos participantes la ocurrencia de algún evento. Como ejemplos, en un chai, cuan­ do un nuevo participante entra, se avisa al resto de los participantes de este hecho; en un sistema de subastas en tiempo real, cuando empiezan las ofertas, se debe avi­ sar a los procesos participantes. Esta característica tam bién es útil en un juego en red cuando se informa a los jugadores de la actualización del estado del juego. Dentro del entorno del API básica de RMI presentada en el capítulo anterior, es imposible que www.FreeLibros.org 2 2 0 C om putación distribuida. Fundam entos y aplicaciones el servidor inicie una llamada al cliente para transmitirle alguna clase de información que esté disponible, debido a que una llamada a método remoto es unidireccional (del cliente al servidor). Una forma de llevar a cabo la transmisión de información es que cada proceso cliente realice un sondeo a l servidor de objeto, invocando de forma re­ petida un método remoto, que supóngase que se llam a haComenzado Oferta, hasta que el método devuelva el valor booleano verdadero: I n t e r f a z S e r v i d o r h = ( I n t e r f a z S e r v i d o r ) N a m i n g .l o o k u p ( U R I R e g i s t r o ) ; w h i l e ( ! ( h . h a C a n e n z a d o O f e r ta ( ) ) { ; > / / c o m ie n z a l a o f e r t a El sondeo {paB htg es de hecho una técnica empleada en muchos programas de red. Pero se trata de una técnica m uy costosa en términos de recursos del sistema, ya que cada invocación de un método remoto implica un hilo separado en la máquina servidora, además de los recursos de sistema que su ejecución conlleva. Una técnica más eficiente se denomina ca flh a rk. permite que cada cliente de objeto interesado en la ocurrencia de un evento se registre a sí mismo con e l servidor d e objeto, de for­ ma que el servidor inicie una invocación de un método remoto del cliente d e objeto cuando dicho evento ocurra. La Figura 8.1 compara las dos técnicas: sondeo y call- back. Sondeo C a llb a c k Un d ie n te realiza una petición al servidor repetidam ente hasta que obtiene la respuesta deseada. U n cliente se registra en el servidor y espera a que el servidor realice un callback. Llamada a m étodo rem oto F ig u ra 8 .1 . Sondeo (polling) frente a callback. En RMI, el caBbadt de diente es una característica que permite a un cliente de objeto registrarse a sí mismo con un servidor de objeto remoto para caBbads, de for­ ma que el servidor pueda llevar a cabo una invocación del método del cliente cuan­ do e l evento ocurra. H ay que observar que con los callbacks de clientes, las invoca­ ciones de los métodos remotos se convierten en bidireccionales, o dúplex, desde el cliente al servidor y viceversa. Debido a que el API de RMI básica, introducida en el capítulo anterior, sólo permite la invocación de métodos remotos de clientes en ser­ vidores de objetos, se necesita claramente sintaxis adicional para dar soporte a esta nueva característica. www.FreeLibros.org RMI avanzado 221 Cuando un servidor de objeto realiza un callback, los papeles de los dos procesos se invierten: el servidor de objeto se convierte en cliente del cliente de objeto, debi­ do a que el primero inicia una invocación de método remoto en el segundo. La Figura 8.2 muestra la arquitectura de RMI con callback de cliente. Compara­ da con la arquitectura básica de RMI, se puede observar que en este caso se necesi­ tan dos conjuntos de proxies, uno para la interfaz remota del servidor, como en la ar­ quitectura básica de RMI, y otro para una interfaz adicional, la interfaz remota del cliente. La interfaz remota del cliente proporciona un método remoto que puede in­ vocar el servidor a través del callback. ......................El cliente busca el objeto rem oto ► El cliente invoca el m étodo rem oto del servidor El servidor invoca el m étod o de callbackdel cliente F ig u ra 8 2 . La a rq u ite c tu ra d e R M I c o n ca llb a c k d e clie n te . Como ejemplo, se extenderá la aplicación HolaMundo, presentada en el capítulo anterior, de forma que e l cliente del objeto se registre con el servidor para callback y entonces se le notifique cualquier registro de otro cliente de objeto para callback con el servidor. Extensión de la parte cliente para ca llb a ck de cliente Para el callback, el cliente debe proporcionar un método remoto que permita al ser­ vidor notificarle el evento correspondiente. Esto puede hacerse de una forma similar a los métodos remotos del servidor de objeto. En la siguiente subsección se describe la sintaxis necesaria para llevar a cabo esto. La interfaz rem ota de cliente Es importante recordar que el servidor de objeto proporciona una interfaz rem ota que declara los métodos que un cliente de objeto puede invocar. Para el callback, es ne­ www.FreeLibros.org 222 C om putación distribuida. Fundam entos y aplicaciones cesario que e l cliente de objeto proporcione una interfaz remota similar. Se le deno­ minará interfaz remota de cliente (por ejemplo, InterfazCallbackCliente ), por oposi­ ción a la interfaz remota de servidor (por ejemplo, InterfazCallbackServidor). La in­ terfaz remota de cliente debe contener al menos un método que será invocado por el servidor en el callback. Como ejemplo, se describe la siguiente interfaz remota de cliente: p u b l i c i n t e r f a z I n t e r f a z C a l l b a c k C l i e n t e e x t e n d s j a v a . m i . R e m ó te { / / E s t e m é to d o r e m o to e s in v o c a d o p o r u n s e r v i d o r / / q u e r e a l i c e u n c a l l b a c k a l c l i e n t e q u e im p le m e n ta / / e s t a i n t e r f a z . / / E l p a r á m e t r o e s u n a c a d e n a d e c a r a c t e r e s q u e / / c o n t i e n e i n f o r m a c i ó n p r o c e s a d a p o r e l c l i e n t e / / u n a v e z r e a l i z a d o e l c a l l b a c k . I I E s t e m é to d o d e v u e l v e u n m e n s a je a l s e r v i d o r , p u b l i c S t r i n g n o t i f i c a m e ( S t r i n g m e n s a je ) th r o w s j a v a . r m i . R e m o te E x c e p t io n ; } / / f i n a l d e l a i n t e r f a z El servidor debe invocar el método notifícame cuando realiza el callback, pasan­ do como argumento una cadena de caracteres (String). Una vez recibido el callback, el cliente utiliza esta cadena para componer otra cadena que devuelve al servidor. La im ple m en tación de la interfaz rem o ta de cliente Al igual que la interfaz remota de servidor, es necesario implementar la interfaz re­ mota de cliente en una clase, denominada ImplCallbackCtiente en el ejemplo, tal y como se muestra a continuación: i m p o r t j a v a . r m i . * ; i m p o r t j a v a . r m i . s e r v e r . * ; p u b l i c c l a s s I m p l C a l l b a c k C l i e n t e e x t e n d s U n ic a s t R e m o te O b je c t im p le m e n ts I n t e r f a z C a l l b a c k C l i e n t e { p u b l i c I m p l C a l l b a c k C l i e n t e ( ) th r o w s R e m o te E x c e p tio n { s u p e r ( ) ; > p u b l i c S t r i n g n o t i f í c a m e ( S t r i n g m e n s a j e ) { S t r i n g m e n s a j e R e t = \" C a l l b a c k r e c i b i d o : 11 + m e n s a j e ; S y s t e m . o u t . p r i n t l n ( m e n s a j e R e t ) ; r e t u r n m e n s a j e R e t ; > } / / f i n a l c l a s e I m p l C a l l b a c k C l i e n t e En este ejem plo el método de callback notifícame simplemente imprime la cade­ na de caracteres que le pasa el servidor como argumento, y devuelve otra cadena a dicho servidor. Al igual que la interfaz remota de servidor, se debe utilizar el compilador m m c con la implementación de la interfaz remota de cliente para generar los proxies nece­ sarios en tiem po de ejecución. www.FreeLibros.org RMI avanzado 2 2 3 Extensión de la clase cliente En la clase del cliente de objeto, se necesita añadir código al cliente para que ins- tancie un objeto de la implementación de la interfaz remota de cliente. A continua­ ción, se registra con el servidor una referencia al objeto utilizando un método remo­ to proporcionado por el servidor (véase la próxima sección, «Extensión de la parte servidora para callback de cliente»). Un ejemplo de cómo debe realizarse esto se mues­ tra a continuación: I n t e r f a z C a l l b a c k S e r v i d o r h = ( I n t e r f a z C a l l b a c k S e r v i d o r ) N a m in g . l o o k u p ( U R L R e g is tr o ) ; I n t e r f a z C a l l b a c k C Ü e n t e o b j C a l l b a c k = new I m p l C a l l b a c k C l i e n t e ( ) ; / / r e g i s t r a r e l o b j e t o p a r a c a l l b a c k h . r e g i s t r a r C a l l b a c k ( o b j C a l l b a c k ) ; Las Figuras entre la 8.3 hasta la 8.5 presentan el código del software de la parte cliente para la aplicación HolaMundo modificada. F ig u ra 8 3 . F ich e ro InterfazC alIbackC I¡ente,java d e la a p lic a c ió n H olaM undo m o d ifica d a . 1 i m p o r t j a v a . r m i . * ; 3 /* * 4 * E s t o e s u n a i n t e r f a z r e m o ta p a r a i l u s t r a r e l 5 * c a l l b a c k de c l i e n t e . 6 * G a u th o r M. L . L i u 7 8 * / 9 p u b l i c i n t e r f a c e I n t e r f a z C a l l b a c k C Ü e n t e 10 e x t e n d s j a v a . r m i . R e m ó t e { 11 / / E s t e m é to d o r e m o to s e i n v o c a m e d i a n t e c a l l b a c k 12 I I d e s e r v i d o r , d e fo r m a q u e r e a l i z a u n c a l l b a c k a 13 / / u n c l i e n t e q u e im p le m e n ta e s t a i n t e r f a z . 14 / / G m essag e u n a c a d e n a d e c a r a c t e r e s q u e c o n t i e n e 15 / / i n f o r m a c i ó n p r o c e s a d a p o r e l c l i e n t e . 16 17 p u b l i c v o i d n o t i f i c a m e ( S t r i n g m e n s a je ) 18 th r o w s j a v a . r m i . R e m o te E x c e p tio n ; 19 20 } / / f i n i n t e r f a z F ig u ra 8 .4 . F iche ro Im pIC alIbackC liente.java d e la a p lic a c ió n H o la M u n d o m o d ifica d a . i i m p o r t j a v a . r m i . * ; 2 ■a i m p o r t j a v a . r m i . s e r v e r . * ; o 4 /* * 5 * E s t a c l a s e im p le m e n ta l a i n t e r f a z r e m o ta 6 * I n t e r f a z C a l l b a c k C Ü e n t e . 7 * G a u th o r M. L . L i u (continúa) www.FreeLibros.org 224 C om putación distribuida. Fundam entos y aplicaciones 8 */ 9 10 public class ImplCallbackCliente extends UnicastReraoteObject 11 im p le m e n ts I n t e r f a z C a l l b a c k C l i e n t e { 12 13 p u b l i c I m p l C a l l b a c k C l i e n t e ( ) th r o w s R e m o te E x c e p tio n { 14 s u p e r ( ) ; 15 > 16 17 p u b l i c S t r i n g n o t i f í c a m e ( S t r i n g m e n s a j e ){ 18 S t r i n g m e n s a je R e t = \" C a l l b a c k r e c i b i d o : \" + m e n s a j e ; 19 S y s t e m . o u t . p r i n t l n ( m e n s a j e R e t ) ; 20 r e t u r n m e n s a j e R e t ; 21 } 22 23 } / / f i n c l a s e I m p l C a l l b a c k C l i e n t e F ig u ra 8 .5 . F iche ro C lienteE jem pIo.java d e la a p lic a c ió n H olaM undo m od ifica da. 1 i m p o r t j a v a . i o . * ; 2 i m p o r t j a v a . r m i . * ; 3 4 / * * 5 * E s t a c l a s e r e p r e s e n t a e l c l i e n t e d e o b j e t o p a r a un 6 * o b j e t o d i s t r i b u i d o d e l a c l a s e I m p l C a l l b a c k S e r v i d o r , 7 * q u e im p le m e n ta l a i n t e r f a z r e m o ta 8 * I n t e r f a z C a l l b a c k S e r v i d o r . T a m b ié n a c e p t a c a l l b a c k s 9 * d e l s e r v i d o r . 10 * 1 1 * 12 * 13 * @ a u th o r M. L . L i u 14 * / 15 16 p u b l i c c l a s s C l i e n t e E j e m p lo { 17 18 p u b l i c s t a t i c v o i d m a i n ( S t r i n g a r g s [ ] ) { 19 t r y { 20 i n t p u e rto R M I; 21 S t r i n g n a n b re N o d o ; 22 I n p u t S tr e a m R e a d e r e n t = 23 new I n p u t S tr e a m R e a d e r ( S y s te m . i n ) ; 24 B u f f e r e d R e a d e r b u f = new B u f f e r e d R e a d e r ( e n t ) ; 25 S y s te m . c u t . p r i n t l n ( 26 \" I n t r o d u c e e l n o m b re d e n o d o d e l r e g i s t r o R M I : \" ) ; 27 n o irbreN odo = b u f . r e a d L i n e ( ) ; 28 S y s t e m . c u t . p r i n t l n ( ( continúa) www.FreeLibros.org RMI avanzado 225 29 \" I n t r o d u c e e l n ú m ero d e p u e r t o d e l r e g i s t r o RM I: \" ) ; 30 S t r i n g n u m P u e r to = b u f . r e a d L i n e ( ) ; 31 p u e rtó R M I = I n t e g e r . p a r s e l n t ( n u m P u e r to ) ; 32 S y s te m , o u t . p r i n t l n ( 33 ''I n t r o d u c e c u a n t o s s e g u n d o s v a a p e rm a n e c e r r e g i s t r a d o : \" ) ; 34 S t r i n g d u r a c io n T ie m p o = b u f . r e a d L i n e ( ) ; 35 i n t ti e m p o = I n t e g e r . p a r s e l n t ( d u r a c i o n T ie m p o ) ; 36 S t r i n g U R L R e g is tro = 37 \" r m i : / / l o c a l h o s t : \"+ n u m P u e r to + \" / c a l l b a c k \" ; 38 / / B ú s q u e d a d e l o b j e t o r e m o to y c a s t a l o b j e t o 39 / / d e l a i n t e r f a z 40 I n t e r f a z C a l l b a c k S e r v i d o r h = 41 ( I n t e r f a z C a l l b a c k S e r v i d o r ) N a m in g .lo o k u p ( U R L R e g is tr o ) ; 42 S y s te m , o u t . p r i n t l n ( \" B ú sq u e d a c o m p l e t a \" ) ; 43 S y s te m , o u t . p r i n t l n ( \" E l s e r v i d o r d i c e \" + h . d e c i r H o l a ( ) ) ; 44 I n t e r f a z C a l l b a c k C l i e n t e o b j C a l l b a c k = 45 new I m p l C a l l b a c k C l i e n t e ( ) ; 46 / / r e g i s t r a r p a r a c a l l b a c k 47 h . r e g i s t r a r C a l l b a c k ( o b j C a l l b a c k ) ; 48 S y s te m , o u t . p r i n t l n ( \" R s g i s t r a d o p a r a c a l l b a c k . \" ) ; 49 t r y { 50 T h r e a d . s l e e p ( t i e m p o * 1 0 0 0 ) ; 51 } 52 c a t c h (I n t e r r u p t e d E x c e p t i o n e x e ) { / / s o b r e e l m é to d o s l e e p 53 h . e l i m i n a r R e g i s t r o C a l l b a c k ( o b j C a l l b a c k ) ; 54 S y s t e m . o u t . p r i n t l n ( \"No r e g i s t r a d o p a r a c a l l b a c k . \" ) ; 55 } 56 } / / f i n t r y 57 c a t c h ( E x c e p t i o n e ) { 58 S y s t e m . o u t . p r i n t l n ( 59 \" E x c e p c ió n e n C l i e n t e E j e m p l o : \" + e ) ; 60 } 61 > / / f i n m a in 62 } / / f i n c l a s e Extensión de la parte servidora para ca llb a ck de cliente En la parte del servidor, se necesita añadir un método remoto para que el cliente pue­ da registrarse para callback. En el caso más sencillo, la cabecera del método puede ser análoga a la siguiente: p u b l i c v o i d r e g i s t r a r C a l l b a c k ( / / S e p u e d e e l e g i r e l n c m b re d e m é to d o d e s e a d o I n t e r f a z C a l l b a c k C l i e n t e o b j C a l l b a c k C l i e n t e ) th r o w s j a v a .r m i .R e m o t e E x c e p t i o n ; Como argumento se pasa una referencia a un objeto que implementa la interfaz remota de cliente (.InterfazCallbackCliente, no ImplCallbackCliente). También se pue- www.FreeLibros.org 226 C om putación distribuida. Fundam entos y aplicaciones de proporcionar un método eliminarRegistroCallback, para que un cliente pueda can­ celar e l registro (de forma que no reciba más callbacks). La implementación de estos métodos, así como la implementación de un método local hacerCallbacks (para rea­ lizar los callbacks) se muestra en la Figura 8.7. La Figura 8.6 muestra el fichero con la interfaz del servidor, que contiene las cabeceras de los métodos adicionales. La Fi­ gura 8.8 muestra el código para el servidor de objeto, que queda sin modificar res­ pecto a la anterior versión, presentada en el capítulo anterior. F ig u ra 8 .6 . F ich e ro InterfazC alIbackServidor.java de la a p lic a c ió n H o la M u n d o m o d ifica d a . 1 i m p o r t j a v a . r m i . * ; 2 3 / * * 4 * E s t o e s u n a i n t e r f a z r e m o ta p a r a i l u s t r a r e l 5 * c a l l b a c k d e c l i e n t e . 6 * @ a u th o r M. L . L i u 7 * / 8 9 p u b l i c i n t e r f a c e I n t e r f a z C a l l b a c k S e r v i d o r e x t e n d s R e m ó te { 10 11 p u b l i c S t r i n g d e c i r H o l a ( ) 12 th r o w s j a v a . r m i . R e m o te E x c e p tio n ; 13 14 / / E s t e m é to d o r e m o to p e r m i t e a u n c l i e n t e 15 / / d e o b j e t o r e g i s t r a r s e p a r a c a l l b a c k 16 / / G param o b j C l i e n t e C a l l b a c k e s u n a r e f e r e n c i a 17 / / a l c l i e n t e d e o b j e t o ; e l s e r v i d o r l o 18 / / u t i l i z a p a r a r e a l i z a r l o s c a l l b a c k s 19 20 p u b l i c v o i d r e g i s t r a r C a l l b a c k ( 21 I n t e r f a z C a l l b a c k C l i e n t e o b j C a l l b a c k C l i e n t e ) 22 t h r c w s j a v a . r m i .R e m o t e E x c e p t io n ; 23 24 / / E s t e m é to d o r e m o to p e r m i t e a u n c l i e n t e 25 / / d e o b j e t o c a n c e l a r s u r e g i s t r o p a r a c a l l b a c k 26 27 p u b l i c v o i d e l i m i n a r R e g i s t r o C a l l b a c k ( 28 I n t e r f a z C a l l b a c k C l i e n t e o b j C a l l b a c k C l i e n t e ) 29 th r o w s j a v a . r m i . R e m o te E x c e p tio n ; 30 } F ig u ra 8 .7 . Fichero Im p IC a lIb a c k S e rv id o r.ja v a de la aplicación H o la M u n d o modificada. 1 i m p o r t j a v a . r m i . * ; 2 i m p o r t j a v a . m i . s e r v e r . * ; 3 i m p o r t j a v a . ú t i l . V e c t o r ; 4 5 /* * 6 * E s t a c l a s e im p le m e n ta l a i n t e r f a z r e m o ta ( continúa) www.FreeLibros.org 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 RMI avanzado 2 2 7 * I n t e r f a z C a l l b a c k S e r v i d o r . * O a u th o r M. L . L i u */ p u b l i c c l a s s I m p l C a l l b a c k S e r v i d o r e x t e n d s U n ic a s tR e r o o te O b je c t im p le m e n ts I n t e r f a z C a l l b a c k S e r v i d o r { p r i v a t e V e c t o r l i s t a C l i e n t e s ; p u b l i c I n p l C a l l b a c k S e r v i d o r ( ) th r o w s R e m o te E x c e p tio n { s u p e r ( ) ; l i s t a C l i e n t e s = new V e c t o r ( ) ; > p u b l i c S t r i n g d e c i r H o l a ( ) t h r o w s j a v a . r m i . R e m o te E x c e p tio n { r e t u r n ( \" H o la M u n d o \") ; > p u b l i c v o i d r e g i s t r a r C a l l b a c k ( I n t e r f a z C a l l b a c k C l i e n t e o b j C a l l b a c k C l i e n t e ) t h r o w s j a v a .r m i . R e m o t e E x c e p t i o n { / / a lm a c e n a e l o b j e t o c a l l b a c k e n e l v e c t o r i f ( ! ( l i s t a C l i e n t e s . c o n t a i n s ( o b j C a l l b a c k C l i e n t e ) ) ) { l i s t a C l i e n t e s . a d d E le m e n t( o b j C a l l b a c k C l i e n t e ) ; S y s t e m . o u t . p r i n t l n ( \" N u e v o c l i e n t e r e g i s t r a d o \" ) ; h a c e r C a l l b a c k s ( ) ; } / / f i n i f > / / E s t e m é to d o r e m o to p e r m i t e a u n c l i e n t e d e o b j e t o / / c a n c e l a r s u r e g i s t r o p a r a c a l l b a c k / / G param i d e s u n i d e n t i f i c a d o r p a r a e l c l i e n t e ; I I e l s e r v i d o r l o u t i l i z a ú n ic a m e n te p a r a i d e n t i f i c a r a l c l i e n t e r e g i s t r a d o . p u b l i c s y n c h r o n i z e d v o i d e l i m i n a r R e g i s t r o C a l l b a c k ( I n t e r f a z C a l l b a c k C l i e n t e o b j C a l l b a c k C l i e n t e ) th r o w s j a v a . r m i . R e m o te E x c e p tio n { i f ( l i s t a C l i e n t e s . re m o v e E le m e n t ( o b j C a l l b a c k C l i e n t e ) ) { S y s t e m . o u t . p r i n t l n ( \" C l i e n t e no r e g i s t r a d o \" ) ; > e l s e { S y s te m . o u t . p r i n t l n ( \" e l i m i n a r R e g i s t r o : e l c l i e n t e n o f u e r e g i s t r a d o . \" > } L>s métodos r e g i s t r a r C a l l b a c k y e l i m i n a r f í e g i s t r o C a l I b a c k modifican una estructura común (el objeto V e c t o r que contiene referencias a los c a l l b a c k de clientes). Dado que estos métodos se pueden invocar concurrentemente, es importante que se protejan con exclusión mutua. En este ejemplo la exclusión mutua se consigue a través del uso de un método sincronizado (s y n c h r o n i z e d)._________ (continúa) www.FreeLibros.org 228 C om putación distribuida. Fundam entos y aplicaciones 53 p r i v a t e s y n c h r o n i z e d v o i d h a c e r C a l l b a c k s ( ) th r o w s j a v a . r m i . R e m o te E x c e p tio n { 54 / / r e a l i z a r c a l l b a c k d e u n c l i e n t e r e g i s t r a d o 55 S y s t e m . o u t . p r i n t l n ( 57 \" C a l l b a c k i n i c i a d o — \" ) ; 58 f o r ( i n t i = 0 ; i < l i s t a C l i e n t e s . s i z e ( ) ; i + + ) { 59 S y s t e m . o u t . p r i n t l n ( \" h a c i e n d o c a l l b a c k n ú m e ro \" + i \" \\ n \" ) ; 60 / / c o n v e r t i r e l o b j e t o v e c t o r a u n o b j e t o c a l l b a c k 61 I n t e r f a z C a l l b a c k C l i e n t e p r o x C l i e n t e = 62 ( I n t e r f a z C a l l b a c k C l i e n t e ) l i s t a C l i e n t e s . e l e m e n t A t ( i ) ; 63 / / i n v o c a r e l m é to d o d e c a l l b a c k 64 p r o x C l i e n t e . n o t i f í c a m e ( \"Núm ero d e c l i e n t e s r e g i s t r a d o s = \" 65 + l i s t a C l i e n t e s . s i z e ( ) ) ; 66 > / / f i n f o r 67 S y s t e m . o u t . p r i n t l n ( 68 + \" S e r v i d o r c a n p l e t o c a l l b a c k s — \" ) ; 69 } / / f i n h a c e r C a l l b a c k s 70 71 } / / f i n c l a s e I m p l C a l l b a c k S e r v i d o r F ig u ra 8 .8 . F iche ro S e rv id o rE je m p Io .ja v a d e la a p lic a c ió n H o la M u n d o m od ifica da. 1 i m p o r t j a v a . r m i . * ; 2 i m p o r t j a v a . r m i . s e r v e r . * ; 3 i m p o r t j a v a . r m i . r e g i s t r y . R e g i s t r y ; 4 i m p o r t j a v a . r m i . r e g i s t r y . L o c a t e R e g i s t r y ; 5 i m p o r t j a v a . n e t . * ; 6 i m p o r t j a v a . i o . * ; 7 8 /** 9 * E s t a c l a s e r e p r e s e n t a e l s e r v i d o r d e o b j e t o p a r a un 10 * o b j e t o d i s t r i b u i d o d e l a c l a s e C a l l b a c k , q u e 11 im p le m e n ta l a i n t e r f a z r e m o ta I n t e r f a z C a l l b a c k . 12 * G a u th o r M. L . L i u 13 * / 14 15 p u b l i c c l a s s S e r v i d o r E j e m p lo { 16 p u b l i c s t a t i c v o i d m a in ( S t r i n g a r g s [ ] ) { 17 I n p u t S tr e a m R e a d e r e n t = 18 new I n p u t S tr e a r ti R e a d e r ( S y s t e m , i n ) ; 19 B u f f e r e d R e a d e r b u f= new B u f f e r e d R e a d e r ( e n t ) ; 20 S t r i n g n u m P u e r to , U R L R e g is tro ; 2 1 t r y { 22 S y s te m , o u t . p r i n t l n ( 23 \" I n t r o d u c i r e l n ú m e ro d e p u e r t o d e l r e g i s t r o R M I : \" ) ; 2 4 n u m P u e rto = (b u f . r e a d L i n e ( ) ) . t r i m ( ) ; 25 i n t num P uertoR M I = I n t e g e r . p a r s e l n t ( n u m P u e r t o ) ; (continúa) www.FreeLibros.org RMI avanzado 229 26 a r r a n c a r R e g i s t r o ( n u m P u e r t o R M I ) ; 27 I m p l C a l l b a c k S e r v i d o r o b jE x p o r t a d o = 28 new I m p l C a l l b a c k S e r v i d o r ( ) ; 29 U R L R e g is tro = 30 \" r m i : / / l o c a l h o s t : \" + n u m P u e r to + “ / c a l l b a c k \" ; 31 N a m i n g .r e b i n d ( U R L R e g is tro , o b j E x p o r t a d o ) ; 32 S y s t e m . o u t . p r i n t l n ( \" S e r v i d o r c a l l b a c k p r e p a r a d o . \" ) ; 33 > / / f i n t r y 34 c a t c h ( E x c e p t i o n e x c ) { 35 S y s te m , o u t . p r i n t l n ( 36 \" E x c e p c ió n e n S e r v i d o r E j e m p l o .m a i n : \" + e x c ) ; 37 } / / f i n c a t c h 38 } / / f i n m a in 39 40 / / E s t e m é to d o a r r a n c a un r e g i s t r o RMI e n e l n o d o 41 / / l o c a l , s i n o e x i s t e e n e l n ú m ero d e p u e r t o e s p e c i f i c a d o . 42 p r i v a t e s t a t i c v o i d a r r a n c a r R e g i s t r o ( i n t n u m P u erto R M I) 43 th r o w s R e m o te E x c e p tio n { 44 t r y { 45 R e g i s t r y r e g i s t r o = 46 L o c a t e R e g i s t r y . g e t R e g i s t r y ( n u m P u erto R M I) ; 47 r e g i s t r o . l i s t ( ) ; 48 / / E s t a ll a m a d a l a n z a u n a e x c e p c i ó n 49 / / s i e l r e g i s t r o n o e x i s t e 50 } 51 c a t c h (R e m o te E x c e p tio n e ) { 52 / / No e x i s t e r e g i s t r o v á l i d o e n e l p u e r t o 53 R e g i s t r y r e g i s t r o = 54 L o c a t e R e g i s t r y . c r e a t e R e g i s t r y ( n u m P u erto R M I) ; 55 > 56 } / / f i n a r r a n c a r R e g i s t r o 57 58 > / / f i n c l a s e El servidor necesita em plear una estructura de datos que mantenga una lista de las referencias a la interfaz de cliente registradas para callbacks. En el código de ejem ­ plo, un objeto Vector es utilizado para este propósito, aunque se puede sustituir por cualquier otra estructura de datos apropiada. Cada llamada a registrareallback impli­ ca añadir una referencia al vector, mientras que cada llamada a eliminarRegistroCall- back supone borrar una referencia del vector. En el ejemplo, el servidor realiza un callback (mediante el método hacer Callbacks) siempre que se lleva a cabo una llam ada a registrare allback, donde se envía a l clien­ te a través de callback el número de clientes actualmente registrados. En otras apli­ caciones, los callbacks se pueden activar por otros eventos y pueden gestionarse a tra­ vés de un manejador de eventos. En el ejemplo, un cliente elimina su registro después de un determinado periodo d e tiempo. En las aplicaciones reales, la cancelación del registro se puede realizar al www.FreeLibros.org 2 3 0 C om putación distribuida. Fundam entos y aplicaciones final de la sesión del cliente (tal como en el caso de una sesión de chai o en una se­ sión de subastas). Pasos para construir una aplicación R M I con ca llb a ck de clien te En las siguientes páginas se presenta una descripción revisada del procedimiento para construir una aplicación RMI paso a paso, permitiendo callback de cliente. A lg o ritm o para desarrollar el softw are de la parte del servidor 1. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 2. Especificar la interfaz remota de servidor en InterfazCallbackServidor Java. Compilarla y revisarla hasta que no exista ningún error de sintaxis. 3. Implementar la interfaz en ImplCallbackServidorjava. Compilarla y revisarla hasta que no exista ningún error d e sintaxis. 4. Utilizar e l compilador RMI rmic para procesar la clase de la implementación y generar los ficheros resguardo y esqueleto para e l objeto remoto: r m ic I m p l C a l l b a c k S e r v i d o r Los ficheros generados se pueden encontrar en e l directorio como ImplCall- backServidor_Skel.class y ImplCallbackServidor_Stub.class. Los pasos 3 y 4 deben repetirse cada vez que se cambie la implementación de la interfaz. 5. Obtener una copia del fichero class de la interfaz remota del cliente. Alterna­ tivamente, obtener una copia del fichero fuente para la interfaz rem ota y com­ pilarlo utilizando javac para generar e l fichero class de la interfaz ¡nterfaz- CallbackCliente.class. 6. Crear el programa correspondiente al servidor de objeto Servidor Ejemplo java. Compilarlo y revisarlo hasta que no exista ningún error de sintaxis. 7. Obtener una copia del fichero resguardo de la interfaz remota del cliente ImplCallbackCliente_Stub.class. 8. Activar e l servidor de objeto j a v a S e r v i d o r E je m p lo A lg o ritm o para desarrollar el softw are de la parte cliente 1. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 2. Especificar la interfaz remota de cliente en InterfazCallbackClientejava. Com­ pilarla y revisarla hasta que no exista ningún error de sintaxis. 3. Implementar la interfaz en ImplCallbackClientejava. Compilarla y revisarla hasta que no exista ningún error d e sintaxis. 4. Utilizar e l compilador RMI rmic para procesar la clase de la implementación Imp l C a l Ib a ckC líente .class y generar los ficheros resguardo y esqueleto www.FreeLibros.org RMI avanzado 231 ImplCallbackCliente_Skel.class y ImplCallbackCliente_Stub.class para el obje­ to remoto: m i c I m p l C a l l b a c k C l i e n t e Los ficheros generados se pueden encontrar en el directorio como ImplCall- backCliente_Skel.class y ImplCallbackCliente_Stub.class. Los pasos 3 y 4 de­ ben repetirse cada vez que se cambie la implementación de la interfaz. 5. Obtener una copia del fichero class de la interfaz rem ota del servidor. Al­ ternativamente, obtener una copia del fichero fuente para la interfaz remota y com pilarlo utilizando ja va c para generar el fichero class de la interfaz Interfaz. 6. Crear el programa correspondiente al cliente de objeto ClienteEjemplo.java. Compilarlo y revisarlo hasta que no exista ningún error de sintaxis. 7. Obtener una copia del fichero resguardo de la interfaz remota del servidor Impl- CallbackServidor_Stub.class. Activar el cliente de objeto j a v a C l i e n t e E j e m p l o La Figura 8.9 muestra los ficheros que se necesitan en los dos extremos, clien­ te y servidor, cuando se utiliza callback de cliente. (Como se mencionó en el capítulo anterior, desde la versión 1.2 d e Java no se requieren clases esquele­ to en las aplicaciones RMI. Las funciones de las clases esqueleto se realizan a través de una técnica denominada re fle o riu ) N o d o d e l s e rv id o r d e o b je to D ire cto rio del servidor de objeto Servidor, class InterfazServidor. class InterfazCliente.class ImpIServidor. class lmplCliente_Stub. class lmplServidor_Stub.class N o d o d e l c lie n te d e o b je to D ire cto rio del cliente de objeto Cliente.class InterfazCliente.class InterfazServidor.class ImpICIiente.class lmplServidor_Stub.class ImpICIiente _Stub. class F ig u ra 8 .9 . C o lo c a c ió n d e lo s fic h e ro s e n un a a p lic a c ió n R M I c o n ca llb a c k de clie n te . www.FreeLibros.org 2 3 2 C om putación distribuida. Fundam entos y aplicaciones En Java, un p a q u e t e es un conjunto de clases, interfaces u otros paquetes relacionados y que están declarados. Caching de Web es una técnica que emplea la técnica más general de caching para evitar transferir un mismo documento repetidas veces. 8 .2 . D ESCA R G A DE RESGUARDO En la arquitectura de un sistema de objetos distribuidos se requiere un proxy para in- teractuar con la llamada a un método remoto de un cliente d e objeto. En Java RMI, este proxy o intermediario es e l resguardo de la interfaz remota del servidor. En el ca­ pítulo anterior se describieron la forma en la que se generan los proxies de la inter­ faz remota del servidor (ambos el resguardo y e l esqueleto) mediante el compilador RMI rmic. La clase resguardo generada debe estar en la máquina cliente en tiempo de ejecución cuando un programa cliente se ejecute. Esto se puede resolver colocan­ do manualmente el fichero class del resguardo en el mismo paquete o directorio que el programa del cliente de objeto. Java RMI proporciona un mecanismo que permite que los clientes obtengan diná­ micamente los resguardos necesarios [developer.java.sun.com, 2). Mediante descaiga dinám ica de reagiardo, no se necesita una copia de la clase del resguardo en la má­ quina cliente. Por el contrario, éste se transmite bajo dem anda desde un servidor web a la máquina cliente cuando se activa dicho cliente. Esta técnica utiliza la «habilidad de descargar dinámicamente software Java de cualquier URL a una máquina virtual Java (JVM, Java Virtual Machiné) ejecutándo­ se en un proceso separado, normalmente en un sistema físico diferente» [java.sun.com/ produets, 1]. Mediante el uso de descarga dinámica, e l desarrollador almacena una clase resguardo en un servidor web como un documento web, que puede ser descar­ gado (utilizando HTTP) cuando un cliente de objeto se ejecuta, de la misma forma que se lleva a cabo la descarga de appieés. El uso d e HTTP para descargar applets se discutirá en el Capítulo 11. Al igual que antes, un servidor exporta un objeto contactando con el registro RMI y registrando una referencia remota al objeto, especificando un nombre simbólico para la referencia. Si se desea utilizar descarga de resguardo, el servidor debe tam bién in­ dicar al registro el URL donde se encuentra alm acenada la clase resguardo. Los me­ canismos para realizar esto se presentarán en una sección posterior. De la misma forma que antes, un cliente que desee invocar un método remoto de un objeto exportado contacta con el registro RMI en la máquina servidora para traer la referencia remota a través del nombre. Sin descarga de resguardo, el objeto res­ guardo (un fichero class Java) debe colocarse en la máquina cliente manualmente y la máquina virtual Java debe poder localizarlo. S i se utiliza descarga de resguardo (es decir, se han realizado los pasos necesarios descritos en e l párrafo anterior con el ser­ vidor de objeto), entonces se puede obtener dinámicamente la clase resguardo de un servidor HTTP de forma que puede interactuar con el cliente de objeto y el soporte en tiempo real de RMI. La clase resguardo descargada no es persistente, es decir, no se almacena de forma permanente en la máquina cliente, sino que por el contrario el sistema libera la clase correspondiente cuando la sesión del cliente finaliza. Si no se utiliza cache en el servidor web, cada ejecución de la clase cliente requiere la des­ carga del resguardo del servidor web. La Figura 8.10 muestra la interacción entre e l cliente de objeto, e l servidor de ob­ jeto y el registro RMI cuando se utiliza descarga de resguardo. Pronto se describirán los algoritmos necesarios para ejecutar una aplicación mediante el uso d e descarga de resguardo. Antes, se debe presentar un tem a relacionado: el gestor de seguridad de RMI. www.FreeLibros.org RMI avanzado 2 3 3 N o d o d e l c lie n te de o b je to N o d o del s e rv id o r de o b je to 2. El re g is tro RMI d e vu e lve u n a refe re n cia re m o ta al o b je to d e la in te rfa z. 3. Si el re sg u a rd o del o b je to d e la in te rfa z n o está en el n o d o c lie n te y el s e rv id o r está co n fig u ra d c para e llo , se descarga el resguardo d e u n s e rv id o r HTTP. 4 . A través d e l resguardo d e l servidor, el proceso c lie n te in te ra c tú a co n el esq u eleto d e l o b je to d e la in te rfa z pa ra a cce d er a lo s m é to d o s d e l o b je to servidor. F ig u ra 8 .1 0 . Descarga de resguardo. 8 .3 . EL G ESTO R DE S E G U R ID A D DE R M I Aunque la descarga de resguardo es una característica útil, su uso supone un pro­ blema para e l sistem a de seguridad. Este problema no está asociado a l uso de RMI, sino a la descarga de objetos en general. Cuando un objeto como un resguardo RMI se transfiere desde un nodo remoto, su ejecución entraña el riesgo de ataques mali­ ciosos al nodo local. Debido a que un objeto descargado procede de un origen des­ conocido, la ejecución de su código, si no se restringe, podría causar estragos en el nodo local, provocando daños similares a los causados por un virus de computador [cert.org, 3]. Para evitar los problemas de seguridad del uso de descarga de resguardo, Java pro­ porciona una clase denominada RMISecurityManager. Un programa RMI puede ins- tanciar un objeto de esta clase. Una vez instanciado, el objeto supervisa durante la ejecución del programa todas las acciones que puedan suponer un riesgo de seguri­ dad. Estas acciones incluyen el acceso a ficheros locales y la realización de conexio­ nes de red, ya que dichas acciones podrían suponer modificaciones de los recursos lo ­ cales no deseadas o mal uso de los recursos de red. En particular, el soporte en tiempo real de RMI requiere que un proceso servidor instale un gestor d e segiridad antes d e exportar cualquier objeto que requiera descarga de resguardo, y que un cliente ins­ tale un gestor de seguridad antes de que puede realizar la descarga del resguardo. Aunque la noción de gestor de seguridad no se introdujo en e l capítulo anterior, se recomienda su uso en todas las aplicaciones RMI, independientemente de que se www.FreeLibros.org 234 C om putación distribuida. Fundam entos y aplicaciones utilice descarga de resguardo o no. Por defecto, un gestor de seguridad RMI es muy restrictivo: no permite acceso a los ficheros y sólo permite conexiones a la máquina origen. (Esta restricción de acceso también se utiliza en las descargas de applets). Esta restricción, sin embargo, no permite a un cliente de objeto RMI contactar con el re­ gistro RM I del servidor de objeto y tam poco le permite llevar a cabo descarga de resguardo. Es posible relajar estas condiciones instalando un fichero especial conoci­ do como fichó*» d e política d e segundad, cuya sintaxis especifica el tipo de res­ tricción que un gestor de seguridad, incluyendo los gestores de seguridad RMI, debe utilizar. Por defecto, existe un fichero de política de seguridad en un directorio espe­ cial de cada sistem a que utiliza Java. Las restricciones especificadas en e l fichero de políticas de seguridad del sistem a (las restricciones por defecto anteriormente men­ cionadas) serán empleadas por el gestor de seguridad a menos que se sobreescriban mediante el uso de un fichero de políticas alternativo. Alternativamente, una aplica­ ción puede especificar un fichero de políticas de seguridad, de forma que las restric­ ciones las impone la propia aplicación. Para los ejercicios realizados por el lector, se recomienda que se especifique un fichero de seguridad con cada aplicación que se eje­ cute, de forma que se tenga control exclusivamente sobre las restricciones impuestas en la aplicación del lector, sin afectar a las restricciones de otros programas. En al­ gunos sistemas, puede ocurrir que un usuario normal no tenga privilegio de acceso para modificar el fichero por defecto de políticas de seguridad de Java. A continuación, se describe cómo una aplicación utiliza el gestor de seguridad de RMI. Instanciación de un gestor de seguridad en un program a R M I La clase RMISecurityManager se puede instanciar tanto en el cliente de objeto como en e l servidor de objeto utilizando la siguiente sentencia: System.setSecurityManager(new RMISecurityManager()); Esta sentencia debería aparecer antes del código d e acceso al registro RMI. Las Figuras 8.11 y 8.12 muestran los ejemplos del programa HolaMundo, presentados en el capítulo anterior, pero instanciando un gestor de seguridad. F ig u ra 8 .1 1 . HolaMundoServidor.java haciendo uso de un gestor de seguridad. 1 import java.rmi.*; 2 import java.rmi.server.*; 3 import java.rmi.registry.Registry; 4 import java.rmi.registry.LocateRegistry; 5 import java.net.*; 6 7 import java.io.*; / 8 /** 9 * Esta clase representa el servidor de objeto para un 10 * objeto distribuido de la clase HolaMundo, que 11 implementa la interfaz remota InterfazHolaMundo. Se 12 instala u n gestor de seguridad para realizar descarga seguro. 13 * @author M. L. Liu (continúa) www.FreeLibros.org 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 RMI avanzado 2 3 5 public class HolaMundoServidor { p u b l i c s t a t i c v o id m a in ( S tr in g a r g s [ ] ) { In p u tS tre a m R e a d e r e n t = new I n p u tS tre a m R e a d e r ( S y ste m . i n ) ; B u f fe re d R e a d e r b u f= new B u f f e r e d R e a d e r ( e n t ) ; S t r i n g n u m P u erto , U R L R e g istro ; t r y { S y stem , o u t . p r i n t l n ( \" I n t r o d u c i r e l num ero d e p u e r t o d e l r e g i s t r o RMI: \" ) ; num P uerto= ( b u f . r e a d L in e () ) . t r i m ( ) ; i n t numPuertoRM I = I n t e g e r . p a r s e l n t ( n u m P u e r t o ) ; // arrancar un gestor de seguridad — esto es // necesario si se utiliza descarga de resguardo System. setSecurityManager( new RMISecurityManager()); a r r a n c a r R e g is tr o (n u m P u e rto R M I ) ; Im plHolaM undo o b jE x p o r ta d o = new Im plH olaM undo( ) ; U R L R egistro = \" r m i : / / l o c a l h o s t : \" + n u m P u erto + \" /h o la M u n d o \"; N a m in g .re b in d (U R L R e g is tro , o b jE x p o r ta d o ) ; S y s t e m . o u t . p r i n t l n ( \" S e r v id o r r e g i s t r a d o . E l r e g i s t r o c o n t i e n e : \" ) ; / / l i s t a r l o s nom bres r e g i s t r a d o s a c tu a lm e n te l i s t a r R e g i s t r o ( U R L R e g is tro ); S y s t e m . o u t . p r i n t l n ( \" S e r v id o r H o la Mundo p r e p a r a d o . \" ) ; } / / f i n t r y c a t c h ( E x c e p tio n e x c ) { S y stem , o u t . p r i n t l n ( \" E x c e p c ió n e n H o la M u n d o S e rv id o r.m a in : \" + e x c ) ; } / / f i n c a t c h } / / f i n m ain / / E s t e m étodo a r r a n c a un r e g i s t r o RMI e n e l nodo / / l o c a l , s i no e x i s t e e n e l núm ero d e p u e r t o e s p e c i f i c a d o , p r i v a t e s t a t i c v o id a r r a n c a r R e g i s t r o ( i n t numPuertoRM I) th ro w s R e m o te E x c e p tio n { t r y { R e g is tr y r e g i s t r o = I o c a t e R e g i s t r y . g e t R e g i s t r y ( num PuertoR M I) ; r e g i s t r o . l i s t ( ) ; / / E s t a lla m a d a l a n z a / / u n a e x c e p c ió n s i e l r e g i s t r o no e x i s t e > c a t c h (R e m o te E x c e p tio n e ) { (continúa) www.FreeLibros.org 236 C om putación distribuida. Fundam entos y aplicaciones 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 / / No e x i s t e r e g i s t r o v á l i d o e n e l p u e r t o S y s t e m . o u t . p r i n t l n ( \"E l r e g i s t r o RMI no s e l o c a l i z a e n e s t e p u e r t o \" + num PuertoRM I) ; R e g is tr y r e g i s t r o = L o c a te R e g is tr y .c r e a te R e g is try ( n u m P u e r to R M I ) ; S y s t e m . o u t . p r i n t l n ( \" R e g is tr o RMI c r e a d o e n e l p u e r t o \"+ num P uertoR M I); > } / / f i n a r r a n c a r R e g i s t r o / / E s t e m étodo l i s t a l o s nom bres r e g i s t r a d o s e n RMI p r i v a t e s t a t i c v o id l i s t a r R e g i s t r o (S t r i n g U R L R eg istro ) th r o w s R e m o te E x c e p tio n , M alform edU R L E xception { S y ste m . o u t . p r i n t l n ( \" R e g is tr o \" + U R L R eg istro + \" c o n t i e n e : \" ) ; S t r i n g [ ] nom bres = N a m in g .lis t( U R L R e g is tr o ) ; f o r ( i n t i= 0 ; i < n o m b res. l e n g t h ; i+ + ) S y s t e m . o u t . p r i n t l n ( n o m b re s[ i ] ) ; } / / f i n l i s t a r R e g i s t r o 81 82 > / / f i n c l a s e F ig u ra 8 .1 2 . HolaMundoCliente.java haciendo uso de un gestor de seguridad. 1 im p o r t j a v a . i o . * ; 2 im p o r t j a v a . r m i . * ; 3 4 /* * 5 * E s t a c l a s e r e p r e s e n t a e l c l i e n t e d e o b j e t o p a r a un 6 * o b j e t o d i s t r i b u i d o d e l a c l a s e H olaM undo, q ue 7 * im p le m e n ta l a i n t e r f a z r e m o ta In te rfa z H o la M u n d o . 8 * S e i n s t a l a un g e s t o r d e s e g u r id a d p a r a r e a l i z a r d e s c a r g a de r e s g u a r d o s e g u r a . 9 * G a u th o r M. L . L iu 10 */ 11 12 public class HolaMundoCliente { 13 14 p u b l i c s t a t i c v o i d m a in ( S t r i n g a r g s [ ] ) { 15 t r y { 16 i n t p u erto R M I; 17 S t r i n g ncm breN odo; 18 In p u tS tre a m R e a d e r e n t = 19 new In p u tS tre a m R e a d e r ( S y ste m , i n ) ; 20 B u ffe re d R e a d e r b u f = new B u f f e r e d R e a d e r ( e n t ) ; 21 S y s t e m . c u t . p r i n t l n ( ( continúa) www.FreeLibros.org RMI avanzado 2 3 7 22 \" I n t r o d u c e e l n o ir b re d e n o d o d e l r e g i s t r o RMI: \" ) ; 23 nom breN odo = b u f . r e a d L i n e ( ) ; 24 S y s te m . o u t . p r i n t l n ( 25 \" I n t r o d u c e e l n ú m ero d e p u e r t o d e l r e g i s t r o RMI: \" ) ; 26 S t r i n g n u m P u e r to = b u f . r e a d L i n e ( ) ; 27 p u e rtó R M I = I n t e g e r . p a r s e l n t ( n u m P u e r t o ) ; 28 29 / / arrancar un gestor de seguridad — esto es 30 / / necesario si se utiliza descarga de resguardo 31 System.setSecurityManager(new RMISecurityManager()); 32 33 S t r i n g U R L R e g is tro = 34 \" r m i : / / l o c a l h o s t : \"+ n u m P u e r to + \" /h o la M u n d o \" ; 35 / / B ú s q u e d a d e l o b j e t o r e m o to y c a s t a l 36 / / o b j e t o d e l a i n t e r f a z 37 I n te r f a z H o la M u n d o h = 38 ( I n te r f a z H o l a M u n d o )N a m in g . lo o k u p ( U R L R e g is tr o ) ; 39 S y s t e m . o u t . p r i n t l n ( \" B ú sq u e d a c o m p l e t a \" ) ; 40 / / i n v o c a r e l m é to d o r e m o to 41 S t r i n g m e n s a j e = h . d e c i r H o l a ( ) ) ; 42 S y s te m , o u t . p r i n t l n ( \" H D la M u n d o C lie n te : \" + m e n s a j e ) ; 43 } / / f i n t r y 44 c a t c h ( E x c e p t i o n e ) { 45 S y s te m . o u t . p r i n t l n ( 46 \" E x c e p c ió n e n H o la M u n d o C lie n te : \" + e ) ; 47 > 48 } / / f i n m a in 49 } / / f i n c l a s e La sintaxis de un fichero de políticas de seguridad de Java Un fichero d e políticas de seguridad de Java es un fichero de texto que contiene có­ digos que permiten especificar la concesión de permisos específicos. A continuación se muestra un fichero típico java.policy para una aplicación RMI. g r a n t { / / E s t e p e r m is o p e r m i t e a l o s c l i e n t e s RMI r e a l i z a r / / c o n e x i o n e s d e s o c k e t s a l o s p u e r t o s p ú b l i c o s d e / / c u a l q u i e r c o m p u ta d o r . / / S i s e a r r a n c a u n p u e r t o e n e l r e g i s t r o RMI e n e s t e / / r a n g o , n o e x i s t i r á u n a v i o l a c i ó n d e a c c e s o d e / / c o n e x i ó n . / / p e r m i s s i o n j a v a . n e t . S o c k e t P e r m i s s i o n 1 0 2 4 - 6 5 5 3 5 \" , / / \" o D n n e c t , a c c e p t , r e s o l v e \" ; / / E s t e p e r m is o p e r m i t e a l o s s o c k e t s a c c e d e r a l p u e r t o / / 8 0 , e l p u e r t o p o r d e f e c t o HTTP q u e e l c l i e n t e (continúa) www.FreeLibros.org // necesita para contactar con el servidor HTTP para // descarga de resguardo permission java.net.SocketPermission \"*:80\", \"connect\"; }? S e recomienda a l lector que cuando realice los ejercicios, haga una copia d e este fichero para la aplicación con el nombre java.policy en el mismo directorio tanto en la máquina del cliente de objeto como en la máquina del servidor de objeto. Cuando se active el cliente, hay que utilizar la opción del mandato que permite especificar que e l proceso cliente debe tener los permisos definidos en el fichero de políticas, de la siguiente forma: java -Ojava.security.policy= java.policy ClienteEjemplo Del mismo modo, el servidor debe activarse del siguiente modo: java -Djava.security.policy=java.policy ServidorEjemplo Estos dos mandatos asumen que el fichero de políticas se llam a java.policy y está disponible en e l directorio actual de la parte servidora y cliente. Una descripción detallada de las políticas de seguridad Java, incluyendo una ex­ p lic a c ió n d e la s in ta x is u tiliz a d a e n e s te fic h e ro , s e p u e d e e n c o n tr a r en [java.sun.com/marketing, 4). Uso de descarga de resguardo y un fichero de políticas de seguridad 1. Si debe descargarse el resguardo de un servidor HTTP, transfiera la clase res­ guardo a un directorio apropiado del servidor HTTP, por ejemplo, al directo­ rio re sg u a rd o s de la máquina www.miempresa.com, y asegúrese de que el per­ miso de acceso del fichero es de lectura para todos los usuarios. 2. Cuando se activa el servidor, se debe especificar las siguientes opciones del mandato: java — Djava.rmi. server. codbase=<URL> -D j ava. security. policy= <ruta canpleta del fichero de políticas de seguridad> donde <URL> es el URL del directorio donde se encuentra la clase resguardo; por ejem ­ plo, http: //www. miempresa. com/resguardos/. Obsérvese la barra del final del URL, que indica que el URL especifica un direc­ torio, no un fichero. <ruta completa del fichero de políticas de seguridad> especifica el fichero de po­ líticas de seguridad de la aplicación; por ejemplo, java.security, si el ficherojava.se- curity se encuentra en el directorio actual. Por ejemplo, java -D java. rmi. server. codebase=http: //www.miempresa .can/resguardos/ -Djava.security.policy=java.security HolaMundoServidor (todo en una línea) 2 3 8 C om putación distribuida. Fundam entos y aplicaciones www.FreeLibros.org RMI avanzado 2 3 9 arrancará la aplicación HolaMundoServidor y permitirá realizar descarga de resguar­ do del directorio resguardos del servidor web d e www.miempresa.com. L a Figura 8.13 muestra e l conjunto de ficheros que se necesitan para una aplica­ ción RMI y dónde se deben colocar, suponiendo descarga dinám ica de resguardo. (Por simplicidad, se asume que la aplicación no usa callback de cliente. Se podrían añadir los ficheros necesarios para realizar callback de cliente, si se deseara.) N o d o d e l c lie n te d e o b je to D ir e c to r io d el c lie n te d e o b je to InterfazEjempIo.class ClienteEjempIo.class java.policy S e rvid o r HTTP lmplEjemplo_stub.class F ig u ra 8 .1 3 . C o lo ca ció n de lo s fic h e ro s RMI en una a p lic a c ió n q u e utiliza d e sca rg a d e resguardo. En la parte del servidor, los ficheros necesarios son los ficheros class del servi­ dor, la interfaz remota, la implementación de la interfaz (generada por javac), el fi­ chero class del resguardo (generado por rmic), la clase del esqueleto (generado por rmic), y el fichero d e políticas de seguridad de la aplicación. En la parte cliente, los ficheros que se necesitan son el fichero class del cliente, el fichero class de la inter­ faz remota del servidor y el fichero de políticas de seguridad de la aplicación. Final­ mente, el fichero class del resguardo se debe almacenar en e l nodo HTTP del cual se descarga el resguardo. N o d o d e l s e rv id o r d e o b je to D ir e c to r io d el s e r v id o r d e o b je to InterfazEjempIo.class ServidorEjempIo.class ImplEjemplo.class lmplEjemplo_Skel. class java.policy www.FreeLibros.org 2 4 0 C om putación distribuida. Fundam entos y aplicaciones Algoritm os para construir una aplicación R M I, que perm ita descarga de resguardo A continuación se realiza una descripción del procedimiento paso a paso para la construc­ ción de una aplicación RMI, teniendo en cuenta el uso de descarga de resguardo. De nue­ vo, por cuestiones de simplicidad, se han obviado los detalles para el callback de cliente. A lg o ritm o para desarrollar el softw are de la parte del servidor 1. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 2. Especificar la interfaz remota de servidor en InterfazEjemplo.java. Compilar­ la y revisarla hasta que no exista ningún error de sintaxis. 3. Implementar la interfaz en ImplEjemplo.java. Compilarla y revisarla hasta que no exista ningún error de sintaxis. 4. Utilizar e l compilador RMI rmic para procesar la clase de la implementación y generar los ficheros resguardo y esqueleto para e l objeto remoto: r m ic Im p lE je m p lo Los ficheros generados se pueden encontrar en el directorio como ImplEjem- plo_Skel.class y ImplEjemplo_Stub.class. Los pasos 3 y 4 deben repetirse cada vez que se cambie la implementación de la interfaz. 5. Crear el programa del servidor d e objeto ServidorEjemplo.java. Compilarlo y revisarlo hasta que no exista ningún error de sintaxis. 6. Si se desea descarga de resguardo, copiar e l fichero resguardo en un directo­ rio apropiado del servidor HTTP. 7. Si se utiliza el registro RMI y no ha sido ya activado, activarlo. Por ejemplo: r m i r e g i s t r y e n u m e ro d e p u e r t o , 1099 p o r d e f e c t o Alternativamente, se puede codificar la activación en el programa del servidor de objeto. 8. Construir un fichero de políticas de seguridad para la aplicación denominado java.policy (u otro nombre), y colocarlo en un directorio apropiado o en e l di­ rectorio actual. 9. Activar el servidor, especificando (1) el campo codebase si se utiliza descar­ ga de resguardo, y (2) el fichero de políticas de seguridad. j a v a - D j a v a . r m i . s e r v e r . c o d e b a s e = h t t p : / / n o d o . d a n . e d u / r e s g u a r d o s / - d j a v a . s e c u r i t y . p o l i c y = j a v a . p o l i c y S e r v i d o r E j e m p l o Este mandato se ejecuta en una única línea, aunque se puede utilizar un ca­ rácter de continuación de línea ('Y) en un sistema UNIX. Se recomienda po­ ner el mandato en un fichero de texto ejecutable (tal como ejecServidor.bat en un sistema Windows o ejecServidor en un sistem a UNIX) y ejecutar el fiche­ ro para arrancar e l servidor. Para la aplicación HolaMundo, el fichero ejecServidor.bat contendría esta línea: ja v a - D j a v a . s e c u r i t y . p o l i c y = j a v a . p o l i c y - D j a v a . r m i . s e r v e r . c o d e b a s e = h t t p : / / v 7 V 7 W . c s c . c a l p o l y . e d u / - m l i u / r e s g u a r d o s / H o la M u n d o S e rv id o r De nuevo, no debería haber saltos de líneas en e l fichero. www.FreeLibros.org RMI avanzado 241 1. Crear un directorio donde se almacenen todos los ficheros generados por la aplicación. 2. Obtener una copia del fichero class de la interfaz remota del servidor. Alter­ nativamente, obtener una copia del fichero fuente para la interfaz remota y compilarlo utilizando javac para generar e l fichero class de la interfaz Inter- fazEjemplo. 3. Crear e l programa cliente ClienteEjemplo.java y compilarlo para generar la clase cliente. 4. Si se desea utilizar descarga de resguardo, obtener una copia del fichero class del resguardo (supóngase que se llama ImplEjemplo_Stub.class) y colocarlo en el directorio actual. 5. Construir un fichero de políticas de seguridad para la aplicación denominado java.policy (u otro nombre), y colocarlo en un directorio apropiado o en el di­ rectorio actual. 6. Activar el cliente, especificando el fichero de políticas de seguridad, j a v a - D j a v a . s e c u r i t y . p o l i c y = j a v a . p o l i c y C l i e n t e E j e m p l o Este mandato se ejecuta en una única línea, aunque se puede utilizar un ca­ rácter de continuación de línea (‘Y) en un sistema UNIX. S e recomienda po­ ner el mandato en un fichero de texto ejecutable (tal como ejecCliente.bat en un sistema Windows o ejecCliente en un sistema UNIX) y ejecutar e l fichero para arrancar el cliente. Para la aplicación HolaMundo, el fichero ejecCliente.bat contendría esta línea: j a v a - D j a v a . s e c u r i t y . p o l i c y = j a v a . p o l i c y H o la M u n d o C lie n te De nuevo, no debería haber saltos de líneas en el fichero. S i se utiliza callback de cliente, deben insertarse en este algoritmo los pa­ sos adicionales descritos en la sección anterior «Pasos para construir una apli­ cación RMI con callback de cliente». A lgoritm o p ara desarro llar el so ftw are de la parte cliente En este capítulo se han analizado algunas de las características avanzadas del API de Java RMI. Aunque estas características no son parte inherente del paradigma de ob­ jetos distribuidos, son interesantes y útiles para algunas aplicaciones. C allback de cliente • El callback de cliente es útil para las aplicaciones que deseen que el servidor les notifique la ocurrencia de algún evento. • El callback de cliente permite que un servidor de objeto realice una invocación de método remoto de un cliente a través de la referencia a una interfaz remota de dicho cliente. • Para dotar a la aplicación de callback de cliente, e l software de la parte clien­ te debe proporcionar una interfaz remota, instanciar un objeto que implemente dicha interfaz y pasar la referencia del objeto al servidor. El servidor de objeto www.FreeLibros.org 242 C om putación distribuida. Fundam entos y aplicaciones guarda estas referencias del cliente en una estructura de datos. Cuando el even­ to esperado ocurre, el servidor de objeto invoca un método callback (definido en la interfaz remota del cliente), pasando los datos a los clientes apropiados. • S e necesitan dos conjuntos de resguardo y esqueleto: uno para la interfaz re­ mota del servidor y el otro para la interfaz remota del cliente. D escarga de resguardo y gestor de seguridad • L a característica d e descarga de resguardo permite que un cliente pueda cargar una clase resguardo en tiem po de ejecución. • Esta técnica requiere la configuración de la propiedad java.rmi.servercodebase cuando se inicia el servidor: esta propiedad debe configurarse con e l directorio de un servidor HTTP donde se encuentre almacenada la copia del fichero class del resguardo y accesible a todos los usuarios. • Esta técnica tam bién requiere la instalación de un gestor de seguridad RMI tan­ to en la parte cliente como en la servidora. • Para llevar a cabo descarga de resguardo, es necesario el uso de un gestor de seguridad, ya que la ejecución de un objeto descargado de una máquina desco­ nocida puede suponer una amenaza para el computador cliente. • Un gestor de seguridad lleva a cabo las restricciones especificadas en un fiche­ ro de políticas de seguridad de Java, que puede ser el fichero de políticas del sistem a o un fichero de políticas aplicado solamente a una aplicación individual. • En este capítulo se mostró un ejem plo de fichero de políticas de seguridad para aplicaciones RMI. • Por cuestiones de seguridad, el uso de los gestores de seguridad es recomenda­ ble en todas las aplicaciones RMI, independientemente de que utilicen descar­ ga de resguardo o no. E JE R C IC IO S 1. En el contexto de Java RMI, ¿qué es el callback de cliente? ¿Por qué es útil? 2. Pruebe el programa ejemplo Callback en una o más máquinas. a. Cree una carpeta (denominada callback) para este ejercicio. Cree dos sub- carpetas (con los nombres Servidor y Cliente, respectivamente) en el PC. Copie los ficheros fuente en las carpetas Servidor y Cliente respectivamente. b. Siga los algoritmos presentados en el capítulo para configurar y ejecutar el servidor de objeto y el cliente de objeto. Escriba un informe indicando las acciones realizadas y las salidas. c. Arranque varios clientes sucesivamente. Escriba en el informe las acciones y las salidas de los programas. d. Copie el contenido de la carpeta callback en una carpeta nueva. Modifique los ficheros fuente en la nueva carpeta, de forma que e l servidor notifique solamente a un cliente cuando se hayan registrado para callback exacta­ mente tres clientes. Muestre los cambios realizados en los ficheros fuente. e. Volviendo a la carpeta callback, arranque un servidor y un cliente, especi­ ficando un tiem po de duración del cliente de 600 segundos. Mientras el www.FreeLibros.org RMI avanzado 243 cliente espera por callback, aborte el proceso cliente mediante el uso de la secuencia «control-c». Rápidamente arranque un nuevo proceso cliente de forma que el servidor intente realizar un callback a todos los clientes re­ gistrados. Apunte lo que se observa. Realice cambios a l código fuente de forma que los problemas observados no ocurran. Describa los cambios realizados a los programas. Entregue los listados fuente modificados. 3. En un ejercicio del capítulo anterior, se pedía utilizar RMI para escribir una aplicación que fuera un prototipo d e un sistem a de encuestas de opinión. Mo­ difique la aplicación para que cada cliente proporcione una interfaz de usua­ rio de forma que se pueda realizar un voto. Adicionalmente, debe mostrar en la pantalla del usuario el recuento actual siem pre que se realice un nuevo voto (sea desde este cliente o desde cualquier otro cliente). Recopile todos los listados de los ficheros fuentes, incluyendo los ficheros de las interfaces. Se recomienda una demostración de los programas en el la­ boratorio. 4. En el contexto de Java RMI, ¿qué es descarga de resguardo? ¿Por qué es útil? 5. Experimente con descarga de resguardo utilizando el ejemplo presentado en la Sección 8.3 de este capítulo. Los ficheros deben encontrarse en la carpeta stub- Downloading de los ejemplos de programas. a. Cree una carpeta (llamada stubDownloading) para este ejercicio. Cree dos subcarpetas en el PC y llám elas Servidor y Cliente, respectivamente. Copie los ficheros RMI del ejemplo HolaMundo en la carpeta correspondiente. b. Compile los ficheros. Utilice rmic para generar los ficheros resguardo y es­ queleto en la carpeta Servidor. Copie el fichero class del resguardo en la carpeta Cliente. c. Arranque un servidor de la carpeta Servidor sin especificar descarga de res­ guardo (es decir, sin configurar la propiedad codebase al arrancar el intér­ prete Java). A continuación, arranque un cliente de la carpeta Cliente. Com­ pruebe que funcionan de la forma esperada. d. En la carpeta Cliente, borre el fichero HolaMundoImpl_Stub.class. Arran­ que un cliente de nuevo. Debería obtenerse una notificación de excepcio­ nes Java en tiempo de ejecución debido a la ausencia de la clase resguardo. e. Volviendo a la carpeta Servidor, copie el fichero HolaMundoImpl_Stub.class a un servidor w eb desde e l que haya acceso, en un directorio denominado resguardos (o con algún otro nombre). Donde sea aplicable, establezca las protecciones de acceso al directorio resguardos y al fichero del resguardo, de forma que se pueda leer por todo el mundo. Arranque un servidor desde la carpeta Servidor, esta vez especi­ ficando descarga de resguardo (es decir, configurando la propiedad code­ base para permitir que se realice descarga de resguardo desde el directorio donde se encuentra e l fichero class del resguardo). f. Volviendo a la carpeta Cliente, pruebe a ejecutar el cliente de nuevo. Si las funciones de descarga de resguardo funcionan como se espera, el cliente debe funcionar esta vez. g. Pruebe a duplicar la carpeta Cliente y arranque otros clientes en diferentes sistemas de la misma forma, utilizando descarga de resguardo. www.FreeLibros.org 244 C om putación distribuida. Fundam entos y aplicaciones Escriba un informe describiendo el experimento. 6. Repita el ejercicio en el ejemplo Callback. Esta vez, el cliente debe poder re­ alizar una descarga d e resguardo del servidor dinámicamente, mientras que el servidor debe poder obtener el resguardo del cliente dinámicamente también. Se recomienda que la primera vez que se realice este experimento, se uti­ lice una copia de los ficheros de resguardo. A continuación borre el resguar­ do de servidor de la carpeta cliente, y pruebe a ejecutar el cliente con descar­ ga de resguardo. Consecutivamente, borre el resguardo del cliente d e la carpeta servidor, y pruebe a ejecutar el servidor con descarga de resguardo. Escriba un informe describiendo el experimento. R EFER EN C IA S 1. Descarga dinámica de código utilizando RMI, http://java.sun.eom/products/jdk/l.2/docs/ guide/rmi/codebase.html 2. Introducción a la com putación distribuida con RMI, http://developer.java.sun.com / developer/onlineTraini ng/rm i/RMI. html 3. CERT® Coordination Center, CERT/CC Computer Virus Resources, http://www.cert.org/ other_sources/vi ruses.html 4. Java Remóte Method Invocation - Computación distribuida para Java, http://java.sun.com/ marketing/ collateral/java rmi. html www.FreeLibros.org CAPÍTULO ' A p lic a c io n e s d e I n t e r n e t Sin ningún tip o de d u d a la aplicación d istribuida más conocida es la W o rld W ido Web (WWW), o la Web. Desde el punto de vista tecnológico la Web es un sistem a distribuido de servidores HTTP y clientes, tam bién conocidos com o servidores Web y clientes Web. Este capítulo examina diversos protocolos de Internet que son de interés no sólo por razones prácticas, sino porque proporcionan un caso de e studio de cóm o los protocolos evolucionan a lo largo del tiem po en respuesta a su dem anda de uso. Antes de la aparición de la W eb, la com unidad de usuarios de Internet estaba form ada por investigadores y académ icos que usaban servicios de red, tales com o el correo y la transferencia de ficheros para el intercam bio de datos. La W orld W ide Web (Telaraña Mundial) nació gracias a Tim Berners-Lee [w3.org/People, 4] a finales de 1990 en el CERN, el Laboratorio Europeo de Física de Partículas en Ginebra, Suiza lpublic.W eb.cern.ch, 6]. Tim Berners-Lee y Robert Cailllau realizaron la propuesta «universal hypertext system» en noviem bre de 1990. Desde esta propuesta original, el crecim iento de la W orld W ide Web ha sido extraordinario (véase Figura 9.1); la Web se ha expandido más allá de la com unidad científica y académ ica, llegando a todos los sectores del m undo, tanto com erciales com o dom ésticos. El W orld W ide Web C o rso rtiu m (W3C) [w3.org, 11] es el encargado de coordinar el continuo desarrollo de las tecnologías Web. www.FreeLibros.org 246 C om putación distribuida. Fundam entos y aplicaciones En los años 60, Doub Engelbart, el inventor del ratón, realizó el prototipo de un sistema on-line (oNLine System) denominado NLS que tenía navegación y edición hipertexto. Sin embargo, fue Ted Nelson el que acuñó el término hipertexto frw3.org/History.html, 2]. 160,000,000 140.000.000 120.000.000 100,000,000 80,000,000 60,000,000 40.000.000 20.000.000 Hobbes’ Internet Timeline Copyright ©2002 Robert H Zakon http://www. zakon. org/robert/internet/timeline/ DATE H0STS DATE H0STS 1 2 /6 9 4 0 5 /8 2 235 0 6 /7 0 9 0 8 /8 3 562 1 0 /7 0 11 1 0 /8 4 1 /0 2 4 1 2 /7 0 13 1 0 /8 5 1 /9 6 1 0 4 /7 1 23 0 2 /8 6 2 ,3 0 8 1 0 /7 2 31 1 1 /8 6 5 /0 8 9 0 1 /7 3 35 1 2 /8 7 2 8 ,1 7 4 0 6 /7 4 62 0 7 /8 8 3 3 ,0 0 0 0 3 /7 7 111 1 0 /8 8 5 6 ,0 0 0 1 2 /7 9 188 0 7 /8 9 1 3 0 ,0 0 0 0 8 /8 1 213 1 0 /8 9 1 5 9 ,0 0 0 New S u tv e y O íd S u tv e y lili If'l lili II rTTTTTTTTTTrrnTTTTTTTrTTrTTTTTTTrTn O ^ ^ f N O ) O O O » S * i ri i un ii i iTi i ni rn i O - r ( N F ig u ra 9 .1 . El c re c im ie n to d e la W W W [zako n.org, 1] (reim presa c o n perm iso). La genialidad de la World Wide Web es que combina tres tecnologías de compu­ tación importantes y bien asentadas: 1. Documentos h ip erte x to Los documentos K p a te x to preceden a la W W W y son documentos en los que ciertas frases o palabras, normalmente destacadas, pueden ser usadas como enlaces a otros documentos. De esta forma, un usua­ rio es capaz de acceder a documentos enlazados haciendo clic con el ratón en el texto destacado. 2. Recuperación de inform ación a través de una red Antes d e la aparición de la WWW, el servicio FTP (File Transfer Protocol, Protocolo de Transferencia de Ficheros) [ietf.org, 12] era el servicio más utilizado para la recuperación de información. 3. SGML {S ta n d a rd G en era ü eed M a iim p L anguage, Lenguaje Estandarizado d e M arcado General). En 1986 se creó un nuevo estándar ISO (ISO 8879) [iso.org, 3] que permitía marcar los documentos con etiquetas. Con este es­ tándar los documentos se podían representar en un formato uniforme en cual­ quier plataforma e independiente del mecanismo de presentación. Combinando estos tres conceptos, la World Wide Web permite marcar un documento con el lenguaje HTML {H y p o ie x t M arim p Lar& iage* Lenguaje d e M a ta d o d e H¡- per texto) de forma que un documento enlazado puede ser automáticamente transfe­ rido de un computador remoto d e Internet y presentado en un computador local. Básicamente la World Wide Web es una aplicación cliente-servidor basada en el protocolo HTTP ( H y p o te x t T ra n sfer P ro to co l Protocolo d e T r a sfistn r ia d e Hi- pertexto) [faqs.org, 8], que ya ha sido descrito brevemente en capítulos anteriores. Un servidor web es un servidor orientado a conexión que implementa HTTP y que por defecto ejecuta en el puerto 80. Un usuario ejecuta un cliente World Wide Web (normalmente conocido como navegador) en una máquina local. El cliente interactúa con el servidor web de acuerdo al protocolo HTTP, especificando el documento a www.FreeLibros.org Aplicaciones d e Internet 247 ferir. S i el servidor localiza e l documento en su directorio, devuelve su contenido al cliente, que lo presenta al usuario. La popularidad de la Web fue tal que, según se dijo, la carga del primer servidor Web, info.cem.ch, se multiplicó por 10 cada año entre 1991 y 1994. 9 .1 . H T M L H TM L (H y p e r te x t M a rk u p L a n g u a g e , le n g u a je de m arc ad o d e h ip e rte x to ) [archive.ncsa.uiuc.edu, 14] es el lenguaje d e etiquetado utilizado para crear documentos que pueden ser recuperados empleando la World Wide Web. HTML está basado en SGML, con semánticas apropiadas para representar la información de un amplio ran­ go de tipos de documentos. HTML puede representar noticias, correos o documenta­ ción hipertexto; menús de opciones; resultados de acceso a bases de datos; documen­ tos estructurados con im ágenes em bebidas; y vistas hipertexto d e cuerpos de información existentes. La Figura 9.2 muestra una página w eb escrita en HTML. F ig u ra 9 .2 . Código HTM L de ejem plo. <HTML> <HEAD> <TITLE>Un ejemplo de pagina Web</TITLE> </HEAD> <HR> <BODY> <í:enter> <Hl>Mi pagina principal</Hl> <IMG SRC=\"/imágenes/miFoto.gif\"> <b>Bienvenido a la pagina de Kelly</b> <P> <! A continuación una lista de hiperenlaces> <a href=\" /doc/miCV.html\">Mi curriculum vitae</a> <p> <a href=\" http: //www.algunaUniversidad.edu/ \">Mi universidad<a> </center> <HR> </BODY> </HTML> 9 .2 . X M L Mientras que HTML es un lenguaje que permite etiquetar un documento para la pos­ terior presentación de la información en él contenida, X M L (E x te m íH e M a ríatp L an- g ia g e , t a l a j e « tem ib le d e etiquetado) [w3.org/XML, 15] permite etiquetar un documento para estructurar su información. También basado en el SGML, XML uti­ liza etiquetas para describir la información contenida en el documento. La Figura 9.3 presenta un ejem plo m uy simple de código XM L [java.sun.com, 16] que describe la información estructurada que representa a un mensaje. Las etiquetas en este ejemplo www.FreeLibros.org 248 C om putación distribuida. Fundam entos y aplicaciones identifican el mensaje como una entidad, las direcciones de destino y de envío, el tem a y el texto del mensaje. Desde su introducción en 1998, XM L ha sido ampliamente utilizado en la com­ putación distribuida. Se utiliza en protocolos tales como SOAP (Simple Object Access Protocol, Protocolo Sim ple de Acceso a Objetos) para llam adas a procedimientos re­ motos basados en la Web y Jabber [jabber.org, 26] para mensajería instantánea. F ig u ra 9 .3 . C ó d ig o X M L d e e je m p lo . < m e n sa je > < £ a r a > tu @ tu D ir e c c i o n . c o m < /p a ra > < d e > y o @ m iD ire c c io n . c o itK /d e > < te m a > E s to e s u n m e n s a je < /te m a > < t e x t o > i H o la m undo! < / t e x t o > < /m e n s a je > 9 .3 . H TTP Originalmente concebido para el envío y la presentación de ficheros de texto, HTTP [w3.org/Protocols/PnTP/HTrP2.htm l, 7; ietf.org, 10; w3.org/Protocols/HTTP/AsIm- plemented.html, 17] se ha extendido para permitir la transferencia de contenidos web de tipos virtualmente ilimitados. Por eso se le conoce como e l protocolo de trans- porte de la Web. La primera versión de HTTP, HTTP/ft9i era un protocolo simple para la transfe­ rencia de datos crudos. La versión de HTTP más ampliamente utilizada es HTTP/LO, cuyo borrador [w3.org/Protocols/HTTP/AsImplemented.html, 17] fue propuesto por Tim Bemers-Lee en 1991. Aunque no tiene una especificación formal, su «uso co­ mún» se describe en el RFC 1945 [faqs.org, 8]. Desde ese momento, se ha desarro­ llado y a menudo adoptado un nuevo protocolo mejorado conocido como HTTP/1.1. HTTP/1.1 es un protocolo mucho más extenso que HTTP/1.0, pero las raíces básicas del protocolo están bien definidas en el más sencillo HTTP/1.0. En el resto d e esta sección se presentará lo esencial del HTTP/1.0 y se indicarán las principales diferen­ cias entre el HTTP/1.0 y el HTTP/1.1. En este capítulo, para mayor claridad, sólo se presentará un subconjunto del protocolo. HTTP es un protocolo orientado a conexión, sin estado y d e petición-respues­ ta Un servidor HTTP, o servidor web, ejecuta por defecto en el puerto TCP 80. Los clientes HTTP, normalmente denominados navegadores web, son procesos que imple- mentan el protocolo HTTP para poder conectarse a los servidores w eb y obtener do­ cumentos HTML. Estos documentos serán presentados de acuerdo a las etiquetas de dicho documento. En HTTP/1.0 cada conexión sólo permite una ronda de petición-respuesta: un clien­ te obtiene una conexión y manda una petición; el servidor procesa la petición, emite una respuesta y finaliza cerrando la conexión. La Figura 9.4, que ya fue vista en el Capítulo 2, es un diagrama de eventos que describe una sesión HTTP/1.0. HTTP es un protocolo de petición-respuesta basado en texto, ya que tanto la pe­ tición como la respuesta son cadenas de caracteres. Cada petición y cada respuesta están compuestas, en orden, por las siguientes partes: www.FreeLibros.org Aplicaciones d e Internet 249 La petición es un mensaje con tres partes: — <m andato> <direcc¡ón del d o c u m e n to eversión HTTP> — cabecera opcional — datos opcionales La respuesta es un mensaje con tres partes: — una línea de estado con form ato e p ro to c o lo x c ó d ig o e sta d o xd e scrip ció n > — inform ación de cabecera, pueden ser varias líneas — el docum ento en sí F ig u ra 9 .4 . D iagram a d e e v e n to s d e l p ro to c o lo d e tra n sfe re n cia d e h ip e rte x to . 1. La línea de p etirió n fresp u esta 2. Una sección d e c a b e c o a 3. Una línea en blanco. 4. El c u e rp a A continuación se describen cada una de estas tres partes: primero la petición y des­ pués la respuesta. La petición del cliente La petición del cliente se envía a l servidor después de establecer la conexión con el mismo. La línea de petición Una línea d e petición tiene e l siguiente formato: < m éto d o H T T P x e s p a c i o x U R I s o l i c i t a d o x e s p a c i o x e s p e c i f i c a c i ó n d e l p r o t o c o l o > \\ r \\ n donde: • <método H7TP> es el nombre de un método definido por el protocolo (que se describirán posteriormente), • <URI solicitado> es e l URI d e un documento web o, de forma más genérica, un objeto web, • <especificación del protocolo> es una especificación del protocolo del cliente, • <espacio> es un carácter de espacio. A continuación se muestra un ejemplo de línea de petición: GET / i n d e x . h t m l H T T P /1 .0 Servidor W eb Navegador Web www.FreeLibros.org 2 5 0 C om putación distribuida. Fundam entos y aplicaciones El <método HTTP> en la petición de un cliente es una palabra reservada que es­ pecifica la operación que el cliente desea del servidor. Algunos de los principales mé­ todos solicitados por los clientes son: • G E T - para solicitar el contenido de un objeto w eb referenciado por el URI es­ pecificado. • HEAD - para solicitar sólo una cabecera del servidor, no el objeto completo. • PO ST - usado para enviar datos a un proceso en el servidor. • P U T - usado para solicitar a l servidor que almacene el contenido adjunto a la petición en e l archivo especificado por e l URI. El <U RI solicitado> es un Identificador de Recurso Uniforme (Uniform Resource Identifier), ya introducido en el Capítulo 1, que tiene el siguiente formato. /c n o m b re d e d i r e c t o r i o > . . . /< n o m b re d e d i r e c t o r i o > / < n o m b r e d e f i c h e r o > La <especificación del protocole» especifica el protocolo (nombre y versión) que asume el cliente. Por ejemplo, HTTP/1.0. C a b e ce ra de la petición La línea de petición puede estar acompañada por una cabecera de petición. De acuer­ do a [faqs.org, 8], «Los campos de la cabecera d e la petición permiten al cliente pa­ sar al servidor información adicional sobre la solicitud y sobre él mismo. Estos cam­ pos actúan como modificadores de la petición, con sem ánticas equivalentes a los parámetros en la invocación de métodos (procedimientos) en un lenguaje de progra­ mación». Una cabecera está compuesta por una o más líneas, con el siguiente formato: < c l a v e > : < v a l o r > \\ r \\ n Algunas d e las claves y valores que pueden aparecer en la cabecera de la petición son: • A ccept - especifica los tipos d e contenido (content-types) aceptados por el cliente. • U ser-A gent - especifica e l tipo de navegador. • C a m e c tio n - se puede especificar «Keep-Alive» para solicitar que el servidor no cierre inmediatamente la conexión después de enviar la respuesta. • Host - nombre del ordenador del servidor. Un ejem plo de cabecera de la petición puede ser: A c c e p t: * /* C o n n e c t i o n : K e e p - A liv e H o s t: w w w .a lg u n a U .e d u U s e r - A g e n t: G e n e r i c C u e rp o de la petición Una petición puede finalizar con un cuerpo de petición, que contiene datos que ne­ cesitan ser enviados al servidor de forma conjunta con la petición. Por ejemplo, si se especifica el método POST en la línea de petición, el cuerpo deberá contener los da­ tos que deben ser entregados al proceso destino. (Esta es una característica importan­ te que se verá con mayor profundidad en las secciones de CGI y servlets). www.FreeLibros.org Aplicaciones d e Internet 251 A continuación se muestran algunos ejemplos de peticiones completas de cliente: E j a t fl o l GET / H T T P /1 .1 < l i n e a e n b l a n c o E je n tfo Z HEAD / H T T P /1 .1 ADCept: */* C b n n e c ti o n : K e e p - A liv e H D S t : a lg u n a M a q u in a . com U s e r - A g e n t: G e n e r i c < L in e a e n b l a n c o E ja tfJ o 3 BDST / c g i / m i S e r v i d o r . c g i H T T P /1 .0 A c c e p t: * /* C b n n e c ti o n : K e e p - A liv e H D S t : a lg u n a M a q u in a . com L te e r -A g e n t: G e n e r i c C b n t e n t - t y p e : a p p l i c a t i o n / x - w w w - f o r m - u r l e n c o d e d O D n t e n t - l e n g t h : 11 < l í n e a e n b l a n c o tto m b r e = jo r g e s e m a il= jo r g e @ a lg u n a U . e d u La respuesta del servidor En respuesta a una petición de un cliente, el servidor HTTP debe enviar una respuesta. De forma similar a una petición, una respuesta HTTP está compuesta de las siguien­ tes partes: 1. La respuesta o la línea de estado. 2. Una sección de cabecera. 3. Una línea en blanco. 4. El cuerpo. La línea de estado La línea de estado tiene el siguiente formato: < p r o to c o lo > < e s p a c i o > < c ó d i g o d e e s t a d o x e s p a c i o x d e s c r i p c i ó n > \\ r \\ n Los códigos de estado son los siguientes: 1 0 0 -1 9 9 I n f o r m a t i v o 2 0 0 -2 9 9 P e t i c i ó n d e l c l i e n t e s a t i s f a c t o r i a 3 0 0 -3 9 9 P e t i c i ó n d e l c l i e n t e r e d i r i g i d a 4 0 0 -4 9 9 P e t i c i ó n d e l c l i e n t e i n c o m p l e t a 5 0 0 -5 9 9 E r r o r e s d e l s e r v i d o r www.FreeLibros.org 2 5 2 C om putación distribuida. Fundam entos y aplicaciones E j a t f l o l HTTP/1 . 0 2 0 0 OK Es una línea de estado enviada por un servidor que ejecuta HTTP/1.0 y que indica que la petición se procesó de forma satisfactoria. E je n flo 2 HTTP/1 . 1 4 0 4 NOT FOUND Es una línea de estado enviada por un servidor que ejecuta HTTP/1.1 y que indica que la respuesta no fue procesada de forma satisfactoria porque el documento espe­ cificado no se encontró. C a b e ce ra de la respuesta La cabecera de la respuesta aparece a continuación de la línea d e estado. La cabece­ ra está compuesta de una o más líneas con el siguiente formato: < c l a v e > : < v a l o r > \\ r \\ n Existen dos tipos de líneas que pueden aparecer en la cabecera d e la respuesta: • Lineas d e respuesta Estas líneas de cabecera devuelven información sobre la respuesta, el servidor y detalles adicionales del acceso a los recursos solicita­ dos, de la siguiente manera: A g e: s e g u n d o s L o c a t i o n : URI R e t r y - A f t e r : f e c h a |s e g u n d o s S e r v e r : c a d e n a V W W -A u th e n tic a te : m é to d o d e a u t e n t i c a c i ó n • Lineas d e entidad. Estas líneas de cabecera contienen información sobre los contenidos de los objetos solicitados por el cliente, de la siguiente manera: C o n te n t - E n c o d in g C o n t e n t - L e n g t h C o n te n t - T y p e : t i p o / s u b t i p o ( v e r MIME) E x p i r e s : f e c h a L a s t - M o d i f i e d : f e c h a A continuación se muestra un ejem plo de cabecera de la respuesta: D a te : M on, 3 0 O c t 2 002 1 8 : 5 2 : 0 8 GMT S e r v e r : A p a c h e / 1 .3 .9 ( U n ix ) A p a c h e J S e r v / 1 .0 L a s t - m o d i f i e d : b t o n , 17 J u n e 200 1 1 6 : 4 5 : 1 3 GMT C o n t e n t - L e n g t h : 1255 C O n n e c tio n : c i ó s e C o n t e n t - i y p e : t e x t / h t m l En [ietf.org, 10] se puede encontrar una lista completa de tipos de líneas de res­ puesta. Algunos de los tipos más importantes son: • C anáent-Type que especifica el nombre del tipo de datos dentro del protocolo MIME, que será analizado más adelante en esta sección. www.FreeLibros.org Aplicaciones d e Internet 2 5 3 • C oném tE ncotM ng que especifica el esquema de codificado de los datos (tales como uuencode o base64), normalmente usados con propósito d e compresión de datos. • C a n ten t-kn g tb es el tamaño en número de bytes del contenido del cuerpo de la respuesta. • E xp ira tia n d a te que d a la fecha/hora (especificada en un formato definido por HTTP) después de la cual el objeto w eb se considera obsoleto. • L ast-M odtiR ed d a te que especifica la fecha en la que el objeto fue modificado por última vez. C u e rp o de la respuesta El cuerpo de la respuesta v a a continuación de la cabecera y de una línea en blanco y contiene los contenidos del objeto w eb solicitado. La Figura 9.5 contiene un ejem plo completo de respuesta HTTP. F ig u ra 9 .5 . Un e je m p lo d e re sp u e sta HTTP. HTTP/1 . 1 2 0 0 OK t e t e : S a t , 15 S ep 2 0 0 1 0 6 : 5 5 : 3 0 GMT S e r v e r : A p a c h e /1 . 3 . 9 ( U n ix ) A p a c h e J S e r v / 1 .0 l a s t - M o d i f i e d : M on, 30 A p r 200 1 2 3 : 0 2 : 3 6 GMT E T ag : \" 5 b 3 8 1 - e c - 3 a e d e f 0 c \" A c c e p t- R a n g e s : b y t e s C b n t e n t - L e n g t h : 236 C b n n e c t i o n : c i ó s e C b n te n t - T y p e : t e x t / h t m l < h tm l> < h ead > < t i t l e > M i p á g i n a w e b < / t i t l e > < /h e a d > < body> ¡H o la m undo! < / b o d y x / h tm l> Tipos de contenido y M IM E Una de las líneas de cabecera más importantes devueltas en la respuesta de un servi­ dor es el tipo de contenido (Content-Typé) del objeto solicitado. La especificación del tipo de contenido sigue un esquema establecido en e l protocolo conocido como M IM E {M ultipurpo se In te rn e t M a ü E x ím s k n , « to m o n e s nultípropóáto para d co rreo o í Internet). Aunque originalmente se utilizó para correos electrónicos, hoy en día M IM E es ampliamente utilizado para describir el contenido de los documentos man­ dados sobre una red. MIME soporta un gran conjunto de tipos d e contenido predefinidos, especificados con e l formato tip o /su b tip o La Tabla 9.1 muestra un pequeño subconjunto de tipos y subtipos. uuencode significa codificación UNIX-a-UNIX (iJNIX-to-UNIX encode) y en s u origen fue un esquem a d e codificación utilizado para enviar contenido d e texto entre sistem as UNIX. Sin embargo, ha sido extendido m ás allá de dichos sistem as. Base64 es un esquem a de codificación para contenidos d e texto especificado en el protocolo MIME gaqs.org, 9].__________ www.FreeLibros.org 254 C om putación distribuida. Fundam entos y aplicaciones Tab la 9 .1 . Un s u b c o n ju n to d e T ip o s d e C o n te n id o M IM E. Tipo Subtipo text message application image audio video Plain, rich text, html, tab-separated valúes, xml Email, news Octet-stream (puede ser utilizado, por ejemplo, para enviar ficheros Java.class), Adobe- postscript, Mac-binhex40, xml jpeg. # basic,midi,mp3 mpeg, quicktime Un clien te H TTP sencillo Para afianzar los conocimientos obtenidos hasta este momento se va a realizar un cliente HTTP básico que ya se debería ser capaz de implementar. Indudablemente el lector ya habrá utilizado un navegador web comercial como Netscape o Internet Ex­ plorer para acceder y visualizar objetos web. Aunque la lógica de presentación en es­ tos navegadores es compleja, la lógica del servicio no lo es, tal y como se puede apre­ ciar en el cliente HTTP básico presentado en la Figura 9.6. En el código de ejemplo, el cliente utiliza un socket orientado a conexión para enviar al servidor w eb una pe­ tición formulada de acuerdo a l HTTP. A continuación el cliente interpreta y presenta la respuesta devuelta por e l servidor, línea por línea. F ig u ra 9 .6 . Un c lie n te HTTP s e n c illo e s c rito c o n la API d e so cke ts. 1 / / M i S o c k e tS tr e a m e s l a c l a s e J a v a p r e s e n t a d a e n e l C a p í t u l o 4 2 i m p o r t M i S o c k e tS tr e a m ; 3 i m p o r t j a v a . n e t . * ; 4 i m p o r t j a v a . i o . * ; 5 6 p u b l i c c l a s s C lie n te H T T P { 7 8 / / A p l i c a c i ó n q u e s e c a n u n i c a c o n u n s e r v i d o r HTTP 9 / / p a r a r e c i b i r e l c o n t e n i d o d e t e x t o d e u n a p á g i n a w eb 10 / / A rg u m e n to s e s p e r a d o s , e n o r d e n : 11 / / < n o m b re d e l s e r v i d o r HTTP> 12 / / < n ú m ero d e p u e r t o d e l s e r v i d o r HTTP> 13 / / < r u t a c o m p l e ta a l d o c u m e n to w eb e n l a m á q u in a s e r v i d o r a > 14 15 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 16 i f ( a r g s . l e n g t h != 3 ) 17 S y s te m , o u t . p r i n t l n 18 ( \" E s t e p r o g r a m a n e c e s i t a 3 a r g u m e n t o s \" ) ; 19 e l s e { 20 t r y { 21 I n e t A d d r e s s m a q u in a = 22 I n e t A d d r e s s .g e tB y N a m e ( a r g s [ 0 ] ) ; 23 i n t p u e r t o = I n t e g e r . p a r s e l n t (a r g s [ 1 ] ) ; 24 S t r i n g n o m b r e F ic h e r o = a r g s [ 2 ] . t r i m ( ) ; (continúa) www.FreeLibros.org Aplicaciones d e Internet 255 25 S t r i n g p e t i c i ó n = 26 \"GET \" + n o ir b r e F ic h e r o + \" H T T P / 1 .0 \\ n \\ n \" ; 27 M i s o c k e t s t r e a m m i S o c k e t = 28 new M i S o c k e tS tr e a m ( m a q u in a , p u e r t o ) ; 29 S y s t e m . o u t . p r i n t l n ( \" C o n e x i ó n r e a l i z a d a \" ) ; 30 m i S o c k e t. e n v i a r M e n s a j e (p e t i c i ó n ) ; 31 / / A h o ra s e r e c i b e l a r e s p u e s t a d e l s e r v i d o r HTTP 32 S t r i n g r e s p u e s t a ; 33 r e s p u e s t a = m i S o c k e t . r e c i b i r M e n s a j e ( ) ; 34 / / L e e r y m o s t r a r u n a l i n e a c a d a v e z 35 w h i l e ( r e s p u e s t a != n u i l ) { 36 S y s te m , o u t . p r i n t l n ( r e s p u e s t a ) ; 37 r e s p u e s t a = m i S o c k e t . r e c i b i r M e n s a j e ( ) ; 38 } 39 > 40 c a t c h ( E x c e p t i o n e x ) { 41 S y s te m . o u t . p r i n t l n ( \" ERROR : \" + e x ) ; 42 e x . p r i n t S t a c k T r a c e ( S y s t e m . o u t ) ; 43 > / / f i n c a t c h 44 } / / f i n e l s e 45 > / / f i n m a in 46 } / / f i n c l a s s El cliente HTTP abre una conexión con un servidor HTTP especificado por el usuario. A continuación e l cliente formula una petición GET sencilla, envía la peti­ ción al servidor y visualiza la respuesta recibida del servidor. A diferencia de los na­ vegadores comerciales, este navegador no interpreta la respuesta, simplemente mues­ tra el texto tal y como lo recibe. También es interesante saber que la API de Java proporciona una clase denom i­ nada URL, expresamente realizada para recibir datos de un objeto w eb identificado por su URI. La Tabla 9.2 describe dos constructores y un método clave dentro de esta clase, que son utilizados en el código de ejemplo de la Figura 9.7 para imple mentar este sencillo navegador web. T a b la 9 .2 . M é to d o s d e l o b je to J a v a URL. M é to d o / C o n s tru c to r D e s c rip c ió n URL (String nombre) URL (String protocolo, String máquina, int puerto, String archivo) InputStream openStream() Crea un objeto URL usando el nombre URL contenido en el String. Crea un objeto URL usando el protocolo, especificado, la maquina, e l puerto y el archivo. Abre una conexión a este URL y devuelve un InputStream con el cual leer de la conexión. F ig u ra 9 .7 . Un c lie n te HTTP s e n c illo e s c rito c o n la c la s e URL. 1 i m p o r t j a v a . n e t . * ; 2 i m p o r t j a v a . i o . * ; 3 (continúa) www.FreeLibros.org 256 C om putación distribuida. Fundam entos y aplicaciones 4 p u b l i c c l a s s n av eg ad o rU R L { 3 6 / / A p l i c a c i ó n q u e u t i l i z a e l o b j e t o URL p a r a r e c i b i r 7 / / e l t e x t o c o n t e n i d o e n u n a p á g i n a w e b . 8 / / A rg u m e n to s e s p e r a d o s , e n o r d e n : 9 / / c n o m b re d e l s e r v i d o r HTTP> 10 / / e n u m e ro d e p u e r t o d e l s e r v i d o r HTTP> 11 / / < r u t a c o m p l e ta a l d o c u m e n to w eb e n l a m á q u in a s e r v i d o r a > 12 13 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 14 i f ( a r g s . l e n g t h != 3 ) 15 S y s te m . o u t . p r i n t l n 16 ( \" E s t e p r o g r a m a n e c e s i t a 3 a r g u m e n t o s \" ) ? 17 e l s e { 18 t r y { 19 S t r i n g m a q u in a = a r g s [ 0 ] ; 20 S t r i n g p u e r t o = a r g s [ 1 ] . t r i m ( ) ; 21 S t r i n g n o m b re A rc h iv o = a r g s [ 2 ] . t r i m ( ) ; 22 S t r i n g cadenaU R L = 23 \" h t t p : / / \" + m a q u in a + + p u e r t o +I|G 24 URL elU RL = new U R L ( \" h t t p \" , m a q u in a , p u e r t o , cad en aU R L ) 25 26 I n p u t S t r e a m e n S tr e a m = elU R L . o p e n S tr e a m ( ) ; 27 B u f f e r e d R e a d e r e n t r a d a = 28 new B u f f e r e d R e a d e r 29 (n ew I n p u t S t r e a m R e a d e r ( e n S t r e a m ) ) ; 30 S t r i n g r e s p u e s t a ; 31 r e s p u e s t a = e n t r a d a . r e a d L i n e ( ) ; 32 / / L e e r y m o s t r a r u n a l í n e a c a d a v e z 33 w h i l e ( r e s p u e s t a != n u i l ) { 34 S y s te m , o u t . p r i n t l n ( r e s p u e s t a ) ; 35 r e s p u e s t a = e n t r a d a . r e a d L i n e ( ) ; 36 } / / f i n w h i l e 37 > 38 c a t c h ( E x c e p t i o n e x ) { 39 S y s t e m .o u t . p r i n t l n (\" ERROR : \" + e x ) ; 40 e x . p r i n t S t a c k T r a c e (S y s te m , o u t ) ; 41 > / / f i n c a t c h 42 > / / f i n e l s e 43 } / / f i n m a in 44 } / / f i n c l a s s HTTP, un protocolo orientado a conexión y sin estado Tal y com o está especificado en [faqs.org, 8], HTTP es un protocolo orientado a co­ nexión. Con HTTP/1.0 la conexión con e l servidor se d o r a autom áticam ente tan pronto como el servidor ha devuelto la respuesta. De esta forma, sólo se permite un turno de intercam bio entre el cliente y e l servidor web. Si un cliente necesita con­ tactar con e l mismo servidor m ás de una vez en una sesión, debe reconectarse al www.FreeLibros.org Aplicaciones d e Internet 2 5 7 servidor cada nueva petición. Este esquem a es lógico con el propósito original de HTTP, es decir, recibir docum entos sim ples por la red. Sin embargo, es ineficiente para recibir docum entos que contienen un gran número d e enlaces a objetos adi­ cionales que deben ser pedidos al servidor, y a que la petición de cada uno de estos enlaces requiere reestablecer la conexión. También es un mecanismo insuficiente para aplicaciones w eb sofisticadas basadas en HTTP (como las que contienen ca­ rritos d e compra). Como resultado HTTP/1.0 se extendió para permitir la cabecera de petición Connection: Keep-Alive, que es enviada por los clientes que desean m an­ tener una conexión persistente con e l servidor; el servidor mantendrá la conexión abierta después de enviar la respuesta. En HTTP/1.1 las conexiones son persisten­ tes por defecto. Una conexión persistente permite enviar m últiples respuestas sobre una misma conexión TCP. HTTP/1.0 (al igual que la versión 1.1) es un protocolo sin estado: e l servidor no mantiene ninguna información de estado sobre la sesión del cliente. Sin tener en cuen­ ta si la conexión se mantiene abierta, cada petición se maneja por el servidor como una nueva. Tal y como sucedía con las conexiones no persistentes, un protocolo sin estado es adecuado para el propósito original del protocolo, pero no es apropiado para aplicaciones más complejas para las cuales HTTP ha sido extendido. 9 .4 . C O N T E N ID O W EB G EN ER A D O DE FO R M A D IN Á M IC A Al principio HTTP se utilizaba para transferir contenido estático, es decir, contenido que existe de forma constante, como por ejemplo un fichero de texto plano o un fi­ chero con una imagen. Según evolucionó la Web, las aplicaciones empezaron a utili­ zar HTTP con nuevos propósitos: como una aplicación que permite al navegador re­ cibir datos basados en información dinámica introducida durante una sesión HTTP. Una aplicación web típica, tal como un carrito de la compra, requiere el envío de los datos introducidos por el cliente en tiempo de ejecución. Por ejemplo, una aplicación empresarial normalmente permite a un usuario introducir datos que más adelante son utilizados como parte de una consulta para recibir datos de una base de datos; a con­ tinuación, el resultado de esta consulta es formateado y enviado al usuario. Para im­ plementar esta aplicación basada en la Web, es necesario permitir al cliente enviar da­ tos durante una sesión web, para poder recibir datos de un servidor web, que sean representados por el navegador w eb (véase Figura 9.8). Con este propósito, el proto­ colo HTTP básico se extendió con protocolos adicionales que permitían la creación de contenidos web generados dinámicamente, es decir, contenidos que no existen de forma constante, sino que son generados dinámicamente de acuerdo a determinados parámetros en tiempo de ejecución. En la Figura 9.8, las líneas punteadas con flechas representan el flujo de datos en­ tre la fuente de datos (en este caso un sistem a de base de datos) y el servidor HTTP. Las líneas de puntos indican que los datos no van directamente de la fuente de datos al servidor. La razón del flujo de los datos indirecto es que un servidor HTTP gené­ rico no posee la lógica de aplicación para recoger los datos d e la fuente de datos. En su lugar, un proceso « t o n o que tiene la lógica de aplicación necesitará intervenir como intermediario. En este ejemplo, el proceso externo ejecuta en la máquina servi­ dora, aceptando datos de entrada del servidor web, ejecutando su lógica de aplicación para obtener los datos de la fuente de datos y devolviendo el resultado al servidor web, que los transmitirá al cliente. www.FreeLibros.org 2 5 8 Computación distribuida. Fundamentos y aplicaciones M á q u in a co n servidor w e b M á q u in a c o n clien te w e b S e rvid o r w e b « id = l 2 3 4 5 » C lie n te w e b A « 5 4 3 2 l= id » «ingrese Y J S istem a de b a se de d a to s «ingresos=30000» >s=30000» F ig u ra 9 .8 . C o n te n id o w e b d in á m ico . El primer protocolo ampliamente adoptado para aumentar a HTTP en el soporte de contenido web generado en tiempo de ejecución es CGI ( C antnan G atew ay In tería ce, interfaz estándar de pasarela), que se verá en el siguiente tema. Aunque es elemental en comparación con otros protocolos más sofisticados que han surgido posteriormente, CGI es el predecesor de estos sofisticados protocolos y facilidades (tales como Java servlet) que sirven para propósitos similares. Entender CGI y alguno de sus protocolos asociados es útil porque prepara para el estudio de protocolos y herramientas más avan­ zadas. Hoy en día los CGI siguen siendo extensamente utilizados en la Web. 9 .5 . CGI CGI (CoBMnoa G atew ay In to fa e q interfaz estándar d e pasarela) (hoohoo.ncsa.uiuc.edu/ egi/overview.html, 19; hoohoo.ncsa.uiuc.edu/cgi/interface.html, 20; comp.leeds.ac.uk, 21] es un protocolo que proporciona una interfaz, o pasarela, entre un servidor de in­ formación y un proceso externo (es decir, un proceso externo al servidor). Utilizando el protocolo CGI, un cliente w eb puede especificar un programa, conocido como sn q p t C G I como objeto w eb de destino de una petición HTTP. El servidor web llam a al script CGI y lo activa como un proceso, pasándole los datos de entrada transmitidos por el cliente web. El script web ejecuta y transmite su salida al servidor web, que devuelve los datos generados por dicho script como el cuerpo de la respuesta al clien­ te web. El diagrama de secuencia de la Figura 9.9 muestra el funcionamiento de una apli­ cación CGI de ejemplo. Un navegador manda la petición de un documento estático hola.html (Figura 9.10). El servidor web busca el documento estático y devuelve su contenido al navegador dentro de cuerpo de la respuesta. El contenido (cuya sintaxis se verá en la próxima sección) contiene una llamada a un script w eb denominado hola.cgi. Cuando se presiona el botón Enviar, presentado en la pantalla del navega­ dor, se manda una nueva petición al servidor web, especificando hola.cgi como obje­ to web a llamar. Suponiendo que el objeto pedido es un script CGI y, por tanto, eje­ cutable, el servidor comienza la ejecución del script pasándole los datos d e entrada del navegador del usuario. En el transcurso de la ejecución del script CGI, se gene­ ra el contenido d e una página w eb como salida del programa y se transmite al servi­ dor. Por último, e l servidor envía la página w eb generada dinámicamente al cliente web en el cuerpo de la respuesta. www.FreeLibros.org Aplicaciones d e Internet 259 M áquina con servidor w eb M áquina con cliente web Script CGI Servidor HTTP Cliente w e b petición d e hola.htm l contenido de hola.htm l petición de hola .cgi datos, si hay, del cliente respuesta del servidor, incluyendo p áginas generadas dinám icam ente F ig u ra 9 .9 . El p ro to c o lo CGI. La Figura 9.10 contiene el código de la página w eb hola.html. Se verán los deta­ lles de la sintaxis más adelante dentro de esta misma sección. Por el momento, es im­ portante darse cuenta de que la etiqueta A C TIO N especifica el nombre del script CGI hola.cgi. F ig u ra 9 .1 0 . H o la.h tm l. < !E je m p lo d e p á g i n a w eb q u e i n v o c a a u n CGI> < !A u t o r : M. L i u , 9 / 1 5 / 0 1 > <HTML> <HEAD> < riT L E > P á g in a w eb q u e i n v o c a a u n s c r i p t w eb< /T IT L E > </HEAD> <BODY> < i l > E s t a p á g i n a m u e s t r a e l u s o d e u n s c r i p t w e b < /H l> <P> <FONT c o l o r = g r e e n > E s t a p á g i n a c o n t i e n e u n a e t i q u e t a d e a c c i ó n q u e e s p e c i f i c a u n s c r i p t w eb. D e s p u é s d e r e c i b i r e s t a p á g i n a d e l s e r v i d o r w e b , e l n a v e g a d o r p r o c e s a s u c o n t e n i d o y , c u a n d o s e p r e s i o n a e l b o t ó n ENVIAR, p i d e a l s e r v i d o r q u e e j e c u t e e l s c r i p t o p r o g r a m a e s p e c i f i c a d o e n l a e t i q u e t a ACTION </F0NT> <BR> E l s c r i p t o p r o g r a m a p u e d e e s t a r e s c r i t o e n un l e n g u a j e d e s c r i p t , p o r e je m p lo P e r l , o p u e d e s e r u n e j e c u t a b l e g e n e r a d o d e s d e u n c ó d i g o f u e n t e e s c r i t o e n u n l e n g u a j e t a l com o C /C ++ < /P > (continúa) www.FreeLibros.org 2 6 0 C om putación distribuida. Fundam entos y aplicaciones Java no se utiliza para implementar programas CGI. En el Capítulo 11 se verán los servlets de Java en profundidad; programas Java equivalentes a los scripts CGI. Linefeed es un carácter de línea nueva (new-line), que tiene un valor ASCII de 10. <HR> <FQRM METHOD=\"post\" ACTION=\"hola.cgi\"> <HR> Presione <input type=\"submit\" value=\"aquí\"> para enviar su petición </FORM> <HR> </BODY> </HTML> La Figura 9.11 muestra una implementación de hola.cgi. El ejemplo está escrito en C. Aunque pueda ser que el lector no esté familiarizado con el lenguaje C, su sin­ taxis es suficientemente parecida a Java como para poder entender los códigos de ejemplo de este capítulo. Un programa CGI puede estar escrito en cualquier lengua­ je de programación, incluyendo los lenguajes interpretados (tales como Perl, TKL, Pyt- hon, JavaScript, Visual Basic script), a l igual que los lenguajes compilados (tales como C, C++, ADA). Sólo a modo de ejemplo, en la Figura 9.12 está una versión del pro­ grama escrita en el popular lenguaje de script Perl. Aunque sin estar familiarizado con Perl, es posible reconocer la sencilla sintaxis del programa, que simplemente produ­ ce el contenido de la página web línea por línea, comenzando con una línea de ca­ becera de respuesta que especifica el tipo de contenido, seguido por dos caracteres de nueva línea, y finalizado por las líneas HTML que especifican el mensaje «Hola Mun­ do» en color azul. F ig u ra 9 .1 1 . H ola.cgi, un p ro gra m a en C c o n un sc r ip t CGI. /* * E s t e p r o g r a m a C e s u n s c r i p t CGI q u e g e n e r a * l a s a l i d a d e u n a p á g i n a w e b . C uan d o e s r e p r e s e n t a d o p o r * e l n a v e g a d o r , s e m u e s t r a e l m e n s a je \" H o la Mundo\" e n a z u l # i n c l u d e < s t d i o . h > m a in ( i n t a r g c , c h a r * a r g v [ ] ) { printf(\"Content-type: text/html%c%c\",10,10); printf(\"<font color = blue>\"); printf(\"<Hl>Hola Mundo</Hl>\"); printf(\"</font>\"); } Las líneas de salida se transmiten a l servidor web, que devuelve dichas líneas al cliente como respuesta. (Obsérvese que no hay línea d e estado en la salida del script CGI: la ausencia de línea de estado se interpreta como estado correcto por el nave­ gador.) La Figura 9.12 presenta e l mismo script web, escrito en el lenguaje interpretado Perl. www.FreeLibros.org Aplicaciones d e Internet 261 F ig u ra 9 .1 2 . H ola.pl, un p ro gra m a Perl c o n un s c rip t CGI. # ! / u s r / l o c a l / b i n / p e r l # L a l i n e a s u p e r i o r d e b e s e r l a p r i m e r a l i n e a d e l p r o g r a m a . # E s p e c i f i c a q u e s e i n v o c a a l i n t é r p r e t e d e P e r l c u a n d o # s e e j e c u t a e l s c r i p t . L a r u t a d e l d i r e c t o r i o e s p e c i f i c a d o # d e b e s e r l a q u e c o n t e n g a e l i n t é r p r e t e d e P e r l # e n e l s e r v i d o r w e b . # H o l a . p l # Un s e n c i l l o s c r i p t CGI e n P e r l p r i n t \" C o n t e n t - t y p e : t e x t / h t m l \\ n \\ n \" ; p r i n t \" < h e a d > \\n \" ; p r i n t \" < t i t l e > H o l a M u n d o < / t i t l e > \\ n \" ; p r i n t \" < / h e a d > \\ n \" ; p r i n t \" < b o d y > \\n \" ; p r i n t \" < f o n t c o l o r = b l u e > \\ n \" ; p r i n t \" < h l> H o la M u n d o < /h l> \\n \" ; p r i n t \" < / f o n t > \\ n \" ; p r i n t \" < / b o d y > \\ n \" ; El ejemplo que se ha presentado no hace uso de información suministrada por el usuario, y el contenido de la página w eb que se genera dinámicamente es predecible. Esto es debido a que el ejem plo proporcionado es un ejemplo básico del protocolo CGI. En la práctica, un script CGI se invoca desde una página web especial conoci­ da como formulario web (que será descrito en la siguiente sección), que acepta en­ tradas en tiempo de ejecución e invoca un script CGI que hace uso de esas entradas. Un form ulario w eb Un formulario w eb [w3.org, 24] es un tipo especial de página w eb que (1) propor­ ciona una interfaz gráfica de usuario que permite al usuario introducir datos y, (2) cuando el usuario pulsa el botón de Envío, invoca la ejecución de un programa ex­ terno en la máquina del servidor web. En la Figura 9.13 se puede ver la pantalla de un navegador mostrando un formulario web sencillo. La Figura 9.14 presenta el código HTML que genera el formulario web. Se pue­ den encontrar más detalles sobre las etiquetas usadas en el código en [ftp.ics.uci.edu, 13; archive.ncsa.uiuc.edu, 14]. F ig u ra 9 .1 4 . C ó d ig o d e un fo rm u la rio w e b s e n c illo [a rch ive .n csa .u iu c.e d u , 14]. 1 <HTML> 2 <HEAD> 3 <TITLE>Un e je m p lo d e f o r m u l a r i o s e n c i ll o < /T I T L E > 4 </HEAD> 5 <BODY> 6 < H l> E s to e s u n f o r m u l a r i o s e n c i l l o < / H l > 7 <FORM METHOD=\"get\" A C T I O N = \" f o r m u la r io .c g i\" > (continúa) www.FreeLibros.org 262 C om putación distribuida. Fundam entos y aplicaciones HTML no es sensible a la diferencia entre letras mayúsculas y minúsculas: el uso de letras mayúsculas en las etiquetas es opcional. Un URL relativo está basado en el directorio de la página web en la que aparece dicho URL Por ejemplo, si la página web es 8 <H2> C u e s t i o n a r i o : < /H 2> 9 I n t r o d u c e t u n a n b r e : <INPUT NAME=\"n o m b re \" x p > 10 ¿ C u á l e s t u p r e g u n t a ? : <INPUT N A M E = \" p re g u n ta \" x p > 11 ¿ C u á l e s t u c o l o r f a v o r i t o ? : 12 <SELECT N A M E = \"color\"> 13 O P T IO N SELECTED>verde a m a r i l l e n t o 14 <O PT IO N >azul 15 <O PTION >pardo r o j i z o 16 <O PT IO N >aciano 17 < O P T IO N >gris o l i v a 18 <O PT IO N >bronce 19 < O P T IO N > añil 20 < O P T IC N >alm endra b l a n c a 21 <O PT IC N >verde 22 <O PTIO N >ocre 23 <O PTIO N >ópalo 24 <OPTION>ámbar 25 < 0 P T I0 N > m o staza 26 < / SELECT> 27 <P> 28 ¿ C u á n to p e s a u n a g o l o n d r i n a ? : 29 <INPUT T Y P E = \" ra d io \" NAME=\"g o l o n d r i n a \" 30 VALUE=\" a f r i c a n \" c h e c k e d > G o l o n d r i n a a f r i c a n a o 31 <INPUT T Y P E = \" ra d io \" N A M E = \"g o lo n d rin a\" V A L U E = \" c o n tin e n ta l\"> 32 G o l o n d r i n a c o n t i n e n t a l 33 <P> 34 A lg o m á s q u e d e s e e s a ñ a d i r 35 <TEXTAREA N A M E = \"texto\" ROWS=5 COLS= 60> < /TEXTAREA> 36 <P> 37 P r e s i o n a <INPUT TYPE=\" s u b m i t \" NAME=\" S B o to n \" V A L U E =\"aquí\"> 38 p a r a e n v i a r . 39 </FORM> 40 <HR> 41 </BODY> 42 </HTML> El código que genera el formulario web se encierra entre las etiquetas <FORM> ... </FORM> (ver líneas 7 y 39 del ejemplo). Con la etiqueta <FORM> (ver línea 7), se pueden especificar atributos para suministrar información adicional al protocolo CGI, incluyendo: • ACTION=<URL> es una cadena de caracteres que contiene el URL absoluto o relativo del programa externo que será iniciado por el servidor web al enviar el formulario: véase línea 7 de la Figura 9.14. • METHOD=<una palabra reservada> , donde la palabra reservada es el nombre del método, PO ST o GET, que especifica la forma en que el programa externo espera recibir los datos enviados por el usuario, denominados datos d e interro- www.FreeLibros.org Aplicaciones d e Internet 2 6 3 3 un ejemplo de fonnubno señalo Microsoft internet txptorer * ------- ^ lü jx j * O 0*:- ' O ' Search favortes Media -'£) “ Lrks “ Norton An tí/rus 3 U n f o r m u l a r i o s e n c i l l o — C u e s tio n a r io : Introduce tu nombre: ¿Cuál es tu pregunta ’* ¿Cuál es tu color favorito?: |verde amarillento^] ¿Cuánto pesa una golondrina?: <* Golondrina africana o c Golondrina continental J Algo mas que desees añadir Presiona °qui 1 para enviar. z\\ .¿j Done -------------------------------------------------- 1— ¿J My Computer --• F ig u ra 9 .1 3 . Un fo rm u la rio w e b se n cillo . gación (query data). El significado de estos métodos se explicará más adelan­ te; véase línea 7 de la Figura 9.14. En el código del formulario, cada uno de los elem entos d e entrada tiene una etiqueta de NOM BRE (véanse líneas 9, 10, 12, 29, 31, 35 y 37). Para cada uno de estos ele­ mentos el usuario debe introducir o seleccionar un valor. La colección de todos los datos de los elementos d e entrada es una cadena de caracteres, denominada cadena de m toT ogaáón (q u a y s ú in g que está formada por pares nombre=valor separados por el carácter &. Cada par nombre=valor se codifica utilizando la codificación URL (URL-encoding) [w3.org, 22; blooberry.com, 23], de tal forma que los caracteres «no seguros» (tales como espacios, comillas, % y &) son representados de forma hexade- cimal. Por ejemplo, la cadena «La respuesta es > 17%» se codifica como: «La%20respuesta%20es%20%3E17%25». A continuación se muestra un ejemplo d e cadena de interrogación para e l formu­ lario de ejemplo: n a r b r e=Juan% 2 O N a d ie & pregunta= paz % 2 0en%2 Onundo&co lo r = a zul& g o lo n d r in a = c o n t in e n t a l & texto= L a% 2O respuesta% 2 0 e s %20%3E17% 25 El em paquetado de los datos en la cadena de caracteres, incluyendo la codifica­ ción de los valores, la realiza e l navegador. Cuando el usuario envía el formulario, se le pasa la cadena de interrogación al servidor en la petición HTTP. La forma de en­ vío de la cadena dependerá del atributo METHOD usado en el formulario. En la si­ guiente sección se explicará como se transmite la cadena de interrogación al servidor y más adelante al programa externo. www.FreeLibros.org 2 6 4 C om putación distribuida. Fundam entos y aplicaciones Procesam iento de la cadena de interrogación Basándose en e l formulario introducido, e l navegador web construye la cadena de in­ terrogación, tal y como se detalló previamente. La cadena se transmite al servidor web, que a su vez la pasa al programa externo (el script CGI especificado en e l for­ mulario). La forma en que se transmite la cadena depende de la especificación del atributo METHOD de la etiqueta FORM del formulario web. El m é to d o GET en lo s fo rm u lario s - e nvío de la cade n a de inte rro ga ción al servidor Si se especifica G ET en la etiqueta FORM METHOD , la cadena de interrogación se transmite al servidor web en una petición HTTP con una línea de método GET , tal y como se describió en la sección 9.3. Se debe recordar que una petición HTTP GET especifica el URI del objeto w eb solicitado por e l cliente. Para dar cabida a la cade­ na de interrogación, la sintaxis de la especificación del URI fue extendida para per­ mitir que se adjuntara la cadena de interrogación al final del URI (para el script CGI), delimitándolo por e l carácter '? ’, como por ejemplo, GET / c g i /h o l a .c g i? n a n b r e = J u a n % 2 0 N a d ie & p r e g u n t a = p a z H T T P/1 .0 Puesto que la longitud de la línea URI de la petición G E T es limitada (debido al tamaño del buffer de entrada impuesto por los computadores), la longitud de la cade­ na de interrogación que puede ser agregada d e esta manera tiene también un tamaño limitado. Por lo tanto, este método no es apropiado si el formulario necesita mandar una gran cantidad de datos, como pueden ser los datos introducidos en una caja de texto (text box). El m é to d o POST en los fo rm u lario s - e nvío de la cadena de inte rro ga ción al servidor Si se especifica PO ST en la etiqueta FORM METHOD, la cadena de interrogación se transmite al servidor w eb en una cabecera HTTP con una línea de método POST, tal y como se describió en la sección 9.3. Se debe recordar que la petición HTTP POST tiene a continuación un cuerpo de petición, que contiene e l texto a ser enviado al ser­ vidor. Utilizando el método POST, el URI del script CGI se especifica con la línea de petición POST, seguida por la cabecera de la petición, una línea en blanco, y por último la cadena de interrogación, como por ejemplo: POST / c g i / h o l a . c g i H T T P/1 .0 A c c e p t: * /* C o n n e c ti o n : K e e p - A liv e H o s t: m i H o s t . a l g o . e d u U s e r - A g e n t: G e n e r i c n o n b re = J u a n % 2 0 N a d ie & p re g u n ta = p a z % 2 0 e n % 2 0 tie rr a & c o lo r= a z u l Puesto que la longitud del cuerpo d e la petición es ilimitada, la cadena d e inte­ rrogación puede tener cualquier longitud. De esta forma, el método PO ST puede ser utilizado para enviar cualquier cantidad de datos al servidor. www.FreeLibros.org Aplicaciones d e Internet 2 6 5 El m é to d o FORM GET - envío de la ca dena de inte rroga ció n al p ro g ra m a externo Con el método GET el servidor invoca a l script CGI y le pasa la cadena de interro­ gación que ha recibido del navegador, adjuntando el URI en la petición HTTP. El pro­ grama CGI, o en general el programa externo, recibirá el formulario codificado en una variable de entorno denominada QUERY_STRING. El programa CGI recupera la cadena de interrogación de la variable de entorno, decodifica la cadena de caracteres para obtener los pares nombre-valor, y hace uso de los valores de los parámetros du­ rante la ejecución del programa para generar salida redactada en HTML. El m é to d o FORM POST - envío de la ca dena de inte rroga ció n al p ro g ra m a externo El servidor invoca al script CGI y le pasa la cadena de interrogación que recibe del navegador en el cuerpo d e la petición. El programa CGI, o en general el programa externo, recibirá e l formulario codificado por la entrada estándar. El programa CGI lee la cadena de interrogación de la entrada estándar, decodifica la cadena de carac­ teres para obtener los pares nombre-valor, y hace uso de los valores de los paráme­ tros durante la ejecución del programa para generar salida redactada en HTML. Codificación y decodificación de la cadena de interrogación Independientemente de que la cadena de interrogación sea obtenida de la variable de entorno QUERY_STRING o de la entrada estándar, el programa CGI debe decodificar la cadena y extraer los pares nombre-valor de la misma. De esta forma los paráme­ tros podrán ser utilizados en la ejecución del programa. Gracias a la popularidad de los programas CGI, existen diversas bibliotecas o clases que proporcionan rutinas (fun­ ciones) y métodos para este propósito. Por ejemplo, Perl tiene unos procedimientos fáciles de usar, en una biblioteca denominada CGI-lib, para el decodificado y la ex­ tracción de los pares nombre-valor en una estructura de datos denominada vector aso­ ciativo', el NCSA (The National C enter f o r Supercomputing Applications) proporcio­ na una biblioteca de rutinas en C con el mismo propósito. La Figura 9.15 presenta un programa CGI, escrito en C, para cuando el formula­ rio de ejemplo especifica el método GET. El programa utiliza unas rutinas denom i­ nadas getword y unescape (líneas 46-49) para la extracción y la decodificación d e la cadena de interrogación. Los pares nombre-valor resultantes se almacenan en una es­ tructura de datos declarada en las líneas 16-19 y 27, que se corresponde con un vec­ tor asociativo. Además, en la línea 39 el código hace uso de la rutina de C getenv para leer la cadena de interrogación de la variable de entorno QUERY_STRING. En este ejemplo, los nombres y valores recibidos son únicamente mostrados por pantalla (líneas 51-63). F ig u ra 9 .1 5 . fo rm u la río G et.c [h o o h o o .n csa .u iu c.e d u , 19]. 1 / * A u t o r : M. L i u , b a s a d o e n u n e je m p lo d e l t u t o r i a l d e CGIs d e NCSA. 2 E s t e e s e l c ó d i g o f u e n t e p a r a f o r m u l a r i o G e t . c g i . 3 S e i n v o c a d e s d e f o r m u l a r i o G e t . h t m l , y g e n e r a 4 d in á m ic a m e n te u n a p á g i n a w eb q u e m u e s t r a l o s p a r e s (continúa) Las variables d e entorno son variables alm acenadas por el sistem a operativo d e la máquina servidora. En la m ayor parte d e los sistem as existe una entrada estándar para los procesos, normalmente el teclado, y una salida estándar, normalmente la pantalla.________________ Un vector asociativo es una estructura d e datos que mantiene un conjunto d e pares (clave, valor)._________________ www.FreeLibros.org 5 n o m b r e - v a l o r o b t e n i d o s d e l f o r m u l a r i o . 6 E s t e p r o g r a m a u t i l i z a l a b i b l i o t e c a CGI d e l NCSA p a r a p r o c e s a r 7 l a c a d e n a d e i n t e r r o g a c i ó n o b t e n i d a a t r a v é s d e l m é to d o GET. 8 */ 9 # i n c l u d e < s t d i o . h > 10 # i f n d e f NO_STDLIB_H 11 # i n c l u d e < s t d l i b . h > 12 # e l s e 13 c h a r * g e t e n v ( ) ; 14 # e n d i f 15 16 t y p e d e f s t r u c t { 17 c h a r n o n b r e [ 128 ] ; 18 c h a r v a l o r [ 1 2 8 ] ; 19 } e n t r a d a ; 20 21 v o i d g e t w o r d ( c h a r * v ro rd , c h a r * l i n e , c h a r s t o p ) ; 22 c h a r x 2 c ( c h a r * w h a t) ; 23 v o i d u n e s c a p e _ u r l ( c h a r * u r l ) ; 24 v o i d p l u s t o s p a c e ( c h a r * s t r ) ; 25 26 m a i n ( i n t a r g c , c h a r * a r g v [ ] ) { 27 e n t r a d a e n t r a d a s [ 1 0 0 0 0 ] ; 28 r e g i s t e r i n t x ,m = 0 ; 29 c h a r * c l ; 30 31 p r i n t f ( \" C o n t e n t - t y p e : te x t/h tm l% c % c \" , 1 0 , 1 0 ) ; 32 33 i f ( s t r c m p ( g e t e n v ( \" KEQüEST_METHOD\" ) , \"G ET\") ) { 34 p r i n t f ( \" E s t e s c r i p t d e b e r í a s e r r e f e r e n c i a d o 35 c o n e l m é to d o G E T .\\ n \" ) ; 36 e x i t ( l ) ; 37 } 38 39 e l = g e t e n v ( \" QUERY_STRING\" ) ; 40 i f ( e l = NULL) { 41 p r i n t f (\" N d h a y i n f o r m a c i ó n q u e d e c o d i f i c a r A n \" ) ; 42 e x i t ( l ) ; 43 > 44 f o r ( x = 0 ; e l [ 0 ] != ' \\ 0 ' ; x + + ) { 45 m =x; 46 g e t w o r d ( e n t r a d a s [ x ] . v a l o r , e l , ' & ' ) ; 47 p l u s t o s p a c e ( e n t r a d a s [ x ] . v a l o r ) ; 48 u n e s c a p e _ _ u r l ( e n t r a d a s [x ] . v a l o r ) ; 49 g e t w o r d ( e n t r a d a s [x ] . n o n b r e , e n t r a d a s [ x ] . v a l o r , ' = ' ) ? 50 } 51 p rin tf( \" < B O D Y b g c o l o r = \\ \"#C CFFC C \\\" > \" ) ; 52 p r i n t f ( \" < H 2 > E sta p á g i n a e s t á g e n e r a d a 2 6 6 C om putación distribuida. Fundam entos y aplicaciones (continúa) www.FreeLibros.org Aplicaciones d e Internet 2 6 7 53 d in á m ic a m e n te p o r f o r m u l a r i o G e t . c g i . < / H 2 > \" ) ; 54 p r i n t f ( \" < H l> R e s u lta d o s d e l a C a d e n a < /H l> \" ) ; 55 p r i n t f ( \" E n v i a s t e l o s s i g u i e n t e s p a r e s n o m b r e / v a l o r \" , 56 \"< p> % c\",1 0 ) ? 57 p r i n t f ( \" < u l> % c \" , 1 0 ) ; 58 59 f o r ( x = 0 ; x <= m ; x+ + ) 60 p r i n t f ( \" < l i > < code> % s = % s< /c o d e > % c \", 61 e n t r a d a s [ x ] . n o m b r e , e n t r a d a s [ x ] . v a l o r , 1 0 )? 62 p r i n t f ( \" </BODY>\" ) ; 63 p r i n t f ( \" </HTML>\" ) ; 64 } La Figura 9.16 presenta un programa CGI, escrito en C, para cuando el formula­ rio de ejemplo especifica el método POST. El programa utiliza unas rutinas denom i­ nadas makeword y unescape (líneas 51-54) para la extracción y la decodificación de la cadena de interrogación. Los pares nombre-valor resultantes se almacenan en una estructura de datos declarada en las líneas 18-21 y 31, que corresponde a un vector asociativo. Obsérvese que el fo r que comienza en la línea 49 lee la cadena de inte­ rrogación de la entrada estándar, extrae una palabra cada vez, la decodifica, y escri­ be e l nombre y el valor en la estructura de datos. En este ejemplo, los nombres y va­ lores recibidos son únicamente mostrados por pantalla (líneas 56-66). F ig u ra 9 .1 6 . fb rm u la rio P o s t.c [h o o h o o .n csa .u iu c.e d u , 19]. 1 / * A u t o r : M. L i u , b a s a d o e n u n e je m p lo d e l t u t o r i a l d e C d s d e NCSA. 2 E s t e e s e l c ó d i g o f u e n t e p a r a f o r m u l a r i o P o s t . c g i . 3 S e i n v o c a d e s d e f o r n u l a r i o P o s t . h t m l , y g e n e r a 4 d in á m ic a m e n te u n a p á g i n a vreb q u e n u e s t r a l o s p a r e s 5 n o m b r e - v a l o r o b t e n i d o s d e l f o r m u l a r i o . 6 E s t e p r o g r a m a u t i l i z a l a b i b l i o t e c a CGI d e l NCSA p a r a p r o c e s a r 7 l a c a d e n a d e i n t e r r o g a c i ó n o b t e n i d a a t r a v é s d e l m é to d o POST. 8 */ 9 # i n c l u d e < s t d i o . h > 10 # i f n d e f NO_STDLIB_H 11 # i n c l u d e < s t d l i b . h > 12 # e l s e 13 c h a r * g e t e n v ( ) ; 14 # e n d i f 15 16 # d e f i n e MAX_ENTRADAS 10000 17 18 t y p e d e f s t r u c t { 19 c h a r * n o m b re ; 20 c h a r *v a l o r ; 21 } e n t r a d a ; 22 23 c h a r * m akew ord( c h a r * l i n e , c h a r s t o p ) ; (continúa) www.FreeLibros.org 2 6 8 C om putación distribuida. Fundam entos y aplicaciones 24 c h a r * fm a k e w o rd ( FIL E * f , c h a r s t o p , i n t * l e n ) ; 25 c h a r x 2 c ( c h a r * w h a t) ; 26 v o i d u n e s c a p e _ u r l ( c h a r * u r l ) ; 27 v o i d p l u s t o s p a c e ( c h a r * s t r ) ; 28 29 30 m a i n ( i n t a r g c , c h a r * a r g v [ ] ) { 31 e n t r a d a e n t r a d a s [ MAX_ENTRADAS ] ; 32 r e g i s t e r i n t x ,m = 0 ; 33 i n t e l ? 34 35 p r i n t f ( \" C o n t e n t - t y p e : t e x t /h t m l % c % c \" , 1 0 , 1 0 ) ; 36 i f ( s t r e m p ( g e t e n v ( \"KEQUEST_METHOD\" ) , \"POST\" ) ) { 37 p r i n t f ( \" E s t e s c r i p t d e b e r í a s e r r e f e r e n c i a d o \" , 38 \" c o n e l m é to d o P 0 S T . \\ n \" ) ; 39 e x i t ( l ) ; 40 } 41 i f ( s t r e m p ( g e t e n v (\" C0NTENT_TYPE \" ) , 42 \" a p p l i c a t i o n / x - w w w ^ f o r m - u r l e n c o d e d \" ) ) { 43 p r i n t f ( \" E s t a c a d e n a d e i n t e r r o g a c i ó n n o c o n t i e n e \" , 44 \" d a t o s U R L c o d if ic a d o s \\ n \" ) ; 45 e x i t ( l ) ; 46 } 47 e l = a t o i ( g e t e n v ( \" C0NTENT_LENGTH\" ) ) ; 48 49 f o r ( x = 0 ; c l && ( ! f e o f ( s t d i n ) ) ; x + + ) { 50 m =x; 51 e n t r a d a s [ x ] . v a l o r = f m a k e w o r d ( s t d i n , ' & ' , & c l ) ; 52 p l u s t o s p a c e ( e n t r a d a s [ x ] . v a l o r ) ; 53 u n e s c a p e _ _ u r l ( e n t r a d a s [ x ] . v a l o r ) ; 54 e n t r a d a s [ x ] . n o n b r e = m ak ew o rd ( e n t r a d a s [ x ] . v a l o r , ' = ' ) ; 55 } 56 p r i n t f ( \"< b o d y b g c o l o r = \\ \" # F F F F 9 9 \\ \" > \" ) ; 57 p r i n t f ( \" < H l> R e s u lta d o s d e l a c a d e n a < / H l > \" ) ; 58 p r i n t f ( \" E n v i a s t e l o s s i g u i e n t e s p a r e s n o n t o r e - v a l o r \" , 59 \"< p> % c\", 1 0 ) ; 60 p r i n t f ( \" < u l> % c\" ,1 0 ) ? 61 62 f o r ( x = 0 ; x <= m ; x+ + ) 63 p r i n t f ( \" < l i > <code>% s = % s < /c o d e > \\n \" , e n t r a d a s [ x ] .n o m b r e , 64 e n t r a d a s [ x ] . v a l o r ) ; 65 p r i n t f ( \" < /b o d y > \" ) ; 66 p r i n t f ( \" < / h t m l > \" ) ; 67 } Variables de entorno utilizadas en los CGI Una variable de entorno es un parámetro del entorno de trabajo de un usuario en un computador, tal como la ruta por defecto para que el sistema localice los programas www.FreeLibros.org Aplicaciones d e Internet 269 invocados por un usuario o la versión del sistema operativo en uso. En un computa­ dor, las variables de entorno pueden ser empleadas en múltiples lenguajes y sistemas operativos para proporcionar información específica a una aplicación. CGI utiliza variables de entorno que son escritas por el servidor HTTP para pasar información sobre las peticiones a los programas externos (script CGÍ). A continuación se muestran algunas de las principales variables de entorno rela­ cionadas con CGI: • REQUEST_METHOD. El tipo de método con e l que se ha realizado la petición. Para CGI puede ser GET o PO ST • QUERY_STRING. Si se ha especificado el método GET en el formulario, esta variable contiene una cadena de caracteres codificada, con los datos del formu­ lario. • CONTENT_TYPE. El tipo de contenido de los datos, que podría ser «applica- tionJx-www-form-urlencoded» para una cadena de interrogación. • CONTENT_LENGTH. La longitud de la cadena de interrogación en número de bytes. 9 .6 . S E S IO N E S W E B Y DATOS DE ESTADO DE LA SESIÓ N Durante una sesión de una aplicación web, tal como un carrito de la compra, se em i­ ten diversas peticiones HTTP, cada una de las cuales puede invocar a un programa externo como puede ser un script CGI. La Figura 9.17 muestra una sesión sim plifi­ cada de esta aplicación: el primer formulario web solicita un identificador (id) de clien­ te, que es validado por el script CGI form ulariol.cgi. El script w eb genera dinám i­ camente un formulario web llam ado formulario2.html. (Obsérvese que este fichero nunca se escribe a disco; sólo existe como salida del script web). El formulario pide al cliente que rellene una orden de compra. La orden de compra del cliente se man­ da a un segundo script web, form ulario2.cgi, que genera dinámicamente otro formu­ lario web transitorio (formulario3.html), que a su vez muestra los datos de la cuenta del cliente y el contenido de su carrito d e la compra. La sesión puede continuar de esta forma invocando a scripts web adicionales y generando dinámicamente páginas web hasta que termina la sesión del usuario. Es importante observar que en este ejemplo, para el segundo script, formulario2.cgi, es necesario saber el valor del elemento de datos id de la cadena de interrogación en­ viada por el primer script CGI, form ulariol.cgi. Es decir, id es un dato de estado de sesión que necesita ser compartido entre los scripts web invocados a lo largo d e la se­ sión. Sin embargo, debido a que los scripts w eb son programas separados ejecutados en contextos independientes, no comparten datos. Por otra parte, ni HTTP ni CGI tie­ nen soporte para datos de estado de sesión, ya que ambos protocolos son sin estado y no tienen e l concepto de sesión. Debido a la popularidad de las aplicaciones d e Internet han surgido diversos me­ canismos que permiten compartir datos de sesión entre scripts CGI (y otros progra­ mas externos). Estos mecanismos pueden ser clasificados de la siguiente manera: • M ecanism os d d la d o d d servidor. Ya que los scripts CGI se ejecutan en el servidor HTTP, es lógico hacer uso de los mecanismos del mismo para mante­ ner los datos de estado de la sesión. En sistemas UNIX, la configuración de variables de entorno se puede encontrar en ficheros ocultos (tales como .login o .eshre) en el directorio raíz de las cuentas. En sistemas Windows se puede encontrar la configuración de las variables de entorno en el panel de control. www.FreeLibros.org 2 7 0 C om putación distribuida. Fundam entos y aplicaciones S crlp t w e b S crip t w e b form2.cgi fo rm l.cg i S e rvid o r w e b N a veg ado r petición de form ulario .ritm / formulario.html __________________________ id=12345 formulario 1 .cgi ?id=12345 | form 2.htm l (dinám ico) com pra=7V formulario2.cgi ?compra=TV formulario2.html, contenido «cliente 12345 tie n e una TV en el carrito» -------------------------- ;-------------------------------------------------------► F ig u ra 9.1 7. Una sesión web que utiliza múltiples programas externos. Por ejemplo, se puede utilizar almacenamiento secundario (ficheros o bases d e datos) en la máquina servidora como un repositorio para los datos de esta­ do d e la sesión: cada script w eb deposita sus datos de estado en e l almacén, de tal forma que pueden ser accedidos por cualquier otro script. La desventaja de este esquema es la sobrecarga involucrada y la necesidad d e administración del alm acén para un gran número de sesiones concurrentes. De forma alternativa, el servidor HTTP puede soportar objetos de datos per­ sistentes que pueden ser empleados como repositorios de datos d e estado. En el Capítulo 11 se verán algunos mecanismos basados en esta idea. • M ecanism os d d la d o d d d ie n te Una ingeniosa idea para mantener los datos de estado de sesión es utilizar la ayuda de los clientes. Ya que cada sesión está asociada a un solo cliente, este esquema permite que los datos de estado se man­ tengan de forma descentralizada. Este esquema permite pasar los datos de esta­ do del script web al cliente, que a su vez pasa estos datos a l siguiente script web. Esta operación puede ser repetida durante toda la sesión web. La Figura 9.18 ilustra esa idea. El elemento de sesión id se pasa desde e l primer script web, vía el servidor web, al navegador. Este elemento se envía del cliente web a l siguiente script CGI cuando se invoca. A su vez, el script CGI 2 pasa los elementos de sesión id y compra a l cliente web. En el siguiente paso, el nave­ gador envía estos elementos al último script CGI, que aporta un elemento adi­ cional, cargo, a los datos de estado de la sesión. En el resto de este capítulo se verán dos esquemas que hacen uso de los mecanismos de mantenimiento de sesión del lado del cliente: • C a n c o s ocultos d e fo rm u la ria Este esquema introduce los datos de estado de sesión en formularios w eb generados dinámicamente. • C o a tíe s Este mecanismo, de nombre tan gracioso1 utiliza almacenamiento transito­ rio o persistente en la máquina del cliente para mantener los datos de estado. Estos datos se pasan en la cabecera de la petición HTTP al script web que los requiera. ' N. del T.: «cookies» significa en castellano «galetitas». www.FreeLibros.org Aplicaciones d e Internet 271 M á q u in a servidora M á q u in a cliente F ig u ra 9 .1 8 . D a to s d e e s ta d o d e s e sió n tra n s m itid o s vía c lie n te w e b . Uso de cam pos ocultos de form ulario para transferir datos de estado de sesión Un campo oculto de formulario o c a n s ío o cu lto es un elemento de tipo ¡N PU T en un formulario web que se especifica con TYPE=HIDDEN. Al contrario que otros ele­ mentos de tipo INPUT, el navegador no presenta un campo oculto y no requiere que el usuario introduzca datos. El valor de este elemento debe ser especificado en el atri­ buto VALUE dentro del campo. La Figura 9.19 muestra el uso de los campos ocultos para pasar datos entre scripts web. El primer script web form ulario 1 .cgi genera el elemento <input type=hidden name=«id» value=«l2345»> dentro d e form ulario2.htm l dinámicamente generado. Cuando se representa formulario2.html, e l navegador no mostrará este campo. El otro campo de entrada, que no está especificado como oculto, se presenta a l usuario para que introduzca una compra. Cuando se envía formulario2.html, se envía la cadena de interrogación «id=12345&compra=tv» al segundo formulario web, formulario2.cgi. Cuando la cadena de interrogación se decodifica, el valor del elemento d e estado id queda disponible para formulario2.cgi. La Figura 9.20 presenta al diagrama de se­ cuencia. El uso de campos ocultos es un esquema elemental para el mantenimiento de los datos de sesión. Tiene el mérito de la simplicidad, ya que sólo requiere la introduc­ ción d e nuevos campos de formulario y no se necesitan recursos adicionales ni en el cliente ni en el servidor. En este esquema, e l cliente HTTP se convierte en un repo­ sitorio temporal de la información de estado y los datos de sesión se envían utilizan­ do el mecanismo normal de transm isión de cadenas de interrogación. Como es lógico, existen contraprestaciones. La simplicidad del esquema conlle­ va el riesgo de privacidad y seguridad, en e l sentido de que los datos de estado se transm iten como campos ocultos de formulario sin proteger. En el ejem plo mostra­ do en la Figura 9.20, e l valor id de un cliente se transmite utilizando un elemento www.FreeLibros.org 272 C om putación distribuida. Fundam entos y aplicaciones F ig u ra 9 .1 9 . U so d e c a m p o s o c u lto s d e fo rm u la rio para e n v ia r d a to s d e e s ta d o ; una visión general. S c rip t w e b S crip t w e b formularío2.cg¡ form ulario 1. cg¡ id = 12345 W e b Server N a ve g a d o r petición de form ulario .btm / formulario.html 1 formulario 1 .cgi? id = 1 2345 formulario2.html (dinám ico) contiene < in p u t type=\"HIDDEN\" NAM E=\"id\" VALUE=\"12345\"> id=12345& com pra=TV \"cliente 12345 tiene una TV en carrito com pra' formulario2. cgi ?id=12 345 & co m prá=TV F ig u ra 9 2 0 . U so d e c a m p o s o c u lto s d e fo rm u la rio para p a s a r in fo rm a ció n d e e s ta d o ; vis ta d e ta lla d a . www.FreeLibros.org Aplicaciones d e Internet 273 de entrada oculto. Aunque este elemento no es presentado por e l navegador, va em ­ bebido en el código fuente de la página w eb generada dinámicamente, form ula­ rio!.htm l, cuyo código es visible por cualquier usuario del navegador. Por lo tanto, este esquem a perm ite que los datos de estado sean expuestos y, por consiguiente, tiene el riesgo de privacidad y seguridad. Por esta razón, los campos ocultos no de­ ben ser utilizados para transm itir datos sensibles tales como núm eros de seguridad o balances de cuentas. Las Figuras 9.21, 9.22 y 9.23 presentan ejemplos d e código para e l uso d e cam­ pos ocultos de formulario para pasar datos d e estado entre scripts CGI. El formu­ lario w eb inicial (Figura 9.21) invoca a l script form ularioO culto.cgi, que extrae el par nombre-valor d e la cadena de interrogación que recibe (líneas 43-48 de la F i­ gura 9.22) y después incluye cada par en un campo oculto d e formulario d e la pá­ gina w eb que genera (líneas 64-66 d e la figura 9.22). Los campos de los datos ocul­ to s s e i n c l u y e n en la c a d e n a de i n t e r r o g a c i ó n p ar a e l s c r i p t C G I form ularioO culto2.cgi, que extrae los pares nombre-valor (líneas 40-46) y sim ple­ mente los presenta (líneas 54-59). F ig u ra 9 .2 1 . Un e je m p lo d e c a m p o s o c u lto s d e fo rm u la rio : f o r m u l a r i o . h t m l . <HTML> <HEAD> < riT L E > E je m p lo d e cam p o s o c u l t o s d e f o r m u la r io < /T I T L E > </HEAD> <BODY> < i l > U t i l i z a c i ó n d e cam p o s o c u l t o s d e f o r m u l a r i o p a r a i n f o r m a c i ó n d e s e s i ó n < / H l > <P> E s t e f o r m u l a r i o i n v o c a a u n s c r i p t CGI q u e u t i l i z a cam p o s o c u l t o s d e f o r m u l a r i o p a r a p a s a r d a t o s d e e s t a d o a o t r o s c r i p t CGI q u e s e r á e j e c u t a d o a c o n t i n u a c i ó n . < /P > <HR> <FORM m e t h o d = \" p o s t\" a c t i o n = \"f o r m u l a r i o O c u l t o . c g i \" > < i 2 > C u e s t i o n a r i o : < /H 2> C Uál e s t u I D : c i n p u t n a m e = \" i d \" x P > <P> P r e s i o n a c i n p u t t y p e = \" s u b m i t \" v a l u e = \" a q u í \" > p a r a e n v i a r t u s o l i c i t u d . </FORM> <HR> </BODY> </HTML> F ig u ra 9 .2 2 . Un e je m p lo d e c a m p o s o c u lto s d e fo rm u la rio : fo rm u la rio O c u lto .c . 1 /* f o r m u l a r i o O c u l t o . c — c o d i g o f u e n t e d e f o r m u l a r i o O c u l t o . c g i 2 A u th o r : M. L . L i u . 3 E s t e s c r i p t g e n e r a d in á m ic a m e n te u n a p á g i n a w eb q u e 4 c o n t i e n e cam p o s o c u l t o s d e f o r m u l a r i o c o n l o s p a r e s 5 n o m b r e - v a l o r r e c i b i d o s e n l a c a d e n a d e i n t e r r o g a c i ó n . (continúa) www.FreeLibros.org 6 */ 7 8 # i n c l u d e < s t d i o . h > 9 # i f n d e f NO_STDLIB_H 10 # i n c l u d e < s t d l i b . h > 11 # e l s e 12 c h a r * g e t e n v ( ) ; 13 # e n d i f 14 15 # d e f i n e MAX_ENTRADAS 10000 16 17 t y p e d e f s t r u c t { 18 c h a r * n o m b re ; 19 c h a r *v a l o r ; 20 > e n t r a d a ; 21 22 c h a r *m akew ord ( c h a r * l i n e , c h a r s t o p ) ; 23 c h a r *fm a k e w o rd ( FIL E * f , c h a r s t o p , i n t * l e n ) ; 24 c h a r x 2 c ( c h a r * w h a t) ; 25 v o i d u n e s c a p e _ u r l ( c h a r * u r l ) ; 26 v o i d p l u s t o s p a c e ( c h a r * s t r ) ; 27 28 29 m a i n ( i n t a r g c , c h a r * a r g v [ ] ) { 30 e n t r a d a e n t r a d a s [ MAX_ENTRADAS ] ; 31 r e g i s t e r i n t x ,m = 0 ; 32 int el; 33 34 p r i n t f ( \" C o n t e n t - t y p e : t e x t /h t m l % c % c \" , 1 0 , 1 0 ) ; 35 i f ( s t r e m p ( g e t e n v ( \" REQUEST_METHOD\" ) , \"POST\" ) ) { 36 p r i n t f 37 ( \" E s t e s c r i p t d e b e s e r u t i l i z a d o c o n e l m é to d o P O S T .\\ n \" ) ; 38 exit(l); 39 } 40 41 e l = a t o i ( g e t e n v ( \"CONTENT_LENGTH\") ) ; 42 43 f o r ( x = 0 ; c l && ( l f e o f ( s t d i n ) ) ;x + + ) { 44 m =x; 45 e n t r a d a s [ x ] . v a l o r = fm a k e w o rd (s t d i n , ' & ' , & c l ) ; 46 p l u s t o s p a c e ( e n t r a d a s [ x ] . v a l o r ) ; 47 u n e s c a p e _ u r l ( e n t r a d a s [x ] . v a l o r ) ; 48 e n t r a d a s [ x ] . n o m b re = m a k e w o r d ( e n t r a d a s [ x ] . v a l o r , ' = ' ) ; 49 > 50 / * G e n e r a r e l f o r m u l a r i o d in á m ic o c o n l o s cam p o s o c u l t o s * / 51 p r i n t f ( \" <FORM m e t h o d = \\ \" p o s t \\ \" a c t i o n = \\ \" f o r m u l a r i o O c u l t o . c g i \\ \" > \" ) ; ( continúa) 274 C om putación distribuida. Fundam entos y aplicaciones www.FreeLibros.org Aplicaciones d e Internet 2 7 5 52 p r i n t f ( \"< H R >E ste f o r m u l a r i o f u e g e n e r a d o d in á m ic a m e n te p o r \" , 53 \" f o r m u l a r i o O c u l t o .c g i < / H 2 > \" ) ; 54 p r i n t f ( \" < H l> R e s u lta d o s d e l a P e t i c i ó n < / H l > \" ) ; 55 p r i n t f ( \" H a s e n v i a d o l o s s i g u i e n t e s p a r e s n o m b r e /v a l o r :< p > % c \" , 1 0 ) ; 56 p r i n t f ( \" < u l> % c \" , 1 0 ) ; 57 58 f o r ( x = 0 ; x <= m ; x+ + ) 59 p r i n t f ( \" < l i > < code> % s = % s< /c o d e > % c \", e n t r a d a s [ x ] . n o m b r e , 60 e n t r a d a s [ x ] . v a l o r , 1 0 ) ; 61 p r i n t f ( \" < /u l> % c \" , 1 0 ) ; 62 63 / * S e p o n e c a d a n o n b r e - v a l o r e n u n cam po o c u l t o d e f o r m u l a r i o * / 64 f o r ( x = 0 ; x <= m ; x+ + ) 65 p r i n t f ( \"<INPUT T Y P E = \\\" HEDDEN\\\" NAME=%S V ALUE=% s>\\n\", , 66 e n t r a d a s [ x ] . n o m b r e , e n t r a d a s [ x ] . v a l o r ) ; 67 68 p r i n t f ( \" P r e s i o n a c i n p u t t y p e = \\ \"s u b m i t \\ \" v a l u e = \\ \" a q u í \\ \"> p a r a \" , 69 \" e n v i a r t u p e t i c i ó n . \" ) ? 70 p r i n t f ( \"<HR>\" ) ; 71 p r i n t f ( \" </FORM>\" ) ; 72 p r i n t f ( \" </BODY>\" ) ; 73 p r i n t f ( \" </HTML>\" ) ; 74 75 } F ig u ra 9 .2 3 . Un e je m p lo d e c a m p o s o c u lto s d e fo rm u la tio : fo rm u la rio O c u lto 2 .c . 1 * / f o r m u l a r i o O c u l t o 2 . c — c ó d i g o f u e n t e p a r a f o r m u l a r i o O c u l t o 2 . c g i 2 A u th o r : M. L . L i u . 3 E s t e s c r i p t p r e s e n t a l o s p a r e s n o m b r e - v a l o r q u e r e c i b e 4 e n l a c a d e n a d e i n t e r r o g a c i ó n . D e b e r ía n e s t a r i n c l u i d o s 5 l o s p a r e s n o m b r e - v a l o r q u e a p a r e c e n e n e l f o r m u l a r i o o c u l t o 6 d e l a p á g i n a w eb q u e i n v o c a e s t e s c r i p t . 7 * / 8 # i n c l u d e < s t d i o . h > 9 # i f n d e f NO_STDLIB_H 10 # i n c l u d e < s t d l i b . h > 1 1 # e l s e 12 c h a r * g e t e n v ( ) ; 13 # e n d i f 14 15 # d e f i n e MAX_ENTRADAS 10000 16 17 t y p e d e f s t r u c t { 18 c h a r * n o m b re ; 19 c h a r *v a l o r ; 20 > e n t r a d a ? (continúa) www.FreeLibros.org 2 7 6 C om putación distribuida. Fundam entos y aplicaciones 21 22 c h a r * m akew ord( c h a r * l i n e , c h a r s t o p ) ; 23 c h a r * fm a k e w o rd ( FIL E * f , c h a r s t o p , i n t * l e n ) ; 24 c h a r x 2 c ( c h a r * w h a t) ; 25 v o i d u n e s c a p e _ u r l ( c h a r * u r l ) ; 26 v o i d p l u s t o s p a c e ( c h a r * s t r ) ; 27 28 m a i n ( i n t a r g c , c h a r * a r g v [ ] ) { 29 e n t r a d a e n t r a d a s [ MAX_ENTRADAS ] ; 30 r e g i s t e r i n t x ,m = 0 ; 31 i n t e l ; 32 33 p r i n t f ( \" C o n t e n t - t y p e : t e x t /h t m l % c % c \" , 1 0 , 1 0 ) ; 34 i f ( s t r c m p ( g e t e n v ( \" KEQUEST_METHOD\" ) , \"POST\" ) ) { 35 p r i n t f ( \" E s t e s c r i p t d e b e r í a u s a r e l m é to d o P O S T A n \" ) ; 36 e x i t ( l ) ; 37 } 38 e l = a t o i ( g e t e n v ( \" CONTENT_LENGTH\" ) ) ; 39 40 f o r ( x = 0 ; c l && ( 1 f e o f ( s t d i n ) ) ; x + + ) { 41 m =x; 42 e n t r a d a s [ x ] . v a l o r = f m a k e w o r d ( s t d i n , ' & ' , & c l ) ; 43 p l u s t o s p a c e ( e n t r a d a s [ x ] . v a l o r ) ; 44 u n e s c a p e _ u r l ( e n t r a d a s [ x ] . v a l o r ) ; 45 e n t r a d a s [ x ] . n o n b r e = m ak ew o rd ( e n t r a d a s [ x ] . v a l o r , ' = ' ) ; 46 } 47 48 p r i n t f ( \" < H 2> E ste s c r i p t f u e g e n e r a d o d in á m ic a m e n te p o r \" , 49 \" f o r m u l a r i o O c u l t o 2 .c g i < / H 2 > \" ) ; 50 p r i n t f ( \" < H l> R e s u lta d o s d e l a p e t i c i ó n < / H l > \" ) ; 51 p r i n t f ( \" E h v i a s t e l o s s i g u i e n t e s p a r e s n o n b r e - v a l o r : < p > % c \" , 1 0 ) ; 52 p r i n t f ( \" <UL>%c\" , 1 0 ) ; 53 54 f o r ( x = 0 ; x <= m ; x+ + ) 55 p r i n t f ( \" < l i > <code>% s = % s< /c o d e > % c \", e n t r a d a s [ x ] . n o m b r e , 56 e n t r a d a s [ x ] . v a l o r , 1 0 ) ; 57 p r i n t f ( \" </U L >% c\", 1 0 ) ; 58 p r i n t f ( \" </HTML>\") ; 59 p r i n t f ( \" </BODY>\") ; 60 } Uso de cookies p ara el envío de datos de estado de sesión Un esquema m ás complejo para repositorio de datos de estado de sesión en la par­ te cliente es e l mecanismo conocido como c o a tíe s así denom inado «por ninguna razón convincente» [ics.uci.edu, 5; hom e.netscape.com , 25]. S in em bargo, en http://www.webopedia.com se afirm a que «el nombre d e las cookies proviene de unos objetos de Unix denom inados m agic cookies. Son señales (tokens) que están ligados a un usuario o programa y que varían dependiendo de las áreas en que en ­ tra el usuario o e l programa». www.FreeLibros.org Aplicaciones d e Internet 277 Este esquema hace uso de una extensión del HTTP básico que permite que una respuesta del servidor pueda contener información d e estado que el cliente deberá a l­ macenar en un objeto. Según [home.netscape.com, 25], «En este objeto de estado debe ir incluida una descripción del rango de URLs para las cuales este estado es válido. Cualquier futura petición hecha por el cliente que caiga dentro de este rango incluirá la transm isión del valor actual del objeto de estado desde al cliente al ser­ vidor». Cada cookie contiene un par nombre-valor con codificación URL, similar al par nombre-valor de la cadena de interrogación, para cada elemento de datos de estado (por ejemplo, id= 12345). Un script CGI puede crear una cookie incluyendo la línea de cabecera Set-Cookie como parte de la respuesta HTTP que genera. Cuando el navega­ dor recibe esta respuesta, crea un objeto, una cookie, que contiene e l par nombre-va­ lor especificado. La cookie se almacena en la máquina cliente, de forma temporal o de forma persistente. A continuación, el par nombre-valor de la cookie se recoge y se in­ serta en una línea d e cabecera de tipo Cookie en cada petición enviada por e l navega­ dor al servidor web. Cuando el servidor web encuentra una línea de cabecera de tipo Cookie, recoge los pares nombre-valor en una cadena y la sitúa en una variable de en­ torno denominada HTTP_COOK¡E. El formato de la cadena HTTPJZOOKIE es el mis­ mo que el descrito en la sección 9.5 para la cadena de interrogación. La Figura 9.24 muestra el uso de las cookies. El script form ulario.cgi introduce una cookie que contiene «id=12345», que se manda al navegador web en una línea de cabecera de respuesta generada dinámicamente. Como resultado, se almacena en la máquina cliente una cookie que contiene «id-12345». Cuando el navegador manda la siguiente petición HTTP para form ulario2.cgi, se recoge e l par nom bre-valor (id= 12345) de la cookie y se incluye en una línea de petición de cabecera. Según se recibe la petición, el servidor extrae la cadena nombre-valor («id= 12345») de la línea de cabecera y la sitúa en la variable de entorno HTTPJZOOKIE. El script w eb fo r ­ m u la r á .c g i ya puede extraer los datos de estado (id= 12345) de HTTPJZOOKIE. Obsérvese que form ulario2.cgi puede generar una cookie adicional, que en este ejemplo, contiene el par nombre-valor «nombre=Juan». S i a continuación se invoca otro script CGI, los pares nombre-valor de todas las cookies generadas previamente se mandan en la cabecera de petición. En el ejemplo, form ulario3.cgi recibirá en H TTPJZO O K IE los datos de estado id= 12345 y nombre=Juan de las dos cookies ge­ neradas por los script w eb previos. Sintaxis de la línea de cabecera de respuesta H TTP S et-C ookie La descripción previa presentaba un escenario simplificado del uso de las cookies para mantener los datos de estado. En realidad, la línea d e cabecera Set-Cookie, utilizada por un script CGI para comenzar una cookie, tiene una sintaxis m uy rica. La siguiente descripción está basada en [home.netscape.com, 25]: La línea de cabecera Set-Cookie es una cadena con el siguiente formato (las pa­ labras clave están en negrita): S e t - C o o k i e : NOMBRE=VALOR; e x p ires= F E C H A ; path= P A T H ; domain=N0MBRE_D0MINIO; s e c u r e La línea comienza con la palabra clave «Set-Cookie» y el delimitador dos puntos (:), seguido por una lista de atributos separados por puntos y comas. Los atributos son los siguientes: www.FreeLibros.org 2 7 8 C om putación distribuida. Fundam entos y aplicaciones Script w e b form .cgi Servidor w e b N avegador F ig u ra 9 .2 4 . U so d e c o o k ie s para e n v ia r e s ta d o d e se sió n . • NOMBRE=VALOR. Similar a los datos de entrada d e un formulario, es un par nombre-valor con codificación URL de los datos de estado a ser almacenados en la cookie. Este es el único atributo requerido en la línea de cabecera. • expires=<fecha>. El atributo expires especifica una fecha que define el tiempo d e validez de una cookie. Una vez que la fecha de expiración ha sido alcanza­ da, la máquina cliente tiene libertad de borrar la cookie, y no se puede asumir que los datos de estado contenidos en la cookie se enviarán al servidor en las siguientes peticiones HTTP. El formato de la fecha es e l siguiente: dia_sesnana, DD-Mes-AAAA HH:MM:SS GMT El formato está basado en RFC 822, RFC 850, RFC 1036 y RFC 1123, con la excepción de que la única zona de tiempo legal es GMT, y que los separa­ dores entre los elementos deben ser puntos. expires es atributo opcional. Si no se especifica, la cookie expirará cuando finalice la sesión de usuario. • domain=<nombre de dominio>. Este atributo establece el dom inio para la cookie creada. De entre todas la cookies almacenadas en la máquina cliente, se supo­ ne que el navegador sólo envía aquellas cuyo atributo de dominio coincide con el nombre de dominio de Internet especificado en el URI del objeto de la peti­ ción HTTP (con la que la cookie es enviada). Si coincide el final de am bos nom­ bres, se chequeará la coincidencia de la ruta para verificar si la cookie debe ser enviada. Por ejemplo, un atributo de dominio «acme.com» debería correspon­ derse con «yunque.acme.com» a l igual que con «envios.acme.com». De esta for­ ma, e l par nombre-valor de la cookie asociada con el atributo de dom inio www.FreeLibros.org Aplicaciones d e Internet 2 7 9 acme.com será enviada en la petición HTTP cuando el objeto solicitado tenga una URI que contenga e l nombre de máquina yunque.acme.com (tal como yun­ que, acm e.com /index.htm l) o envios.caja.acm e.com (tal com o envios.caja. acme.com/sales/shop.htm). Sólo las máquinas dentro del dominio especificado pueden establecer una cookie para dicho dominio, y los dominios deben tener al menos dos o tres pun­ tos para evitar dominios de la forma: .com, .edu y va.us. El valor por defecto del dominio es el nombre la máquina servidora que ge­ neró la cookie. Por ejemplo, si el servidor es www.algunaU.edu, y no se ha es­ pecificado atributo de dominio, el dominio será www.algunaU.edu. • path=<cadena con ruía>. El atributo path se utiliza para especificar el sub­ conjunto de URIs dentro de un dominio, para los cuales la cookie es válida. Si una cookie tiene correspondencia con el nombre de dominio, entonces el com­ ponente de la ruta del URI se compara con el atributo path, y si hay corres­ pondencia, la cookie se considera válida y se envía junto con la petición HTTP. Por ejemplo, la ruta «/foo» se corresponde con «/foobar» y con «/foo/bar.html». La ruta «/» es la más genérica. Si no se especifica el atributo path, se asume que la ruta es la misma que la del documento descrito por la cabecera que contiene la cookie. Los ejemplos de la Tabla 9.3 muestran el uso de los atributos Domain y Path. En los ejemplos, * representa cualquier cadena. • secure. Si una cookie está marcada como segura, será transmitida sólo si el ca­ nal de comunicaciones es seguro, como lo que sucede con los servidores HTTPS (HTTP sobre SSL). Si no se especifica «secure», se considera que la cookie es suficientemente segura como para ser mandada en texto plano sobre un canal no seguro. T a b la 9 .3 . E je m p lo s d e c o n fig u ra c ió n d e lo s a trib u to s D o m a in y P ath d e la s c o o k ie s. A tribu to D o m a in A tribu to P a th Los URI solicitad os que harán que el par nom bre-valor de la c o o k i e se envíe en la cabecera de la pe tició n www.algunaU.edu Ninguno “.www.algunaU.edu/* www.algunaU.edu / “.www.algunaU.edu/* www.algunaU.edu /área *. www. algunaU.edu/área* www.algunaU.edu /área/área *. www. algunaU.edu/áreatárea* Sintaxis de la línea de cabecera de petición H TTP coo kie Cuando se solicita un URL a un servidor HTTP, el navegador comparará e l URI con­ tra todas las cookies almacenadas en la máquina cliente [home.netscape.com, 25]. Si se encuentra alguna cookie coincidente, se incluirá una línea con los pares nombre- valor de dichas cookies en la cabecera de petición HTTP. El formato d e la línea es el siguiente: ODOkie: NAMEi=VALUEi; NAME*=¿VALUEÍ; NAMEn=VALUEn Cuando e l servidor HTTP encuentra esta línea en la cabecera de la petición, ex­ trae la subcadena con los pares nombres-valor y la sitúa en una variable de entorno www.FreeLibros.org 280 C om putación distribuida. Fundam entos y aplicaciones HTTP_COOKIE. Cuando e l script CGI se ejecuta, puede recibir los datos de estado como pares nombres-valor de la variable de entorno H TTP_C00K1E. Por ejemplo, si se envía al servidor la siguiente petición GET / c g i / h o l a .c g i ? n a n b r e = J u a n & p r e g u n t a = p a z H TTP/1 .0 C o o k ie : e d a d = 2 5 < l í n e a e n b l a n c o El servidor colocará la cadena «nombre=Juan&pregunta=paz» en la variable de en­ torno QUERY_STRING y la cadena «edad=25» en HTTP_COOKIE para la invocación del script CGI. Por otro lado, si la petición es POST / c g i / h o l a . c g i H T T P/1 .0 C o o k ie : e d a d = 2 5 c l í n e a e n b l a n c o n o ir b re = J u a n & p re g u n ta = p a z entonces el servidor enviará la cadena «nombre=Juan&pregunta=paz» a la entrada es­ tándar del script CGI, mientras que la cadena «edad=25» se colocará en la variable de entorno HTTP_COOKIE. Los atributos domain y path de las cookies están diseñados para permitir compar­ tir datos d e estado entre scripts CGI predeterminados, tal y como se muestra en los siguientes ejemplos (tomados directamente de [home.netscape.com, 25]): E je n jJ o 1 . S ecu en cia d e ta n sa c d o u e s El cliente solicita un documento y recibe la siguiente respuesta: S e t - C o o k i e : CLIENTE=WILE_E_COYOTE; p a t h = / ; e x p ir e s = W e d n e s d a y , 0 9 -N o v -9 9 2 3 :1 2 : 4 0 GMT Cuando el cliente solicita un URL en la ruta «/» del servidor, envía C o o k ie : CLIENTE=WILE_E_COYOTE El cliente solicita un documento y recibe la siguiente respuesta: S e t - C o o k i e : NUMERO_PARTE=LANZACOHETE S_00 0 1 ; p a t h = / Cuando el cliente solicita un URL en la ruta «/» del servidor, envía c o o k i e : CLIENTE=WILE_E_COYOTE; NUMERO_P ARTE=LANZ ^COHETES_0001 El cliente recibe: S e t - C o o k i e : ENVIO=FEDEX; p a t h = / a r e a Cuando el cliente solicita un URL en la ruta «/» del servidor, envía c o o k i e : CLIENTE=WILE_E_C OYOTE; NUMERO_PARTE=LANZ ACOHETES_0001 Cuando el cliente solicita un URL en la ruta «/área» del servidor, envía lo si­ guiente: c o o k i e : CLIENTE=WILE_E_COYOTE; NUMERO_PARTE=LANZACOHETES_00 0 1 ; ENVIO=FEDEX E jem plo Z S ecu en cia d e tra a sa c d m e s S e asume que todas las cookies anteriores han sido borradas. El cliente recibe lo siguiente: S e t - C o o k i e : NUMERO_PARTE=LANZACOHETES_0001; p a t h = / www.FreeLibros.org Aplicaciones d e Internet 2 8 1 Cuando el cliente solicita un URL en la ruta «/» del servidor, envía C b o k ie : NÜMERO_PARTE=LANZACOHETES_0001 El cliente recibe lo siguiente: S e t - C o o k i e : NUMERO_PARTE=COHETE_MONTABLE_00 2 3 ; p a th = /m u n ic i ó n Cuando el cliente solicita un URL en la ruta «/munición» del servidor, envía lo siguiente: C b o k ie : NüMER0_PARTE=C0HETE_M0NTABLE _ 0 0 2 3 ; NUMERO_PARTE=LANZ ACOHETESJ)001 Nota: existen dos pares nombre-valor denominados NUMERO_PARTE, ya que hay dos cookies que coinciden con el atributo path: «/» y «/munición». C ódigo de ejem plo de la utilización de cookies para transm itir datos de estado En esta sección se ponen en práctica diversos scripts CGI que hacen uso de la coo­ kies. La Figura 9.25 muestra un formulario w eb estático, que una vez enviado, invo­ ca el script CGI cookie.cgi. El código fuente de cookie.cgi se muestra en la Figura 9.26. En las líneas 39-45, el script CGI obtiene la cadena de interrogación de la entrada estándar (ya que se uti­ lizó el método POST), extrae los pares nombre-valor de la cadena de interrogación, y los coloca en un vector asociativo. En las líneas 50-54, cada uno de los pares nom­ bre-valor del vector se coloca en una cookie de nueva creación. Por simplicidad, no se han definido más atributos de las cookies por lo que su vida será la de la actual sesión web. (Nota: en la aplicación real sólo los pares nombres-valor que son nece­ sarios como datos de sesión deben ser situados en cookies). F ig u ra 9 .2 5 . Cookie.html. <HEAD> <TITLE>Un f o r m u l a r i o s e n c i l l o q u e i n v o c a u n s c r i p t CGI q u e c r e a c o o k i e s </TITL E > </HEAD> <BODY> < H l> E s te e s u n f o r m u l a r i o s e n c i l l o q u e i n v o c a a u n s c r i p t C G I, O D o k ie .c g i < /H l> <P> <HR> <FORM m ethod= \"P O S T \" a c t i o n = \" c o o k i e . c g i \" > C u á l e s t u n o m b re : c i n p u t n a m e = \" n o m b r e \" x p > C u á l e s t u e d a d : < i n p u t n a m e = \" e d a d \" X P > C u á l e s t u i d : < i n p u t n a m e = \" i d \" x p > P r e s i o n a c i n p u t t y p e = \" s u b m i t 1' v a l u e = \" a q u í \"> p a r a e n v i a r t u c o n s u l t a . </FORM> </BODY> </HTML> www.FreeLibros.org 2 8 2 C om putación distribuida. Fundam entos y aplicaciones F ig u ra 9 .2 6 . c o o k ie .c . 1 / * c o o k i e . c - c ó d i g o f u e n t e d e c o o k i e . c g i 2 A u t h o r : M. L . L i u . 3 E s t e s c r i p t , s o l i c i t a d o p o r c o o k i e . h t m l , c r e a u n a c o o k i e 4 p a r a c a d a p a r n a n b r e - v a l o r e n l a c a d e n a d e i n t e r r o g a c i ó n 5 * / 6 7 # i n c l u d e < s t d i o . h > 8 #ifndef NO_STDLIB_H 9 # i n c l u d e < s t d l i b . h > 10 # e l s e 11 c h a r * g e t e n v ( ) ; 12 # e n d i f 13 14 # d e f i n e MAX_ENTRADAS 10000 15 16 t y p e d e f s t r u c t { 17 c h a r * n o m b re ; 18 c h a r * v a l o r ; 19 } e n t r a d a ; 20 21 c h a r * m akew ord( c h a r * l i n e , c h a r s t o p ) ; 22 c h a r * fm a k e w o rd (F IL E * f , c h a r s t o p , i n t * l e n ) ; 23 c h a r x 2 c ( c h a r * w h a t) ; 24 v o i d u n e s c a p e _ u r l ( c h a r * u r l ) ; 25 v o i d p l u s t o s p a c e ( c h a r * s t r ) ; 26 27 m a i n ( i n t a r g c , c h a r * a r g v [ ] ) { 28 e n t r a d a e n t r a d a s [MAX_ENTRADAS] ; 29 r e g i s t e r i n t x ,m = 0 ; 30 int el; 31 32 i f ( s t r e m p ( g e t e n v ( \" KEQUEST_METHOD\" ) , \"POST\" ) ) { 33 p r i n t f ( \" E s t e s c r i p t d e b e r í a s e r r e f e r e n c i a d o c o n 34 e l m é to d o P 0 S T . \\ n \" ) ; 35 e x i t ( l ) ; 36 } 37 e l = a t o i ( g e t e n v ( \" CX)NTENT_LENGTH\" ) ) ; 38 39 f o r ( x = 0 ; c l && ( l f e o f ( s t d i n ) ) ;x + + ) { 40 m =x; 41 e n t r a d a s [ x ] . v a l o r = f m a k e w o r d ( s t d i n , , & c l ) ; 42 p l u s t o s p a c e ( e n t r a d a s [ x ] . v a l o r ) ; 43 u n e s c a p e _ u r l ( e n t r a d a s [x ] . v a l o r ) ; 44 e n t r a d a s [ x ] . n o m b re = m a k e w o r d ( e n t r a d a s [ x ] . v a l o r , ' = ' ) ; 45 } 46 47 / * S e g e n e r a u n a l i n e a d e c a b e c e r a S e t - c o o k i e p a r a c a d a p a r 48 n a n b r e - v a l o r . C ada l í n e a c r e a u n a c o o k i e c o n l o s a t r i b u t o s ( continúa) www.FreeLibros.org Aplicaciones d e Internet 2 8 3 49 p o r d e f e c t o * / 50 f o r ( x = 0 ; x<=m; x+ + ) 51 { 52 p r i n t f ( \" S e t - c o o k i e : % s=% s% c\\n\", 53 e n t r a d a s [ x ] . n a n b r e , e n t r a d a s [ x ] . v a l o r , ' \\ 0 ' ) ; 54 > 55 / * * * IMPORTANTE: NINGÚN BLANCO ANTES O DESPUÉS DEL SIGNO IGUAL ***/ 56 / * * * S e t - c o o k i e d e b e c o m e n z a r l a c a b e c e r a d e l a r e s p u e s t a * * * / 57 p r i n t f ( \" C o n t e n t - t y p e : t e x t /h t m l % c % c \" , 1 0 , 1 0 ) ; 58 p r i n t f ( \" < fo rm m ethod=PO ST a c t i o n = c o o k i e 2 . c g i > \\ n \" ) ; 59 p r i n t f ( \"< b o d y b g c o lo r = \\\" # C C F F C C \\\" > \" ) ; 60 p r i n t f ( \" P r e s i o n a < i n p u t ty p e = s u fc m it v a l u e = a q u i > p a r a 61 c r e a r l a s c o o k i e s \\ n \" ) ; 62 p r i n t f ( \" < / f o r m > \\ n < h r x / h t m l > \" ) ; 63 } La Figura 9.27 muestra e l código fuente del siguiente script CGI, cookie2.cgi, que es solicitado por el formulario w eb generado dinámicamente por cookie.cgi (ver línea 58 de Figura 9.26). El script CGI cookie2.cgi recoge todos los pares nombres-valor de la variable de entorno HTTP_COOKIE (líneas 41, 51-57), después solamente im­ prime sus valores. En una aplicación real, los datos de estado recogidos deberán ser usados en la lógica de la aplicación. F ig u ra 9 .2 7 . coo k¡e2 .c. 1 / * c o o k i e 2 . c - c ó d i g o f u e n t e d e c o o k i e 2 . c g i 2 A u t h o r : M. L . L i u . 3 E s t e s c r i p t C G I, in v o c a d o p o r l a p á g i n a w eb g e n e r a d a p o r 4 c o o k i e . c g i , r e c i b e l o s d a t o s d e e s t a d o d e l a s c o o k i e s 5 c r e a d a s p o r c o o k i e . c g i . 6 */ 7 8 # i n c l u d e < s t d i o . h > 9 # i f n d e f NO_STDLIB_H 10 # i n c l u d e < s t d l i b . h > 11 # e l s e 12 c h a r * g e t e n v ( ) ; 13 # e n d i f 14 15 # d e f i n e MAX_ENTRADAS 10000 16 17 t y p e d e f s t r u c t { 18 c h a r n a n b r e [ 1 2 8 ] ; 19 c h a r v a l o r [ 1 2 8 ] ; 20 } e n t r a d a C o o k i e ; 21 22 c h a r * m akew ord( c h a r * l i n e , c h a r s t o p ) ; (continúa) www.FreeLibros.org 2 8 4 C om putación distribuida. Fundam entos y aplicaciones 23 c h a r * fm a k e w o rd ( FIL E * f , c h a r s t o p , i n t * l e n ) ; 24 c h a r x 2 c ( c h a r * w h a t) ; 25 v o i d u n e s c a p e _ u r l ( c h a r * u r l ) ; 26 v o i d p l u s t o s p a c e ( c h a r * s t r ) ; 27 28 v o i d g e t w o r d ( c h a r * v ro rd , c h a r * l i n e , c h a r s t o p ) ; 29 30 m a i n ( i n t a r g c , c h a r * a r g v [ ] ) { 31 e n t r a d a C o o k i e c E n t r a d a s [ MAX_ENTRADAS ] ; 32 / * a lm a c e n a m ie n to p a r a l o s p a r e s n o m b r e - v a l o r r e c o g i d o s 33 d e HTTP_COOKIE * / 34 r e g i s t e r i n t x ,m = 0 ; 35 i n t e l ; 36 c h a r * c a d e n a C o o k ie ; 37 38 / * C ó d ig o p a r a l a c a d e n a d e i n t e r r o g a c i ó n o m i t i d o p o r s i m p l i c i d a d * / 39 40 / * r e c o g e r l o s d a t o s d e e s t a d o d e l a s c o o k i e s * / 41 c a d e n a C o o k ie = geten v (\"H T T P _ C O O K IE \") ; 42 i f ( c a d e n a C o o k i e == NULL) { 43 p r i n t f ( \"No h a y i n f o r m a c i ó n d e c o o k i e s . \\ n \" ) ; 44 e x i t ( l ) ; 45 } 46 p r i n t f ( \" C o n t e n t - t y p e : t e x t /h t m l % c % c \" , 1 0 , 1 0 ) ; 47 48 p r i n t f ( \" < body b g c o l o r = \\ \" #CCFFCC\\\" > \" ) ; 49 p r i n t f ( \" < H l> C o o k ie r e c i b i d a < / H l > \" ) ; 50 p r i n t f ( \" L a c a d e n a d e l a c o o k i e e s : % s \\ n \" , c a d e n a C o o k ie ) ; 51 f o r ( x = 0 ; c a d e n a C o o k ie [ 0 ] != ' \\ 0 ' ; x + + ) { 52 m =x; 53 g e t w o r d ( c E n t r a d a s [ x ] . v a l o r , c a d e n a C o o k ie , ' ; ' ) ; 54 p l u s t o s p a c e ( c E n t r a d a s [ x ] . v a l o r ) ; 55 u n e s c a p e _ u r l ( c E n t r a d a s [ x ] . v a l o r ) ; 56 g e t w o r d ( c E n t r a d a s [ x ] .n o m b r e , c E n t r a d a s [ x ] . v a l o r , ' = ' ) ; 57 } 58 59 p r i n t f ( \" <p>Se h a n r e c o g i d o l o s s i g u i e n t e s p a r e s n o r r b r e / v a l o r 60 d e l a s c o o k ie s :< p > % c \" , 1 0 ) ; 61 p r i n t f ( \" < u l> % c\" , 1 0 ) ; 62 f o r ( x = 0 ; x <= m ; x+ + ) 63 p r i n t f ( \" < l i > < code> % s = % s< /c o d e > % c \", 64 c E n t r a d a s [ x ] . n a n b r e , C E n t r a d a s [ x ] . v a l o r , 1 0 ) ; 65 p r i n t f ( \" < / f o r m > \\ n < h r x / h t m l > \" ) ; 6 6 } Privacidad de los datos y consideraciones de seguridad Las cookies han sido am pliamente utilizadas en aplicaciones w eb comerciales. Las cookies son un mecanismo más sofisticado que los campos ocultos de formulario para www.FreeLibros.org Aplicaciones d e Internet 2 8 5 el mantenimiento de los datos de sesión. Sin embargo, su uso ha creado muchas con­ troversias. En primer lugar, las cookies pueden ser escritas en ficheros de la máquina del usua­ rio sin el conocimiento o aprobación explícita del usuario. (Es posible que un usua­ rio configure al navegador para que no acepte cookies; desafortunadamente, esto pue­ de causar problemas cuando el sitio w eb visitado espera ser capaz de utilizar cookies). Aunque los ficheros de las cookies son de tam año pequeño, la acumulación de un gran número de estos ficheros ocupa recursos del sistema. En segundo lugar, las cookies pueden ser utilizadas para recoger información per­ sonal de los usuarios w eb sin su conocimiento o aprobación. Los defensores de la pri­ vacidad han expresado su preocupación sobre el uso de las cookies para recoger los perfiles (patrones interesantes) de los usuarios de los navegadores. La sesión State M a­ nagement d e [research.att.com, 18] proporciona una explicación detallada de cómo las cookies pueden ser utilizadas para construir perfiles de usuario. Por otra parte, las cookies persistentes, almacenadas en ficheros fácilmente acce­ sibles, pueden revelar información personal de usuarios que comparten un computador, creando de esta forma una importante amenaza para la seguridad y la privacidad. Por esta razón HTTP/1.1 realiza aportaciones específicas para solucionar estas preocupaciones. Desafortunadam ente estas aportaciones no han sido ampliamente adoptadas, por lo que los problemas de privacidad derivados del uso de las cookies continúan. Aquí concluye esta introducción a las aplicaciones de Internet. En el Capítulo 11 se estudiarán protocolos y herramientas más avanzadas, que incluyen los servlets y los servicios web. R E S U M E N Este capítulo presenta una introducción a las aplicaciones de Internet y a los proto­ colos principales que las sustentan. A continuación se muestra un resumen de los te­ mas tratados. • HTML ( Hypertext Markup Language, lenguaje de marcado de hipertexto) es un lenguaje de marcado utilizado para crear documentos que pueden ser recibidos utilizando la Web. Este lenguaje permite que un documento sea marcado a fin de poder presentar la información en él contenida. • XM L (Extensible M arkup Language, lenguaje extensible d e etiquetado) permi­ te que un documento sea etiquetado para estructurar la información. • HTTP (Hypertext Transfer Protocoí, protocolo de transferencia d e hipertexto) es el protocolo de transporte de la Web. — HTTP es un protocolo que permite la transferencia d e contenido web de cual­ quier tipo. HTTP es un protocolo orientado a conexión, sin estado y de pe­ tición-respuesta. Un servidor HTTP, un servidor web, ejecuta por defecto en el puerto TCP 80. Los clientes HTTP, coloquialmente denominados navega­ dores web, son procesos que implementan HTTP para poder interactuar con un servidor web y recibir documentos con formato HTML, cuyo contenido es presentado de acuerdo a las etiquetas del documento. www.FreeLibros.org 286 C om putación distribuida. Fundam entos y aplicaciones — En HTTP/1.0, cada conexión permite un único tum o de petición/respuesta: un cliente obtiene una conexión, manda una petición; el servidor procesa la petición, genera una respuesta y finaliza cerrando la conexión. — HTTP está basado en texto: la petición y la respuesta son cadenas de carac­ teres. Cada petición y respuesta están compuestas de cuatro partes: la línea de petición/respuesta; una sección de cabecera; una línea en blanco; el cuerpo. Una línea de petición tiene el siguiente formato: <método H T T P x e s p a c io x U R I solicitad o x esp acio x esp ecificació n de protocolo >\\r\\n Los métodos principales d e HTTP son GET y POST. Una cabecera está compuesta por una o más líneas, cada una de ellas de la forma <clave>: <valor>\\r\\n El cuerpo de la petición contiene datos que necesitan ser enviados al ser­ vidor junto con la petición. • Una respuesta HTTP está compuesta de la respuesta o la línea de estado, una cabecera de sección, una línea en blanco y el cuerpo. La línea de estado tiene el formato <protocoloxespació x código estad o x e sp ació xdescripción> \\r\\n La cabecera de la respuesta está compuesta de una o más líneas, cada una de ellas con el siguiente formato <clave>: <valor>\\r\\n El cuerpo de la respuesta continúa a la cabecera y a una línea en blanco y contiene el contenido del objeto web solicitado. • El protocolo CGI (Common Gateway ¡nterface, Interfaz Estándar de Pasarela) es un protocolo que expande HTTP para la generación de contenido web en tiempo de ejecución. Utilizando el protocolo CGI, un cliente web puede espe­ cificar un programa extemo, conocido como script CGI, como objeto web de la petición HTTP. Cuando es solicitado, el servidor w eb llam a al script CGI y lo activa como un proceso. El script w eb ejecuta y transmite su salida al servidor web, que devuelve los datos generados por el script como respuesta HTTP al cliente. • Un formulario w eb es un tipo especial de página w eb que (1) proporciona una interfaz gráfica de usuario que permite al usuario introducir datos y, (2) cuan­ do el usuario pulsa el botón de Envío, invoca la ejecución d e un programa ex­ terno en la máquina del servidor web. • Los datos de entrada se recogen en la cadena de interrogación usando codifica­ ción URL. Esta cadena se envía al script w eb especificado en la etiqueta ACTION del formulario web. • Han surgido diversos mecanismos para permitir que los datos de sesión sean compartidos entre los script w eb invocados durante una sesión web. Estos me­ canismos pueden ser clasificados como mecanismos del lado del servidor y del lado del cliente. Los mecanismos del lado del cliente incluyen el uso de cam­ pos ocultos d e formularios y de las denominadas cookies. • El uso de campos ocultos de formularios y cookies crea amenazas de seguridad y privacidad. www.FreeLibros.org Aplicaciones d e Internet 2 8 7 E J E R C IC IO S 1. En el contexto de las aplicaciones basadas en la Web, ¿qué papel juega cada uno de los siguientes lenguajes/protocolos? HTML, MIME, XML, HTTP, CGI. 2. Cuando un servidor HTTP envía e l contenido de un documento a un cliente en el cuerpo de la respuesta, utiliza la línea de cabecera Content-Lenght para especificar la longitud en bytes del cuerpo. Para los documentos estáticos la longitud en bytes la proporciona el sistem a de ficheros. Pero para páginas web generadas dinámicamente, tales como las generadas por un script CGI, la lon­ gitud debe ser determinada en tiempo de ejecución. a. Para una página web generada dinámicamente, ¿cóm o puede saber el ser­ vidor w eb la longitud del contenido especificado en la cabecera Content- Lenght? Recuerde que las líneas de cabecera aparecen antes que e l cuerpo en la respuesta HTTP b. Mire cómo H TTP/1.1 soluciona este problema y resuma lo que encuentre (véase la Sección 4.4 de RFC 2068 [ietf.org, 10]). 3. Compile clienteHTTP.java, el código de ejemplo mostrado en la Figura 9.6. Ejecútelo para contactar con un servidor web cuyo nombre conozca para (a) buscar un fichero que exista, y (b) buscar un fichero que sepa que no existe. Capture la salida de cada ejecución. Analice las líneas de la respuesta del ser­ vidor en cada caso e identifique las diferentes partes (línea de estado, línea (s) de cabecera y cuerpo). 4. Repita el ejercicio previo utilizando navegador URL.java, mostrado en la Fi­ gura 9.7. Para el resto de los ejercicios necesitará acceso a los siguientes re­ cursos: • Un servidor w eb que soporte CGI (además necesitará preguntar a l adm i­ nistrador del sistema en qué directorio d e la máquina puede almacenar las páginas web y los script CGI), y • Un co m p ilad o r C, ta l com o gcc, e l com pilador GNU de C (http:// www.gnu.org/software/gcc/gcc.html), que genera código máquina para el ser­ vidor web. 5. Haga experimentos que e l ejem plo CG I Hola presentado en las Figuras 9.10 y 9.11. a. Consiga los ficheros fuente del C G I Hola presentados en la Figura 9.10 y 9.11. b. Instale hola.html en el servidor web, asegurándose de que permite acceso de lectura a todo el mundo. c. Compile hola.c (con util.c que contiene las rutinas de procesado de la ca­ dena de interrogación) para generar y ejecutar hola.cgi. (El mandato es gcc hola.c util.c u hola.cgi). Instale hola.cgi en el servidor web, asegurándose de que permite acceso de lectura/ejecución a todo el mundo. d. Abra un navegador y especifique el URL de hola.html. Cuando se presen­ te la página presione el botón de envío del formulario para invocar hola.cgi. e. Resuma el experimento y analice los resultados. 6. Escriba un programa cliente que invoque a hola.cgi. a. Escríbalo utilizando la A PI socket stream. www.FreeLibros.org 288 C om putación distribuida. Fundam entos y aplicaciones b. Escríbalo utilizando la clase URL. c. Entregue el listado de los programas. 7. Realice los siguientes experimentos con el ejem plo de formulario w eb pre­ sentado en las Figuras 9.14, 9.15 y 9.16. a. Consiga los códigos de form ularioPOST.html, formularioPOST.c, formula- rioGET.html y formularioGET.c. b. Instale formularioPOST.html en el servidor web. c. Compile formularioPOST.c con util.c para generar el ejecutable formula- rio.cgi. Instale form ulario.cgi en el servidor web. d. Abra formularioPOST.html. Introduzca algunos datos que incluyan, al me­ nos, un carácter en blanco. Presione el botón de envío. e. ¿Qué aparece en el campo URL del navegador (normalmente en la parte superior de la pantalla)? Dentro del URL identifique la parte que se co­ rresponde con la cadena de interrogación. ¿Está la cadena codificada con codificación URL? ¿Cómo lo puede saber? f. Los datos que introdujo en el apartado d, ¿son presentados correctamente? g. Modifique formulario.htm l para especificar el método PO ST en la etiqueta FORM (en lugar de GET). Reinstale formulario.htm l en e l servidor web. h. Compile formularioPOST.c con util.c para generar formulario.cgi. Instale form ulario.cgi en el servidor web. i. Visualice, introduzca datos y envíe formulario.html. j. ¿Qué aparece en el campo URL del navegador (normalmente en la parte superior de la pantalla)? k. Los datos que introdujo en el apartado i, ¿son presentados correctamente? 1. Resuma esta experimentación y sus observaciones. Incluya comentarios so ­ bre las diferencias de comportamiento entre los métodos G E T y POST. m. ¿Por qué no es buena idea utilizar el método G ET para enviar datos tales como el DNI o el número de la tarjeta de crédito en una petición HTTP? (Sugerencia: observe e l campo URL que muestre e l navegador w eb cuan­ do ejecute el ejem plo formularioGET). 8. Escriba un programa cliente que invoque directamente form ulario.cgi con el método G E T especificado, utilice la API socket stream o la clase URL. Entre­ gue el programa. (Sugerencia: utilice una cadena de interrogación sencilla en su código, tal como «nombre=Pedro%20Rosales&pregunta=medalla%10oro». También puede servir de ayuda revisar e l ejem plo 3 de la petición HTTP en la sección 9.3). 9. Escriba un programa cliente que invoque directamente form ulario.cgi con el método P O ST especificado, utilice la API socket stream o la clase URL. 10. Experimente con e l ejemplo de campos ocultos presentado en las Figuras 9.12, 9.22 y 9.23 a. Obtenga el código fuente de formulario.htm l, formularioOculto.c y form u­ lar ioOculto2.c. b. Instale formulario.htm l en el servidor. c. Compile formularioOculto.c con util.c para generar un ejecutable form ula- rioOculto.cgi. Instale form ularioO culto, cgi en e l servidor web. www.FreeLibros.org Aplicaciones d e Internet 289 d. Compile formularioO culío2.c con uíil.c para generar un ejecutable form u­ lar ioOculto2.cgi. Instale formularioOculto2.cgi en e l servidor web. e. Abra form ulario.htm l Introduzca un nombre y presione el botón Enviar. Cuando se presente la página web generada dinámicamente, utilice la op­ ción Ver código de su navegador para ver el código fuente de la página web (tal y como fue generada por formularioOculto.cgi). ¿Ve los datos ocultos embebidos en el código fuente? f. ¿Se pasaron los datos (el nombre introducido en el formulario estático) de sesión al último script web? g. Resuma el experimento y sus observaciones. 11. Experimente con e l ejem plo de cookies presentado en las Figuras 9.25, 9.26 y 9.27. a. Obtenga el código fuente de formulario.html, cookie.c y cookie2.c. b. Instale formulario.htm l en el servidor. c. Compile cookie.c con util.c para generar un ejecutable cookie.cgi. Instale cookie.cgi en el servidor web. d. Compile cookie2.c con util.c para generar un ejecutable cookie2.cgi. Insta­ le cookie2.cgi en el servidor web. e. Abra formulario.html. ¿Se pasaron los datos (el nombre introducido en el formulario estático) de sesión al último script web? f. Resuma el experimento y sus observaciones. 12. En este ejercicio experimentará con el ejem plo cookie presentado en las Fi­ guras 9.25, 9.26 y 9.27 para investigar el uso de los atributos path y domain en las cookies. En el servidor, duplique el fichero formulario.html en dos directorios dife­ rentes, cookie 1 y cookie2, respectivamente, de forma que el URL de estas pá­ ginas se diferencie en sus rutas, por ejemplo www.alpha.org/cookiel/formula­ rio.html y www.alpha.org/cookie2/formulario.html. a. Abra dos sesiones con el navegador d e su computador. Acceda a form ula­ rio.html en el directorio cookiel en am bas sesiones, pero introduzca datos diferentes (por ejemplo, nombre=“alfa\" en uno y nombre=“beta” en el otro) en cada uno de ellos. ¿Cuáles son los valores respectivos de los atributos path y domain de las cookies generadas en cada sesión? En cada sesión, ¿qué cookie o cookies enviará el navegador a cookie2.cgi a través del ser­ vidor? ¿Cuál es la salida esperada? Describa sus observaciones. Explique la salida. b. Abra dos sesiones con el navegador de su computador. Acceda a form ula­ rio.html en el directorio cookiel en una sesión y formulario.html en el d i­ rectorio cookie2 d e la otra sesión. Introduzca datos diferentes (por ejemplo, nombre=“alfa” en uno y nombre=“beta” en e l otro) en cada uno de ellos. ¿Cuáles son los valores respectivos de los atributos path y domain de las cookies generadas en cada sesión? En cada sesión, ¿qué cookie o cookies enviará el navegador a cookie2.cgi a través del servidor? ¿Cuál es la sali­ da esperada? Describa sus observaciones. Explique la salida. c. Modifique el código del script CGI (en cookie.c) para que las cookies se generen con la ruta 7 ”. www.FreeLibros.org 290 C om putación distribuida. Fundam entos y aplicaciones Abra dos sesiones con el navegador de su computadora. Acceda a form u- lario.html en el directorio cookie 1 en una sesión y formulario.html en el di­ rectorio cookie2 de la otra sesión. Introduzca datos diferentes (por ejemplo, nombre=“alfa” en uno y nombre=“beta” en el otro) en cada uno de eÜos. ¿Cuáles son los valores respectivos de los atributos path y domain de las cookies generadas en cada sesión? En cada sesión, ¿qué cookie o cookies enviará el navegador a cookie2.cgi a través del servidor? ¿Cuál es la sali­ d a esperada? Describa sus observaciones. Explique la salida. d. Suponga que instala formulario.html, cookie.c y cookie2.c en otro servidor, por ejemplo www.beta.org, de forma que se tiene dos conjuntos de fiche­ ros idénticos, uno en www.alfa.org y otro en www.beta.org. Abra dos se­ siones de navegador diferente en el computador, acceda a www.alfa.org/for- mulario.html en la primera sesión y www.beta.org/cookie2/formulario.html en la segunda sesión. Introduzca “alfa” como nombre en la primera sesión y «beta» en la segunda. ¿Cuáles son los valores respectivos de los atribu­ tos path y domain de las cookies generadas en cada sesión? En cada se­ sión, ¿qué cookie o cookies enviará el navegador a cookie2.cgi a través del servidor? ¿Cuál es la salida esperada? Razone la respuesta. 13. Este ejercicio experimenta con el ejemplo cookie presentado en las Figuras 9.25, 9.26 y 9.27 para investigar e l uso del atributo expires con las cookies. Modifique el código fuente del script CGI (en cookie.c) para añadir el atri­ buto expires a la línea de cabecera Set-Cookie, d e esta manera: E x p i r e s M on, 0 9 -D e c -2 0 0 2 1 3 : 4 6 : 0 0 GMT para que las cookies se escriban a fichero (en lugar de existir de forma tem ­ poral en el navegador). Abra dos sesiones con el navegador d e su computador. Acceda a form ula­ rio.html en el directorio cookie en ambas sesiones, pero introduzca datos di­ ferentes (por ejemplo, nombre=“alfa” en uno y nombre=“beta” en e l otro) en cada uno de ellos. ¿Cuáles son los valores respectivos de los atributos path y domain de las cookies generadas en cada sesión? En cada sesión, ¿qué cookie o cookies enviará el navegador a cookie2.cgi a través del servidor? ¿Cuál es la salida esperada? Describa sus observaciones. Explique la salida. 14. A la caza de la cookie: Cierre su navegador y reinícielo para comenzar una nueva sesión. Ejecute el ejem plo cookie que escribe las cookies en fichero (tal y como se describió en la anterior sección). Introduzca una cadena rara (por ejemplo, «dfgjhff») en el campo del formulario. Cuando se ejecute se debería crear una cookie con la cadena extraña que se introdujo. Utilice una herramienta de búsqueda de su sistema para encontrar el fiche­ ro que contiene la cadena extraña. (En un sistema UNIX se puede utilizar el comando grep. En un sistema Windows se puede utilizar la utilidad encontrar- fichero). ¿Encontraste el fichero? En caso afirmativo, identifica sus elementos. 15. Lea la sección “State M anagement” (“Gestión d e estado”) en [research.att.com, 18]. a. Resuma los problemas de seguridad sobre el uso de las cookies. b. Proporcione, con explicaciones, una sesión HTTP de ejemplo en la que se utilicen las cookies para construir un perfil consistente en (i) el número de www.FreeLibros.org Aplicaciones d e Internet 291 tarjeta de crédito del usuario y (ii) una traza de los URL que el usuario vi­ sitó en el sitio w eb durante su última sesión. c. ¿Cuáles son soluciones específicas que se hicieron en el HTTP/1.1 para so ­ lucionar estos problemas? Resúmalas. (Puede ser útil consultar [ietf.org, 10] y [research.att.com, 18]). El resto de los ejercicios son para estudiantes que conocim ientos avanzados de C u otros lenguajes de program ación para implementar scripts CGI. Los estudiantes que no estén familiarizados con estos lenguajes, pueden saltarse estos ejercicios. Se ten­ drá la ocasión de practicar estos ejercicios utilizando e l lenguaje Java en el Capí­ tulo 11. 16. Modifique los ficheros de ejemplo cookie para implementar un conjunto de pá­ ginas w eb y scripts CGI con un carrito de la compra sencillo tal y como se muestra en la Figura 9.17. Los datos de estado que necesitan ser mantenidos son (a) ID del cliente y (b) nombre d e la mercancía. 17. Escoja: (a) escriba un script CGI o (b) encuentre un script CGI gratuito (in­ tente usar el programa Login de http://tectonicdesigns.com/freecgi) que le per­ mita proporcionar seguridad a su página web. Cuando se solicite su página web, la salida debería ser parecida a la mostrada en la siguiente figura. Si la contraseña introducida es correcta, su página debería ser mostrada. Instale el script y verifíquelo. Describa el trabajo y describa cómo proporciona protec­ ción con contraseñas. Nota: e l script CGI necesitará sacar una línea como la siguiente: < h t m l > < h e a d X M E T A HTTP-EQUIV=\" REFRESH\" C0NTENT=\" O ; URL=<url de tu página w e b > \" x / h e a d x / h t m l > \\ n para reenviar a su página web después de verificar la contraseña. P o r fa v o r , id e n tifiq ú e se : N om bre | Contraseña E nviar R E FER EN C IA S 1. H o b b es’ In tern et T ím eline, http://www.zakon.org/robert/intemet/tit7ielme/ 2. A L ittle H isto ry o f th e W orld W ide W eb, http://www.w3.org/History.html 3. ISO 8879:1986, Inform ation processing— T ext a n d o ffice system s— S tan d ard G eneralized M ar- kup L anguage (SGM L), International O rganization for Standardization, http://www.iso.org/ 4. P eople o f th e W 3 C , http://www.w3.org/People/ 5. R FC 2109 H T I P S tate M anagem ent M echanism , http://www.ics.uci.edu/pub/ietf/http/rfc2I09.txt 6. W elcom e to C E R N , http://public.Web.cem.ch/Public/ 7. HTTP: A protocol for netw orked inform ation, http://wwyv.w3.org/Protocols/HTTP/HTTP2.html 8. R F C 1945, H ypertext T ransfer P rotocol— H T T P/1.0, http://www.faqs.org/rfcs/rfcI945.html www.FreeLibros.org 2 9 2 C om putación distribuida. Fundam entos y aplicaciones 9. R F C 1521, M IM E (M ultipurpose In tern et M ail E xtensions) Part O ne, http://www.faqs.org/ rfcs/rfc 1521.html 10. R FC 2068, H yp ertex t T ransfer Protocoí— H T T P/1.1, http://www.ietf.org/rfc/rfc2068.txt 11. T h e W orld W ide W eb C onsortium , http://www.w3.org/ 12. R FC 959, F ile T ransfer Protocoí (FT P), http:l/www.ietforg/rfclrfc0959.txt?nunber=959 13. R FC 1866, H ypertext M arkup L anguage 2.0, http://ftp.ics.uci.edu/pub/ietf/htniUrfcl866.txt 14. N C S A — A B e g in n e r’s G u id e t o H T M L , http://archive.ncsa.uiuc.edu/General/lnternet/ WWW/HTMLPrimerAll.html 15. E xtensible M arkup L anguage (X M L), http://www.w3.org/XMLI 16. A Q u ick In tro d u c tio n t o X M L , http://java.sun.com/xmlljaxp-l.lldocsltutorialloverview/ l_xml.html 17. T h e O riginal H T T P a s d e fin e d in 1991, T im B erners-L ee, http://www.w3.org/Protocols/ HTTP/Aslmplemented.html 18. B alach an d er K rishnam urthy, Je ffrey C. M ogul, a n d D avid M . K ristol. K ey D ifferences bet- w e en H T T P /1.0 a n d H T T P/1.1, http://www.research.att.com/~bala/papers/hOvhl.html 19. T h e C om m on G atew ay Interface, http://hoohoo.ncsa.uiuc.edu/cgi/overview.html 20. T h e C o m m o n G a te w a y I n te r f a c e S p e c if i c a t io n , h ttp ://h o o h o o .n csa .u iu c.ed u /cg i/ interface.html 21. C G I T utorial, http://www.comp.leeds.ac.uk/nik/Cgi/start.html 22. R FC 1738, T h e U niform R esource L ocators, http://www.w3.org/Addressinglrfcl738.txt 23. U R L E ncoding, http://www.blooberry.com/indexdot/html/topics/urlencoding.htm 24. H y p e rte x t M a rk u p L a n g u a g e 2.0— F o rm s, http://www.w3.org/MarkUp/htnil-spec/html- spec_8.html 25. C lie n t S id e S ta te — H T T P C ookies, N e tsc a p e Inc., http://home.netscape.com/newsref/std/ cookie_spec.htm 26. What is Jabber?, Jab b er S o ftw are Foundation, http://www.jabber.org/about/overview.htm www.FreeLibros.org CAPITULO C O R B A - Com m on O bject R eq u est B ro ker A rc h ite c tu re En el Capítulo 7 ya se presentó el paradigma de objetos distribuidos. Entre los temas cubiertos se encontraba la arquitectura para un sistema de objetos distribuidos típico, ilustrada mediante Java RMI. En este capítulo, se presentará una arquitectura alternativa (una arquitectura estándar) para objetos d istribuidos. A la arquitectura se la conoce com o C o m m o n O b je c t R e q u e s t B ro k e r A rc h ite c tu re (CORBA). Las razones de este interés en CORBA son dos: en prim er lugar, proporciona un caso de estudio que ilustra dos arquitecturas sim ilares, pero en contraste, para un concepto determ inado, los objetos d istribuidos. En segundo lugar, CORBA proporciona un ejem plo de una arquitectura diseñada para alcanzar la m áxim a interoperabilidad. CORBA es una arquitectura de o bjetos d istribuidos diseñada para pe rm itir que dichos o bjetos d istribuidos interoperen sobre entornos heterogéneos, d o nd e los o bjetos pueden estar im plem entados en diferentes lenguajes de program ación y/o desplegados sobre diferentes plataform as. CORBA se diferencia de la arquitectura Java RMI en un aspecto significativo: RMI es una tecnología propietaria de Sun M icrosystem s, Inc. y sólo soporta objetos que se encuentren escritos en el lenguaje Java. Por el contrario, CORBA ha sido desarrollado p o r O M G (O b je ct M a n a g e m e n t G ro u p ) [corba.org, 1], un consorcio de em presas, y www.FreeLibros.org 294 C om putación distribuida. Fundam entos y aplicaciones fue diseñado para maxim izar el grado de interoperabilidad. Es im portante saber que CORBA no es en sí m ism o una herramienta para dar so p orte a objetos d istribuidos; se trata de un conjunto de protocolos. Una herram ienta que dé so p orte a dichos protocolos se denom ina com patible con C O R B A (CORBA com pliant), y los objetos que se desarrollen sobre ella podrán interoperar con otros objetos desarrollados por otra herramienta com patible con CORBA. CORBA proporciona un conjunto de protocolos m uy rico [Siegel, 4], y el abordar to d o s ellos está más allá del ám bito de este libro. Sin em bargo, se centrará en los conceptos clave de CORBA que estén relacionados con el paradigm a de objetos d istribuidos. También se estudiará una herram ienta basada en CORBA: In te rfa c e D e fin itio n Language (IDL) de Java. 1 0 .1 . A R Q U IT E C T U R A B La Figura 10.1 m uestra la arquitectura básica de CORBA [omg.org/gettingstarted, 2]. Como arquitectura de objetos distribuidos, guarda una gran semejanza con la ar­ quitectura RMI. D esde e l punto de vista lógico, un d ie n te d e objeto realiza una llamada a un m étodo de un objeto distribuido. El cliente interactúa con un proxy, un s k i b mientras que la im plementación del objeto interactúa con un proxy de servi­ dor, un stodeéon A diferencia del caso de Java RMI, una capa adicional de soft­ ware, conocida com o ORB {O bfect R e q u e st Brvkea) es necesaria. En el lado del cliente, la capa del ORB actúa con intermediaria entre el stub y la red y sistema operativo local del cliente. En e l lado del servidor, la capa del ORB sirve de inter­ mediaria entre e l skeleton y la red y sistem a operativo del servidor. Utilizando un protocolo común, las capas ORB de am bos extrem os son capaces d e resolver las d i­ ferencias existentes en lo referente a lenguajes d e programación, así como las rela­ tivas a las plataform as (red y sistem a operativo), para d e esta forma ayudar a la co­ municación entre los dos extremos. El cliente utiliza un servid o d e nom brado para localizar e l objeto. N o m b re d e l servicio Búsqueda de n o m b re -► Flujo d e d a to s ló g ic o ► Flujo d e d a to s físico Im p le m e n ta c ió n del o b je to ^ Stub Skeleton ORB ORB Red Red Sistem a o p e ra tiv o Sistem a o p e ra tiv o F ig u ra 10.1. A rq u ite c tu ra C O R B A básica. www.FreeLibros.org CORBA - C o m m on O b je ct R equest A rchitecture 295 1 0 .2 . LA IN TE R FA Z DE O B JE TO S DE C O RBA Un objeto distribuido se define usando un fichero similar al fichero que define la in­ terfaz remota en Java RMI. Debido a que CORBA es independiente de lenguaje, la interfaz se define por medio d e un lenguaje universal con una sintaxis específica, co­ nocido como CORBA L n ta R tce D eG nhhut L a n g ia g e QOL-lengpiaje de definición de interfaces) Encontrará que la sintaxis de CORBA IDL es muy similar a la de Java o C++, pero recuerde que un objeto definido en CORBA IDL puede implementarse en un gran número de lenguajes, incluyendo C, C++, Java, COBOL, Smalltalk, Ada, List, Python, e IDLScript [omg.org/gettingstarted, 2]. Para cada uno d e estos lengua­ jes, OMG tiene una traducción (mapping) estándar d e CORBA IDL a dicho lenguaje de programación, de forma que se pueda usar un compilador para procesar las inter­ faces CORBA y generar los proxies necesarios para servir de interfaz ante la imple- mentación del objeto o ante e l cliente, que pueden estar, por tanto, escritos en cual­ quier lenguaje soportado por CORBA. La Figura 10.2 muestra una aplicación donde el cliente es un programa escrito en Java mientras que el objeto está implementado en C++. Cabe resaltar que el stub ge­ nerado por la traducción de la interfaz del objeto CORBA es un stub en Java, mien­ tras que e l skeleton se ha generado traduciendo el interfaz a un skeleton C++. A pe­ sar de estar implementados en diferentes lenguajes, los dos ORB pueden interactuar gracias a los protocolos comunes soportados por ambos. Existe un gran número de ORB disponibles, tanto experimentales como comer­ ciales [corba.org, 1; puder.org, 19]. C lie n te d e o b je to e s c rito e n J a v a Stub J a v a g e n e ra d o p o r m e d io d e la com pilación del interfaz de o b je to C O RBA O R B e s c rito en Ja va Im p le m e n ta c ió n d e l o b je to ^ e s c rita e n C + + Skeleton C ++ g e n e ra d o p o r m e d io d e la compilación del interfaz de o b je to CORBA O R B e s c rito e n C + + F ig u ra 10.2. In d e p e n d e n cia d e le ng uaje e n CORBA. 1 0 .3 . PR O TO C O LO S IN TE R -O R B Para que dos ORB puedan interoperar, OMG ha especificado un protocolo conocido como G e n o * Inter-O R B PnMocai (GIOP), una especificación que proporciona un marco general para que se construyan protocolos interoperables por encima d e un ni­ vel d e transporte específico. Un caso especial de este protocolo es el L n ta n e t Inter- O R B Pm éocal (IIO P) que se corresponde con el GIOP aplicado sobre el nivel de transporte de TCP/IP. La especificación d e IIOP incluye los siguientes elementos: 1. Requisitos de gestión de transporte Estos requisitos especifican qué se ne­ cesita para conectarse y desconectarse, y los papeles que el cliente y el obje­ to servidor interpretan en establecer y liberar conexiones. www.FreeLibros.org 2 9 6 C om putación distribuida. Fundam entos y aplicaciones En arquitectura de computadores, un bus es equivalente a una autopista sobre la cual viajan los datos entre los componentes de un computador. En redes informáticas, un bus es un cable central que interconecta dispositivos. 2. Definición d e la r e p r & sn ta á fm común d e datos. Se necesita definir un es­ quema de codificación para empaquetar y desempaquetar los datos para cada tipo de datos del H)L. 3. Form atos de lo s m otsajes. Se necesita definir los diferentes formatos de los distintos tipos de mensajes. Los mensajes permiten a los clientes enviar soli­ citudes al objeto servidor y recibir sus respuestas. Cada cliente usa un men­ saje de petición para invocar a un método declarado en la interfaz CORBA de un objeto y recibe un mensaje de respuesta del servidor. Un ORB que soporte la especificación de IIOP puede interoperar con otro ORB compatible IIOP a través de Internet. De aquí surge la denominación b is de objetos: Internet se ve como un bus de objetos CORBA ínter conectados, como se muestra en la Figura 10.3. F ig u ra 10.3. Intern et c o m o un b u s d e o b je to s . 1 0 .4 . SER VID O R ES DE O BJETOS Y C LIE N TE S DE O BJETOS Como en el caso de Java RMI, un servidor d e objetos exporta cada objeto distri­ buido CORBA, similar al caso del servidor de objetos RMI. Un cliente d e objetas obtiene la referencia a un objeto distribuido por medio de un servicio de nombres o de directorio (que se verá a continuación) y posteriormente invoca los métodos de di­ cho objeto distribuido. 1 0 .5 . R E FER EN C IA S A O B JE TO S CORBA También como en el caso de Java RMI, un objeto distribuido CORBA se localiza por medio d e una refrenda a objeto Ya que CORBA es independiente de lenguaje, una referencia a un objeto CORBA es una entidad abstracta traducida a una referencia de objeto específica de cada lenguaje por medio del ORB, en una representación elegi­ da por el desarrollador del propio ORB. Por interoperabilidad, OMG especifica un protocolo para referencias abstractas de objetos, conocido como protocolo In á a vp era U e O bject R e fe re n te (1 0 R). Un ORB que sea compatible con el protocolo IOR permitirá que una referencia a objeto se re­ gistre y se obtenga desde un servicio de directorio compatible con IOR. Las referen­ www.FreeLibros.org CORBA - C o m m on O b je ct R equest A rchite cture 2 9 7 cias a objetos CORBA representadas en este protocolo se denominan tam bién IO R {Intetnpem ide O bject R eám aces). Una IOR es una cadena de caracteres que contiene codificada la información si­ guiente: • El tipo de objeto. • El ordenador donde se encuentra el objeto. • El número de puerto del servidor del objeto. • Una clave del objeto, una cadena de bytes que identifica al objeto. La clave de objeto la utiliza el servidor de objetos para localizar el objeto internamente. Una IOR es una cadena de caracteres parecida a esta: IO R :0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 d 4 9 4 4 4 c 3 a 6 7 7 2 6 9 6 4 3 a 3 1 2 e 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 c 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 5 7 5 6 c 7 4 7 2 6 1 2 e 6 4 7 5 6 2 6 c 6 9 6 e 2 e 6 9 6 f6 e 6 1 2 e 6 9 6 5 0 0 0 0 0 9 6 3 0 0 0 0 0 0 2 8 3 a 5 c 7 5 6 c 7 4 7 2 6 1 2 e 6 4 7 5 6 2 6 c 6 9 6 e 2 e 6 9 6 f6 e 6 1 2 e 6 9 6 5 3 a 6 7 7 2 6 9 6 4 3 a 3 0 3 a 3 a 4 9 5 2 3 a 6 7 7 2 6 9 6 4 0 0 3 a La representación consiste en un prefijo con los caracteres IOR: seguido por una se­ cuencia hexadecimal de caracteres numéricos, cada carácter representa 4 bits de datos bi­ narios en la IOR. Los detalles de la representación no son importantes para este estudio; a los lectores que estén interesados se les refiere a la bibliografía para más detalle. 1 0 .6 . S E R V IC IO DE N O M B R E S Y S E R V IC IO DE N O M B R ES IN TE R O P E R A B LE DE C O RBA En el Capítulo 7, cuando se estudió Java RMI, se presentó el registro RMI como un servicio de directorio distribuido para objetos RMI distribuidos. CORBA especifica un servicio de directorio con el mismo propósito. El servicio d e nom bres ( N m tm g S e r■ Wbd [omg.org/technology, 5; java.sun.com/j2se, 16] sirve como un directorio de ob­ jetos CORBA, haciendo el papel de su análogo, el registro RMI, con la excepción de que el Servicio de Nombres de CORBA es independiente de plataforma y de lengua­ je de programación. Servicio de nom bres de C O RBA El Servicio de Nombres permite que clientes basados en ORB obtengan las referen­ cias a los objetos que desean usar. Permite asociar nombres a referencias objetos. Los clientes pueden consultar al Servicio de Nombres usando un nombre predeterminado para obtener la referencia asociada al objeto. Para exportar un objeto distribuido, un servidor de objetos CORBA contacta con el Servicio de Nombres para asociar (b in tt un nombre simbólico al objeto. El Ser­ vicio de Nombres mantiene una base de datos con los nombres y los objetos asocia­ dos a dichos nombres. Para obtener una referencia a un objeto, un cliente de objetos solicita que el Servi­ cio de Nombres busque el objeto asociado con dicho nombre (a este proceso se le de­ nomina resolución (resolví) del nombre del objeto). El API para el Servicio de Nom­ bres se encuentra especificada por medio de una interfaz IDL, que incluye métodos que permiten a servidores asociar nombres a objetos y a los clientes resolverlos. Para ser lo www.FreeLibros.org 298 Computación distribuida. Fundamentos y aplicaciones más general posible, el esquema de nombrado de objetos en CORBA es necesariamen­ te complejo. Ya que el espacio de nombrado es universal, se define una jerarquía de nombrado estándar d e una manera similar a un directorio de ficheros, como se muestra en la Figura 10.4. En este esquema de nombrado, un co n ta to de nombrado (n a m ia g ca n te«4 se corresponde con una carpeta o directorio en un árbol de ficheros, mientras que los nombres de objetos se corresponden con los ficheros. El nombre completo de un objeto, incluyendo todos los contextos de nombrado asociados, se denomina nom­ bre con^mesto. El primer componente de un nombre compuesto proporciona el nom­ bre de contexto de nombrado donde se encuentra el segundo. Este proceso continúa has­ ta que se llega al último componente del nombre compuesto. La sintaxis para un nombre d e un objeto es la siguiente: ccontexto de nombrado>.<contexto de nombrado>. ... <contexto de nom brado.<nom - bre del o b je to Donde la secuencia de contextos de nombrado lleva hasta el nombre del objeto. La Figura 10.5 muestra un ejemplo de una jerarquía de nombrado. Como se pue­ de ver, un objeto que representa el departamento de ropa de hombres se denominaría tienda.ropa.hombre, donde tienda y ropa son contextos de nombrado, y hombre el nombre del objeto. Los contextos de nombrado y los nombres se crean utilizando los métodos pro­ porcionados por la interfaz del Servicio de Nombres. Servicio de nom bres interoperable de C O RBA El h tk ra p e ra H e N a m in g S e rv ic e (INS - Servicio d e N om bres Interoperable) [omg.org/technology, 5; java.sun.com/j2se, 16] es un sistema de nombrado basado en el formato URL para el Servicio de Nombres de CORBA. Permite que las aplicacio- www.FreeLibros.org CORBA - C o m m on O b je ct R equest A rchitecture 2 9 9 tienda F ig u ra 10.5. Un ejem plo de la jerarquía de nom brado de CORBA. nes compartan un contexto inicial de nombrado y que proporcionen un URL para acceder a un objeto CORBA. Utilizando este sistema, un URL del tipo corbana- m e::acm e.com :2050jftienda/ropa/m ujer se podría usar para acced er a l objeto tienda!ropa!mujer del servicio de nombres en el puerto 2050 del servidor con nom­ bre acme.com. 1 0 .7 . S E R V IC IO S DE O B JE TO S CORBA Dentro de las especificaciones de CORBA se encuentran varias que proporcionan ser­ vicios usados habitualmente por los objetos distribuidos para construir aplicaciones. A continuación se recogen algunos de los servicios [corba.org, 1]: • Servicio d e concurraida (C a n a n r a u j S a v i a } - servicio que proporciona control de concurrencia. • Servicio de eventos (E vaM S a v i a } - para la sincronización de eventos. • Servicio de lo g (L o g sfn g S a v i a } - para registrar eventos. • Servicio de nombres (N a ttA tg S a v i a } - servicio de directorio, como se ha descrito en la sección anterior. • Servid o «le planificación { S c h a M e n g S e rv ia } - para planificación de eventos. • Servid o de seguridad ( S e a u ity S a v ic i} - para gestión de seguridad. • Servid o de negodadón {T n n E n g S e rv ia } - para localizar servicios por tipo (no por nombre). • S ervid o d e tiem po (T ím e S a v i a } - un servicio para eventos relativos al tiempo. • Servid o de notificación (N otífícatiaa S a v i a } - para notificación d e eventos. • Servid o d e transaedones d e objetos {O bject Transactian S o v i e t - para pro­ cesamiento d e transacciones. www.FreeLibros.org 3 0 0 Computación distribuida. Fundamentos y aplicaciones Cada servicio se define por medio de un IDL estándar que puede ser implemen- tado por los desarrolladores d e objetos de servicio, y los métodos del objeto de ser­ vicio se pueden invocar desde cualquier cliente CORBA. Como ejemplo, la especificación de CORBA del servicio de tiempo describe las siguientes funcionalidades: • Permite al usuario obtener el tiempo en el instante actual junto con una esti­ mación del error cometido. • Hacer comprobaciones sobre el orden en el que se han producido varios «eventos». • Generar eventos relativos al tiempo por medio de temporizadores y alarmas. • Calcular el intervalo de tiempo entre dos eventos. El servicio de tiempo consiste en dos servicios, cada uno de ellos descrito por medio de una interfaz de servicio: 1. El Servicio de tiem po maneja objetos d e tipo tiempo universal (Universal Time) y objetos d e tipo intervalo de tiem po (Time Intervaí) y está representa­ do por la interfaz U m e S m ic e El servicio proporciona herramientas para re­ gistrar tiempos en aplicaciones CORBA. 2. El Servicio d e eventos d e ticnqio gestiona objetos del tipo manej adores de eventos de tiempo (Time Event Handlers) y se encuentra recogido en la inter­ faz TnneEvent&rvice; que proporciona métodos para programar y cancelar temporizadores con tiempos absolutos, relativos o periódicos. Por medio d e estas especificaciones, se han desarrollado varios objetos para el servi­ cio d e tiem po de CORBA por parte de diferentes fabricantes, investigadores o individualmente. 1 0 .8 . A D A PTA D O R ES DE O B JETO S En la arquitectura básica de CORBA, la implementación de objetos distribuidos inter­ actúa con el skeleton para conectarse con el stub en el lado del cliente. Cuando la arquitectura evolucionó, se añadió un componente software al skeleton en el lado del servidor: el adaptador de objetos (obfect a d a p ta ) (véase la Figura 10.6). Un adapta­ dor de objetos simplifica las responsabilidades que tiene un ORB asistiéndole en hacer llegar las peticiones del cliente a la implementación del objeto. Cuando un ORB reci­ be una petición de un cliente, localiza el adaptador de objetos asociado a dicho objeto y redirige la petición a dicho adaptador. El adaptador interactúa con el skeleton de la implementación del objeto, el cual realiza el empaquetamiento e invoca el método apro­ piado del objeto. Hay diferentes tipos de adaptadores de objetos CORBA. El Portable O bfect A dapto' (POA - adaptador d e objetas portable) [citeseer.nj.nec.com, 8] es un tipo particular de adaptador de objetos definido por una especificación de CORBA. Un adaptador de ob­ jetos de tipo POA permite que una implementación de objeto funcione en varios ORB, de forma que la implementación del objeto sea portable a través de varias plataformas. 1 0 .9 . ID L DE JAVA Con las especificaciones de CORBA, un programador puede implementar cualquier componente especificado en e l marco de CORBA. En realidad, un gran número de www.FreeLibros.org CORBA - C o m m on O b je ct R equest A rchite cture 3 0 1 Implementación del Objeto Distribuido Adaptador de Objetos ORB del Servidor F ig u ra 10 .6. Un ada ptado r de objetos. herramientas CORBA se encuentran disponibles [corba.org, 1], muchas de las cuales puede obtenerse sin coste alguno. Algunas d e estas herramientas están desarrolladas por empresas, otras por investigadores y algunas otras por grupos independientes. Como ejem plo de una herramienta de este tipo, se va a ver el IDL de Java (o Java IDL). Java IDL es parte del la plataforma Java 2, Standard Edition (J2SE). Java IDL incluye un ORB, un con^alador ID L- a-J a v a y un subconjunto d e los servidos es- ten ia* d e CORBA Es necesario reseñar que además de Java EDL, Java proporcio­ na varias herramientas compatibles con CORBA [java.sun.com/j2ee, 7], incluyendo RMI sobre IIOP [java.sun.eom /j2se/l.3, 9], que permite que una aplicación CORBA se escriba con la sintaxis y la semántica de RMI. Con su conocimiento de RMI y CORBA, debería ser capaz de aprender RMI sobre IIOP por su cuenta. En el resto de este capítulo, se tratará Java EDL como un ejemplo de entorno CORBA. Paquetes claves de Java IDL Java IDL proporciona una serie de paquetes que contienen interfaces y clases para dar soporte a CORBA [java.sun.eom /j2se/l.4, 17]: • El paquete org.omg.CORBA contiene las interfaces y las clases que proporcio­ nan la traducción (mapping) de las API de CORBA OMG a l lenguaje d e pro­ gramación Java. • El paquete org.omg.CosNaming contiene los interfaces y las clases que dan so ­ porte al Servicio de Nombrado para Java IDL. • org.omg.CORBA contiene interfaces y clases para soportar e l API de acceso al ORB. H erram ientas de Java IDL Java IDL dispone de un conjunto de herramientas para desarrollar aplicaciones COR­ BA [java.sun.com/products, 18]: e l compilador IDL-a-Java (Nota: se desaconseja la utilización de la ante­ rior versión de este compilador, idl2java.) • e r b d - proceso servidor que da soporte al Servicio de Nombrado, así como a otros servicios. • s a v a t o a l - proporciona una interfaz en línea de mandatos para que los pro­ gramadores d e aplicaciones puedan registrar/desregistrar objetos, y arrancar/pa­ rar servidores. • tn a n r s a v - una versión antigua del Servicio de Nombrado de Java IDL cuyo uso se desaconseja actualmente. www.FreeLibros.org 3 0 2 Computación distribuida. Fundamentos y aplicaciones Una aplicación C O R B A de ejem plo El siguiente ejemplo ilustra el uso de las funcionalidades de soporte a IDL disponi­ bles en el entorno Java 2 Standard Edition (J2SE), versión 1.4 [java.sun.com/j2se/l.4, 20]. Si usted está utilizando una versión anterior de Java, como J2SE 1.3, la sintaxis y algunos d e los mecanismos que se describirán aquí serán diferentes. El ejemplo muestra un objeto CORBA que proporciona un método que devuelve la cadena de ca­ racteres “Hola mundo\". El ejemplo, aunque m uy simple, permite ilustrar los funda­ mentos básicos. En e l ejemplo, el objeto distribuido se denomina Hola. Cuando desarrolle su apli­ cación, podrá substituirlos por un nombre diferente de objeto en cualquiera de los si­ tios en los que la palabra Hola aparezca como descripción. Fich e ro de la interfaz C O R B A El punto de arranque d e una aplicación CORBA es el desarrollo del fichero de inter­ faz CORBA escrito en el IDL de OMG, simplemente llamada fichero IDL. Recuerde que EDL es un lenguaje universal, de forma que la sintaxis d e este fichero d e inter­ faz es la misma independientemente de cuáles sean las herramientas CORBA utiliza­ das. La Figura 10.7 muestra un ejemplo de un posible fichero EDL que declara la in­ terfaz llamada Hola. La interfaz define dos métodos: e l método decirHolaf) no requiere ningún argumento y devuelve una cadena de caracteres (nótese que el tipo string se escribe en minúsculas: este tipo string es un tipo de datos del IDL de CORBA); el método apagar() desactiva el ORB y se recomienda incluirlo en todos los interfaces de servicio CORBA. Las palabras module, interface, string, y oneway son palabras reservadas en IDL. Un module (módulo), como indica la palabra, describe un módu­ lo software. Se pueden declarar una o varias interfaces dentro de un mismo módulo, así como uno o varios métodos se pueden declarar dentro de cada interfaz. El modi­ ficador oneway denota que el método apagar requiere sólo una comunicación del clien­ te al servidor (y ninguna respuesta del servidor al cliente). El fichero IDL puede colocarse en un directorio dedicado para esta aplicación. El fichero se compila usando el compilador idlj de la siguiente forma: idlj — fall H o l a .idl F ig u ra 1 0 .7 . Hola.idl. l module HolaApp 2 { 3 interface Hola 4 { 5 string decirHola(); 6 oneway void ap a g a r ( ) ; 7 >? 8 La opción -fall es necesaria para que el compilador genere todos los ficheros ne­ cesarios para el resto del ejemplo, que en este caso, los creará en e l directorio Hola- App. En general, estos ficheros se generan en un subdirectorio denominado con el mismo nombre que e l módulo compilado. Si la compilación tiene éxito se generan los siguientes ficheros: www.FreeLibros.org CORBA - C o m m on O b je ct R equest A rchite cture 3 0 3 1. Hola Operations.java 2. Hola.java 3. HolaHelper.java 4. HolaHolder.java 5. JiolaStub.java 6. HolaPOA.java Estos ficheros se generan por el compilador idlj de forma automática como resultado de una compilación con éxito; estos ficheros no necesitan ninguna modificación por su parte. S e explicará brevemente cada uno de estos ficheros en los siguientes párra­ fos. Para este libro, resulta interesante de todas formas que conozca los contenidos de cada uno de estos ficheros. HolaOperations.java, el interfaz de op eraciones El fichero HolaOperations.java (Figura 10.8), conocido d e forma general como i n ­ te rfa z d e o p erario n es Ja v a , es un fichero d e interfaz Java que traduce el fichero de interfaz EDL CORBA (Hola.idí). El fichero contiene los métodos definidos en el fichero IDL original: en este caso los métodos decirHolaf) y apagar<). F ig u ra 10 .8 . H olaA pp/H olaO perations.java. 1 2 package HolaApp; 3 4 /** 5 * HolaApp/HolaOperations.j ava 6 * Generated b y the IDL-to-Java compiler 7 * versión \"3.1\" from Hola.idí 8 9 */ 10 public interface HolaOperations 11 { 12 String decirHola () ; 13 void apagar (); 14 > // interface HolaCperations Hola.java, el fich e ro de firm a de interfaz El fichero Hola.java (Figura 10.9), denominado f i c h a n d e firm a d e interfaz. Ex­ tiende las clases estándar de CORBA org.om g.portable.IDLEntity, org.om g.COR­ BA. Object, y la interfaz específica de la aplicación, HolaOperations, descrito en la sección anterior. F ig u ra 10 .9 . H olaA pp/H ola.java. 1 package HolaApp; 2 3 /** (continúa) www.FreeLibros.org 3 0 4 Computación distribuida. Fundamentos y aplicaciones 4 * H o la A p p /H o la .ja v a 5 * G e n e ra te d by t h e I D L - to - J a v a c o m p ile r ( p o r t a b l e ) , 6 * v e r s i ó n \" 3 .1 \" f r a n H o l a . i d l 7 * / 8 9 p u b l i c i n t e r f a c e H o la e x te n d s H o la O p e r a tio n s , 10 org.om g.C O R B A .O bject, 11 o r g . omg. CORBA. p o r t a b l e . I D L E n tity 12 { 13 } / / i n t e r f a c e H ola El fichero de firma de interfaz combina las características del interfaz de opera­ ciones de Java {HolaOperations.java) con las características de las clases CORBA que extiende. HolaHelper.java , la cla se de ayuda La clase Java HolaHelper (Figura 10.10), proporciona funcionalidades auxiliares ne­ cesarias para dar soporte a los objetos CORBA en e l contexto del lenguaje d e pro­ gramación Java. En particular, un método, narrow (véase la línea 49) permite que una referencia a un objeto CORBA se pueda convertir a su tipo correspondiente en Java, de forma que el objeto CORBA pueda utilizarse con la sintaxis de un objeto Java. La descripción detallada de la sintaxis y la semántica del fichero está más allá del ám ­ bito de este libro. F ig u ra 1 0 .1 0 . H o la A p p /H olaH elper.java. 1 package HolaApp; 2 3 4 /* * 5 * HolaApp/HolaHelper.java 6 * Generated by the IDL-to-Java compiler (portable), 7 * versión \"3.1\" fran Hola.idl 8 */ 9 10 abstract public class HolaHelper 11 { 12 private static String _ i d = \"iDLHolaApp/Holal. 0 \" ; 13 14 public static void insert 15 (org.omg.CORBA.Any a, HolaApp.Hola that) 16 { 17 org.omg.CORBA.portable.OutputStream out = 18 a.create_output_stream (); 19 a.type (type ()); 20 write (out, that); 21 a.read_value (out.create_input_stream (), type ()); ( continúa) www.FreeLibros.org 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 6 6 67 68 69 CORBA - Common Object Request Architecture 3 0 5 > / / e n d i n s e r t p u b l i c s t a t i c H o la A p p .H o la e x t r a c t (org.om g.C O R B A .A ny a ) {r e t u m r e a d ( a . c r e a t e _ i n p u t _ s t r e a m ( ) ) ; } / / e n d e x t r a c t p r i v a t e s t a t i c org.om g.C O R B A .T ypeC ode ty p e C o d e = n u i l ; s y n c h r o n i z e d p u b l i c s t a t i c org.om g.C O R B A .T ypeC ode t y p e ( {i f ( ty p e C o d e == n u i l ) { ty p e C o d e = o r g . omg. CORBA. ORB. i n i t ( ) . c r e a t e _ i n t e r f a c e _ t c (H o la A p p . H o l a H e l p e r . i d ( ) , \" H o la \" ) ; } r e t u m ty p e C o d e ; } / / e n d t y p e p u b l i c s t a t i c S t r i n g i d ( ) {r e t u r n _ i d ; } / / e n d i d p u b l i c s t a t i c H o la A p p .H o la r e a d ( o r g .o m g . CORBA. p o r t a b l e . I n p u t S tr e a m i s t r e a m ) {r e t u m n a r r c w ( i s t r e a m . r e a d _ O b j e c t ( _ H o la S t u b . c í a s s ) ) ; > / / e n d r e a d p u b l i c s t a t i c v o i d w r i t e ( o r g . om g. CORBA. p o r t a b l e . O u tp u tS t r e a m o s t r e a m , H o la A p p .H o la v a l u é ) {o s t r e a m . w r i t e _ 0 b j e c t ( ( o r g . omg. CORBA. Ob j e c t ) v a l u é ) ; } / / e n d w r i t e p u b l i c s t a t i c H o la A p p .H o la n a r r o w (o r g .a n g .C O R B A .O b je c t o b j ) {i f ( o b j == n u i l ) r e t u r n n u i l ; e l s e i f ( o b j i n s t a n c e o f H o la A p p .H o la ) r e t u r n (H o la A p p . H o l a ) o b j ; e l s e i f ( ! o b j . _ i s _ a ( i d ( ) ) ) t h r o w new o r g . a n g . CORBA. BAD_PARAM ( ) ; e l s e { (continúa) www.FreeLibros.org 3 0 6 C om putación distribuida. Fundam entos y aplicaciones En IDL, un parámetro s e puede declarar com o out a e s un parámetro de salida y inout si el parámetro contiene un velor d e entrada y alm acena a la vez un valor d e salida. 70 o r g .o m g .C O R B A .p o r t a b le .D e le g a t e d e l e g a t e = 71 ( ( o r g .o m g .C O R B A .p o r t a b l e .O b j e c t l m p l ) o b j ) . 72 _ g e t _ d e l e g a t e ( ) ; 73 H o laA p p . _ H o la S tu b s t u b = new H o la A p p ._ H o la S tu b ( ) ; 74 s t u b . _ s e t _ d e l e g a t e ( d e l e g a t e ) ; 75 r e t u r n s t u b ; 76 } / / e n d e l s e 77 } / / e n d n a r r o w 78 79 } / / e n d c l a s s HolaHolder.java, la clase conten e do ra La clase Java H olaHolder (Figura 10.11), contiene una referencia al objeto que im­ plementa la interfaz Hola. La clase proyecta los parámetros de tipo o u t o inout del IDL a la sintaxis de Java. F ig u ra 1 0 .1 1 . H olaA pp/H olaH older.java. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 p a c k a g e H o laA p p ; /** * H o la A p p /H o la H o ld e r .j a v a * G e n e r a t e d b y t h e I D L - t o - J a v a c o m p i l e r ( p o r t a b l e ) , v e r s i ó n \" 3 .1 \" * fr o m h e l i o . i d l * S u n d a y , D e c e irb e r 2 9 , 2 0 0 2 3 4 1 5 0 PM PST */ p u b l i c f i n a l c l a s s H o la H o ld e r im p le m e n ts o r g .o m g .C O R B A .p o r ta b le . S tr e a m a b l e { p u b l i c H o la A p p .H o la v a l u é = n u i l ; p u b l i c H o la H o ld e r ( ) p u b l i c H o la H o ld e r (H o la A p p .H o la i n i t i a l V a l u e ) v a l u é = i n i t i a l V a l u e ; p u b l i c v o i d _ r e a d ( o r g .o m g .C O R B A .p o r t a b le .I n p u t S tr e a m i ) v a l u é = H o la A p p .H o l a H e l p e r .r e a d ( i ) ; p u b l i c v o i d _ w r i t e ( o r g .o m g .C O R B A .p o r ta b le .O u tp u tS tr e a m o ) (continúa) www.FreeLibros.org CORBA - C o m m on O b je ct R equest A rchite cture 3 0 7 29 30 31 32 33 34 35 36 37 public org. ang. CORBA. TypeCode _type () {r e t u m HolaApp.HolaHelper.type (); > { > HolaApp.HolaHelper.write (o, valué); 38 } _HolaStub.java, el fich e ro de re sgu a rd o [stub) La clase Java HolaStub (Figura 10.12), es el fichero de resguardo o stub, el proxy de cliente, que interactúa con el objeto cliente. Extiende org.omg.CORBA.portable.Ob- jectlm pl e implementa la interfaz Helio.java. 1 p a c k a g e H o la A p p ; 2 3 4 / * * 5 * H o la A p p /_ H o la S tu b . j a v a 6 * G e n e r a t e d b y t h e I D L - t o - J a v a c o m p i l e r ( p o r t a b l e ) , 7 * v e r s i ó n 113 . 1 \" fro m H o l a . i d l 8 */ 9 10 p u b l i c c l a s s _ H o la S tu b e x t e n d s 11 o r g . a n g . CORBA. p o r t a b l e . O b j e c t l m p l 12 im p le m e n ts H o la A p p . H o la F ig u ra 1 0 .1 2 . H olaA pp/_H olaStub.java. 13 { 14 15 16 17 18 19 2 0 21 22 23 24 25 26 27 28 29 public String decirHola () {org.omg.CORBA.portable.InputStream $in = nuil; t r y { org.omg.CORBA.portable.OutputStream $out = } catch (org.cmg.CORBA.portable.ApplicationException $ex) { $in = $ex.getlnputstream (); String _id = $ex.getld (); throw new org. ang. CORBA. MARSHAL (_id); } catch (org.ang.CORBA.portable.RemarshalException $rm) { return decirHola (); $in = _invoke ($out); String $result = $in.read_string (); return $result; request (\"decirHola\", true); (continúa) www.FreeLibros.org 3 0 8 C om putación distribuida. Fundam entos y aplicaciones 30 > f i n a l l y { 31 _ r e l e a s e R e p l y ( $ i n ) ; 32 } 33 > / / d e c i r H o l a 34 35 p u b l i c v o i d a p a g a r ( ) 36 { 37 o r g .o m g .C O R B A .p o r t a b le .I n p u t S tr e a m $ i n = n u i l ; 38 t r y { 39 o r g . om g. CORBA. p o r t a b l e . C X itp u tS tre a m $ o u t = 40 _ r e q u e s t ( \" a p a g a r \" , f a l s e ) ; 41 $ i n = _ i n v o k e ( $ o u t ) ; 42 } c a t c h ( o r g .o m g .C O R B A .p o r ta b le .A p p li c a ti o n E x c e p ti o n $ e x ) { 43 $ i n = $ e x . g e t I n p u t S t r e a m ( ) ; 44 S t r i n g _ i d = $ e x . g e t l d ( ) ; 45 th r o w new org.ang.CORBA.MARSHAL ( _ i d ) ; 46 } c a t c h ( o r g .o m g .C O R B A .p o r ta b le .R e m a r s h a lE x c e p tio n $ rm ) { 47 a p a g a r ( ) ; 48 } f i n a l l y { 49 _ r e l e a s e R e p l y ( $ i n ) ; 50 } 51 } / / a p a g a r 52 53 / / T y p e - s p e c i f i c CORBAObject o p e r a t i o n s 54 p r i v a t e s t a t i c S t r i n g [ ] i d s = { 55 \" ID L H o la A p p /H o la 1 . 0 \" } ; 56 57 p u b l i c S t r i n g [ ] _ i d s ( ) 58 { 59 r e t u r n ( S t r i n g [ ] ) i d s . c l o n e ( ) ? 60 } 61 62 p r i v a t e v o i d r e a d O b j e c t ( j a v a . i o . O b j e c t l n p u t S t r e a m s ) 63 th r o w s j a v a . i o . I O E x c e p t i o n 64 { 65 S t r i n g s t r = s . read U T F ( ) ; 66 S t r i n g [ ] a r g s = n u i l ; 67 j a v a . ú t i l . P r o p e r t i e s p r o p s = n u i l ; 68 o rg .o m g .C O R B A .O b je c t o b j = 69 o r g . omg.CORBA.ORB. i n i t ( a r g s , p r o p s ) . 70 s t r i n g _ t o _ o b j e c t ( s t r ) ; 71 o r g .o m g .C O R B A .p o r t a b le .D e le g a t e d e l e g a t e = 72 ( ( o r g . om g. CORBA. p o r t a b l e . O b j e c t l m p l ) o b j ) . 73 _ g e t _ d e l e g a t e ( ) ; 74 _ s e t _ d e l e g a t e ( d e l e g a t e ) ; 75 > 76 77 p r i v a t e v o i d w r i t e O b j e c t ( j a v a . i o . O b j e c t O u t p u t S t r e a m s ) ( continúa) www.FreeLibros.org CORBA - Common Object Request Architecture 3 0 9 78 th r o w s j a v a . i o . I O E x c e p t i o n 79 { 80 S t r i n g [ ] a r g s = n u i l ; 81 j a v a . u t i l . P r o p e r t i e s p r o p s = n u i l ; 82 S t r i n g s t r = o rg .o m g .C O R B A .O R B .in it 83 ( a r g s , p r o p s ) . o b j e c t _ t o _ s t r i n g ( t h i s ) ; 84 s . w r i t e ü T F ( s t r ) ; 85 } 86 } / / c l a s s _ H o la S tu b HolaPOAjava, el skeleton del s e rvid o r y el a d a p ta d o r de o b je to s P O A La clase Java HolaPOA (Figura 10.13), es la combinación del skeleton (el proxy aso­ ciado al servidor) y el adaptador de objetos POA (Portable Object Adapter). Extiende la clase org.omg. PosrtableServer Servant, e implementa las interfaces lnvokeHandler y HolaOperations. F ig u ra 1 0 .1 3 . H olaA pp/H olaP O A .java. 1 p a c k a g e H o la A p p ; 2 3 4 / * * 5 * H olaA pp/H olaPO A . ja v a 6 * G e n e r a te d b y t h e I D L - to - J a v a c o m p ile r ( p o r t a b l e ) , 7 * v e r s i ó n \" 3 .1 \" from H o l a . i d l 8 */ 9 10 p u b l i c a b s t r a c t c l a s s HolaPOA e x te n d s 11 o r g . a n g . P o r t a b l e S e r v e r . S e r v a n t 12 im p le m e n ts H olaA pp. H o la O p e r a tio n s , 13 o r g . a n g . CORBA. p o r t a b l e . ln v o k e H a n d le r 14 { 15 16 / / C o n s t r u c t o r s 17 18 p r i v a t e s t a t i c j a v a . u t i l . H a s h t a b l e _ m e th o d s = 19 new j a v a . u t i l . H a s h t a b l e ( ) ; 20 s t a t i c 21 { 22 _ m e th o d s . p u t (\" d e c ir H o la \" , new j a v a . l a n g . I n t e g e r (0)); 23 _ m e th o d s .p u t ( \" a p a g a r \" , new j a v a . l a n g . I n t e g e r (1 )); 24 } 25 26 p u b l i c o rg .o m g .C O R B A .p o rta b le .O u tp u tS tre a m _ in v o k e 27 ( S t r i n g $ m e th o d , o rg .o m g .C O R B A .p o rta b le .In p u tS tre a m i n , 28 o rg .o m g .C O R B A .p o rta b le .R e s p o n se H a n d le r $ r h ) 29 { (continúa) www.FreeLibros.org 3 1 0 Computación distribuida. Fundamentos y aplicaciones 30 o r g .o m g .C O R B A .p o r ta b le .O u tp u tS tr e a m o u t = n u i l ; 31 j a v a . l a n g . I n t e g e r ra e th o d = 32 ( j a v a . l a n g . I n t e g e r )_ m e t h o d s . g e t ( $ m e th o d ) ; 33 i f ( m e th o d == n u i l ) 34 th r o w new o r g . o n g . CORBA. BAD_OPERATION 35 ( 0 , o r g .o m g . CORBA. C o m p l e t i o n S t a t u s . COMPLETED_MAYBE) ; 36 37 s w i t c h ( m e t h o d . i n t V a l u e ( ) ) 38 { 39 c a s e 0 / / H o la A p p /H o la /d e c ir H o la 40 { 41 S t r i n g $ r e s u l t = n u i l ; 42 $ r e s u l t = t h i s . d e c i r H o l a ( ) ; 43 o u t = $ r h . c r e a t e R e p l y ( ) ; 44 o u t . w r i t e _ s t r i n g ( $ r e s u l t ) ; 45 b r e a k ; 46 > 47 48 c a s e 1 / / H o la A p p /H o la /a p a g a r p a c k a g e H o la A p p ; 49 { 50 t h i s . a p a g a r ( ) ; 51 o u t = $ r h . c r e a t e R e p l y ( ) ; 52 b r e a k ; 53 } 54 55 d e f a u l t 56 t h r o w new org.ang.CO RBA .BA D _0PERA TI0N 57 ( 0 , o r g . a n g . CORBA. C a n p l e t i o n S t a t u s . COMPLETED_MAYBE) ; 58 > 59 60 r e t u r n o u t ; 61 } / / _ i n v o k e 62 63 / / T y p e - s p e c i f i c CORBAObject o p e r a t i o n s 64 p r i v a t e s t a t i c S t r i n g [ ) i d s = { 65 \" ID L H o laA p p /H o la 1 .0 \" > ; 66 67 p u b l i c S t r i n g [ ] _ a l l _ i n t e r f a c e s 68 ( o r g . omg. P o r t a b l e S e r v e r . POA p o a , b y t e [ ] o b j e c t l d ) 69 { 70 r e t u r n ( S t r i n g [ ] ) i d s . c l o n e ( ) ; 71 > 72 73 p u b l i c H o la _ t h i s ( ) 74 { 75 r e t u r n H o l a H e l p e r .n a r r o w ( 76 s u p e r . _ t h i s _ o b j e c t ( ) ) ; 77 > (continúa) www.FreeLibros.org CORBA - Common Object Request Architecture 3 1 1 78 79 80 81 82 83 p u b l i c H o la _ th is(o rg .o m g .C O R B A .O R B o r b ) {r e t u m H o l a H e l p e r . n a r r o w ( 84 85 > / / c l a s s HolaPOA La aplicación Aparte del fichero IDL (Hola.idí), los ficheros vistos hasta el momento, todos ellos se generan automáticamente cuando se compila el fichero IDL con el compilador idlj y no se necesitan modificar. A continuación se va a ver los ficheros fuente de la apli­ cación que sí debe desarrollar el programador. C la se s en el servidor En el lado del servidor, se necesitan dos clases: el servant y el servidor. El servant, H olalmpl, es la implementación de la interfaz IDL Hola', cada objeto Hola es una ins­ tancia de esta clase. E l serva a t (N. del T.: sirviente en inglés), como se encuentra codificado en la Fi­ gura 10.14, es una subclase de HolaPOA. El servant contiene la definición de cada método declarado en la interfaz IDL: en este ejemplo, los métodos decirHola y apa­ gar. Obsérvese que la sintaxis para escribir estos métodos es la misma que la de los métodos habituales en Java: la lógica para interactuar con el ORB, y para el em pa­ quetamiento (marshalling) d e datos se proporciona por medio del skeleton, cuyo có­ digo se incluye en HolaPOA.java (Figura 10.13). 1 / / E l s e r v a n t - l a i m p le m e n ta c i ó n d e l o b j e t o - p a r a e l e je m p lo 2 / / H o la . O b s é r v e s e q u e s e t r a t a d e u n a s u b c l a s e d e H olaPO A , c u y o 3 / / c ó d i g o f u e n t e s e g e n e r a d e l a c o m p i l a c i ó n d e H o l a . i d í u s a n d o 4 / / e l c o m p i la d o r i d l j . 6 i m p o r t H o la A p p .* ; 7 i m p o r t o rg .o m g .C o s N a m in g .* ; 8 i m p o r t o r g .o m g .C o s N a m in g .N a m in g C o n te x tP a c k a g e .* ; 9 i m p o r t o rg .o m g .C O R B A .* ; 10 i m p o r t o r g . omg. P o r t a b l e S e r v e r . * ; 11 i m p o r t o r g .o m g .P o r t a b l e S e r v e r .P O A ; F ig u ra 10.14. H olaA pp/H olalm pl.java. 5 12 13 i m p o r t j a v a . ú t i l . P r o p e r t i e s ; 14 15 c l a s s H o la lm p l e x t e n d s H olaPO A { 16 p r i v a t e ORB o r b ;16 (continúa) www.FreeLibros.org 3 1 2 Computación distribuida. Fundamentos y aplicaciones 17 18 p u b l i c v o i d setO R B ( ORB o r b _ v a l ) { 19 o r b = o r b _ v a l ; 20 > 21 22 / / im p le m e n ta c i ó n d e l m é to d o d e c i r H o l a ( ) 23 p u b l i c S t r i n g d e c i r H o l a ( ) { 24 r e t u r n \" \\n H o la m undo ! ! \\ n \" ; 25 } 26 27 / / i m p le m e n ta c i ó n d e l m é to d o a p a g a r ( ) 28 p u b l i c v o i d a p a g a r ( ) { 29 o r b . a p a g a r ( f a l s e ) ; 30 > 31 } / / f i n c l a s e E l servidor. La Figura 10.15 presenta el código d e ejem plo para un servidor de objeto. El proceso servidor es el responsable de crear e inicializar el ORB (en este caso, el ORB de Java IDL), activar el gestor del adaptador de objetos POA (Porta­ ble Object Adapter Manager), crear una instancia de la implementación del objeto (un servant), y de registrar el objeto en el ORB. Obsérvese que en la implementación de Java, el Servicio d e Nombrado se proporciona por el propio ORB. En el código, el Servicio de Nombrado Interoperable se utiliza para registrar el objeto con el nombre \"Hola\" (líneas 25-37). Después de anunciar que el servidor de objetos está listo, el servidor se queda a la espera de peticiones de los clientes redirigidas por el ORB (lí­ neas 39-43). F ig u ra 1 0 .1 5 . HolaApp/ServidorHola.java. 1 / / U n s e r v i d o r p a r a e l o b j e t o H o la 2 3 p u b l i c c l a s s S e r v i d o r H o l a { 4 5 p u b l i c s t a t i c v o i d m a in ( S t r i n g a r g s [ ] ) { 6 t r y { 7 / / c r e a e i n i c i a l i z a e l ORB 8 ORB o r b = O R B . i n i t ( a r g s , n u i l ) ; 9 10 / / o b t i e n e l a r e f e r e n c i a a l rootP O A y a c t i v a a l POAManager 11 POA r o o t p o a = 12 ( P O A ) o r b . r e s o l v e _ i n i t i a l _ r e f e r e n c e s ( \" R ootP O A \") ; 13 r o o t p o a . the_ P Q A M an ag er ( ) . a c t i v a t e ( ) ; 14 15 / / c r e a u n s e r v a n t y l o r e g i s t r a e n e l ORB 16 H o la lm p l h o l a l m p l = new H o l a l m p l ( ) ; 17 h o l a l m p l . setO R B ( o r b ) ; 18 19 / / o b t i e n e l a r e f e r e n c i a d e o b j e t o d e l s e r v a n t 20 o rg .o m g .C O R B A .O b je c t r e f = ( continúa) www.FreeLibros.org CORBA - C o m m on Object Request Architecture 3 1 3 21 r o o t p o a . s e r v a n t _ t o _ r e f e r e n c e ( h o l a l m p l ) ; 22 / / y l a c o n v i e r t e a u n a r e f e r e n c i a CORBA 23 H o la h r e f = H o la H e lp e r . n a r r o w ( r e f ) ; 24 25 / / o b t i e n e e l c o n t e x t o d e n o m b ra d o r a í z 26 / / N a m e S e rv ic e i n v o c a a l s e r v i c i o d e n o n b r e s t e m p o r a l 27 o rg .o m g .C O R B A .O b je c t o b j R e f = 28 o r b . r e s o l v e _ i n i t i a l _ r e f e r e n c e s ( \" N a m e S e r v ic e \" ) ; 29 / / U sa N a m in g C o n te x tE x t, q u e e s p a r t e d e l a e s p e c i f i c a c i ó n 30 / / S e r v i c i o d e N om brado I n t e r o p e r a b l e ( I N S ) . 31 N a m in g C o n te x tE x t n c R e f = 32 N a m in g C o n te x tE x tH e lp e r . n a r r o w ( o b j R e f ) ; 33 34 / / e n l z a l a r e f e r e n c i a d e l o b j e t o c o n e l n o m b re 35 S t r i n g ñam e = \" H o l a \" ; 36 N am eC an p o n en t p a t h [ ] = n c R e f .to _ n a m e ( ñam e ) ; 37 n c R e f . r e b i n d ( p a t h , h r e f ) ; 38 39 S y s te m , o u t . p r i n t l n 40 ( \" S e r v i d o r H o l a l i s t o y e s p e r a n d o 41 42 / / e s p e r a l a s i n v o c a c i o n e s d e l o s c l i e n t e s 43 o r b . r u n ( ) ; 44 > 45 46 c a t c h ( E x c e p t i o n e ) { 47 S y s te m , e r r . p r i n t l n ( \" ERROR \" + e ) ; 48 e . p r i n t S t a c k T r a c e ( S y s te m . o u t ) ; 49 } 50 51 S y s te m . o u t . p r i n t l n ( \" S e r v i d o r H o l a S a l i e n d o . . . \" ) ? 52 53 } / / f i n m a in 54 } / / f i n c l a s e La aplicación cliente del objeto La Figura 10.16 muestra un ejemplo de cliente para el objeto Hola. El ejem plo se en­ cuentra escrito como una aplicación Java, aunque el programa cliente tam bién puede tratarse de un applet o un servlet. El código cliente se debe encargar de crear e inicializar el ORB (línea 14), bus­ car e l objeto usando e l Servicio de Nombrado Interoperable (líneas 16-22), invocar el método narrow del objeto Helper para convertir la referencia del objeto a una refe­ rencia de una implementación del objeto Hola (líneas 24-27), e invocar los métodos remotos usando dicha referencia (líneas29-33). El método decirHola del objeto se in­ voca para recibir una cadena de caracteres como valor d e retomo, y el método apa­ gar para desactivar el servicio. www.FreeLibros.org 3 1 4 Computación distribuida. Fundamentos y aplicaciones F ig u ra 1 0 .1 6 . H o la A p p /C lie n te H o la .ja va . 1 / / U n e je m p lo d e a p l i c a c i ó n c l i e n t e d e l o b j e t o 2 i m p o r t H o la A p p .* ; 3 i n p o r t o rg .o m g .C o s N a m in g .* ; 4 i m p o r t o r g .o m g .C o s N a m in g .N a m in g C o n te x tP a c k a g e .* ; 5 i m p o r t o rg .o m g .C O R B A .* ; 6 7 p u b l i c c l a s s C l i e n t e H o l a 8 { 9 s t a t i c H o la h o l a l m p l ; 10 11 p u b l i c s t a t i c v o i d m a i n ( S t r i n g a r g s [ ] ) { 12 t r y { 13 / / c r e a e i n i c i a l i z a e l ORB 14 ORB o r b = ORB. i n i t ( a r g s , n u i l ) ; 15 16 / / o b t i e n e e l c o n t e x t o d e n o n to ra d o r a í z 17 o rg .o m g .C O R B A .O b je c t o b j R e f = 18 o r b . r e s o l v e _ i n i t i a l _ r e f e r e n c e s ( \" N a m e S e r v ic e \" ) ; 19 / / U s a N a m in g C o n te x tE x t e n l u g a r d e N a m in g C o n te x t 20 / / p a r t e d e l S e r v i c i o d e N om brado I n t e r o p e r a b l e . 21 N a m in g C o n te x tE x t n c R e f = 22 N a m in g C o n te x tE x tH e lp e r . n a r r o w ( o b j R e f ) ; 23 24 / / r e s u e l v e l a R e f e r e n c i a a l o b j e t o e n e l S e r v . d e Nombrado 25 S t r i n g n o m b re = \" H o l a \" ; 26 h o l a l m p l = 27 H o la H e lp e r . n a r r o w ( n c R e f . r e s o l v e _ s t r ( n o m b r e ) ) ; 28 29 S y s t e m . o u t . p r i n t l n 30 ( \" O b te n id o u n m a n e j a d o r p a r a e l o b j e t o s e r v i d o r \" 31 + h o l a l m p l ) ; 32 S y s te m . o u t . p r i n t l n (h o l a l m p l . d e c i r H o l a ( ) ) ; 33 h o l a l m p l . a p a g a r ( ) ; 34 35 } 36 c a t c h ( E x c e p t i o n e ) { 37 S y s te m . o u t . p r i n t l n (\"ERROR \" + e ) ; 38 e . p r i n t S t a c k T r a c e ( S y s t e m . o u t ) ; 39 } 40 } / / f i n m a in 41 42 > / / f i n c l a s e En el resto del capítulo se van a presentar los algoritmos para desarrollar aplica­ ciones usando Java IDL. www.FreeLibros.org CORBA - Common Object Request Architecture 3 1 5 Com pilación y ejecución de una aplicación Java IDL Para los ejercicios finales del capítulo, será necesaria la compilación y ejecución de aplicaciones Java IDL. A continuación se muestra una descripción d e dicho procedi­ miento. Parte servidora 1. Colóquese en el directorio que contiene el fichero IDL Hola.idl. 2. Ejecute el compilador IDL-a-Java, idlj, con el fichero IDL. Este paso asume que usted ha incluido e l directorio java/bin en su path. i d l j —f a l l H o l a . i d l Debe utilizarse la opción -fall con el compilador idlj para generar todo el código de soporte cliente y servidor. Los ficheros que se generan proporcio­ nan las funcionalidades estándares y no necesitan ser modificados. Con la opción -fall los ficheros que el compilador genera con el fichero Hola.idl son: • HolaPOA.java • _HolaStub.java • Hola.java • HolaHelper.java • HolaHolder.java • HolaOperations.java Estos ficheros se crean automáticamente en un subdirectorio, que en el caso de este ejemplo se denomina HolaApp. 3. Compile los ficheros .java del directorio HolaApp, incluyendo los stubs y los skeletons. j a v a c * . j a v a H o l a A p p / * .j a v a 4. Arranque e l Demonio del ORB Java, orbd, que incluye el servidor del Servi­ cio de Nombrado. Para arrancar orbd en un sistema UNIX, introduzca sobre la línea de co­ mando: o r b d - O R B I n i t i a l P o r t e n u m e ro d e p u e rto > & En un sistema Windows, introduzca sobre la línea de comando: s t a r t o r b d - O R B I n i t i a l P o r t e n u m e ro d e p u e r t o s Nótese que enumero de p u e r to es un puerto en el cual usted desea que el servidor de nombre se ejecute; debe ser un número de puerto por encima de 1024, por ejemplo 1234. 5. Arranque e l servidor Hola. Para arrancar el servidor Hola en un sistema UNIX, introduzca (en una sola línea) lo siguiente: j a v a S e r v i d o r H o l a - O R B I n i t i a l P o r t 1234 - O R B I n i t i a l H o s t l o c a l h o s t En un sistema Windows, introduzca (en una sola línea) lo siguiente: s t a r t j a v a S e r v id o r H o la - O R B I n iti a lP o r t 1234 - O R B I n itia lH o s t l o c a l h o s t En sistem as Unix, un «demonio» e s una tarea que s e ejecuta en background en respuesta a eventos. www.FreeLibros.org 3 1 6 C om putación distribuida. Fundam entos y aplicaciones La opción -O RBInitialH ost especifica el ordenador en el cual el Servidor de Nombrado está. La opción -O RBInitialH ost indica el puerto en el cual el Ser­ vidor d e Nombrado (orbd) se encuentra, tal y como se describió en e l paso 4. Parte cliente 1. Obtenga y compile e l fichero Hola.idl de la máquina servidora: i d l j —f a l l H o l a . i d l Copie el directorio que contiene Hola.idl (incluyendo el subdirectorio genera­ do por idlj) a la máquina cliente. 2. En el directorio HolaApp de la máquina cliente, cree el fichero ClienteHola.java. Compile los ficheros .java, incluyendo stubs y skeletons (que están en el di­ rectorio HolaApp): j a v a c * . j a v a H o l a A p p / * .j a v a 3. En la máquina cliente, ejecute la aplicación cliente Hola d e la siguiente for­ ma (todo en una línea): j a v a C lie n te H o la - O R B I n itia lH o s t < o r d e n a d o r d e l s e r v i d o r d e nc*ibrado> - O R B I n i t i a l P o r t < p u e r t o d e l s e r v i d o r d e n o m b r a d o El <ordenador d e l s e r v id o r de nom brado es la máquina donde está eje­ cutando Servidor de Nombrado. En este caso, puede ser el nombre de dom i­ nio o la dirección IP de la máquina servidora. C allba ck de cliente Recuerde que RMI proporciona la posibilidad de realizar callbacks hacia el cliente, que permite que un cliente se registre en un servidor de objetos de forma que el ser­ vidor pueda iniciar una llamada al cliente, posteriormente, debido al suceso de algún evento. L a m ism a p o sib ilid ad ex iste e n e l caso de Jav a IDL. L a referencia [java.sun.com/products, 18] proporciona un ejemplo d e código de dicha aplicación. 1 0 .1 0 . COM PARATIVA Una cuestión clave en este libro es que en informática distribuida (y en informática en general) hay típicamente muchas formas de acometer la misma tarea. Este capítu­ lo presenta un ejemplo. Como se ha podido ver, y como experimentará cuando abor­ de algunos de los ejercicios del final de este capítulo, la misma aplicación (por ejem ­ plo, un juego en red) se puede implementar usando las herramientas ofrecidas por Java RMI o por CORBA, tales como Java IDL. Se espera que en este punto, habiendo es­ tudiado las dos herramientas, será capaz de hacer una comparativa inteligente de las dos y realizar las comparaciones, tal y como se solicita en algunos de los ejercicios. Este capítulo le ha presentado la arquitectura CORBA (Common Object Request Broker Architecture) así como una herramienta específica basada en esta arquitectura: Java EDL. www.FreeLibros.org CORBA - Common Object Request Architecture 3 1 7 Los tem as clave de CORBA que se han presentado son: • La arquitectura básica de CORBA y su énfasis en la interoperabilidad de obje­ tos y la independencia de plataforma. • El ORB (Object Request Broker) y sus funcionalidades. • El protocolo IOP (Inter-ORB Protocol) y su significado. • Referencia a objetos CORBA y el protocolo IOR (Interoperable Object Refe- rence). • El Servicio de Nombrado de CORBA y el Servicio de Nombrado Interoperable (INS). • Los servicios de objetos CORBA estándar y cómo se proporcionan. • Adaptadores de objetos, POA (Portable Object Adapter), y su significado. Los tem as clave presentados junto a Java IDL son: • Los paquetes Java disponibles que contienen interfaces y clases para dar soporte CORBA. • Las herramientas para desarrollar una aplicación CORBA, incluido idlj (el com­ pilador IDL) y orbd (el ORB y servidor de nombres). • Se ha presentado una aplicación de ejem plo llamada Hola para ilustrar la sin­ taxis básica de Java EDL. • Se han presentado los pasos para compilar y ejecutar una aplicación. Las herramientas para CORBA y Java RMI son tecnologías compatibles y alternati­ vas que proporcionan objetos distribuidos. Una aplicación se puede implementar usan­ do cualquiera de las dos tecnologías, pero existen ventajas e inconvenientes en cada una de ellas. E J E R C IC IO S 1. En el contexto de CORBA, ¿qué significan los siguientes acrónimos? Para cada acrónimo, indique el nombre completo y una breve descripción: CORBA, ORB, GIOP, IIOP, IOR, INS, POA. 2. Describa, por medio de un diagrama de bloques una descripción que ilustre la arquitectura CORBA. El diagrama debe incluir los siguientes componentes: un objeto distribuido, un servidor de objetos, un cliente de objetos, el skeleton, el stub, el ORB y e l adaptador de objetos. Describa, por medio de otro diagrama de bloques que ilustre la arquitectu­ ra Java RMI, incluyendo los componentes equivalentes: un objeto distribuido, un servidor de objetos, un cliente de objetos, el skeleton y e l stub. Basándose en sus diagramas, escriba un párrafo que describa las diferen­ cias principales entre las dos arquitecturas. Trate d e explicar dichas dife­ rencias. 3. Comparada con Java RMI, ¿cuáles son los principales puntos fuertes de una herramienta CORBA, si hay alguno? ¿Cuáles son los puntos débiles, si hay al­ guno? 4. Siga e l algoritmo presentado en el capítulo para compilar y ejecutar e l ejem ­ plo Hola en una máquina. Escriba un informe describiendo su experiencia, in­ cluyendo cualquier dificultad que haya encontrado y cómo la h a resuelto. www.FreeLibros.org 318 Computación distribuida. Fundamentos y aplicaciones 5. Siga el algoritmo presentado en e l capítulo para compilar y ejecutar el ejem ­ plo Hola en dos máquinas. Escriba un informe describiendo su experiencia, incluyendo cualquier dificultad que haya encontrado y cómo la ha resuelto. (Puede encontrar la referencia (java.sun.com /j2se/l.4, 13] útil.) 6. Use Java IDL para construir un servidor y un cliente que implemente el pro­ tocolo Daytime. 7. Usando Java IDL, escriba una aplicación para un prototipo de un sistema de consultas de opinión. Asúmase que sólo se va a encuestar un tema. Los en­ trevistados pueden responder sí, no o ns/nc. Escriba una aplicación servidora, que acepte los votos, guarde la cuenta (en memoria), y proporcione las cuen­ tas actuales a aquellos que estén interesados. a Escriba el fichero de interfaz primero. Debería proporcionar métodos remo­ tos para aceptar una respuesta a la encuesta, proporcionando los recuentos ac­ tuales (ejemplo: 10 sí, 2 no, 5 ns/nc) sólo cuando el cliente lo requiera. b. Diseñe e implemente un servidor que (i) exporte los métodos remotos, y (ii) mantenga información d e estado (las cuentas). c. Diseñe e implemente una aplicación cliente que proporcione una interfaz de usuario para aceptar una respuesta y/o una petición, y para interactuar con e l servidor apropiadamente a través de la invocación de métodos remotos. d. Pruebe la aplicación ejecutando dos o más clientes en máquinas diferentes (preferiblemente en plataformas diferentes). e. Entregue los listados de los ficheros, que deben incluir los ficheros fuente (el fichero de interfaz, los ficheros del servidor y los ficheros del cliente), y un fichero LEEME que explique los contenidos y las interrelaciones de los ficheros fuente, así como el procedimiento para ejecutar el trabajo. 8. Cree una aplicación Java IDL para gestionar unas elecciones. El servidor ex­ porta dos métodos: • emitirVoto, que acepta como parámetro una cadena de caracteres que con­ tiene un nombre de candidato (Gore o Bush), y no devuelve nada, y • obtenerResultado, que devuelve, en un vector de enteros, el recuento actual para cada candidato. Pruebe la aplicación ejecutando todos los procesos en una máquina. A conti­ nuación pruebe la aplicación ejecutando el proceso cliente y servidor en má­ quinas separadas. Entregue el código fuente de la interfaz remota, el servidor y el cliente. 9. Construya un juego distribuido para dos jugadores de las tres en raya usando (a) Java RMI con callbacks de cliente y (b) Java EDL con callbacks de cliente. Diseñe sus aplicaciones de forma que el cliente sea lo más ligero posible; esto es, que los clientes deben almacenar el menor estado y tengan el menor código posible. El servidor mantendrá el estado del juego y sincronizará los tum os de los jugadores. Entregue (a) documentos de diseño, incluyendo un diagrama de clases UML, (b) listado de las fuentes, y (c) un informe comparando ventajas e inconve­ nientes entre las dos tecnologías, en términos de facilidad d e implementación, independencia de lenguaje, independencia de plataforma, y sobrecarga en la ejecución. www.FreeLibros.org CORBA - Common Object Request Architecture 3 1 9 R E FER EN C IA S 1. Welcome To The OMG’s CORBA Website, http:lhvww.corba.org/ 2. C O R B A FA Q, http://www.omg.org/gettingstarted/corbafaq.htm 3. C O R B A for B eginners, http://cgi.omg.org/corba/beginners.htmI 4. Jo n Siegel. C O R B A 3 F undam entáis a n d Program m ing. N ew York, NY: Jo h n W iley, 2000. 5. O M G N a m in g S e rv ic e sp e c ific a tio n , http:llwww.omg.org/technologyldocumentslformall nam ing_service.htm 6. C O R B A N am ing S erv ice Evaluation, S e a n Landis a n d W illiam S hapiro, http://www.cs.umd.edu/ ~billshaplpaperslnaming.doc, 1999. 7. C O R B A a n d Java™ technologies, http://java.sun.com/j2ee/corba/ 8. Irfan P yarali a n d D. C. S c h m id t. “A n OverV iew o f th e C O R B A P ortable O b je ct A d a p ter.” A C M S tandardV iew 6, (M arch 1998). http://citeseernj.nec.com/pyarali98overview.html 9. JavaT M RM I-IIO P Docum entation, http://javasun.com/j2se/I3/docs/guide/rmi-iiop/index.html 10. C etus L inks: 18,452 L inks o n O bjects a n d C om ponents/C O R B A , http://www.cetus-links.org/ oo_corba.html 11. T h e Ja v a T utorial T rail: IDL, http://java.sun.com/docs/books/tutorial/idl/index.html 12. Java™ ID L , http://java.sun.com/products/jdk/idl/ 13. Ja v a IDL: T h e “H elio W orld\" E xam ple o n T w o M achines, http:lljava.sun.com/j2sell.4/docs! guideHdlltutoriaHjidl2machines.html 14. Ja v a IDL S a m p le code, http:lljava.sun.com/j2sell.4ldocslguideHdl/jidlSampleCode.html 15. J a v a ID L : N a m in g S e r v i c e , h ttp ://ja v a .su n .e o m /p ro d u c ts/jd k /l.2 /d o cs/g u id e/id l/ jidlNaming.html 16. N am ing Service, S u n M icroSystem s, http:lljavasun.com/j2sell.4ldocslguide/idlIjidlNaming. html 17. Ja v a IDL T echnology D ocum entation, http://java.sun.eom/j2se/l.4/docs/guide/idl/index.html 18. Ja v a IDL: E xam ple 3, H elio W orld w ith C allb ack O bject, http://java.sun.com/products/jdk/ 1.4/docs/guidelidlljidlExample3.html 19. C O R B A P ro d u ct Profíles, http://www.puder.org/corba/matrix/ 20. Ja v a 2 P latform , S tan d ard E dition (J2SE), http:lljava.sun.com/j2sell.4/ www.FreeLibros.orgwww.FreeLibros.org CAPITULO A p lic a c io n e s d e I n t e r n e t P a r t e 2 En el C apítulo 9 se estudió el HTTP, los CGI y el m antenim iento de la inform ación de estado para aplicaciones de Internet. D ebido a la popularidad de las aplicaciones w eb, han surgido una gran cantidad de protocolos y conjuntos de herramientas. En este capítulo se explorarán algunos de los protocolos y mecanism os más recientes, incluyendo los applets, servlets y SOAP (Simple O bject Access P rotocoí, Protocolo S im ple de Acceso a Objetos). 1 1 .1 . A P P LE TS Explicado brevemente, los applets [java.sun.com/docs, 1; java.sun.com /applets, 2; javaboutique.intem et.com , 3; java.sun.com /sfaq, 17] son clases Java solicitadas por el navegador a un servidor w eb utilizando e l protocolo HTTP y ejecutadas a conti­ nuación por la máquina virtual de Java en e l entorno del navegador (véase la F i­ gura 11.1). F ig u ra 11 .1 . Un a p p le t d e J a v a se s o lic ita u tiliz a n d o HTTP. Un applet se especifica en una página HTML usando la etiqueta APPLET, tal y como se muestra en la Figura 11.2. www.FreeLibros.org 3 2 2 Computación distribuida. Fundamentos y aplicaciones F ig u ra 11.2. Una página web que especifica un applet. <H tm l> <H ead> < T it le > E j e m p l o d e a p p l e t < / T i t l e > < /H ead > <Body> E s to e s l o q u e m u e s t r a e l a p p l e t d e s p u é s d e s u e j e c u c i ó n : < b r > < A p p le t C o d e = \" H o la M a n d o .c la s s \" w id th = 2 0 0 H e ig h t= 1 0 0 > < /A p p le t> Un visor de applets es un programa que se proporciona en el Java SDK para ejecutar un applet sin necesidad de utilizar un navegador. Cuando el navegador analiza la etiqueta APPLET, se lanza una petición contra el servidor HTTP especificado en la etiqueta applet o, si no hay un servidor especifica­ do, contra el servidor por defecto (el servidor del cual se ha descargado la página web). Un ejemplo de una petición HTTP sería el siguiente: GET / a p p l e t s / H o l a M u n d o . c l a s s H T T P /1 .1 c l í n e a e n b la n c o > En la petición, HolaMundo.class es el nombre del fichero en donde está definida la clase del applet. El servidor HTTP localiza el fichero y envía su contenido al clien­ te en el cuerpo de la respuesta HTTP. Una vez recibido el fichero de la clase del applet, el navegador lo ejecuta en su Máquina Virtual de Java (JVM) y muestra su resultado. L a Figura 11.3 muestra una sesión w eb durante la cual un cliente solicita una pá­ gina web que contiene una etiqueta APPLET. A continuación la clase del applet se transmite desde el servidor al cliente (navegador), en cuya máquina se ejecuta la cla­ se applet y se muestra el resultado. Un applet es un tipo especial de programa Java que se carga en el navegador o en un visor de applets. Cada applet hereda d e la clase Java Applet, la cual es una sub­ clase de la clase Java awt.Container, que d a soporte al pintado de gráficos. De esta forma, un applet puede ser fácilmente codificado para pintar gráficos. La Figura 11.4 M áquina servidora M áquina cliente servidor w e b myPagina Web. h tm l <applet code= \"HolaMundo.class\" </a pp let> HolaMundo.class petición de miPaginaWeb.html myPag ina Web. h tm l petición de H o laM u nd o.class HolaMundo.class Navegador HolaMundo.class F ig u ra 11.3. Una sesión web con un applet. www.FreeLibros.org ilustra el código fuente d e un applet que dibuja la cadena de texto «Hola mundo» cuando se ejecuta. F ig u ra 1 1 .4 . H elloW orld.java, th e s o u rc e c o d e f o r an a p p le t. im p o r t j a v a . a p p l e t . A p p l e t ; im p o r t j a v a . a w t . G r a p h i c s ; p u b l i c c l a s s H olaM undo e x t e n d s A p p l e t { p u b l i c v o i d p i n t a r ( G r a p h i c s g ) { g . p i n t a r C a d e n a ( \" H o la M undo! \" , 5 0 , 2 5 ) ; > / / f i n p i n t a r } / / f i n c l a s e Aplicaciones d e Internet - Parte 2 En la práctica, el código de un applet puede ser mucho más complejo, teniendo gráficos elaborados y manejo de eventos. Es mejor probar los applets con un visor de applets antes de intentar ejecutarlos utilizando un navegador. Cuando se prueba un applet en un navegador, puede ser de ayuda mirar los mensajes que se muestran en la pantalla de la consola de Java. El In­ ternet Explorer, por ejemplo, permite hacer esto si se selecciona la opción «consola Java activada» en el menú de herramientas de Internet. Debido a que los applets se descargan de una máquina remota y se ejecutan en la máquina local, su ejecución está sometida a restricciones por razones de seguridad. (En el Capítulo 8 se vieron conceptos similares para la descarga del stub RMI.) Una de estas restricciones es que un applet no tiene permitido leer o escribir ficheros al­ macenados en el computador en el que está ejecutando. Otra restricción es que el ap­ plet no tiene permitido la realización de conexiones de red excepto a la máquina de la que proviene (véase la Figura 11.5). Existen otras restricciones (java.sun.com/sfaq, 17] impuestas para limitar e l daño que se puede realizar a la máquina del sistema por un potencial objeto maligno descargado de un fuente de la que no se confía. Los applets son programas interesantes. Sin embargo, en el contexto de la compu­ tación distribuida tienen una importancia limitada; se introducen aquí sobre todo por coherencia. Los lectores interesados pueden consultar otras fuentes (java.sun.com/docs, 1; java.sun.com/applets, 2; javaboutique.intemet.com, 3; java.sun.com/sfaq, 17] para detalles adicionales. Se puede obtener código fuente de applets de ejem plo de nume­ rosas fuentes, tales como (java.sun.com/sfaq, 17]. 1 1 .2 . SER VLETS Los servlets son otro tipo de programa Java. Mientras que los applets se mandan des­ de el servidor al cliente HTTP para ser ejecutados en la máquina cliente, los servlet son extensiones del servidor y son ejecutados en la máquina servidora. En el Capítulo 9 se estudiaron unos programas de extensión del servidor: scripts CGI. Como se recordará, los scripts CGI son programas extemos que extienden las capacidades de un servidor HTTP para dar soporte al procesamiento de formularios web. De forma similar a los scripts CGI, un servlet HTTP (una forma especial de servlet) ejecuta en la máquina ser­ vidora como una acción desencadenada por la petición del cliente. A diferencia de un 3 2 3 www.FreeLibros.org 324 Computación distribuida. Fundamentos y aplicaciones M á q u in a servidora M á q u in a C lien te F ig u ra 11 .5 . Un a p p le t tie n e p ro h ib id o re a liza r c o n e x io n e s d e re d al exterior. script CGI, sin embargo, un servlet puede ser utilizado para extender cualquier servidor que tenga un protocolo del tipo petición-respuesta. Los servlets se utilizan normalmen­ te con servidores HTTP, en cuyo caso se denominan servlets HTTP. El resto de esta sección se centrará en los servlets HTTP, a los que se hará refe- rerencia simplemente como servlets; los lectores deberán tener en cuenta que se está abordando una clase especial d e servlets. Soporte arquitectónico A diferencia de los scripts CGI (que ejecutan en la máquina servidora sin ningún sis­ tem a de soporte arquitectónico adicional) la ejecución de los servlets requiere la exis­ tencia de un módulo conocido como motor de servlets o contenedor de servlets (véase la Figura 11.6). Cada servlet se ejecuta en el contexto proporcionado por el motor de servlets que ejecuta en la máquina servidora. La Figura 11.7 muestra el ciclo de vida de un servlet. El código de un servlet, que es una clase Java, se carga en el motor de servlets. Posteriormente, e l servidor actúa como un intermediario entre el cliente y el servlet: el cliente realiza peticiones al serv­ let a través del servidor, y el servlet m anda la respuesta al cliente a través del servi­ dor. Dependiendo de la implementación del servidor, un servlet puede persistir mien­ tras siga teniendo peticiones, o de forma indefinida hasta que se apague el servidor. La persistencia es otra diferencia entre un servlet y un script CGI: un script CGI se recarga cada vez que un cliente lo solicita, mientras que una sola instancia d e un servlet seguirá ejecutando m ientras tenga peticiones. Debido a esta persistencia, un servlet puede mantener datos de estado de las sesiones de los clientes durante su tiempo de vida. Por ejemplo, se puede utilizar una variable para contar cuántas veces se ha solicitado un servlet desde su carga. www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 2 5 M o to r d e servlets o c o n te n e d o r d e servlets Se n e ce sita un c o n te n e d o r de s e rv le ts o m o to r de s e rv le ts . El m o to r de s e rv le ts p u e d e fo rm a r p a rte d e l s e rv id o r o s e r un m ó d u lo e x te rn o d e l m is m o . F ig u ra 11 .6 . S op orte d e la a rq u ite c tu ra d e un se rvle t. Un servlet es un objeto de la clase javax.Servlet, que es parte d e una biblioteca de una clase d e Java heredada denominada Javax\\ la biblioteca Javax no se incluye como parte del Java Development Kit (JDK) pero se puede descargar por separado (java.sun. com/products/servlet/download. html, 5]. M o to r d e servlets C lie n te El s e rv id o r c a rg a el c ó d ig o fu e n te y lo in ic ia liz a , p o s ib le m e n te c o m o re s u lta d o d e la p e tic ió n d e un c lie n te . M o to r d e servlets C lie n te (c ó d ig o s e rv le t) S e rvid o r ----------- ' C lie n te A tra v é s del s e rv id o r el s e rv le t tr a ta las p e tic io n e s de lo s c lie n te s . M o to r d e servlets (c ó d ig o s e r v le t)-------- S e rvid o r ^ ---------------- El s e rv id o r b o rra el s e rv le t c u a n d o n o tie n e m ás p e tic io n e s de c lie n te s . (A lg u n o s s e rv id o re s re a liza n e ste pa so s ó lo c u a n d o se apagan). F ig u ra 11 .7 . El tie m p o d e v id a d e un se rvle t. Existen varias implementaciones que proporcionan la arquitectura servlet. Las dos siguientes están fácilmente disponibles: www.FreeLibros.org 3 2 6 Computación distribuida. Fundamentos y aplicaciones • El JSW DK (Java Server Web Development Kit) [java.sun.com/products/serv- let/archive.html, 4] es un paquete gratuito proporcionado por Sun Microsystems desde que se introdujo por primera vez la tecnología servlet. JSW DK tiene la intención de ser una implementación de referencia, lo que significa que se pro­ porciona por Sun Microsystems para demostrar la tecnología, pero no tiene la intención de ser utilizada en producción. Su simplicidad hace de este paquete un punto de inicio ideal para estudiantes. Desafortunadamente este paquete sólo está disponible en el sitio w eb de Sun, y no se puede asegurar su disponibili­ dad en el futuro. • Apache Tomcat [jakarta.apache.org, 6] es una implementación gratuita de códi­ go abierto para las tecnologías Java Servlet y Java Server Pages desarrollado dentro del proyecto Yakarta en e l Apache Software Foundation. También está disponible el soporte a servlets en servidores de aplicación comerciales tales como WebLogic, iPlanet y WebSphere. Entre los métodos especificados con cada objeto servlet están: • Init() - invocado por el motor de servlets cuando se inicia un servlet. • Shutdownf) - invocado por el motor de servlets cuando un servlet ya no se ne­ cesita. • Service() - invocado por el motor d e servlets cuando la petición de un cliente se reenvía al servlet. El diagrama de secuencia de la Figura 11.8 muestra la interacción entre el servidor HTTP, el contenedor de servlets, un servlet y los clientes concurrentes que mandan peticiones al servlet a través del servidor. C o n te n e d o r C lie n te 1 C lie n te 2 S e rv id o r s e rv le t S e rvle t c a rg a servlet ------------------- ► in itO p e tic ió n H TTP -------------- ► serviceO -------------------► respuesta HTTP p e tic ió n H\"rTP serviceO ------------------- ► respuesta HTTP te rm in a r ------------------- ► ap a g a r d e stro yO --------------------► F ig u ra 11.8. Interacción entre clientes, servidor, contenedor de servlets y servlets. www.FreeLibros.org Aplicaciones d e Internet - Parte 2 327 La programación de un servlet HTTP [Hunter and Crawford, 19] se simplifica gracias a la abstracción proporcionada por el API servlet, un conjunto de clases e interfaces que contienen los métodos init(), destroyO y service)) que ya se han mencionado. La clase abstracta de Java HTTPServlet, que es una subclase de la interfaz servlet, pro­ porciona abstracción adicional a los servlets HTTP tal y como se ilustra en la Figura 11.9 [jakarta.apache.org, 6]. Como una subclase de un servlet genérico, un servlet HTTP hereda los métodos imt(), destroyO y service)). Dado e l papel de los servlets como extensión del servidor HTTP, se definen métodos adicionales [java.sun.org/products/servlet/2.2, 7], dos de los cuales se muestran en la Tabla 11.1. Program ación de servlets F i g u r a 1 1 .9 . Jerarquía de clases de Java de un objeto servlet. T a b la 1 1 .1 . Principales m étodos de un servlet HTTP. M é to d o /C o n s tru c to r D e sc rip c ió n void connectf InetAddress dirección, in t puerto) void disconnect( ) M éto d o C re a u na c o n e x ió n ló g ic a e n tre e s te socket y u n socket en la d ire c c ió n y p u e rto re m o to s. T e rm in a la c o n ex ió n a ctu al, s i e x iste , d e e s te socket. D e sc rip c ió n pro te c te d v o id doG etfH ttpServletRequest req, H ttpServletResponse resp) pro te c te d v o id doP ostf H ttpServletRequest req, H ttpServletResponse resp) L lam a d o p o r e l s e rv id o r ( a tra v é s d e l m é to d o service) p ara p e rm itir a lo s s e rv le ts m a n e jar la pe tic ió n GET. L lam a d o p o r e l s e rv id o r (a t ra v é s d e l m é to d o service) p ara p e rm itir a los s e rv le ts m a n e jar l a pe tic ió n POST. www.FreeLibros.org 3 2 8 Computación distribuida. Fundamentos y aplicaciones Como se recordará del Capítulo 9, una petición HTTP puede invocar a un pro­ grama externo (tal como un script CGI) y pasarle parámetros utilizando los métodos G E T o POST. De forma similar, un servlet se puede invocar a través de una petición HTTP, pasándole los parámetros en la cadena d e interrogación tal y como fue des­ crito en el Capítulo 9. Revisión: si una petición especifica el método GET, la cadena de interrogación se concatena al URI y e l servidor HTTP la sitúa en la variable de entorno QUERY_STR¡NG\\ si la petición especifica el método POST, la cadena de in­ terrogación se sitúa en el cuerpo de la petición y el servidor HTTP escribe la cadena en la entrada estándar del programa externo (un script CGI o un servlet). Con los servlets, los parámetros pasados se encapsulan en la clase HITPServletRequest. Cuando se solicita un servlet con GET, el servidor HTTP Dama al método doG et del servlet; el servidor llamará al método doPost del servlet si éste se solicita con POST. Algunos métodos de la clase HTTPServletRequest facilitan la extracción de los pará­ metros de la cadena de interrogación, independientemente de si la petición se hizo es­ pecificando el método G ET o POST. La Figura 11.10 m uestra e l código fuente de un formulario w eb d e ejemplo que invoca a un servlet. En este ejemplo, el formulario w eb especifica el método POST. Cuando se envía e l formulario web, el servidor HTTP carga e l código del servlet (almacenado con e l nombre form ularioServlet) en el contenedor de servlets. El con­ tenedor de servlets inicia el servlet invocando su método init() y a continuación lla­ ma a su m étodo service<). Como se m uestra en la Figura 11.11, el método service<) a su vez invoca al m étodo doP ostf) en el servlet, ejecutando su código. S i el códi­ go genera una respuesta, se envía a l navegador desde el servlet a través del servi­ dor HTTP. Si el formulario especifica e l método GET, se invocará al m étodo do- Get() en su lugar. F ig u ra 1 1 .1 0 . C ó d ig o fu e n te d e un fo rm u la rio w e b d e e je m p lo q u e in vo ca a un se rvle t. <html> <head> <title>Un formulario web que invoca a un servlet</title> </head> < body> <Hl>Este es un formulario sencillo que invoca a un servlet</Hl> <P> Este es un ejemplo que muestra el uso de un formulario web procesado con un servlet de Java. <P> <font color = red> <HR> <form method“ \"post\" action- “ http: / /localhost: 8080/e j emplos/servlet/formularioServlet\" > <H2> Cuestionario: </H2> Cuál es tu peso: cinput name=\"peso\"xP> Cuál es tu pregunta: cinput name=\"pregunta\">cp> Cuál es tu color favorito: ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 2 9 < s e l e c t n a m e = \" c o l o r \"> O p t i o n s e l e c t e d > v e r d e a m a r i l l e n t o < / s e l e c t > <P> C U ál e s e l p e s o d e u n a g o l o n d r i n a : < i n p u t t y p e = \" r a d i o \" n a m e = \" g o lo n d r in a \" v a l u e = \" a f r i c a n a \" d ie c k e d > G o l o n d r i n a a f r i c a n a o < i n p u t t y p e = \" r a d i o \" n a m e = \" g o lo n d r in a \" v a l u e = \" c o n t i n e n t a l \"> G o l o n d r i n a ODntinental <P> T ie n e s a l g o q u e a ñ a d i r < t e x t a r e a nam e= \" t e x t o \" ro w s= 5 c o l s = 6 0 x / t e x t a r e a > <P> P r e s i o n a < i n p u t t y p e = \" s u b m i t \" v a l u e = \" a q u í \"> p a r a e n v i a r t u p e t i c i ó n . < /fo rm > < h r> < /b o d y > < /h tm l> M á q u in a d ie n te M á q u in a servido ra F ig u ra 11.11. Los m étodos doPost and doGet en un servlet HTTP. Como se muestra en la Tabla 11.1, los métodos doPost y doG et reciben como pará­ metros referencias a dos objetos: primero, un objeto HttpServletRequest y, segundo, un objeto HttpServletResponse. Un objeto del primer tipo encapsula una petición HTTP, tal y como se vio en el Capítulo 9. Un objeto del segundo tipo encapsula una respuesta HTTP, como también se vio en el Capítulo 9. Dentro del servlet, la infor­ m ación de la petición se extrae utilizando lo s m étodos apropiados d el objeto HttpServletRequest, algunos de los cuales se muestran en la Tabla 11.2. Se procesa la información y se genera una respuesta utilizando los métodos apropiados del objeto HttpServletResponse. En la Tabla 11.3 se muestran algunos de los métodos principa­ les de la clase HttpServletResponse. La Figura 11.12 m uestra el código de ejem plo de un servlet. El código hace uso de los métodos introducidos en las Tablas 11.2 y 11.3 para procesar la peti­ ción HTTP generada cuando se envía la página w eb de la Figura 11.10. S i se com ­ para este código con e l código d el scrip t CGI form ularioP ost.c (Figura 9.16) del Capítulo 9, se verá la m ism a lógica de aplicación y que la abstracción proporcio­ nada por Java hace a l código m ucho más legible. O bserve que este ejem plo so ­ brescribe e l método doPost, ya que el formulario w eb que invoca al servlet espe­ cifica e l m étodo POST. www.FreeLibros.org 3 3 0 Computación distribuida. Fundamentos y aplicaciones T a b la 1 1 2 . M étodos seleccionados del o b je to H ttp S e r v Ie tfíe q u e s t. M éto d o D e sc rip c ió n public String getH eadetiString ñame) public String getM ethodf) public String getQ ueryStringf) public String getP aram etetiString ñame) public E nnm eration getParam eterNam es() public S trin g l JgetParameterValnesf String ñame) Devuelve el valor de la cabecera de la petición especificada como una cadena. Devuelve el nombre del método HTTP con el que fue realizada la petición. Por ejemplo, GET, PO ST o PUT. Devuelve la cadena de interrogación enviada con la petición. Devuelve el valor de un parámetro de la petición como una cadena, o m ili si el parámetro no existe. Devuelve una enumeración de objetos cadena con el nombre de los parámetros contenidos en la petición. Si la petición no tiene parámetros el método devuelve una enumeración vacía Devuelve un vector de objetos cadena con todos los valores que tiene el parámetro solicitado, o m ili si el parámetro no existe. T a b la 1 1 2 . M étodos seleccionados del o b je to H ttp S e r v Ie tfíe s p o n s e . M éto d o D e sc rip c ió n public void setC ontentTypef String type) void addH eader(String ñame, String valué) void sendError(int se, String msg) void setH eadetiString ñame, String valué) void setStatus(int se) public ServIetOutputStream getOutputStream !) throws java.io.IO Exception public PrintW riter getW riteri) throws java.io.IO Exception public void sendRedirect (String location) throws java.io.IO Exception Establece el tipo de contenido de la respuesta a ser enviada al cliente. Este método debe ser llamado antes de que se obtenga el objeto P rintW riter de la respuesta. Añade una línea de cabecera de respuesta con el nombre y valor dados. Envía una respuesta de error al cliente utilizando el código de estado especificado y el mensaje de descripción. Establece una cabecera de respuesta con el nombre y valor dados. Establece el código de estado de esta respuesta. Devuelve un objeto ServIetOutputStream adecuado para escribir datos binarios en la respuesta. Para escribir el cuerpo se puede llamar o bien a este método o bien al método getW riter(), pero no a ambos. Devuelve un objeto PrintW riter que puede enviar caracteres de texto al cliente. Para escribir el cuerpo se puede llamar o bien a este método o bien al método getO utputStream (), pero no a ambos. Invoca la ejecución del servlet en el URL especificado en la cadena location. La redirecdón debe ser invocada antes de que la respuesta (en caso de existir) del servlet actual se escriba a l objeto HTTPServletResponse. La ejecudón del servlet actual continuará después de la redirecdón. F i g u r a 1 1 .1 2 . C ódigo de ejem plo de un servlet que procesa un form ulario. 1 / / Un e j e n p l o d e s e r v l e t q u e p r o c e s a un f o r m u l a r i o w eb 2 / / A u t h o r : M. L i u ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 331 3 4 i m p o r t j a v a . i o . * ; 5 i m p o r t j a v a x . s e r v l e t . * ; 6 i m p o r t j a v a x . s e r v l e t . h t t p . * ; 7 8 p u b l i c c l a s s s e r v l e t F o r m u l a r i o e x t e n d s H t t p S e r v l e t { 9 10 p u b l i c v o i d d o P o s t ( H t t p S e r v l e t R e q u e s t r e q u e s t , 11 H t t p S e r v l e t R e s p o n s e r e s ) 12 th r o w s S e r v l e t E x c e p t i o n , I O E x c e p ti o n ( 13 14 / / S e d e b e e s t a b l e c e r p r i m e r o e l t i p o d e 15 / / c o n t e n i d o d e l c u e r p o d e l a r e s p u e s t a 16 r e s . s e t C o n t e n t T y p e ( \" t e x t / h t m l \" ) ; 17 18 / / S tr e a m d e s a l i d a p a r a e l c u e r p o d e l a r e s p u e s t a 19 S e r v l e tC X i tp u t S tr e a m s a l i d a = r e s . g e t O u t p u t S t r e a m ( ) ; 20 21 s a l i d a . p r i n t l n ( \" < h tm l> \" ) ; 22 s a l i d a . p r i n t l n ( \" < h e a d > < t i t l e > R e s p u e t a d e l s e r v l e t \" + 23 \" < / t i t l e x / h e a d > \" ) ; 24 s a l i d a . p r i n t l n ( \" < b o d y > \" ) ; 25 s a l i d a . p r i n t l n ( \" < body b g c o l o r = \\ \" b e i g e \\ ; 26 s a l i d a . p r i n t l n ( \" < P > H o l a , < / FONTXFONT FACE=\" + 27 \" \\ \" A r i a l \\ \" SIZE=5 C O L O R = \\\"#ffO O O O \\\"> \") ; 28 / / R e c o g e r e l v a l o r d e l p a r á m e t r o \"n o m b re\" 29 s a l i d a . p r i n t l n ( r e q u e s t . g e t P a r a m e t e r ( \" n o m b r e \" ) + 30 \" < /P x /F O N T > \" ) ; 31 s a l i d a . p r i n t l n ( \" < b r > \" ) ; 32 s a l i d a . p r i n t l n ( \" < h r x b r > \" ) ; 33 / / R e c o g e r e l v a l o r d e l p a r á m e t r o \" p r e g u n t a \" 34 s a l i d a . p r i n t l n ( \" < U L X L I > P r e g u n ta : \" + 35 r e q u e s t . g e t P a r a m e t e r ( \" p r e g u n t a \" ) + \" < / L I > \" ) ; 36 s a l i d a . p r i n t l n ( \" < L I > C o lo r : \" + 37 r e q u e s t . g e t P a r a m e t e r ( \" c o l o r \" ) + \" < / L I > \" ) ; 38 s a l i d a . p r i n t l n ( \" < L I > T i p o d e g o l o n d r i n a : \" + 39 r e q u e s t . g e t P a r a m e t e r ( \" g o l o n d r i n a \" ) + \" < / L I > \" ) ; 40 s a l i d a . p r i n t l n ( \" < L I > Y d i j i s t e : \" + 41 r e q u e s t . g e t P a r a m e t e r (\" t e x t o \" ) ) ; 42 s a l i d a . p r i n t l n ( \"< /U L X B R > \" ) ; 43 s a l i d a . p r i n t l n ( \" < H R > \" ) ; 44 s a l i d a . p r i n t l n ( \" < P x h 3 > P e t i c i ó n p r o c e s a d a p o r : \" + 45 \" < f o n t c o l o r = \\\" # 0 0 A A F F \\\" > \" ) ; 46 s a l i d a . p r i n t l n (r e q u e s t . g e t R e m o t e H o s t ( ) + 47 \" < / F O N I X / h 3 X / P > \" ) ; 48 s a l i d a . p r i n t l n ( \" < / b o d y x / h t m l > \" ) ; 49 } 50 > / / f i n c l a s s www.FreeLibros.org 3 3 2 Computación distribuida. Fundamentos y aplicaciones M antenim iento de la inform ación de estado en la program ación de servlets De vuelta al Capítulo 9, cuando se introdujeron los scripts CGI, se estudiaron los mé­ todos a través de los cuales la información de estado se puede pasar entre scripts. Ya que los scripts CGI son programas independientes, se requieren mecanismos especia­ les para permitir la compartición de información entre ellos. S e debe recordar que al­ guno de los mecanismos descritos en el Capítulo 9 eran campos ocultos de formula­ rio y cookies. Los servlets tienen una selección más amplia de mecanismos, algunos de los cua­ les se presentan a continuación, incluyendo e l uso de (1) variables servlet, (2) cam­ pos ocultos de formulario, (3) cookies y (4) objetos d e sesión. Variables servlet Como ya se mencionó, los servlets son persistentes: una sola instancia de un servlet, una vez cargado en e l motor de servlets, se ejecuta hasta que el servlet se destruye. Por lo tanto, es posible almacenar información de estado en las variables del servlet. Sin embargo, no es común que los programadores utilicen este método para mante­ ner la información de estado, por las siguientes razones: Un programador no tiene control sobre el ciclo de vida de un servlet. Dependien­ do d e la implementación del servidor que interactúa con el motor de servlets, un servlet puede persistir durante un determinado tiempo, o puede persistir de forma indefinida hasta que se apaga el motor. Debido a que en un determinado momento sólo está ejecutando una copia única del servlet, la información de estado almacenada en las variables del servlet será glo­ bal a todos los clientes, haciendo difícil separar los datos de estado de las sesiones concurrentes. La Figura 11.13 presenta el código fuente de un servlet que utiliza una variable para mantener un contador a lo largo del tiem po de vida del servlet. El contador se incrementa cada vez que se ejecuta el servlet. S e puede experimentar con este ejem ­ plo ejecutando el servlet varias veces, de forma secuencial o concurrente, tal y como se pide hacer en uno d e los ejercicios al final d e este capítulo. F ig u ra 1 1 .1 3 . C ontador.java. 1 / / Un e je m p lo q u e m u e s t r a e l u s o d e v a r i a b l e s 2 / / s e r v l e t p a r a a l m a c e n a r i n f o r m a c i ó n d e e s t a d o . 3 / / M. L i u 4 5 i m p o r t j a v a . i o . * ; 6 i m p o r t j a v a x . s e r v l e t . * ; 7 i m p o r t j a v a x . s e r v l e t . h t t p . * ; 8 9 p u b l i c c l a s s C o n ta d o r e x t e n d s H t t p S e r v l e t { 10 11 i n t c o n t a d o r = 0 ; 12 13 p u b l i c v o i d d o G e t( H t t p S e r v l e t R e q u e s t r e q u e s t , ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 3 3 14 H t t p S e r v l e t R e s p o n s e r e s p o n s e ) 15 th r o w s S e r v l e t E x c e p t i o n , I O E x c e p ti o n { 16 r e s p o n s e . s e t C o n t e n t T y p e ( \" t e x t / p l a i n \" ) ; 17 P r i n t W r i t e r s a l i d a = r e s p o n s e . g e t W r i t e r ( ) ; 18 19 c o n t a d o r + + ; 2 0 21 s a l i d a . p r i n t l n ( \" E s t e s e r v l e t h a s i d o \" + 22 \" a c c e d i d o \" + c o n t a d o r + \" v e c e s . \" ) ; 23 } / / f i n d o G e t 24 } / / f i n c l a s s Contador.java no es seguro con los hilos (thread safe) ya que la operación de in­ cremento de la variable contador (línea 19) se puede interrumpir, por lo que una ope­ ración d e incremento puede sobreescribir a otra. La Figura 11.14 es una versión se­ gura que utiliza un método de sincronización para asegurar que sólo una invocación del servlet puede acceder e incrementar el contador. F ig u ra 1 1 .1 4 . C ontador2.java. 1 / / Un s e r v l e t q u e m a n t i e n e un c o n t a d o r p a r a 2 / / e l n ú m ero d e v e c e s q u e h a s i d o a c c e d i d o 3 / / d e s d e s u c a r g a . 4 / / M. L i u 5 6 i m p o r t j a v a . i o . * ; 7 i m p o r t j a v a x . s e r v l e t . * ; 8 i m p o r t j a v a x . s e r v l e t . h t t p . * ; 9 10 p u b l i c c l a s s C o n ta d o r 2 e x t e n d s H t t p S e r v l e t { 11 12 p u b l i c i n t c o n t a d o r = 0 ; 13 14 p u b l i c v o i d d o G e t ( H t t p S e r v l e t R e q u e s t r e q u e s t , 15 H t t p S e r v l e t R e s p o n s e r e s p o n s e ) 16 th r o w s S e r v l e t E x c e p t i o n , I O E x c e p ti o n { 17 r e s p o n s e . s e t C o n t e n t T y p e ( \" t e x t / p l a i n \" ) ; 18 P r i n t W r i t e r s a l i d a = r e s p o n s e . g e t W r i t e r ( ) ; 19 i n c r e m e n t o ( s a l i d a ) ; 20 > / / f i n d o G e t 21 22 p r i v a t e s y n c h r o n i z e d v o i d i n c r e m e n t o ( P r i n t W r i t e r o u t p u t ) { 23 o u t p u t . p r i n t l n ( \" E s t e s e r v l e t h a s i d o \" + 24 \" a c c e d i d o \" + c o u n t e r + \" v e c e s . \" ) ; 25 c o u n t e r + + ; 26 } / / f i n i n c r e m e n t o 27 28 > / / f i n c l a s s www.FreeLibros.org 334 Computación distribuida. Fundamentos y aplicaciones C a m p o s o c u lto s de form ulario El uso de campos ocultos de formulario, como se describió en el Capítulo 9, puede ser aplicado exactamente de la misma forma con servlets y con scrípts CGI para pa­ sar información de estado. Las sentencias HTML que contienen campos ocultos de formulario se pueden escribir a un stream de salida de un PrintWriter asociado con el HTTPServletResponse para almacenar los datos de estado a ser enviados al siguiente servlet en una cadena de interrogación. El siguiente fragmento de código muestra la salida de una línea en la respuesta HTTP que contiene un campo oculto de formula­ rio cuyo nombre es ID y cuyo valor es el recibido en la variable algúnValor: response.setContentType(\"text/plain\"); PrintWriter salida = response.getWriter( ); salida.println(\"<INPUT TYPE=\\\"HIDDEN\\\" ÑAME=ID VALUE=\" + algúnValor); Cookies Las cookies tam bién pueden aplicarse de la misma manera que en los scripts CGI. Java proporciona clases y métodos para facilitar su uso. La clase, HttpCookie, representa las cookies que se vieron en e l Capítulo 9. En la Tabla 11.4 se describen los principales métodos de esta clase. T a b la 11 .4 . P rin cip a le s m é to d o s en la c la s e C ookie. M éto d o D e sc rip c ió n public Cookief String ñame, String valué) public String getD om ainf ) public in t getM axA gef ) public String getN am e( ) public String getP ath( ) public String getValuef ) public void setD om ainf String pattern) public void setM axA gef in t expiry) public void setP athf String uri) public void setValuef String n ew Valué) Construye una cookie con el nombre y valor especificado. Devuelve el nombre de dominio de esta cookie. Devuelve la edad máxima de la cookie, especificada en segundos. Por defecto, -1 indica que la cookie será persistente hasta que se cierre el navegador. Devuelve el nombre de la cookie. Devuelve la ruta en e l servidor a la que el navegador devuelve la cookie. Devuelve el valor de la cookie. Establece el atributo dominio de esta cookie. Establece el atributo expiración de esta cookie a un periodo de tiempo especificado en segundos. Establece el atributo ruta de esta cookie. Asigna un valor a la cookie. La clase HttpRequest proporciona un método, getCookies, para recoger las cookies enviadas con la petición HTTP, como se muestra en la Tabla 11.5. T a b la 11-5. El m é to d o g e tC o o k ie de la c la s e H ttp R e q u e s t. M éto d o D e sc rip c ió n public Cookie[ ] getCookies( ) Devuelve un vector con todos los objetos Cookie enviados por el cliente en la petición. www.FreeLibros.org Las Figuras 11.5 a 11.18 presentan una serie de códigos que muestran la imple- mentación básica de un carrito de la compra utilizando programación con servlets. F ig u ra 11.15. El fo rm u la rio w e b carrito.htm l. <HTML> <HEAD> < r iT L E > F r u ta s O n lin e < /T IT L E > </HEAD> <BODY b g c o lo r= # C C F F C O <CENTERXHl>Tenemos l o s s i g u i e n t e s a r t ic u l o s < / H l x /C E N T E R > <HR> <FORM A CTIC W =\"http: / / l o c a l h o s t : 8 080/ e j e m p l o s / s e r v l e t / C a r r i t o \" METHOD=\"POST\"> <TABLE CELLSPACING=\" 5 \" CELLPADDING=\" 5 \"> <TR> <TD ALIGN=\" c e n t e r \" x B > A ñ a d ir a l c a r r i t o < / B x / T D > <TD ALIGN=\" c e n t e r \" x / TD> <TD ALIGN=\" c e n t e r \" x / T D > </TR> <TR> <TD ALIGN=\" c e n t e r \" x iN P U T T Y PE =\"C heckbox\" NAME= \" c b j e t o _ a \" VALUE=\"manzana $ l \" x / T D > <TD ALIGN= \" l e f t \">m anzana</T D > </TR> <TR> <TD ALIGN=\" c e n t e r \" x iN P U T T Y PE =\"C heckbox\" NAME=\"o b j e t o _ b \" VALUE=\" n a r a n j a $ 2 \" x / T D > <TD ALIGN=\" l e f t \" > n a r a n j a < / T D > </TR> <TR> <TD ALIGN=\" c e n t e r \" x iN P U T T Y PE =\"C heckbox\" NAME= \" c b j e t o _ c \" VALUE=\" p e r a $ 3 \" x / T D > <TD ALIGN=\" l e f t \" > p e r a < / T D > </TR> </TABLE> <HRXBR> <CENTER> P r e s i o n a CNPUT TYPE=\" S u b m i t\" N A M E = \" C a rtl_ su b m it\" VALUE=\" E n v i a r \"> p a r a e n v i a r t u p e d i d o . </CENTER> </FORM> </BODY> </HTML> Aplicaciones d e Internet - Parte 2 3 3 5 F ig u ra 1 1 .1 6 . B s e rv le t Carrito. 1 i m p o r t j a v a x . s e r v l e t . * ; 2 / / C ó d ig o f u e n t e d e l s e r v l e t C a r r i t o , in v o c a d o c u a n d o (continúa) www.FreeLibros.org 3 3 6 Computación distribuida. Fundamentos y aplicaciones 3 / / s e e n v í a e l f o r m u l a r i o w eb c a r r i t o . h t m l 4 / / M. L i u 5 6 i m p o r t j a v a x . s e r v l e t . h t t p . * ; 7 i m p o r t j a v a . i o . * ; 8 i m p o r t j a v a . u t i l . * ; 9 10 p u b l i c c l a s s C a r r i t o e x t e n d s H t t p S e r v l e t 11 { 12 p u b l i c v o i d d o P o s t ( H t t p S e r v l e t R e q u e s t r e q u e s t , 13 H t t p S e r v l e t R e s p o n s e r e s p o n s e ) 14 t h r c w s S e r v l e t E x c e p t i o n , I O E x c e p ti o n 15 { 16 r e s p o n s e . s e t C o n t e n t T y p e ( \" t e x t / h t m l \" ) ; 17 S e r v l e t O u t p u t S t r e a m s a l i d a = r e s p o n s e . g e t O u t p u t S t r e a m ( ) ; 18 s a l i d a . p r i n t l n ( \" < h tm l> \" ) ; 19 s a l i d a . p r i n t l n ( \" < h e a d x t i t l e > R e s p u e s t a d e l s e r v l e t \" + 20 \" < / t i t l e x / h e a d > \" ) ; 21 s a l i d a . p r i n t l n ( \" < b o d y > \" ) ; 22 C o o k ie c ; 23 24 / * R e c o g e r d a t o s d e l f o r m u l a r i o * / 25 E n u m e r a tio n c l a v e s ; 26 S t r i n g ñ a m e , v a l u é , p r e f i x ; 27 c l a v e s = r e q u e s t . g e t P a r a m e t e r N a m e s ( ) ; 28 w h i l e ( c l a v e s . h a s M o re E le m e n ts ( ) ) 29 { 30 n o n b r e = ( S t r i n g ) c l a v e s . n e x t E l e m e n t ( ) ; 31 p r e f i j o = n o m b re . s u b s t r i n g ( 0 , 4 ) ; 32 33 i f ( p r e f i j o . e q u a l s ( \" o b j e t o \" ) ) 34 / / E s t e c h e q u e o e s n e c e s a r i o p a r a e l i m i n a r 35 / / cam p o s d e e n t r a d a q u e n o s o n o b j e t o s . 36 { 37 /* R e c o g e r e l v a l o r d e l p a r á m e t r o * / 38 v a l o r = r e q u e s t . g e t P a r a m e t e r ( n o m b r e ) ; 39 /* C r e a r u n a c o o k i e * / 40 s a l i d a . p r i n t l n ( \" < H 4 > E s ta b le c e r c o o k i e : \" + n o m b re + 41 \" \" + v a l o r + \" < /H 4 > \" ) ; 42 c = new C o o k ie ( n o m b re , v a l o r ) ; 43 44 /* E s t a b l a c e r e x p i r a c i ó n e n u n d í a * / 45 /* c .s e tM a x A g e ( 1 * 2 4 * 6 0 * 6 0 ) ; * / 4 6 r e s p o n s e . a d d C o o k ie ( c ) ; 47 } / / f i n i f 48 } / / f i n w h i l e 49 s a l i d a . p r i n t l n ( \" < / b o d y x / h t m l > \" ) ; 50 ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 337 51 / * R e a l i z a r u n a r e d i r e c c i ó n p a r a e n v i a r l a s c o o k i e s e 52 i n v o c a r o t r o s e r v l e t q u e m u e s t r e l o s o b j e t o s 53 d e l c a r r i t o d e l a c o m p ra * / 54 r e s p o n s e . s e n d R e d i r e c t ( \" C a r r i t o 2 \" ) ; 55 56 57 } / / f i n d o P o s t 58 } / / f i n c l a s s F ig u ra 1 1 .1 7 . El servlet Carríto2. 1 / / S e r v l e t q u e m u e s t r a e l c o n t e n i d o d e l c a r r i t o d e l a c o m p ra 2 / / ( d a t o s a lm a c e n a d o s p o r e l s e r v l e t C a r r i t o ) 3 / / M. L i u , b a s a d o e n v a r i a s f u e n t e s 4 5 i m p o r t j a v a x . s e r v l e t . * ; 6 i m p o r t j a v a x . s e r v l e t . h t t p . * ; 7 i m p o r t j a v a . i o . * ; 8 i m p o r t j a v a . ú t i l . * ; 9 10 p u b l i c c l a s s C a r r i t o 2 e x t e n d s H t t p S e r v l e t 11 { 12 / * V i s u a l i z a r o b j e t o s d e l c a r r i t o * / 13 p u b l i c v o i d d o G e t ( H t t p S e r v l e t R e q u e s t r e q u e s t , 14 H t t p S e r v l e t R e s p o n s e r e s p o n s e ) 15 th r o w s S e r v l e t E x c e p t i o n , I O E x c e p ti o n { 16 17 r e s p o n s e . s e t C o n t e n t T y p e ( \" t e x t / h t m l \" ) ; 18 S e r v l e tC X i tp u t S tr e a m s a l i d a = r e s p o n s e . g e t O u t p u t S t r e a m ( ) ; 19 s a l i d a . p r i n t l n ( \" < h tm l> \" ) ; 20 s a l i d a . p r i n t l n ( \" < h e a d > < t i t l e > R e s p u e s t a d e l s e r v l e t \" + 21 \" < / t i t l e x / h e a d > \" ) ; 22 s a l i d a . p r i n t l n ( \" < b o d y > \" ) ; 23 s a l i d a . p r i n t l n ( \" < b o d y b g c o l o r = \\ \" b e i g e \\ \" > \" ) ; 24 s a l i d a . p r i n t l n ( \" C o n t e n i d o d e t u c a r r i t o d e l a c a n p ra < U L > \" ) ; 25 26 / * R e c o g e r l a s c o o k i e s * / 27 C o o k ie c o o k i e s [ ] ; 28 29 c o o k i e s = r e q u e s t . g e t C o o k i e s ( ) ; 30 i f ( c o o k i e s != n u i l ) 31 { 32 f o r ( i n t i = 0 ; i < c o o k i e s . l e n g t h ; i+ + ) 33 { 34 /* N o t a : e s i m p o r t a n t e i d e n t i f i c a r l a s c o o k i e s 35 p o r s u n o m b r e , y a q u e p u e d e h a b e r o t r a s c o o k i e s 36 en u s o d e e s t e s i t i o * / 37 i f ( c o o k i e s [ i ] . g e t N a m e ( ) . s t a r t s W i t h ( \" o b j e t o \" ) ) (continúa) www.FreeLibros.org 338 Computación distribuida. Fundamentos y aplicaciones 38 { 39 s a l i d a . p r i n t l n ( \"< L I> \" + c o o k i e s [ i ] . g e t N a m e ( ) + 40 11 \\ t \" + c o o k i e s [ i ] . g e t V a l u e ( ) ) ; 41 > 42 > / / f i n f o r 43 } / / f i n i f 44 45 s a l i d a . p r i n t l n ( \" < /U L > \" ) ; 46 s a l i d a . p r i n t l n ( \" <HR>\" ) ; 47 s a l i d a . p r i n t l n ( \" < / b o d y x / h t m l > \" ) ; 48 49 } / / f i n d o G e t 50 51 } / / f i n C a r r i t o F ig u ra 1 1 .1 8 . C arrito2.htm l. <HTML> <CENTER> <FQRM A C T I0 N = \" C a rr ito 2 \" METHOD=\" GET\"> < h l > V i s u a l i z a r l o s o b j e t o s a c t u a l e s e n e l c a r r i t o < / h l > <P> P r e s i o n a <INPUT TYPE=\"S u b m it\" N A M E = \" C & rrito 2 _ e n v ia r\" V A L U E = \"E nviar\"> p a r a v e r e l c o n t e n i d o d e t u c a r r i t o d e l a c o m p r a . </CENTER> </F0RM> </B0DY> </HTML> La Figura 11.15 es el código fuente del formulario web Carrito.html. Cuando se muestra e l formulario presenta tres objetos disponibles para su selección. Cuando se envía el formulario, se inicia e l servlet Carrito (Figura 11.6). En el ejemplo, se asume que el servlet ejecuta en la máquina local. Sin embargo, el nom­ bre del dominio y el número de puerto se pueden reemplazar con los de un servidor alternativo. El nombre de los parámetros de la petición pasados por el formulario web se obtienen utilizando e l método getParameterNames (línea 27), para a continuación obtener el valor de los parámetros con e l método getPárameter (línea 38). Para cada parámetro cuyo nombre comience con el prefijo adecuado (“objeto\", en nuestro caso), el nombre y el valor se utilizan para crear una nueva cookie (línea 42), que se añade a la respuesta utilizando el método addCookie (línea 46). Si se selecciona naranja, por ejemplo, la cookie generada tendrá el nombre “objeto_b\", y el valor “naranja $2”. Hay sentencias en el código (líneas 44-45) que ajustan las cookies para durar un día, aun­ que estas sentencias están comentadas. Se llam a al método sendRedirect del objeto HttpServletResponse para invocar al siguiente servlet, Carrito2. El servlet Carrito2 genera dinámicamente una página web que muestra el contenido del carrito de la compra. www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 3 9 En C arrito2java (Figura 11.17), las cookies se recogen una por una (líneas 29- 43) utilizando el método getCookies del objeto HttpServletRequest. Sólo se procesan las cookies con el prefijo adecuado (objeto). Se supone que el valor d e cada cookie contiene el nombre y el precio del objeto seleccionado. En la página web generada dinámicamente se incluye una descripción de cada objeto. L a Figura 11.18 muestra el formulario w eb Carrito2.html que, cuando se envía, invoca al servlet Carrito2 directamente para permitir a un usuario visualizar los con­ tenidos del carrito de la compra durante una sesión. Debido a que un servlet es persistente, uno se puede preguntar, ¿el uso de las cookies, tal y como se muestra en el ejemplo del carrito de la compra, puede presen­ tar compartición de información de sesión, causando que los contenidos del carrito de la compra de un usuario se le muestren a otro? Se considera que el cliente A y el cliente B, que están usando d e forma concurrente carrito.html desde computadores d i­ ferentes. Cada petición HTTP de los clientes desencadenará la invocación de la mis­ ma instancia del servlet Carrito, que genera las cookies para las selecciones de los usuarios. La petición del cliente A hace que las cookies se generen basándose en los parámetros de la petición que envía A, mientras que la petición del cliente B hace que las cookies se generen basándose en los parámetros de la petición que envía B. Las cookies de A se almacenan en el navegador de la computadora A. De forma análoga, las cookies de B se almacenan en e l navegador de la computadora B. Las cookies son enviadas por cada navegador en las siguientes peticiones HTTP (a la máquina con el servlet Carrito) que realiza su usuario, por lo que no hay confusión en los datos de los diferentes carritos de la compra. Sin embargo, la situación es diferente si las sesiones paralelas se realizan desde el mismo computador. Hay un ejercicio al final del capítulo en el cual se puede inves­ tigar y experimentar con este escenario. O b je to Session El API de Servlets proporciona un mecanismo especial para mantener información de estado específica de una sesión particular de un cliente HTTP. El mecanismo se co­ noce como objetos session. Un objeto session implementa la interfaz HttpSession. Un servlet puede crear este objeto y después utilizarlo como un repositorio de datos de estado a lo largo de la sesión del cliente. Para diferenciar sesiones diferentes, cada objeto de sesión debe tener un identificador único. El identificador se asigna de for­ ma automática por el contenedor de servlets y es transparente al usuario. A lo largo de la sesión del cliente, e l identificador de sesión se pasa entre el servidor y el clien­ te utilizando una cookie o algún otro mecanismo. Una vez que se ha creado el obje­ to sesión, un servlet puede depositar en él uno o más objetos que contienen informa­ ción de estado. Cada objeto añadido al objeto sesión se especifica con un nombre. Más adelante, e l objeto puede ser accedido por otro servlet, o incluso por el mismo servlet, invocado en la misma sesión de usuario. El objeto session persistirá durante un intervalo d e inactividad que puede ser es­ tablecido por código, o por un valor por defecto que depende de la implementación. Cuando el intervalo finalice, el contenedor de servlets invalidará el objeto session por lo que su contenido ya no podrá ser accedido. La invalidación de un objeto session tam bién se puede iniciar por programa; es una buena práctica hacerlo en el código al final de una sesión. www.FreeLibros.org 3 4 0 Computación distribuida. Fundamentos y aplicaciones La Tabla 11.6 m uestra los principales m étodos que se pueden invocar con HTTPSession. El método setAttribute se utiliza para añadir datos de sesión a un objeto session, mientras que el método getAttribute u opcionalmente el método getAttribute- Names se puede utilizar para recoger datos de sesión de un objeto session existente. El método setMaxInactivelnterval permite establecer el intervalo de tiempo de inactividad para un objeto session, mientras que el método invalídate invalidará el objeto session. T a b la 11 .6 . P rin cip a le s m é to d o s d e la in te rfa z H TTPSession. M éto d o D e sc rip c ió n public Object getAttribute(String ñam e) throws java.lang.IUegalStateException public Enumeration getAttribute Ñam e s( ) throws java.lang.IUegalStateException public void setAttribute (String ñam e, Object valué) throws java.lang.IUegalStateException public void invalídate! ) throws java.lang.IUegalStateException public int getM axInactivelntervaU) public void setMaxInactivelnterval ( in t interval) public String getld( ) Devuelve el objeto de esta sesión con el nombre especificado, o m d l en caso de no existir dicho nombre. Devuelve una enumeración de objetos cadena con el nombre de todos los objetos de esta sesión. Enlaza un objeto con esta sesión, utilizando el nombre especificado. Si ya existe un objeto con e l mismo nombre en la sesión, se reemplaza dicho objeto. Invalida esta sesión y a continuación elim ina el enlace con los objetos de la misma. Devuelve el máximo tiempo del intervalo, un entero que especifica el número de segundos que el contenedor de servlets mantendrá esta sesión abierta entre accesos del cliente. Después de este intervalo, el contenedor de servlets invalidará la sesión. El tiempo máximo del intervalo se puede establecer con el método setM axInactivelnterval. Un tiempo negativo indica que la sesión nunca finaliza. Especifica el tiempo, en segundos, entre llamadas de clientes antes de que el contenedor de servlets invalide la sesión. Un tiempo negativo indica que la sesión no debe finalizar. Devuelve una cadena que contiene el identificador único de esta sesión. El identificador lo asigna el contenedor de servlets y es dependiente de la implementación. Un objeto session se puede crear y posteriormente recuperar utilizando el método getSession de la clase HttpRequest, como se muestra en la Tabla 11.7. Las Figuras 11.19 y 11.20 revisan el código fuente de los servlets Carrito y Ca­ rrito2, previamente presentados en las Figuras 11.16 y 11.17. En este conjunto de có­ digos de ejemplo se utiliza un objeto session (en lugar d e cookies) para mantener los objetos del carrito de la compra. T a b la 11 .7 . El m é to d o g e tS e s s io n de la c la s e H ttp R e q u e s t. M éto d o D e sc rip c ió n public HttpSession getSessionf b o olean create) Devuelve el H ttpSession actual asociado con esta petición o si no hay sesión actual y el parámetro create contiene true, devuelve una nueva sesión. Si create vale fa lse y la petición no tiene un H ttpSession válido, el método devuelve nuil. www.FreeLibros.org Aplicaciones d e Internet - Parte 2 341 F ig u ra 1 1 .1 9 . El servlet Carrito utilizando el objeto session. 1 i m p o r t j a v a x . s e r v l e t . * ; 2 / / C ó d ig o f u e n t e d e l s e r v l e t C a r r i t o in v o c a d o c u a n d o 3 / / s e e n v í a e l f o r m u l a r i o w eb c a r r i t o . h t m l 4 / / M. L i u 5 6 i m p o r t j a v a x . s e r v l e t . h t t p . * ; 7 i m p o r t j a v a . i o . * ; 8 i m p o r t j a v a . ú t i l . * ; 9 10 p u b l i c c l a s s C a r r i t o e x t e n d s H t t p S e r v l e t 11 { 12 p u b l i c v o i d d o P o s t ( H t t p S e r v l e t R e q u e s t r e q u e s t , 13 H t t p S e r v l e t R e s p o n s e r e s p o n s e ) 14 th r o w s S e r v l e t E x c e p t i o n , I O E x c e p ti o n { 15 16 17 / * R e c u p e r a e l o b j e t o s e s s i o n o c r e a 18 u n o n u e v o * / 19 H t t p S e s s i o n s e s s i o n = r e q u e s t . g e t S e s s i o n ( t r u e ) ; 2 0 21 I n t e g e r c o n t a d o r O b j e t o s = 22 (Integer) session.getAttribute(\"contadorObjetos\"); 23 V e c t o r o b j e t o s = 24 ( V e c t o r ) s e s s i o n . g e t V a l u e ( \" o b j e t o s \" ) ; 25 / * S i t o d a v í a n o s e h a s e l e c c i o n a d o n in g ú n o b j e t o , 26 p o n e r e l c o n t a d o r a c e r o y c r e a r u n v e c t o r . * / 27 i f ( c o n t a d o r O b j e t o s == n u i l ) { 28 c o n t a d o r O b j e t o s = new I n t e g e r ( 0 ) ; 29 o b j e t o s = new V e c t o r ( ) ; 30 } 31 32 / / S e r e c o m ie n d a o b t e n e r e l o b j e t o s e s s i o n 33 / / a n t e s d e e s c r i b i r c u a l q u i e r s a l i d a . 34 P r i n t W r i t e r s a l i d a = r e s p o n s e . g e t W r i t e r ( ) ; 35 r e s p o n s e . s e t C o n t e n t T y p e ( \" t e x t / h t m l \" ) ; 36 37 / * R e c o g e r l o s p a r á m e t r o s e n v i a d o s * / 38 E n u m e r a tio n c l a v e s ; 39 S t r i n g n o n b r e , v a l o r , p r e f i j o ; 40 i n t c o n t a d o r = i t e m C o u n t . i n t V a l u e ( ) ; 41 c l a v e s = r e q u e s t .g e t P a r a m e t e r N a m e s ( ) ; 42 w h i l e ( c l a v e s . h a s M o re E le m e n ts ( ) ) 43 { 44 n o n b r e = ( S t r i n g ) c l a v e s . n e x t E l e m e n t ( ) ; 45 p r e f i j o = ñ am e. s u b s t r i n g ( 0 , 4 ) ; 46 s a l i d a . p r i n t l n ( \"nam e=\" + n o m b re + 11 p r e f i x = \" + 47 p r e f i j o ) ; 48 i f ( p r e f i j o . e q u a l s ( \" o b j e t o \" ) ) (continúa) www.FreeLibros.org 342 Computación distribuida. Fundamentos y aplicaciones 49 { 50 / / a ñ a d i r e l o b j e t o a l a l i s t a d e o b j e t o s 51 v a l o r = r e q u e s t . g e t P a r a m e t e r ( n o m b r e ) ; 52 s a l i d a . p r i n t l n ( \" a ñ a d i e n d o e l o b j e t o : \" + 53 v a l o r + \" c o n ta d o r = \" + c o n t a d o r ) ; 54 o b j e t o s . a d d ( v a l o r ) ; 55 c o n t a d o r + + ; 56 } / / f i n i f 57 } / / f i n w h i l e 58 c o n t a d o r O b j e t o s = new I n t e g e r ( c o n t a d o r ) ; 59 s e s s i o n . p u t V a l u e ( \" < x > n ta d o rO b je to s \" , c o n t a d o r O b j e t o s ) ; 60 i f ( o b j e t o s != n u i l ) 61 s e s s i o n . s e t A t t r i b u t e ( \" o b j e t o s \" , o b j e t o s ) ; 62 63 / * R e a l i z a r u n a r e d i r e c c i ó n p a r a i n v o c a r o t r o 64 s e r v l e t q u e m u e s t r e l o s o b j e t o s d e l c a r r i t o 65 d e l a c o m p ra * / 66 67 r e s p o n s e . s e n d R e d i r e c t 68 ( \"h t t p : / / l o c a l h o s t : 8 0 8 0 / e j e m p l o s / s e r v l e t / C a r r i t o 2 \" ) ; 69 } / / f i n d o P o s t 70 71 } / / f i n c l a s s F ig u ra 1 1 .2 0 . El s e rv le t C arríto2 u tiliza n d o e l o b je to se s sio n . 1 / / S e r v l e t p a r a v i s u a l i z a r q u é h a y e n e l c a r r i t o d e l a c o m p ra 2 / / ( d a t o s a lm a c e n a d o s p o r e l s e r v l e t C a r r i t o ) 3 / / M. L i u , b a s a d o e n v a r i a s f u e n t e s 4 5 i m p o r t j a v a x . s e r v l e t . * ; 6 i m p o r t j a v a x . s e r v l e t . h t t p . * ; 7 i m p o r t j a v a . i o . * ; 8 i m p o r t j a v a . u t i l . * ; 9 10 p u b l i c c l a s s C a r r i t o 2 e x t e n d s H t t p S e r v l e t { 11 12 /* V i s u a l i z a r o b j e t o s e n e l c a r r i t o d e l a c a n p r a * / 13 p u b l i c v o i d d o G e t( H t t p S e r v l e t R e q u e s t r e q u e s t , 14 H t t p S e r v l e t R e s p o n s e r e s p o n s e ) 15 th r o w s S e r v l e t E x c e p t i o n , I O E x c e p ti o n { 16 17 18 / / R e c o g e r e l o b j e t o s e s s i o n , s i e x i s t e 19 H t t p S e s s i o n s e s s i o n = r e q u e s t . g e t S e s s i o n ( f a l s e ) ; 20 I n t e g e r c o n t a d o r O b j e t o s ; ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 4 3 21 V e c t o r o b j e t o s = n u i l ; 22 i f ( s e s s i o n == n u i l ) 23 { 24 / / n o s e h a c r e a d o n in g ú n o b j e t o s e s s i o n 25 c o n t a d o r O b j e t o s = new I n t e g e r ( 0 ) ; 26 } 27 e l s e 28 { 29 c o n t a d o r O b j e t o s = 30 ( I n t e g e r ) s e s s i o n . g e t V a l u e ( \" c o n t a d o r O b j e t o s \" ) ; 31 o b j e t o s = 32 ( V e c t o r ) s e s s i o n . g e t V a l u e ( \" o b j e t o s \" ) ; 33 } 34 / / S e r e c o m ie n d a o b t e n e r e l o b j e t o s e s s i o n 35 / / a n t e s d e e s c r i b i r c u a l q u i e r s a l i d a . 36 P r i n t W r i t e r s a l i d a = r e s p o n s e . g e t W r i t e r ( ) ; 37 r e s p o n s e . s e t C o n t e n t T y p e ( \" t e x t / h t m l \" ) ; 38 39 s a l i d a . p r i n t l n ( \" < h tm l> \" ) ; 40 s a l i d a . p r i n t l n ( \" < h e a d > < t i t l e > R e s p u e s t a d e l s e r v l e t \" + 41 \" < / t i t l e > < / h e a d > \" ) ; 42 s a l i d a . p r i n t l n ( \" < b o d y > \" ) ; 43 s a l i d a . p r i n t l n ( \" < body b g c o l o r = \\ \" b e i g e \\ \" > \" ) ; 44 s a l i d a . p r i n t l n 45 ( \" C o n t e n id o d e t u c a r r i t o d e l a c o m p ra \" + 46 \" u t i l i z a n d o e l o b j e t o s e s s io n < U L > \" ) ; 47 48 i n t c o n t a d o r = c o n t a d o r O b j e t o s . i n t V a l ú e ( ) ; 49 / * R e c o g e r l o s o b j e t o s d e l o b j e t o s e s s i o n * / 50 f o r ( i n t i = 0 ; i < c o n t a d o r ; i+ + ) 51 s a l i d a . p r i n t l n ( \"< L I> \" + o b j e t o s . g e t ( i ) ) ; 52 53 s a l i d a . p r i n t l n ( \" </U L > \" ) ; 54 s a l i d a . p r i n t l n ( \" <HR>\" ) ; 55 s a l i d a . p r i n t l n ( \" < / b o d y x / h t m l > \" ) ; 56 57 > / / f i n d o G e t 58 59 } / / f i n C a r r i t o 2 Aquí concluye la introducción a los servlets. El material que se ha presentado pro­ porciona una visión general d e la tecnología. A l final del capítulo encontrarás ejerci­ cios que te permitirán practicar con los servlets. Una tecnología m uy cercana a los servlets es JSP (Java Server Pages, Páginas Java de Servidor) [java.sun.com, 25], que permiten crear páginas web con código servlet embebido. El uso de JSP puede simplificar significativamente el código para generar páginas web de forma dinámica. Los lectores interesados pueden consultar las refe­ rencias [java.sun.com, 25] y [javaboutique.internet.com, 26]. www.FreeLibros.org 3 4 4 Computación distribuida. Fundamentos y aplicaciones 1 1 .3 . S E R V IC IO S W EB En el capítulo 3 se vio e l paradigma de servicios de red para computación distribui­ da. Utilizando este paradigma, una aplicación ejecuta alguna de sus tareas haciendo uso de servicios ya implementados disponibles en la red. En estas aplicaciones los servicios de red se pueden integrar dinámicamente, según se necesite. Este paradigma ha sido extendido a servicias web, una tecnología que ha surgido recientemente. Los servios web proporcionan servicios d e red transportados por HTTP, y están siendo propuestos como una nueva forma de construir aplicaciones de red des­ de componentes distribuidos (servicios) independientes del lenguaje y d e la platafor­ ma. Los protocolos y las A PI de la tecnología están evolucionando todavía. En esta sección se verá uno de estos protocolos, el SOAP {S im p le O bject A cc ess Pm éocoi, protocolo a n ille de acceso a objetos) [w3.org, 9], y una API de ejemplo, el API SOAP d e Apache F ig u ra 11 -21 - El m o d e lo c o n c e p tu a l d e servio tos w e b . La Figura 11.21 muestra el modelo conceptual de servicios web. Un servicio web se proporciona por un objeto servidor y se accede por un cliente. El servidor y el cliente intercambian mensajes de acuerdo a protocolos estándares desarrollados para los servicios web. La Figura 11.22 representa la jerarquía del protocolo. Lógicamen­ te, el servidor y el cliente intercambian mensajes en la capa d e aplicación Física­ mente, se requiere una serie de protocolos para dar soporte al intercambio de mensa­ jes. Un protocolo de descubrim iento de servidos permite a l servicio ser registrado y localizado. Las funcionalidades proporcionadas en la capa d e descripción del ser­ v id o permiten que un servicio sea descrito en el directorio. La capa de m ensajería proporciona los mecanismos para la intercomunicación de procesos, incluyendo fun­ cionalidades d e empaquetamiento (marshaling) de datos. La c^pa de transporte en­ vía los mensajes. Finalmente, la capa d e red representa la jerarquía del protocolo de red para la transm isión física y el encaminamiento de paquetes. La Figura 11.23 muestra los protocolos predominantes utilizados para servicios web. Para e l descubrimiento de servicios, el protocolo estándar se denomina UDDI (U n iversa l D escríptíon, D isco very a n d L tte g p a tio n , descripción, descubrim iento e integración universales) [uddi.org, 21]. La sintaxis y semántica para describir ser­ vicios se especifica utilizando W SDL ( W eb S e rv ic e D escríp tío n L a n g ra g e, lo m a ­ j e d e descripción de servicios web) [w3.org, 22]. En la capa de mensajería, se in­ te rc a m b ia n m e n s a je s c o d ific a d o s e n XM L s ig u ie n d o e l p ro to c o lo SO AP www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 4 5 -► aplicación -< ■ descubrimiento de servicios descripción de servicios mensajería transporte red descubrim iento de servicios ► aplicación descripción de servicios mensajería transporte red J a b b e r es un protocolo abierto, basado en XML y utilizado para mensajería instantánea y asistencia |¡abber.org, 23]._________ F ig u ra 1 1 .2 2 . Jera rqu ía d e p ro to c o lo s de s e rv ic io s w e b . [mole.informatik.uni-stuttgart.de, 9; sun.com, 10; Edwards, 11]. En la capa de trans­ porte, HTTP sirve para transmitir peticiones y respuestas, se utilizan SM TP o Jab­ ber para transmitir mensajes y se utiliza TC P para transmitir los datos. Finalmente, el protocolo del nivel d e red es IP. La Figura 11.24 muestra la arquitectura software de un servicio web. El escuchador del servicio en la máquina servidora recoge las peticiones de servicios transmitidas sobre la red. Cuando se recibe una petición, se reenvía al proxy del servicio. El proxy invoca a la lógica de aplicación del objeto servicio y transmite el valor devuelto al llamante. Aunque todos los protocolos mencionados en la Figura 11.23 son d e interés, SOAP es particularmente importante para este estudio. El resto de este capítulo se centrará en el protocolo SOAP y sus aplicaciones. a p lic a c ió n d e s c u b rim ie n to de s e rv ic io s d e s c rip c ió n de s e rv ic io s m e n sa je ría tra n s p o rte red UDDI (U n ive rsa l D e s c rip tio n , D isco ve ry, and In te g ra tio n , D e s c rip c ió n , D e s c u b rim ie n to e In te g ra c ió n U n iversa le s). WSDL (Web S ervice D e s c rip tio n Language, L e n g u a je d e D e s c rip c ió n d e S ervicios W eb). XML, SOAP (S im ple O b je c t A ccess P ro to co l, P ro to c o lo S im p le de A cce so a O b je to s ). TCP, HTTP, SMTP, Jabber. IP. F ig u ra 1 1 .2 3 . P ro to c o lo s d e s e rvicio s w e b . www.FreeLibros.org 3 4 6 Computación distribuida. Fundamentos y aplicaciones Petición de servicio F ig u ra 11.24. A rq u ite c tu ra s o ftw a re d e se n /icio s w e b. 1 1 .4 . SOAP En los pasados capítulos se estudió el paradigma de objetos distribuidos, incluyendo dos protocolos/arquitecturas que soportan el paradigma: Java RMI y CORBA. SOAP es un protocolo que incorpora el paradigma de los objetos distribuidos y los protoco­ los de Internet. En concreto, es un protocolo que extiende HTTP para permitir acce­ so a objetos distribuidos que representan servicios web. La Figura 11.25 muestra el modelo para el protocolo simple d e acceso a objetos. Un cliente web manda una petición HTTP, cuyo cuerpo contiene un mensaje con for­ mato SOAP que representa la llamada a un método de un objeto d e servicio. La pe­ tición se transmite a un servidor web, que la reenvía, junto con los parámetros de la llamada a l método. A continuación se invoca e l método. Una vez completado, e l va­ lor devuelto por el método se envía al servidor w eb y a continuación se transmite al cliente w eb en e l cuerpo de la respuesta HTTP. ---------Servidor web nombre del método, lista de parámetros Cliente web ..... ► valor devuelto petición HTTP respuesta HTTP F ig u ra 1 1 .2 5 . B m o d e lo SOAP. Por razones de interoperabilidad, e l mensaje SOAP se codifica en XML. Cada men­ saje SOAP tiene un formato sencillo, como se representa en la Figura 11.26. Recubrim iento SOAP Cabecera SOAP Bloque de cabecera Bloque de cabecera K \\ / / Cuerpo SOAP Cuerpo del mensaje <D -Q F ig u ra 1 1 .2 6 . Esquem a d e un m ensaje d e p e tic ió n SOAP. www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 4 7 Cada mensaje SOAP se transporta en una petición o respuesta HTTP, tal como se explicará en las siguientes secciones. Una petición SOAP La Figura 11.27 muestra la sintaxis de una petición HTTP con una petición SOAP. Los elementos de la petición HTTP se describen en los siguientes párrafos. F ig u ra 1 1 .2 7 . U na p e tic ió n HTTP c o n un a p e tic ió n SO AP (Fuente: [so a p w a re .o rg , 11]). F D S T /e je m p lo s H T T P /1 .1 HTTP r e q u e s t l i n e U s e r - A g e n t: R a d io U s e r L a n d /7 .0 (W inN T ) ------ H D S t : l o c a l h o s t : 81 HTTP r e q u e s t h e a d e r l i n e s C b n t e n t - T y p e : t e x t / x m l ; c h a r s e t = u t f - 8 C b n t e n t - l e n g t h :4 7 4 ------------------------------------------------ Linea d e p etición HTTP L ín eas d e c a b e c e ra de la p e tició n H T T P Lín ea d e c a b e c e ra S O A P A c tio nSDAPAction: ''/ejemplos11 ----------------- <?xml version=\" 1.0\" ?> -------------------------- <SOAP-ENV:Envelope SOAP-ENV:encodingStyle= \"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns: SOAP-ENV=\" http: / /schemas. xmlsoap. org/soap/envelope/\" xmlns: xsd=\" http: / /www. w3 . org/1999 /XMLSchema\" xmlns: xsi=\" http: / /www. w3 . org/1999 /XMLSchema-instance\" > <SOAP-ENV:Body> ----------------------- < m :g e tS ta te N a m e x m ln s : m=\" h t t p : / /www. s o a p w a r e . o r g / \"> < n u m e sta d o x s i : t y p e = \"x s d : i n t \" > 4 l < / n u m e s t a d o > < /m : g e tS t a te N a m e > < / SOAP-ENV: B ody> -------------------------------------------------------------------- < /SOAP-ENV: E n v e lo p e > --------------------------------------------------------------------- R ecubri­ miento SOAP Líneas de ca b e c e ra de la petición H T T P El URI en la primera línea de la cabecera de petición HTTP debe especificar el ob­ jeto a l que se dirige la llam ada a método remoto. En el ejemplo 11.27, el objeto re­ moto es /ejemplos. Las líneas de cabecera User-Agent y Host se deben especificar. El Content Type debe especificarse como text/xml. El charset es una especifica­ ción de la representación de caracteres aceptada; por defecto es US-ASCII. Otras es­ pecificaciones charset que se aceptan son UTF-8 y UTF-16 , que son esquemas de co­ dificación Unicode. El Content Length, si está especificado, debe ser la longitud en bytes del cuerpo de la petición. La línea de cabecera SOAPAction especifica el objeto remoto al que se dirige la petición. La interpretación de este elemento de cabecera depende del programa. En la mayor parte de los casos, el URI (especificado en la primera línea de cabecera) y el SOAPAction tendrán el mismo valor. Cuerpo d e la petición HTTP www.FreeLibros.org 3 4 8 Computación distribuida. Fundamentos y aplicaciones Una estructura e s un tipo de estructura d e datos en C y s u derivado C++. También s e denomina registro.________________ F ig u ra 1 1 .2 8 . Una p e tició n S O A P (Fuente: [so a p w a re .o rg , 11]). <SQAP-ENV:Envelope SOAP-ENV:encodingStyle= \" http://schemas.xmlsoap.org/soap/encoding/\" xmlns:SOAP-ENC=\" http://schemas.xmlsoap.org/soap/encoding/\" xmlns: SOAP-ENV=\" http: / /schemas. xmlsoap. org/soap/envelope/\" xmlns: xsd=\" http: / /www. w3. org/1999 /XMLSchema\" xmlns :xsi =\" http://www.w3.org/1999/XMLSchema-instance\" > <SQAP-ENV:Body> I------------------- nom bre del m étodo ^------------- nom bre del servidor <m:obtenerNombreEstado xmlns:m =\" http: //www. s o asare. org/\"> <numestado xsi:type=\"xsd:int\">41</numestado> _________ </m: obtenerNonbreEstadO Parám etro n u m esta d o < /SOAP-ENV: B ody> ^ tipo ¡n t y v a lo r 41 < / SOAP-ENV: E n v e lo p e> El c u e rp o de la petición La Figura 11.28 destaca la sintaxis del cuerpo de la petición, que está codificada en XML. Hay dos partes en el cuerpo: e l recubrimiento SOAP y e l cuerpo SOAP. E l re a ib rím k n É o SOAP. Este recubrimiento SOAP se define con el elemento <SOAP-ENV:Envelope>. El elem ento tiene un conjunto de atributos requeridos que especifican el esquema de codificación y e l estilo del recubrimiento. E l c u e r p o S O A P . El cuerpo SO A P está definido con la etiq u eta <SOAP- ENV:Body>. El cuerpo SOAP contiene un solo elemento, que representa la llamada al método. Junto con el elemento se especifican el nombre del método (obtenerNom­ breEstado en el ejemplo), el nombre de cada parámetro (numestados en e l ejemplo), el valor de cada parámetro (41 en el ejemplo) y el tipo de datos d e cada parámetro. T ip o s de datos SOAP tiene un rico conjunto de tipos de datos independientes del lenguaje, que es­ tán basados en los tipos de datos de los esquemas XML. La descripción completa de los tipos de datos está fuera del alcance de este libro; los lectores interesados pueden ver [w3.org, 24]. La Tabla 11.8 resume un subconjunto de los principales tipos de datos escalares soportados por un subconjunto de SOAP 1.1. Los tipos de datos no escalares, incluyendo objetos, estructuras, matrices, vectores y enumerados, también están soportados en SOAP. Alguno de estos tipos se comentan en las siguientes secciones. E stru rtw a s. Un valor puede ser una estructura, que se especifica con un elemento XML que contiene subelementos. Las estructuras pueden estar anidadas y pueden con­ tener cualquier otro tipo de datos, incluyendo una matriz. A continuación se muestra un ejemplo de una estructura d e dos elementos: < param > c l i m i t e l n f e r i o r x s i : t y p e = \" x s d : i n t \" > 18 < / l i m i t e l n f e r i o r > d i m i t e S u p e r i o r x s i : t y p e = \" x s d : i n t \"> 1 3 9 < / l i m i t e S u p e r i o r > < /p a ra m > www.FreeLibros.org Aplicaciones d e Internet - Parte 2 Ta b la 1 1 .8 . T ip o s d e d a to s e sca la re s d e l e sq u e m a X M L (Fuente: [so a p w a re .o rg , 11]). Y b lo r d e l atributo T ip o E je m p lo xsd: int xsd:boolean xsd:string xsd:float o xsd:double xsd:timelnstant SOAP-ENC ibase€4 Entero con signo de 32-bit Valor booleano, 1 ó 0 Cadena de caracteres Número de coma flotante con signo Fecha^Hora Binario codificado en Base64 -12 1 Hola Mundo -12,214 200 l-03-27T00:00:01-08:00 e W9 lIGNhbidOIHJlY WQ gdGhpcyE= Los nombres de la estructura son significativos; el orden de los elementos no. M atrices, Un valor puede ser una matriz, que se especifica como un elemento XML con un atributo SOAP-ENC:arrayType cuyos valores comienzan con ur-type[<nú­ mero de elementos de la matriz>]. El siguiente es un ejem plo de una matriz de cuatro elementos: <param SOAP-ENC:arrayType=\"xsd:ur-type[4]\" xsi: type=\" SDAP-ENC: Array\" > <item xsi:type=\"xsd:int\">12</item> <item xsi: type=\" xsd: string\" >Egipto</ item> <item xsi:type=\"xsd:boolean\">0</itein> <item xsi:type=\"xsd:int\">-31</item> <param> El orden de los elementos de la matriz es significativo; el nombre de los elem en­ tos no. O b je to s Se puede transmitir un objeto en la petición/respuesta SOAP si el pro­ veedor del servicio define y registra el tipo del objeto como un subtipo, y las dos par­ tes proporcionan un señalizador y deserializador apropiado. A continuación el nom­ bre del subtipo se declara como el atributo xsi.type del parámetro. Una respuesta SOAP La Figura 11.29 muestra una respuesta HTTP que contiene una respuesta SOAP exitosa. La cabecera HTTP tiene el formato habitual. Obsérvese que el contení type es text/xml. F ig u ra 11.29. Una re sp u e sta HTTP q u e c o n tie n e un a re sp u e sta S O A P c o n é x ito (Fuente: [so a p w a re .o rg , 11]). HTTP/1.1 200 OK Qjnnection: cióse Cbntent-Length: 499 Cbntent-Type: text/xml; charset=utf-8 Date: Wed, 28 Mar 2001 05:05:04 GMT Server: UserLand Frontier/7.0-WinNT <?xml version=\"1.0\"?> 349 (continúa) www.FreeLibros.org 3 5 0 C om putación distribuida. Fundam entos y aplicaciones <SQAP-ENV: Envelope SOAPENV: encodingStyle=\" http: //schemas. xmlsoap. org/soap/encoding/\" xmlns: S0APENC=\" http://schemas.xmlsoap.org/soap/encoding/\" xmlns: SOAP-ENV=\" http: / /schemas. xmlsoap. org/soap/envelope/\" xmlns: x s d = \" http: / /www. w 3 . org/1999 /XMLSchema\" xmlns: x s i = \" http: / /www. w 3 . org/19 9 9 /XMLSchema-instance\" > <SQAP-ENV:Body> < m : obtenerNombreEstadoResponse xmlns: m = \" http: / /www. soapware. org/\" > <Result xs i :t y p e = \"xsd:st r i n g \">Dakota del Sur</Result> </m: obtenerNonbreEstadoResponse> </SOAP-ENV:Body> </ SOAP-ENV:Envelope> L a Figura 11.30 destaca la respuesta SOAP contenida en la respuesta HTTP. Como con la petición SOAP, la respuesta está compuesta de dos partes: e l recubrimiento y el cuerpo. La sintaxis del recubrimiento es la misma que con la petición. La sintaxis del cuer­ po también es análoga a la de la petición. El único elemento contenido en <SOAP- ENV:Body> tiene un nombre que coincide con el nombre del método que ha sido lla­ mado, con la palabra Response añadida al final del nombre del método (obtenerNombre Estado en el ejemplo). El tipo d e datos (string) y el valor (Dakota del Sur) del valor devuelto está contenido en el subelemento Result. F ig u ra 11.30. Una re sp u e sta SO AP (Fuente: [so a p w a re .o rg , 11]). <?xml version=\"1 .0\"?> <SOAP-ENV:Envelope SOAP-ENV: encodingStyle =\"http://schemas.xmlsoap.org /soap/encoding/\" xmlns: S0AP-ENC=\" http: / /schemas.xmlsoap. org /soap/encoding/\" xmlns: S0AP-ENV=\" http: / /schemas. xmlsoap. org /soap/envelope/\" xmlns: x s d = \" http: / /www. w 3 . org/19 9 9 /XMLSchema\" xmlns: x s i = \" http: / /www. w 3 . org/19 99 /XMLSchema-instance\" > <SQAP-ENV:Body> n o m b re d e l m é to d o | n o m b re d e l s e rv id o r <3n:obtenerNombreEstadoResponse xmlns :m=\" http: / /www. soapware .org/\" > <Result xsi:type=\"xsd:string\">Dakota del Sur</Result> va lo r </m:obtenerNombreEstadoResponse > devuelto </ SOAP-ENV:Body> </ SOAP-ENV:Envelope> Una llamada a método SOAP puede fallar, quizá debido a errores en la especifi­ cación del nombre del método o en los parámetros. Cuando una llamada a método no puede ser completada de forma satisfactoria, la respuesta HTTP (véase Figura 11.31) contiene un cuerpo SOAP que define un código y una cadena d e error. El código de error (SOAP-ENV:Client en el ejemplo) identifica el error, mientras que la cadena de error proporciona una descripción del mismo. www.FreeLibros.org Aplicaciones d e Internet - Parte 2 351 F ig u ra 1 1 2 1 . Una re sp u e sta HTTP q u e c o n tie n e una lla m a d a a m é to d o S O A P fa llid a (Fuente: [so a p w a re .o rg , 11]). HTTP/1 .1 500 S e r v e r E r r o r O o n n e c tio n : c i ó s e O o n te n t-L e n g th : 511 O o n te n t-T y p e : t e x t / x m l ; c h a r s e t = u t f - 8 t e t e : Wed, 28 Mar 2001 0 5 :0 6 :3 2 GMT S e r v e r : U serL and F ro n tie r /7 .0 - W in N T <?xml v e r s i o n = \" 1 .0 \" ? > <SOAP-ENV: E n v e lo p e SOAPENV: encodingStyle=\" http: //schemas. xmlsoap.org/soap/encoding/\" xmlns: SOAPENV=\" h t t p : / /s c h e m a s . x m ls o a p . o r g / s o a p / e n v e l o p e / \" x m ln s: x s d = \" h t t p : / /www .w 3. o r g / 19 9 9/XMLSchema\" x m ln s: x s i = \" h t t p : //www .w 3. o r g / 19 9 9 /X M L S ch em a-in sta n ce\" > <SOAP-ENV:Body> <SOAP-ENV:Fault> < f aultcode>SQ A P-EN V : C l i e n t < / f a u lt c o d e > < f a u lts tr i n g > N o s e p u ed e lla m a r a o b te n e rN o m b re E sta d o p o rq u e h ay d e m a sia d o s p a r á m e t r o s . < / f a u l t s t r i n g > </S0AP-ENV:Fault> </S0AP-ENV:Body> </ SOAP-ENV:Envelope> Apache SOAP Apache Axis es el paso siguiente de Apache SOAP [xml.apache.org, 20]. Es una reimplementación de Apache SOAP, presumiblemente con tiempos de ejecución mejorados.___________ La clase RPCMessage El API Apache SOAP proporciona una clase denominada RPCMessage que encapsu- la una petición SOAP. Un objeto de esta clase contiene las siguientes instancias de campos: targetObjectURI, methodName, param s y header, que representan los diver­ sos campos de una petición SOAP. La clase tiene métodos para establecer y recupe­ rar los valores de cada una de estos campos. La cla se Cali La clase Cali es una subclase de la clase RPCMessage y representa una llamada a método remoto. S e puede crear un objeto de esta clase en un programa cliente SOAP, Como se puede observar en las descripciones precedentes, escribir código para gene­ rar directamente la sintaxis XML para las peticiones y respuestas SOAP puede ser te­ dioso y propenso a errores. Por consiguiente, han aparecido numerosas API para SOAP que proporcionan la abstracción necesaria para facilitar la programación que compe­ te a las peticiones/respuestas SOAP. Entre los conjuntos de herramientas disponibles está Apache SO AP y Apache Axis para la programación en Java; y SOAP::Lite para programar en Perl. M icrosoft.NET tam bién soporta SOAP. El resto de esta sección proporcionará una visión general de la A PI Apache SOAP [xmethods.com, 12; 106.ibm.com, 13; xml.apache.org, 14; xml.apache.org, 15] p arala construcción de clientes y d e objetos de servicios. Primero se verán algunas clases importantes de Apache SOAP y luego se verán algunos códigos de ejemplo. www.FreeLibros.org que puede llamar al método invoke para realizar la llam ada a método remoto. La Tabla 11.9 presenta la especificación del método invoke. 3 5 2 C om putación distribuida. Fundam entos y aplicaciones T a b la 1 1 .9 . El m é to d o in vo ke d e la c la s e Cali. M éto d o D e sc rip c ió n public Response invoke (U RL url, String SOAPActionURI) throws SO APException Invoca esta llamada en e l URL especificado. La cla se Para m e te r Un objeto de la clase Parameter representa tanto parámetros como los valores de­ vueltos por una llamada a método. En el programa cliente, se crea un objeto d e esta clase por cada parámetro de método remoto, invocando al constructor de esta clase, cuya especificación se muestra en la Tabla 11.10. En el servidor, se construye un ob­ jeto de esta clase para el valor devuelto. T a b la 1 1 .1 0 . El c o n s tru c to r d e la c la s e P aram eter. C o n s tru c to r D e sc rip c ió n public P áram eter(String ñame, Class type, Object valué, String encodingStyleU RI) Crea un objeto P aram eter con el nombre, tipo de datos, valor y estilo de codificación dados. La cla se Response Un objeto de la clase Response representa la respuesta d e una llam ada a método. Tan­ to e l cliente como el servidor utilizan objetos Response para representar el resultado de una invocación a método. El servidor crea la respuesta. El cliente extrae informa­ ción de la respuesta. En la Tabla 11.11 se presentan los principales métodos de la cla­ se Response. T a b la 11.11. M é to d o s p rin cip a le s d e la c la s e R e s p o n s o . M éto d o D e sc rip c ió n public P aram eter getR etum V aluef ) public boolean generatedFaultf ) public F ault getFaultO Este método se invoca desde los clientes para recibir el valor devuelto de una llamada a método. Este método se invoca desde los clientes para ver si una llamada a método ha generado un error. Este método puede ser invocado por un cliente para analizar el error que causó al fallo de la llamada a método. La cla se Fault Un objeto de la clase F ault representa e l contenido y la semántica del elemento <SOAP-ENV:Fault>, y lo devuelve el método getFault ejecutado por el cliente. En www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 5 3 el código de ejemplo, el método getFaultString (Tabla 11.12) se invoca desde un clien­ te para recibir la descripción del error que causó el fallo de la llamada a método. Ta b la 11.12. El m é to d o g etF a u ltS trin g de la c la s e Fault. Método Descripción public String getF aultStringf ) Devuelve una cadena que contiene una descripción breve del error que causó el fallo de la llamada a método. Servicios w e b ya im plem entados La idea de los servicios w eb es permitir a los desarrolladores de software hacer uso de servicios ya implementados. Como se puede imaginar, estos servicios irán desde servicios lucrativos proporcionados por proveedores comerciales (tales como valida- dores de tarjetas de crédito) hasta servicios gratuitos proporcionados por la comuni­ dad de usuarios (tales como juegos en red o traducciones). Actualmente hay disponibles un cierto número de servicios w eb para aquellos que estén interesados en experimentar con la tecnología. En [xmethods.net, 16] se pro­ porciona una lista de estos servicios, muchos de los cuales están accesibles utilizan­ do el API Apache SOAP. En la Figura 11.32 se muestra un ejemplo de servicio descrito en [xmethods.net, 16]. F ig u ra 1 1 3 2 . D e scrip ció n d e un e je m p lo d e s e rv ic io w e b ya im p le m e n ta d o . X M ethods ID 8 S e r v i c e O w n e r : x m e t h o d s .n e t G o n ta c t E m a i l : s u p p o r tG x m e th o d s . n e t S e r v i c e Home P a g e : C e s c r i p t i o n : C u r r e n t t e m p e r a t u r a i n a g i v e n U .S . z i p c o d e r e g i ó n . 93AP I m p l e m e n t a t i o n : A p a c h e SOAP Con cada servicio listado en [xmethods.net, 16] se proporciona un perfil como en mostrado en la Figura 11.33. F ig u ra 1 1 3 3 . D e scrip ció n d e un e je m p lo d e s e rv ic io w e b y a im p le m e n ta d o . M ethod Ñ am e getT em p Ehdpoint URL h t t p : / / S e r v i c e s . x m e t h o d s . n e t : 80/ s o a p / s e r v l e t / r p c r o u t e r SO A PA ction M ethod N am espace URI u r n : x m e th o d s - T e m p e r a t u r e In p u t Param eters z i p c o d e s t r i n g O utput Param eters r e t u r n f l o a t El perfil contiene información para invocar al servicio, incluyendo el URL del ob­ jeto de servicio (http://services.xmethods.net:80/soap/servlet/rpcrouter, en el ejemplo), el nombre del método (getTemp, en este caso) o métodos proporcionados por el ser­ vicio y los parámetros (un string) y valor devuelto (un float) del método. www.FreeLibros.org 3 5 4 C om putación distribuida. Fundam entos y aplicaciones Invocación de un servicio w e b utilizando A pache SOAP La figura 11.34 muestra el código d e ejem plo de un programa que invoca a un ser­ vicio SOAP. En las líneas 1.6, e l programa cliente importa los diversos paquetes requeridos por Apache/SOAP. Para prepararse para la invocación de un método proporcionado por el servicio web, el programa instancia el objeto Cali y asigna valores a sus campos uti­ lizando los métodos del objeto (líneas 26-34): C a l i c a l i = new C a l i ( ) ; / / p r e p a r a r l a i n v o c a c i ó n d e l s e r v i c i o c a l i . s e t E n c o d i n g S ty l e U R I ( C o n s t a n t s .NS_URI_SOAP_ENC ) ; c a l i . s e t T a r g e t O b j e c t U R I ( \" u r n : x m e t h o d s - T e m p e r a t u r e \" ) ; c a l i . s e tM e th o d N a m e ( \" g e tT e m p \" ) ; El método setTargetObjectURI se especifica con un URI que identifica el objeto de servicio SOAP en la máquina remota. En e l ejemplo, el URL es el listado en Method Namespace de la Figura 11.33. Para preparar los argumentos para la invocación, se instancia un objeto de la cla­ se Parameter para cada parámetro. Cada objeto Parameter se inicializa con el nom­ bre, e l tipo de datos, e l valor y el estilo de codificación del argumento (que por de­ fecto es nulf), como en las líneas 37-38: P a r a m e te r a P a ra m = new P a r a m e t e r ( \" z i p c o d e \" , S t r i n g . c l a s s , z i p c o d e , n u i l ) ; El parámetro nombre (zipcode) y el tipo de datos (String.class) se lista en la des­ cripción del servicio mostrada en la Figura 11.33. Por simplicidad, el valor del pará­ metro de entrada se escribe directamente en la línea 14 del código de ejemplo, pero podría ser obtenido en tiempo de ejecución. La lista de parámetros se recoge en un vector (líneas 39-40): V e c t o r p a ra m s = new V e c t o r ( ) ; p a r a m s . addE le m e n t ( a P a ra m ) ; Y a continuación se asocia e l vector al objeto Cali (línea 41): c a l i . s e t P a r a m s (p a r a m s ) ; Para realizar la llamada a método del servicio web, se especifica el método invo- ke() del objeto Cali en el URL (línea 44): R e s p o n s e r e s p o n s e = c a l i . i n v o k e ( u r l , donde url se refiere a un objeto de la clase Java URL, instanciado con el servicio web URL (líneas 12-13): URL u r l = new U R L (\"h t t p : / / l o c a l h o s t : 8 0 8 0 / s o a p / s e r v l e t / r p c r o u t e r \" ) ; El URL se puede encontrar en la descripción del servicio web (listado como End- point URL en la Figura 11.33). L a invocación del método debe ser chequeada en bus­ ca de errores (líneas 47-53), y, si no hay ninguno, el valor devuelto puede ser utili­ zado en el procesado del resto del programa (líneas 57-59). F ig u ra 11.34. Un e je m p lo d e c lie n te de s e rv ic io w e b . 1 i m p o r t j a v a . i o . * ; 2 i m p o r t j a v a . n e t . * ; 3 i m p o r t j a v a . u t i l . * ; ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 5 5 4 i m p o r t o r g . a p a c h e . s o a p . u t i l . x m l . * ; 5 i m p o r t o r g . a p a c h e . s o a p . * ? 6 i m p o r t o r g . a p a c h e . s o a p . r p c . * ; 7 8 p u b l i c c l a s s T e m p C lie n t{ 9 10 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 11 t r y { 12 URL u r l = new URL( 13 h t t p : / / s e r v i c e s . x m e th o d s . co m : 80 / s o a p / s e r v l e t / r p c r o u t e r ; 14 S t r i n g z ip c o d e = ''9 3 4 2 0 \" ; 15 f l o a t te i r p = g e t T e m p ( u r l , z i p c o d e ) ; 16 S y s t e m . c u t . p r i n t l n (\" L a t e m p e r a t u r e e s \" + t e m p ) ; 17 } 18 c a t c h (E x c e p t i o n e ) { 19 e . p r i n t S t a c k T r a c e ( ) ; 20 } 21 } / / f i n m a in 22 23 p u b l i c s t a t i c f l o a t getT esnp (URL u r l , S t r i n g z i p c o d e ) 24 t h r c w s E x c e p t i o n { 25 26 C a l i c a l i = new C a l i ( ) ; 27 28 / / E s p e c i f i c a c i ó n d e l a c o d i f i c a c i ó n SOAP 29 S t r i n g e n c o d in g S ty le U R I = C o n s t a n t s . NS_URI_SOAP_ENC ; 30 c a l i . s e t E n c o d i n g S t y l e U R I ( e n c o d in g S t y le U R I ) ; 31 32 / / E s t a b l e c e r l o s p a r á m e t r o s d e l o c a l i z a c i ó n d e s e r v i c i o s 33 c a l i . s e t T a r g e t O b j e c t U R I ( \" u r n : x m e t h o d s - T e m p e r a t u r e \" ) ; 34 c a l i . se tM e th o d N a m e ( \" g e tT e m p \" ) ; 35 36 / / C r e a r v e c t o r d e p a r á m e t r o s 37 P a r a m e t e r a P a ra m = 38 new P a r a m e t e r ( \" z i p c o d e \" , S t r i n g . c l a s s , z i p c o d e , n u i l ) ; 39 V e c t o r p a ra m s = new V e c t o r ( ) ; 40 p a r a m s . a d d E le m e n t ( a P a r a m ) ; 41 c a l l . s e t P a r a m s ( p a r a m s ) ; 42 43 / / I n v o c a r a l s e r v i c i o 44 R e s p o n s e r e s p = c a l l . i n v o k e ( u r l , \" \" ) ; 45 46 / / P r o c e s a r l a r e s p u e s t a 47 i f ( r e s p . g e n e r a t e d F a u l t ( ) ) { 48 / / L a ll a m a d a n o f u e s a t i s f a c t o r i a 49 F a u l t f = r e s p . g e t F a u l t ( ) ; / / h u b o u n e r r o r 50 S y s t e m . e r r . p r i n t l n ( \" F a u l t = \" + f . g e t F a u l t C o d e ( ) + 51 \" , \" + f . g e t F a u l t S t r i n g ( ) ) ; (continúa) www.FreeLibros.org 3 5 6 C om putación distribuida. Fundam entos y aplicaciones 52 t h r c w new E x c e p t i o n ( f . g e t F a u l t S t r i n g ( ) ) ; 53 > 54 e l s e { 55 / / L a ll a m a d a f u e s a t i s f a c t o r i a 56 / / E x t r a e r e l v a l o r d e v u e l t o y d e v o l v e r e l r e s u l t a d o 57 P a r a m e t e r r e s u l t = r e s p . g e t R e t u r n V a l u e ( ) ; 58 F l o a t readC X it= ( F l o a t ) r e s u l t . g e t V a l u e ( ) ; 59 r e t u r n r e a d O u t . f l o a t V a l u e ( ) ; 60 } 61 } / / f i n g etT em p 62 63 } / / f i n c l a s s Im plem entación de un servicio w eb utilizando A pache SOAP Un servicio w eb se define utilizando una interfaz de Java, que contiene las declara­ ciones de los métodos proporcionados por el servicio. La Figura 11.35 muestra la in­ terfaz TTemp para un servicio w eb de ejemplo, Temp, que proporciona el método getTemp llamado por nuestro cliente en ejem plo en la Figura 11.34. F i g u r a 1 1 .3 5 . Una in te rfa z Java para un s e rv ic io w e b sencillo. 1 / / Un e j e i r p l o d e i n t e r f a z d e o b j e t o d e s e r v i c i o SOAP. 2 / / E s t e m é to d o a c e p t a u n a c a d e n a c o n e l c ó d i g o p o s t a l 3 / / y d e v u e l v e l a t e m p e r a t u r a d e l á r e a . 4 5 p u b l i c i n t e r f a c e ITem p 6 { 7 f l o a t g e t T e m p ( S t r i n g z i p C o d e ) ; 8 9 } / / f i n i n t e r f a c e La interfaz del servicio web se implementa como una clase de Java. L a Figura 11.36 muestra una definición de ejem plo de la clase Temp, que implementa la inter­ faz ITemp. Por simplicidad se devuelve un valor fijo. F ig u ra 11.36. Im plem entación de un servicio w e b sencillo. 1 // Un ejeirplo de implementación de objeto de servicio SOAP 2 3 public class Teirp implements ITemp 4 { 5 public float getTemp(String zipCode) 6 { 7 System.out.println(\"Temperatura para el 8 código postal \" + zipCode + \" solicitado.\"); 9 return 7 4 . 5F; // devuelve una constante por simplicidad ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 5 7 11 } / / f i n g e tT e m p 12 13 } / / f i n c l a s s 10 Un servicio SOAP necesita ser instalado y configurado en la máquina servidora. Este procedimiento depende de la implementación. Para Apache SOAP, se puede en­ contrar información en las referencias [xmethods.com, 12] y [xml.apache.org, 14]. ummi Este capítulo ha presentado tres protocolos y mecanismos de aplicaciones de Internet. Apple ts • Un applet es una clase Java cuyo código se descarga desde el servidor web y ejecuta en el entorno del navegador en la máquina cliente. • Un navegador solicita un applet cuando escanea una página web y encuentra una clase especificada en la etiqueta APPLET. • Por razones de seguridad, la ejecución de un applet está expuesta a restriccio­ nes: por definición, un applet no puede acceder a ficheros del sistema de fi­ cheros d e la máquina cliente o hacer conexiones de red a otra máquina que no sea de la que proviene. Servlets • Un servlet es una extensión de un servidor petición-respuesta. Un servlet HTTP es, como un script CGI, una extensión de un servidor HTTP. • Un servlet HTTP es una clase Java cuyo código se carga en un contenedor de servlets en la máquina servidora y que se inicia por e l servidor HTTP en res­ puesta a una petición HTTP del servlet. • Al contrario que los script CGI, un servlet HTTP es persistente: un script CGI se recarga cada vez que un cliente lo solicita, mientras que una sola instancia del servlet ejecutará al menos mientras haya peticiones que lo soliciten. • Para la programación de servlets: la clase HTTPServletRequest encapsula una petición HTTP, mientras que la clase HTTPServletResponse encapsula la res­ puesta. • Para el mantenimiento de la información de estado, un servlet puede utilizar los mecanismos disponibles para los scripts CGI, tales como campos ocultos o cookies. Además, la información d e estado se puede mantener con los siguien­ tes mecanismos: — Las variables servlets pueden almacenar datos globales. — Se puede crear y mantener, en la máquina donde está ejecutando e l servlet, un objeto session que contenga objetos de datos de sesión. www.FreeLibros.org 3 5 8 C om putación distribuida. Fundam entos y aplicaciones Protocolo sim ple de acceso a objeto • SOAP es un protocolo que hace uso d e las peticiones y respuestas HTTP para efectuar llamadas a métodos remotos en servicios web. • Una llamada a método SOAP se embebe en una petición HTTP y se codifica en XML; el valor devuelto se embebe en una respuesta HTTP y se codifica con XML. • Existen varias API de SOAP disponibles para programación de servicios web y llam adas a métodos. En este capítulo se ha introducido el API Apache. E JE R C IC IO S Nota: alguno de estos ejercicios requiere un servidor web que soporte applets y serv­ lets. Para los ejercicios de programación de servlets, es posible descargar e instalar el Apache Tomcat Server [apache.org, 18] o el servidor Java JSWDK. Ejercicios de Applets 1. Instale HolaMundo.html y HolaMundo.class (compilado d e HolaMundo.java) en un servidor web en el que tenga acceso. Si el servidor es una máquina UNIX, asegúrese de poner los permisos de lectura y ejecución universales a estos ficheros. Utilice un navegador para acceder a HolaMundo.html. Descri­ ba la salida y explique los eventos que suceden para llevar a este resultado. 2. Modifique NetCoruteetApplet.java para reemplazar el nombre de la máquina www.alpha.edu por el servidor web que está utilizando para estos ejercicios. Instale miApplet.html y NetCormectApplet.class (compilado de NetConnectAp- plet.java) en e l servidor web. Utilice su navegador para abrir miApplet.html. ¿Realizó el applet la conexión socket de forma satisfactoria? 3. Vuelva a modificar NetConnectApplet.java para reemplazar e l nombre de la máquina www.beta.edu por otro servidor web. Compile y guarde la nueva ver­ sión en el servidor w eb que utilizó en el ejercicio 2. Utilice su navegador para abrir miApplet.html. ¿Realizó el applet ambas conexiones socket de forma sa­ tisfactoria? Describa y explique los resultados. 4. ¿Cuáles son las dos restricciones de seguridad de los applets comentadas en este capítulo? Para cada de una de las restricciones, explique por qué es necesaria. Ejercicios genéricos de servlets 1. Rellene la siguiente tabla para comparar los servlets con los applets. Applet Servlet Lenguaje de programación. ¿Cuál e s la clase base de la que debe heredar la clase applet/servlet? Soporte software necesario para ejecutar el programa (en el servidor). ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 5 9 A pplet Servlet Soporte software necesario para ejecutar el programa (en el cliente). ¿Dónde se ejecuta el programa, en el cliente o en el servidor? Esboza un código de la petición HTTP para invocar al programa. ¿Cómo se carga el programa para la ejecución? Muestra un buen uso de este tipo de programa en una aplicación web. Restricciones, si hay, en este tipo de programa (por razones de seguridad). Liste otras diferencias. 2. Rellene la siguiente tabla para comparar y contrastar los servlets con los scripts CGI. Servlets Scripts C G I Lenguaje(s) de programación. Soporte software requerido para ejecutar e l programa. Esboza un código de la petición HTTP para invocar al programa. ¿Cómo se carga el programa para la ejecución? ¿Es persistente e l programa? (Es decir, ¿se ejecuta múltiples veces la misma instancia?) Nombre lo s mecanismos que pueden ser utilizados para mantener los datos de sesión. Liste otras diferencias. Ejercicios de program ación con servlets Los ficheros de programa de estos ejercicios se pueden encontrar en el directorio servlets\\simple de los ejemplos de este capítulo. 1. Inicie el servidor Apache Tomcat [jakarta.apache.org, 6] si no está iniciado en su computador. Pruebe el servlet de ejem plo que viene con el servidor, intro­ duciendo la siguiente dirección: h t t p : / / c n a n b r e s e r v i d o r w e b > :8 0 8 0 Elija e l enlace Servlet Examples. S e verá un conjunto d e servlets de ejemplo; para cada uno de ellos se puede ver el código o se puede ejecutar. Mire el có­ digo fuente de cada uno de ellos y ejecútelos. Fíjese en la ruta URL que se muestra en e l navegador cuando se ejecuta el servlet: esta es la ruta URL que deberá especificar en sus servlets. En el servidor A pache Tomcat, la ruta por defecto es http://localhost:8080/exam ples/servlet/. Por ejem plo, abrir http://localhost:8080/exam ples/servlet/HelloW ord ejecutará el servlet Hello- WorldExample. www.FreeLibros.org 3 6 0 C om putación distribuida. Fundam entos y aplicaciones 2. Cree un directorio en su PC y copie los ficheros del directorio servlets\\simple. Compile HelloWorld.java y Counter2.java. Después cópielos en el directorio de las clases servlet. (En el servidor Apache Tomcat, e l directorio por defec­ to d e la s clases serv le t es T O M C A T _H O M E \\w ebapps\\exam ples\\W E B - INFVclasses). a. Utilice el navegador para ejecutar e l servlet HelloWorld. b. Para verificar que los servlet se pueden ejecutar en una máquina servidora que no es el localhost, utilice el navegador de su sistema para ejecutar el servlet HelloWorld en el sistema d e su profesor o de sus compañeros. c. Compile e l fichero Counterl.java, e instale el fichero con la clase resul­ tante C ounterl.class en el directorio de servlets. A continuación acceda a él utilizando la ruta URL del servlet. Refresque el navegador repetidamen­ te para ejecutar el servlet C ounterl varias veces. Describa y explique e l va­ lor del contador mostrado por el navegador en las ejecuciones. d. Abra otro navegador y acceda al servlet Counterl. Describa y explique el valor del contador mostrado por el navegador. e. Cierre las ventanas del navegador. A continuación abra un nuevo navega­ dor y acceda al servlet Counterl. Describa y explique el valor del conta­ dor mostrado por e l navegador. f. Pare el servidor y rem ídelo. A continuación refresque la pantalla del nave­ gador de forma que el servlet C ounterl se reejecute. Describa y explique el valor del contador mostrado por e l navegador. g. Basándose en los experimentos con e l Counterl, describa el tiempo de vida d e un servlet en el entorno del servidor Jakarta Tomcat. h. Modifique C ounterl .java para que el valor del contador se incremente en 2 unidades cada vez. Recompile e instale el fichero clase. (Nota: en algu­ nos servidores, tales como el JSWDK, se debe apagar e l servidor y vol­ verlo a iniciar antes de que el nuevo servlet surta efecto). Demuestre el cambio realizado. j. Compile GetForm.java y PostForm.java. Instale los ficheros de clase re­ sultantes en e l directorio de los ficheros de clase del servidor. k. Abra las páginas GetForm.html y PostForm.html. ¿Ejecutan los servlet co­ rrectamente? Compare las salidas, incluyendo el URL mostrado en e l na­ vegador, con las generadas utilizando scripts CGI. 3. Escriba un formulario web HTML y su servlet para realizar un control de ac­ ceso sencillo en su página web. La página mostrada debería tener el siguiente aspecto: P o r fa v o r, identifiqúese: N o m b re | Contraseña \\~ Enviar I www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 6 1 Si los datos de la cuenta (por ejemplo: nombre Pepe y contraseña «12345») se introducen correctamente, tu página web debe ser mostrada; en caso con­ trario, se mostrará un mensaje de «Datos inválidos». Instale el servidor y prué­ belo. (Nota: para acceder a su página web después d e que la contraseña haya sido verificada, el servlet necesitará escribir la siguiente línea: <htm l><head><M ETA HTTP-EQUIV=\" REFRESH\" CONTENT=\" 0 ; U R L = < url d e SU p á g i n a w e b > \" x / h e a d x / h t m l > No se olvide de que un carácter con comillas dobles en una cadena nece­ sita ser precedido de una barra inversa. Realice el código fuente de su servlet. Utilización de cookies con los servlets Nota: asegúrese d e abrir una sesión nueva del navegador cuando ejecute o reejecute cualquiera de los siguientes experimentos, ya que las cookies generadas en una sesión persistirán a lo largo de la misma. 1. Copie los ficheros del directorio servletsVookies a un directorio. 2. Comente la sentencia que redirige el servlet Cart2 a l final de Cart.java. 3. Compile e instale el servlet Cart. Abra Cart.html y seleccione «naranja». Ve­ rifique la salida mostrada al enviar el formulario. 4. Deshaga los cambios del paso 2 para que el servlet Cart se redirija a Cart2. Compile e instale el servlet Cart2. Abra Cart.html. Seleccione un elemento. Verifique que el elemento está en el carrito de la compra. Abra Cart2.html y verifique que el carrito de la com­ pra se muestra correctamente. Utilice el botón de regreso de su navegador para volver a Cart.html. S e­ leccione otro objeto. Verifique d e nuevo su carrito de la compra. Utilice d e nuevo e l botón de regreso de su navegador para volver a Cart.html. Seleccione el último elemento. Verifique su carrito de la compra de nuevo. Describa y explique sus comentarios. 5. Descomente la llamada al método setMaxAge en Cart.java para que las cookies generadas no sean transitorias. Compile y reinstale el servlet Cart. Abra dos sesiones de navegador diferentes y acceda a Cart.html en cada una de ellas. Seleccione un objeto en la primera sesión, envíelo, y seleccione un objeto d i­ ferente en la segunda sesión. Envíe la segunda página. Describa y explique sus observaciones. Para librarse de las cookies no transitorias: modifique el método setMaxAge y ponga su argumento a 0. Compile y reinstale e l servlet Cart. Abra una nue­ v a sesión del navegador y acceda a Cart.html. Seleccione los tres objetos. Cuan­ do envíe el formulario debería ver e l carrito vacío. 6. Quite el comentario del método setMaxAge en Cart.java para que las cookies generadas no sean transitorias. Modifique el formulario web y servlets para (i) permitir al usuario elegir la cantidad de cada objeto a comprar (por ejemplo, 4 naranjas), y (ii) incluya en la salida el precio total de los objetos del carri­ to de la compra. www.FreeLibros.org 3 6 2 C om putación distribuida. Fundam entos y aplicaciones Forma de actuar sugerida: a. Modifique Cart.html para añadir un campo de entrada para la cantidad de cada objeto, como sigue: <TR> <TD ALIGN=\" c e n t e r \" x i n p u t T Y PE =\"C heckbox\" NAME= \" ite m _ a \" V A L U E =\"apple $ l \" x / T D > <TD ALIGN=\" l e f t \" > a p p le < /T D > <TD ALIGN=\" l e f t \" >How m any? < i n p u t n am e= \" q u a n t i t y _ i t e m _ a \" x / T D > </TR> Acceda a la página modificada para asegurarse de que la salida es correcta. b. Segundo, modifique Cart.java d e forma que la cantidad introducida en cada objeto seleccionado sea adjuntada en e l comienzo del valor de la cookie. Por ejemplo: 10 apple $1, s i se han seleccionado 10 apples. Descomente de forma temporal la última sentencia (la redirección) en Cart.java de forma que pueda verificar la cadena generada para cada valor d e la cookie. c. Modifique Cart2.java. Para cada valor de la cookie, obtenga la cantidad y el precio. Mantenga una sum a acumulativa del precio total. Imprima la sa­ lida cuando se hayan procesado todas las cookies. El código recomendado para recoger el valor de cada cookie es el si­ guiente: t r y { v a l u é = c o o k i e s [ i ] . g e t V a l u e ( ) ; o u t . p r i n t l n ( \" < L I > \" + v a l u é ) ; s t = new S t r i n g T o k e n i z e r (v a l u é ) ; q j a n t i t y = I n t e g e r . p a r s e l n t ( s t . n e x t T o k e n ( ) ) ; s t . n e x tT o k e n ( \" $ \\ n \" ) ; p r i c e = I n t e g e r . p a r s e l n t (s t . n e x tT o k e n ( ) ) ; / / a ñ a d i r c ó d i g o p a r a i m p r i m i r / / v a l o r d e l a c o o k i e y p r o c e s a r / / l a c a n t i d a d d e e l e m e n t o s y e l / / v a l o r d e l o s e l e m e n t o s } c a t c h ( E x c e p t i o n e x ) / / e x c e p c i ó n f o r m a t o n ú m ero { } / / s e n c i l l a m e n t e s e s a l t a e s t e e le m e n to Utilización de un objeto session con servlets Nota: asegúrese de abrir una sesión nueva del navegador cuando ejecute o reejecute cualquiera de los siguientes experimentos, ya que las objeto session generados en una sesión persistirán a lo largo d e la misma. 1. Copie los ficheros del directorio servlets\\session a un directorio. 2. Comente la sentencia que redirige al servlet Cart2 al final de Cart.java. 3. Compile e instale el servlet Cart. Abra Cart.html y seleccione naranja. Verifi­ que la salida mostrada al enviar el formulario. Averigüe si se puede verificar la salida mirando el código d e Cart.java. www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 6 3 4. Deshaga los cambios del paso 2 para que el servlet Cart se redirija a Cart2. Compile e instale el servlet Cart2. Abra Cart.htm i Seleccione un elemento. Verifique que el elemento está en el carrito de la compra. Abra Cart2.html y verifique que el carrito de la com­ pra se muestra correctamente. Utilice el botón de regreso de su navegador para volver a Cart.htmi. S e­ leccione otro objeto. Verifique d e nuevo su carrito de la compra. Utilice d e nuevo e l botón de regreso de su navegador para volver a Cart.htmi. Seleccione el último elemento. Verifique su carrito de la compra de nuevo. Describa y explique sus comentarios. ¿Qué encuentra diferente respec­ to a l apartado 4 del anterior conjunto de problemas, cuando se utilizaban las cookies para almacenar el contenido del carrito de la compra? Abra dos sesiones de navegador diferentes y acceda a Cart.htmi en cada una de ellas. Seleccione un objeto en la primera sesión, envíelo, y seleccione un objeto diferente en la segunda sesión y envíelo. 5. Describa y explique sus observaciones. ¿Qué encuentra diferente respecto al apartado 5 del anterior conjunto de problemas, cuando se utilizaban las coo­ kies para almacenar el contenido del carrito d e la compra? 6. Modifique el formulario w eb y servlets para (i) permitir al usuario elegir la cantidad de cada objeto a comprar (por ejemplo, 4 naranjas), y (ii) incluya en la salida el precio total de los objetos del carrito de la compra. Forma de actuar sugerida: a. Modifique Cart.htmi para añadir un campo de entrada para la cantidad de cada objeto, como sigue: <TR> <TD ALIGN=\"c e n t e r \" XTNPUT T Y PE =\"C heckbox\" N A M E=\"item _a\" V A L U E =\"apple $ l \" x / T D > <TD ALIGN=\" l e f t \" > a p p le < /T D > <TD ALIGN=\" l e f t \" >How m any? < i n p u t nam e= \" q u a n t i t y _ i t e m _ a \" x / T D > </TR > Acceda a la página modificada para asegurarse de que la salida es correcta. b. Cree una clase denominada Item, que tiene los siguientes datos de instan­ cia: nombre del elemento, precio y cantidad. ¡tem.Java se proporciona en el mismo directorio. Compile y mueva Item.class al directorio donde resi­ den los ficheros con las clases servlet. c. Modifique Cart.java para que cada selección se recoja en una referencia a un objeto Item que sea añadido al vector de elementos. Comente temporal­ mente la última sentencia (la redirección) en Cart.java para que pueda ver los valores de los objetos que se están añadiendo a l objeto session. Aquí está el código sugerido: w h i l e ( k e y s .h a s M o r e E le m e n ts ( ) ) { ñam e = (S t r i n g ) k e y s . n e x t E l e m e n t ( ) ; p r e f i x = ñ am e. s u b s t r i n g ( 0 , 4 ) ; o u t . p r i n t l n ( \"nam e=\" + ñam e + ''p r e f i x = '' + p r e f i x ) ; (continúa) www.FreeLibros.org 3 6 4 Computación distribuida. Fundamentos y aplicaciones i f ( p r e f i x . e q u a l s ( \" i t e m \" ) ) { q j a n t i t y N a m e = \" q u a n t i t y _ \" + ñ am e; o u t . p r i n t l n ( \" q u a n tity N a m e = \" + q u a n ti ty N a m e ) ; q i a n t i t y = r e q u e s t . g e t P a r a m e t e r ( q u a n t i t y N a m e ) ; / / a ñ a d i r e le m e n to a l a l i s t a d e e l e m e n t o s v a l u é = r e q u e s t . g e t P a r a m e t e r ( ñ a m e ) ; s t = new S t r i n g T o k e n i z e r (v a l u é ) ; ñame = s t . n e x t T o k e n ( \" $ \\ n \" ) ; p r i c e = s t . n e x t T o k e n ( ) ; o u t . p r i n t l n ( \" a d d i n g nam e= \" + ñam e + \" p r i c e = \" + p r i c e + \"q u a n t i t y = \" + q u a n t i t y ) ; i t e m s .a d d ( n e w I t e m ( ñ a m e , I n t e g e r . p a r s e l n t ( p r i c e ) , I n t e g e r . p a r s e l n t ( q u a n t i t y ) ) ) ; O D unt++; > / / f i n i f > / / f i n w h i l e Compile e instale el servlet Cart. Cuando esté satisfecho con la salida, descomente el método de redirección a l final de Cart.java. d. Modifique Cart2.java. Para cada objeto Item recibido del objeto de sesión, extraiga el precio de la unidad y la cantidad. Mantenga una sum a del pre­ cio total hasta el momento. Imprima la sum a total cuando todos los obje­ tos Item hayan sido procesados. Aquí está el código sugerido: f b r ( i n t i = 0 ; i < c o u n t ; i + + ) { n e x t l t e m = ( I t e m ) i t e r a s . g e t ( i ) ; c u t . p r i n t l n ( \" < L I > \" + i + \" \" + n e x t l t e m . t o S t r i n g ( ) ) ; t o t a l -h= n e x t l t e m . g e t P r i c e ( ) * n e x t l t e m . g e t ( * i a n t i t y ( ) ; } Compile e instale el servlet Cart2. Abra Cart.html y verifique la salida. 7. Considere la utilización d e objetos session para almacenar datos de sesión. ¿Por qué no es necesario utilizar exclusión mutua para proteger la recuperación y actualización del objeto session? Ejercicios SOAP 1. Acceda a la página http://www.xmethods.net/ [xmethods.net, 16]. Elija uno de los servicios con estilo RPC y escriba un cliente Java que utilice el API A pa­ che SOAP para llamar al servicio y mostrar el resultado devuelto. Entregue el código fuente. 2. Considere la siguiente petición HTTP [soapware.org, 11]: PDST /e x a m p le s H T T P/1 .1 L b e r - A g e n t: R a d io U s e r L a n d /7 .0 (WinNT) HDSt: l o c a l h o s t : 8 1 C b n te n t - T y p e : t e x t / x m l ; c h a r s e t = u t f - 8 ( t o n t e n t - l e n g t h : 474 ( continúa) www.FreeLibros.org Aplicaciones d e Internet - Parte 2 3 6 5 S O A P A ctio n : \" / e x a m p l e s \" < ?x m l v e r s i o n = \" 1 . 0 \" 7 > <SOAP-ENV:Envelope SOAPENV: encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:SOAP-ENC=\"http: / /schemas .xmlsoap.org/soap/encoding/\" xmlns:SOAPENV=\" h t t p : / / s c h e m a s . x m l s o a p . o r g / s o a p / e n v e l o p e / \" x m ln s : x s d = \" h t t p : / /www. w 3 . o r g / 199 9 /X M ISchem a\" x m ln s : x s i = \" h t t p : / /www. w 3 . o r g / 199 9 /X M I S c h e m a - in s ta n c e \" > <SOAP-ENV:Body> < m : g e t S t a t ú a m e x m ln s : m=\" h t t p : / /www. s o a p w a r e . o r g / \" > < s ta te n u m x s i : t y p e = \" x s d : i n t \">4 l < / s t a t e n u m > < /m : g e tS ta te N a m e > </SOAP-ENV:Body> </ SOAP-ENV :Envelope> Identifique los componentes SOAP en la petición. 3. Considere la siguiente respuesta HTTP: H T T P /1 .1 2 0 0 OK C o n n e c t i o n : c i ó s e C o n t e n t - L e n g t h : 499 C o n te n t - T y p e : t e x t / x m l ; c h a r s e t = u t f - 8 D a t e : W ed, 28 M ar 200 1 0 5 : 0 5 : 0 4 GMT S e r v e r : U s e rL a n d F r o n t ie r / 7 .O - W in N T <? x m l v e r s i o n = 111 . 0 \" 7 > <SOAP-ENV: E n v e lo p e SOAPENV: e n c o d i n g S t y l e = \"h t t p : / / s c h e m a s . x m l s o a p . o r g / s o a p / e n c o d i n g / \" x m ln s :SOAP-ENC= \" h t t p : / /s c h e m a s . x m l s o a p . o r g / s o a p / e n c o d i n g / \" x m ln s : SOAPENV=\" h t t p : / / s c h e m a s . x m l s o a p . o r g / s o a p / e n v e l o p e / \" x m ln s :x s d = \" h t t p : / / www.w3 . o r g / 1 9 9 9 /XMLSchema\" x m ln s : x s i = \" h t t p : / /www. w3 . o r g / 1999 /X M L S c h e m a -in s ta n c e \" > <SOAP-ENV:Body> <m: g e tS ta te N a m e R e s p o n s e x m l n s : m=\" h t t p : / /www. s o a p w a r e . o r g / \" > < R e s u l t x s i : t y p e = \" x s d : s t r i n g \" > S o u t h D a k o ta < / R e s u lt > < /m : g e tS ta te N a m e R e s p o n s e > </SOAP-ENV:Body> </SOAP-ENV:Envelope> Identifique los componentes SOAP en la petición. 7. Escriba un servicio SOAP (interfaz y clase) que proporcione dos métodos: (i) add, que acepta dos enteros y devuelve la suma, y (ii) subtract, que reci­ ba dos enteros y devuelve la diferencias. Escriba un programa cliente que invoque a los dos métodos y procese la salida. S i es posible, instale y configure el servicio creado y ejecute su programa cliente para testear el servicio. www.FreeLibros.org 3 6 6 Computación distribuida. Fundamentos y aplicaciones R EFER EN C IA S 1. OverV iew o f A pplets, http://java.sun.com/docs/books/tutorial/appletloverviewlindex.html 2. A pplets, http://java.sun.com/applets/7frontpage-spotlight 3. Java(T M ) B outique, Free Ja v a A pplets, G am es, Program m ing T utorials, a n d D o w n lo ad s— A p p le t C ategories, http://javaboutique.intemet.com/ 4. Ja v a S e rv le t T echnology Im plem entations & S p ecifícatio n s A rchive, http://java.sun.com/ productslservletlarchive.html 5. Jav a(T M ) S e rv le t T ec h n o lo g y — Im p le m e n ta tio n s & S p e c ifíc a tio n s , http://java.sun.com/ productslservletldo\\vnload.html 6. T h e A pache T o m c a t S erver, http://jakarta.apache.org/tomcat/index.html 7. javax.servlet.http.HttpServlet d a s s sp e c ifíca tio n , http://java.sun.eom/products/servlet/2.2/ javadocljavaxlservletlhttplHttpServlet.html 8. N eil G unton. “SO A P: S im p lify in g D istributed D evelopm ent.\" Dr. D obbs Journal, S eptem - ber 2001. 9. S im p le O b je ct A c ce ss Protocol (SO A P) 1.1, http://www.w3.org/TR/SOAP/ 10. S O A P T utorial, http://www.w3schools.com/soap/default.asp 11. D av e W iner a n d Ja k e S avin. S oapW are.O rg: A B u sy D e v e lo p e r’s G u id e to S O A P 1.1, http:llwww.soapware.org/bdg. U serL and S o ftw are, A pril 2, 2001. 12. A Q u ick-S tart G uide fo r In stalling A p ach e SO A P, http://wwwxmethods.com/gettingstarted/ apache.html 13. developerW orks: W eb Services: T h e W eb Services (r)evolution: P a rt 2, H e lio w orld, W eb service-style, http://www-I06.ibm.com/developenvorks/library/ws-peer2/ 14. A pache S O A P D ocum entation: U s e r's G uide, http://xml.apache.org/soap/docs/index.html 15. A p ach e S O A P V 2.2 D ocum entation, http://xml.apache.org/soap/docs/index.html 16. X M ethods— W eb S e rv ice L istings, http:/lwwwxmethods.net/ 17. java.sun.com. F requently A sk e d Q uestions— A p p le t Security, http:lljava.sun.com/sfaql 18. W elco m e l-T h e A p ach e S o ftw are F oundation, http://apache.org/ 19. Ja so n H unter a n d W illia m C raw ford. Java Servlet Programming. S ebastopol, CA: O ’ReiUy, 1998. 20. A p ach e A xis, http://xml.apache.org/axis/ 21. uddi.org, http://www.uddi.org/ 22. W brld W ide Wfeb Consortium. Wfeb Service Definition Language (WSDL), http://www.w3.org/TR/wsdl 23. Jab b er S o ftw are Foundation, http://www.jabber.orgl 24. W o rld W id e W eb C onsortium . X M L S c h e m a P a rt 2: D a taty p es, http://www.w3.org/TR/ xmlschema-2/ 25. Ja v a S e rv e r P age T utorial, http://java.sun.com/products/jsp/pdf/jsptut.pdf 26. T utorial: S e rv lets a n d JS P , http://javaboutique.internet.com/tutorials/jsp.htttil www.FreeLibros.org CAPÍTULO P a r a d i g m a s a v a n z a d o s d e c o m p u t a c i ó n d i s t r i b u i d a En los capítulos anteriores se han explorado un diverso número de paradigmas inicialm ente presentados en el Capítulo 3, donde se m ostraba una jerarquía de paradigm as repetida aquí en la Figura 12.1. N ivel de a b s tra c c ió n Alto Bajo Espacios de objetos, aplicaciones colaborativas Servicios de red, (ORB) object request broker, sistema de mensajes, agentes mó/iles Llamada a procedimientos remotos, invocación de métodos remotos Cliente-servidor, peer-to-peer Paso de mensajes F ig u ra 1 2 .1 . Los p a ra d ig m a s d e c o m p u ta c ió n d is trib u id a y s u nivel d e a b s tra c c ió n . Este capítulo presenta alguno de los paradigm as más avanzados. Algunos de ellos están siendo aún investigados, m ientras que otros son usados am pliam ente en la práctica. Especialmente, este capítulo dará una visión general de los siguientes paradigm as de com putación distribuida: sistem as de colas de m ensajes, agentes móviles, servicios de red, espacios de objetos y com putación colaborativa. www.FreeLibros.org 3 6 8 C om putación distribuida. Fundam entos y aplicaciones 1 2 .1 . RARADIGMA DE SISTEM A S DE COLAS DE M EN SAJES El paradigma de sistem as de colas de mensajes, tam bién denominado náddleivare orientado a m m sajes (MOM, m essage-otieatedn*d(M ew are. es una elaboración del paradigma de paso de mensajes. En este paradigma, un sistema de mensajes actúa como intermediario entre procesos separados e independientes. E m is o r La Figura 12.2 ilustra el paradigma. Los mensajes se envían al sistema d e men­ sajes, que actúa de conmutador de los mismos, encaminándolos a los receptores apro­ piados. A través de un sistema de mensajes, los procesos intercambian mensajes de forma asincrona, de una manera desacoplada. Un emisor deposita un mensaje en el sistema, el cual lo reenvía a una cola de mensajes asociada con cada receptor. Una vez que el mensaje se ha enviado, el emisor se libera para poder realizar otras tareas. El mensa­ je se reenvía por parte del sistema de mensajes hasta los clientes. Cada cliente pue­ de extraer de su cola bajo demanda. Los modelos de sistemas de colas de mensajes se pueden clasificar en dos subti­ pos, punto-a-punto y publicación'suscripción que se describen a continuación: M odelo de m ensajes p u nto-a-pun to El modelo mostrado en la Figura 12.2 se corresponde con el modelo de mensajes pun- to-a-punto. En este modelo, un sistema de mensajes redirige un mensaje desde e l emi­ sor hasta la cola de mensajes del receptor. A diferencia del modelo básico de paso de mensajes, el modelo de mensaje punto-a-punto proporciona un depósito de los men­ sajes que permite que el envío y la recepción estén desacoplados. Comparado con e l modelo básico de paso de mensajes, este paradigma propor­ ciona una abstracción adicional para operaciones asincronas: no existe un bloqueo entre emisor y receptor. M odelo de m ensajes publicación/suscripción En este modelo, mostrado en la Figura 12.3, cada mensaje se asocia con un determi­ nado tema o evento. Las aplicaciones interesadas en el suceso de un evento específi- www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 6 9 co se pueden suscribir a los mensajes de dicho evento. Cuando ocurre el evento que se aguarda, el proceso publica un mensaje anunciando el evento o asunto. El sistema de cola de mensajes distribuye el mensaje a todos los suscriptores. E d ito r El modelo de mensajes publicación/suscripción ofrece una potente abstracción para mdtkKfasaón o comunicación en & npo La operación publicar permite al proceso difundir a un grupo de procesos, y la operación suscribir permite a un proceso es­ cuchar dicha difusión de mensajes. El paradigma de sistem a de mensajes se emplea comercialmentre de forma muy amplia en aplicaciones distribuidas. Existe un gran número d e herramientas que dan soporte a este paradigma. Algunas d e ellas son: • MQ*Series d e IBM (rebautizado como WebSphere MQ) [4.ibm.com, 3], • M icrosoft’s M essage Queue (MSMQ) [microsoft.com, 2], • Java M essage Service (JMS) [java.sun.com, 1] disponible con el J2EE SDK [java.sun.com, 4] versiones 1.3 o superiores. Para aquellos estudiantes interesados en una API que dé soporte a un modelo de sis­ tema de paso de mensajes, JMS es un buen punto de arranque. La Figura 12.4 y la Figura 12.5 muestran un ejemplo de programación con JMS. Un EmisorMensaje envía un mensaje a una cola JMS, mientras que ReceptorMensa- je lo recibe de la cola. Para poder apreciar el asíncronismo que el sistema de cola de mensajes proporciona, deberá experimentar arrancando una o varias copias de Recep- torMensaje, y posteriormente el EmisorMensaje. Cada uno de los clientes debe reci­ bir un mensaje (“¡Hola Mundo!”) una vez que se ha enviado. (Nota: los programas de ejemplo sólo compilarán y ejecutarán en un sistem a que tenga instalado JMS; con­ sulte [java.sun.com, 1] para obtener información sobre cómo descargar e instalar JMS.) F ig u ra 12 .4 . Un e je m p lo d e un e m is o r d e m e n sa je s p u n to -a -p u n to . 1 /** 2 * L a c l a s e E m is o rM e n s a je m anda u n m e n s a je \" IH o la M undo1\" a 3 * u n a c o l a d e m e n s a je s d e J a v a M e s s a g e S y s te m (J M S ). E s t e (continúa) www.FreeLibros.org 3 7 0 C om putación distribuida. Fundam entos y aplicaciones 4 * p ro g r a m a e s t á p r e p a r a d o p a r a e j e c u t a r s e c o n l a c l a s e 5 * R e c e p to r M e n s a j e , q u e r e c i b e e l m e n s a je v í a e l s e r v i c i o 6 * JM S. 7 * P a r a e j e c u t a r e l p r o g r a m a : E l p r o v e e d o r JMS d e b e e s t a r 8 * a r r a n c a d o y s e d e b e h a b e r c r e a d o u n a c o l a . E l n o m b re d e 9 * l a c o l a s e d e b e e s p e c i f i c a r como u n a r g u m e n to e n l a l í n e a 10 * d e m a n d a to s a l a r r a n c a r e l p r o g r a m a . 11 * M. L i u , b a s a d o e n l o s e j e m p l o s d e l 12 * t u t o r i a l h t t p : / / j a v a . s u n . c o m / p r o d u c t s / j m s / t u t o r i a l / 13 * / 14 i m p o r t j a v a x . j m s . * ; / / p a r a l a s c l a s e s JMS 15 i m p o r t j a v a x . n a m i n g . * ; / / p a r a l a s c l a s e s JNDI 16 17 p u b l i c c l a s s E m is o rM e n s a je { 18 19 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 20 S t r i n g n o m b re C o la = n u i l ; 21 C o n t e x t c o n te x to J N D I = n u i l ; 22 Q u e u e C o n n e c t io n F a c t o r y f a b r i c a C o n e x i o n e s 23 = n u i l ; 24 Q u e u e C o n n e c tio n c o n e x io n C o l a = n u i l ; 25 f r i e u e S e s s i o n s e s i o n C o l a = n u i l ; 26 f r ie u e c o l a = n u i l ; 27 Q u e u e S e n d e r e m i s o r C o l a = n u i l ; 28 T e x tM e s s a g e m e n s a je = n u i l ; 29 f i n a l i n t NUM_MSGS; 30 31 i f ( ( a r g s . l e n g t h != 1 ) ) { 32 S y s t e m . o u t . p r i n t l n ( \"U so : j a v a 11 + 33 ''E m is o rM e n s a je < n o m b r e - c o l a > \" ) ; 34 S y s te m . e x i t ( 1 ) ; 35 } 36 n o m b re C o la = new S t r i n g ( a r g s [ 0 ] ) ; 37 S y s t e m . o u t . p r i n t l n ( \"N cm bre d e l a c o l a e s \" + n o m b r e C o la ) ; 38 39 / * C r e a u n o b j e t o I n i t i a l C o n t e x t d e JN D I s i 40 n o e x i s t e n i n g u n a o . * / 41 42 t r y { 43 c o n te x to J N D I = new I n i t i a l C o n t e x t ( ) ; 44 } c a t c h ( N a m in g E x c e p tio n e ) { 45 S y s te m , o u t . p r i n t l n (\"N o s e h a p o d id o c r e a r e l c o n t e x t o \" + 46 \"JN D I: \" + e . t o S t r i n g ( ) ) ; 47 S y s t e m . e x i t ( l ) ; 48 } 49 50 / * B ú s q u e d a d e l a f á b r i c a d e c o n e x i o n e s y l a c o l a . S i 51 a l g u n a d e l a s d o s n o e x i s t e . * / ( continúa) www.FreeLibros.org 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 Paradigmas avanzados d e com p u ta ció n d istrib u id a 371 t r y { f a b r i c a C o n e x i o n e s = ( Q u e u e C o n n e c t io n F a c t o r y ) c o n te x t o J N D I .l o o k u p ( \" Q u e u e C o n n e c t i o n F a c t o r y \" ) c o l a = (Q u e u e ) c o n te x t o J N D I . l o o k u p ( n a n b r e C o l a ) ; } c a t c h (N a m in g E x c e p tio n e ) { S y s t e m . o u t . p r i n t l n ( \" B ú sq u e d a JN D I f a l l i d a : \" + e . t o S t r i n g ( ) ) ; S y s t e m . e x i t ( l ) ; > t r y { / * c r e a r c o n e x i ó n * / c o n e x io n C o l a = f a b r i c a C o n e x i o n e s . c r e a t e Q u e u e C o n n e c t i o n ( ) ; / * c r e a r s e s i ó n * / s e s i o n C o l a = c o n e x i o n C o l a . c r e a t e Q u e u e S e s s i o n ( f a l s e , Session.AUTO_ACKNOWLEDGE) ; / * c r e a r e m i s o r y o b j e t o m e n s a j e . * / e m i s o r C o l a = s e s i o n C o l a . c r e a t e S e n d e r ( c o l a ) ; m e n s a je = s e s i o n C o l a . c r e a t e T e x t M e s s a g e ( ) ; / * d e f i n i r m e n s a je * / m e n s a j e . s e t T e x t ( \" iH o la M undo! \" ) ; S y s t e m . o u t . p r i n t l n ( \" E h v ia n d o m e n s a j e : \" + m e n s a j e . g e t T e x t ( ) ) ; / * e n v i a r a JMS * / e m i s o r C o l a . s e n d ( m e n s a j e ) ; } c a t c h ( J M S E x c e p tio n e ) { S y s t e m . o u t . p r i n t l n ( \" H a o c u r r i d o u n a e x c e p c i ó n : \" + e . t o S t r i n g ( ) ) ; } f i n a l l y { / * c e r r a r l a c o l a d e c o n e x ió n * / i f ( c o n e x i o n C o l a != n u i l ) { t r y { c o n e x i o n C o l a . c i ó s e ( ) ; } c a t c h (J M S E x c e p tio n e ) {} > } / / f i n f i n a l l y } / / f i n m a in > / / f i n c l a s s www.FreeLibros.org F ig u ra 12.5. Un ejemplo de un receptor de mensajes punto-a-punto. 372 Computación distribuida. Fundamentos y aplicaciones 1 /** 2 * L a c l a s e R e c e p to r M e n s a j e s e d e b e u s a r j u n t o c o n 3 * l a c l a s e E m is o r M e n s a je , l a c u a l m anda u n m e n s a je 4 * v i a t h e JM S. 5 * S e d e b e d a r e l m ism o n a n b r e d e c o l a q u e e n E m is o rM e n s a je 6 * p o r m e d io d e u n a rg u m e n to e n l a l í n e a d e m a n d a to s 7 * M. L i u , b a s a d o e n l o s e j e m p l o s d e l 8 * T u t o r i a l , h t t p : / / j a v a . s u n . c o m / p r o d u c t s / j m s / t u t o r i a l / 9 * / 10 11 i m p o r t j a v a x . j m s . * ; 12 i m p o r t j a v a x . n a m i n g . * ; 13 14 p u b l i c c l a s s R e c e p to r M e n s a j e { 15 16 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 17 S t r i n g n o m b re C o la = n u i l ; 18 C o n t e x t c o n te x to J N D I = n u i l ; 19 f r i e u e C o n n e c t i o n F a c t o r y f a b r i c a C o n e x i o n e s 20 = n u il; 21 Q u e u e C o n n e c tio n c o n e x io n C o l a = n u i l ; 22 & i e u e S e s s i o n s e s i o n C o l a = n u i l ; 23 f r ie u e c o l a = n u i l ; 24 f r i e u e R e c e i v e r r e c e p t o r C o l a = n u i l ; 25 T e x tM e s s a g e m e n s a je = n u i l ; 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 t r y { c o n te x to J N D I = new I n i t i a l C o n t e x t ( ) ; i f ( a r g s . l e n g t h != 1 ) { / * B ú s q u e d a d e l a f á b r i c a d e c o n e x i o n e s y l a c o l a . S i a l g u n a d e l a s d o s n o e x i s t e . * / S y s t e m . e x i t ( l ) ; > n o m b re C o la = new S t r i n g ( a r g s [ 0 ] ) ; S y s t e m . o u t . p r i n t l n ( \" N a n b r e d e l a c o l a e s \" + n o m b r e C o la ) ; / * C r e a un o b j e t o I n i t i a l C o n t e x t d e JN D I s i n o e x i s t e n i n g u n a o . * / } c a t c h (N a m in g E x c e p tio n e ) { S y s te m , o u t . p r i n t l n (\"N o s e h a p o d id o c r e a r e l c o n t e x t o \" + > S y s t e m . o u t . p r i n t l n ( \"U so : j a v a \" + S y s t e m . e x i t ( 1 ) ; \"JN D I: \" + e . t o S t r i n g ( ) ) ; \" R e c e p tc M e n s a je < n o ir b r e - c o la > \" ) ; ( continúa) www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 7 3 48 t r y { 49 f a b r i c a C o n e x i o n e s = 50 (Q u e u e C o n n e c t io n F a c t o r y ) 51 c o n te x t o J N D I . l o o k u p ( \" Q u e u e C o n n e c t io n F a c t o r y \" ) ; 52 c o l a = (Q u e u e ) c o n te x t o J N D I . l o o k u p ( n a n b r e C o l a ) ; 53 } c a t c h ( N a m in g E x c e p tio n e ) { 54 S y s t e m . o u t . p r i n t l n ( \" B ú sq u e d a JN D I f a l l i d a : \" + 55 e . t o S t r i n g ( ) ) ; 56 S y s te m , e x i t ( 1 ) ; 57 } 58 59 t r y { 60 / * c r e a r c o n e x i ó n * / 61 c o n e x io n C o l a = 62 f a b r i c a C o n e x i o n e s . c r e a t e Q u e u e C o n n e c t i o n ( ) ; 63 / * c r e a r s e s i ó n d e l a c o n e x i ó n * / 64 s e s i o n C o l a = 65 c o n e x i o n C o l a . c r e a t e Q u e u e S e s s i o n ( f a l s e , 66 Session.AUTO_ACKNOWLEDGE); 67 / * c r e a r u n r e c e p t o r * / 68 r e c e p t o r C o l a = s e s i o n C o l a . c r e a t e R e c e i v e r ( c o l a ) ; 69 c o n e x i o n C o l a . s t a r t ( ) ; 70 / * r e c i b e e l m e n s a je * / 71 M e s s a g e m = r e c e p t o r C o l a . r e c e i v e ( 1 ) ; 72 m e n s a je = (T e x tM e s s a g e ) m; 73 S y s t e m . o u t . p r i n t l n ( \" l e y e n d o m e n s a j e : \" + 74 m e n s a j e . g e t T e x t ( ) ) ; 75 } c a t c h ( J M S E x c e p tio n e ) { 76 S y s t e m . o u t . p r i n t l n ( \"Ha o c u r r i d o u n a e x c e p c i ó n : \" + 77 e . t o S t r i n g ( ) ) ; 78 } f i n a l l y { 79 i f ( c o n e x i o n C o l a 1= n u i l ) { 80 t r y { 81 c o n e x i o n C o l a . c i ó s e ( ) ; 82 } c a t c h (J M S E x c e p tio n e ) {} 83 > 84 } / / f i n f i n a l l y 85 } / / f i n m a in 86 } / / f i n c l a s s Se recomienda a los lectores interesados en más detalles sobre el A PI de JMS la referencia [java.sun.com, 1] que muestra más ejemplos, incluyendo los relativos al mo­ delo pubficaaónfcusm pcirin. 1 2 .2 . A G E N T E S M Ó VILES Un agm fte m óvil es un paradigma de computación distribuida que ha interesado a los investigadores desde los años 80. Los agentes móviles se han convertido en tecnoló­ www.FreeLibros.org 374 Computación distribuida. Fundamentos y aplicaciones gicamente viables gracias a las últimas tecnologías y hoy por hoy tienen e l potencial de revolucionar las aplicaciones en red. En e l contexto de la informática, un a g m te e s un programa software independiente que se ejecuta en representación del usuario. Un agente móvil es un programa que, una vez lanzado por e l usuario, puede via­ ja r de ordenador a ordenador autónomamente y puede continuar con sus función in­ cluso si el usuario se desconecta. La Figura 12.6 ilustra el concepto de un agente móvil. C om putador 2 C om putador 3 F ig u ra 12 .6 . Un a g e n te m ó vil v ia ja d e un c o m p u ta d o r a otro. A rquitectura básica Un agente móvil es un objeto so ializab le: un objeto cuyos datos al igual que el es­ tado se pueden empaquetar para ser transmitidos por la red. El lector recordará el tér­ mino empaquetado d e datos {data m a rsh a im g , presentado por primera vez en el Capítulo 1, como e l aplanamiento y codificación de estructuras d e datos con el fin de transmitirlas d e un computador a otro. Un objeto se puede señalizar y transmitir en­ tre dos ordenadores de la misma forma. Una vez llegado, el objeto se reconstruye y se deserializa, con su estado restaurado como a l momento de señalizarse, y entonces el objeto puede retom ar su ejecución en el sistema donde acaba de llegar. L a arquitectura básica para dar soporte a agentes móviles se muestra en la Figu­ ra 12.7. Un objeto serializable, representando al agente móvil, se lanza en un compu - tador. El agente contiene los siguientes datos: • Información d e identidad: Información que permite identificar al agente. • Itinerario: Una lista de direcciones de ordenadores que el agente debe visitar. www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n distribu ida 3 7 5 • D atos d e l a ta rc a : Los datos que el agente requiere para realizar sus tareas, o bien datos recogidos por el agente. F ig u ra 12 .7 . Un a g e n te m ó vil v ia ja p o r v a rio s o rd e n a d o re s. Un agente también lleva consigo la lógica (código) para realizar las tareas. En cada parada, el agente llega a un servidor. A través del servidor de agentes, el agente móvil usa los recursos locales para realizar sus tareas. Como parte de la arquitectura, se necesita un servicio de directorio que permita al agente buscar el servidor en cada parada. Cuando el agente ha concluido su tarea en un sitio, el objeto agente se señaliza, y, con la ayuda de un servidor de agentes, el objeto se transporta al siguiente ordenador del itinerario. Hay varios entornos que se han desarrollado para proporcionar arquitecturas de so ­ porte a agentes móviles, por ejemplo Aglet [Lange and Oshima,5; aglets.sourcefor- ge.net, 6), Concordia [merl.com, 7], y Grasshopper [grasshopper.de, 8]. Por sim plici­ dad, sin embargo, se mostrará el concepto de agente móvil usando objetos serializables y Java RMI. (Nota: la implementación presentada vale para demostrar e l concepto de agente móvil. Para verdaderos desarrollos, existen consideraciones, a discutir, que la demostración no trata). La Figura 12.8 presenta la interfaz Java de un agente; la implementación de la in­ terfaz se ve en la Figura 12.9. F ig u ra 1 2 .8 . InterfazAgente,java. / / U na i n t e r f a z p a r a u n o b j e t o t r a n s p o r t a b l e / / q u e r e p r e s e n t a u n a g e n t e m ó v i l / / M. L i u (continúa) www.FreeLibros.org 3 7 6 Computación distribuida. Fundamentos y aplicaciones i m p o r t j a v a . i o . S e r i a l i z a b l e ; public interface InterfazAgente extends Serializable { v o i d e j e c u t a ( ) ; } F ig u ra 12 .9 . A g e n te .ja v a . 1 / / U na i m p le m e n ta c i ó n d e u n a g e n t e m ó v i l 2 3 i m p o r t j a v a . i o . * ; 4 i m p o r t j a v a . ú t i l . * ; 5 i m p o r t j a v a . r m i . * ; 6 i m p o r t j a v a . r m i . r e g i s t r y . R e g i s t r y ; 7 i m p o r t j a v a . r m i . r e g i s t r y . L o c a t e R e g i s t r y ; 8 9 p u b l i c c l a s s A g e n te ir a p le m e n ts I n t e r f a z A g e n t e { 10 11 i n t in d i c e N o d o ; / / c u á l e s e l s i g u i e n t e o r d e n a d o r a v i s i t a r 12 S t r i n g n o m b re ; 13 V e c t o r l i s t a N o d o s ; / / e l i t i n e r a r i o 14 i n t p u e rto R M I = 1 2 3 4 5 ; 15 16 p u b l i c A g e n t e ( S t r i n g m iN o n b r e , V e c t o r l a L i s t a C o m p u t a d o r a s , 17 i n t e l P u e rto R M I ) { 18 n a n b r e = m iN om bre ; 19 l i s t a N o d o s = l a L i s t a N o d o s ; 20 in d i c e N o d o = 0 ; 21 p u e rto R M I = e lP u e r to R M I ; 2 2 > 23 24 / / E s t e m é to d o d e f i n e l a s t a r e a s q u e r e a l i z a e l a g e n t e 25 / / m ó v i l u n a v e z q u e l l e g a a u n s e r v i d o r . 26 p u b l i c v o i d e j e c u t a ( ) { 27 S t r i n g a c t u a l , s i g u i e n t e ; 28 d o r m i r ( 2 ) ; / / p a u s a p a r a p o d e r v i s u a l i z a r l o 29 S y s t e m . o u t . p r i n t l n ( \" í A q u í e l a g e n t e 0 0 7 ! \" ) ; 30 a c t u a l = ( S t r i n g ) l i s t a N o d o s . e le m e n tA t ( i n d i c e N o d o ) ; 31 in d ic e N o d o + + ; 32 i f ( i n d ic e N o d o < l i s t a N o d o s . s i z e ( ) ) { 33 / / s i h a y m ás c o m p u ta d o r a s q u e v i s i t a r 34 s i g u i e n t e = ( S t r i n g ) l i s t a N o d o s . e l e m e n t A t ( in d i c e N o d o ) ; 35 d o r m i r ( 5 ) ; / / p a u s a p a r a p o d e r v i s u a l i z a r l o 36 t r y { 37 / / L o c a l i z a e l r e g i s t r o RMI e n e l s i g u i e n t e n o d o 38 R e g i s t r y r e g i s t r o = L o c a t e R e g i s t r y . g e t R e g i s t r y 39 ( \" l o c a l h o s t \" , p u e r to R M I ) ; 40 S e r v e r l n t e r f a c e h = ( S e r v e r l n t e r f a c e ) 4 1 r e g i s t r o . l o o k u p ( s i g u i e n t e ) ; ( continúa) www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 7 7 42 S y s t e m . o u t . p r i n t l n ( \" B u s c a n d o \" + s i g u i e n t e + 43 \" e n \" + a c t u a l + \" c o m p le ta d o \" ) ; 44 d o r m i r ( 5 ) ; / / p a u s a p a r a p o d e r v i s u a l i z a r l o 45 / / P i d e a l s e r v i d o r d e l s i g u i e n t e n odo q u e r e c i b a a 46 / / e s t e a g e n t e . 47 h . r e c i b e ( t h i s ) ; 48 } / / f i n t r y 49 c a t c h ( E x c e p t i o n e ) { 50 S y s t e m . o u t . p r i n t l n 51 ( \" E x c e p c ió n e n e l e j e c u t a d e l A g e n te : \" + e ) ; 52 > 53 } / / f i n i f 54 e l s e { / / s i s e h a n h e c h o t o d a s l a s p a r a d a s 55 d o r m i r ( 5 ) ; / / p a u s a p a r a p o d e r v i s u a l i z a r l o 56 S y s te m , o u t . p r i n t l n ( \" E l A g e n te 007 h a r e g r e s a d o a c a s a \" ) ; 57 d o r m i r ( 5 ) ; / / p a u s a p a r a p o d e r v i s u a l i z a r l o 58 > 59 } 60 61 / / E l m é to d o d o r m i r s u s p e n d e l a e j e c u c i ó n d e e s t e o b j e t o 62 / / u n n ú m ero d e t e r m i n a d o d e s e g u n d o s . 63 s t a t i c v o i d d o r m i r ( d o u b l e t i m e ){ 64 t r y { 65 T h r e a d . s l e e p ( ( l o n g ) ( t i m e * 1 0 0 0 . 0 ) ) ; 66 } 67 c a t c h ( I n t e r r u p t e d E x c e p t i o n e ) { 68 S y s t e m . o u t . p r i n t l n ( \" e x c e p c i ó n e n d o r m i r ) ; 69 } 70 } / / f i n d o r m i r 71 72 } / / f i n c l a s s A g e n te El núcleo de la implementación del agente (Figura 12.9) está en su constructor (lí­ neas 16 -22) y en su método ejecuta (líneas 26 -59). El constructor inicializa los da­ tos de estado del agente, incluyendo el itinerario y el índice a l siguiente computador a visitar en dicho itinerario. El método ejecuta contiene la lógica de las tareas que se espera que el agente realice en cada ordenador. En esta demo, las tareas se resumen en la salida de un simple mensaje (línea 56) y en la búsqueda del servidor de agen­ tes de la siguiente parada (líneas 32 -53). La implementación de servidor de agentes se muestra en las Figuras 12.10y 12.11. F ig u ra 1 2 .1 0 . InterfazServidor.java. / / F i c h e r o d e i n t e r f a z d e l s e r v i d o r d e a g e n t e s - M. L i u im p o r t j a v a . r m i . * ; p u b l i c i n t e r f a c e I n t e r a z S e r v i d o r e x t e n d s R e m ó te { p u b l i c v o i d r e c i b e ( A g e n te h ) t h r o w s j a v a . m i . R e m o te E x c e p tio n ; } www.FreeLibros.org 3 7 8 Computación distribuida. Fundamentos y aplicaciones El servidor, por su parte, se registra en el registro RMI y proporciona un método, recibe, que el agente móvil invoca cuando está preparado para transportarse al servi­ dor. El método imprime un mensaje que anuncia la llegada del agente, y posterior­ mente llam a al método ejecuta del agente. Nótese que el método recibe acepta como argumento el objeto agente serializable. 1 / / U na i m p le m e n ta c i ó n d e u n s e r v i d o r a g e n t e s 2 i m p o r t j a v a . r m i . * ; 3 i m p o r t j a v a . r m i . s e r v e r . * ; 4 i m p o r t j a v a . r m i . r e g i s t r y . R e g i s t r y ; 5 i m p o r t j a v a . r m i . r e g i s t r y . L o c a t e R e g i s t r y ; 6 i m p o r t j a v a . n e t . * ; 7 i m p o r t j a v a . i o . * ; 8 9 p u b l i c c l a s s S e r v i d o r e x t e n d s U n ic a s t R e m o te O b je c t 10 im p le m e n ts I n t e r f a z S e r v i d o r { 11 s t a t i c i n t p u e rto R M I = 1 2 3 4 5 ; 12 p u b l i c S e r v i d o r ( ) t h r o w s R e m o te E x c e p tio n { 13 s u p e r ( ) ; F ig u ra 1 2 .1 1 . Servidor.java. 14 15 16 17 18 19 20 2 1 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 p u b l i c s t a t i c v o i d m a i n ( S t r i n g a r g s [ ] ) { I n p u t S tr e a m R e a d e r i s = new I n p u t S t r e a m R e a d e r ( S y s t e m .i n ) ; B u f f e r e d R e a d e r b r = new B u f f e r e d R e a d e r ( i s ) ; S t r i n g s ; S t r i n g m iN om bre = \" s e r v i d o r \" + a r g s [ 0 ] ; public void recibe(Agent h) throws RemoteException { > > d o r m i r ( 3 ) ; / / p a u s a p a r a p o d e r v i s u a l i z a r l o S y s te m , o u t . p r i n t l n ( \"***** e i A g e n te \" + h .n a m e + \" ha l l e g a d o . \" ) ; h . e j e c u t a ( ) ; //a rg u m e n to s 1 , 2 y 3 de l a l i n e a d e m andatos re s p e c tiv a m e n te , / / N o t a : L os s e r v i d o r e s s e e s p e r a q u e s e a r r a n q u e n c o n l o s t r y { System, setSecurityManager(new RMISecurityManager()); Servidor h = new Servidor(); Registry registro = S y s t e m . o u t . p r i n t l n (\" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \" ); S y s t e m . o u t . p r i n t l n (\" A g e n te \" + m iN a rb re + \" l i s t o . \" ) ; S y s t e m . o u t . p r i n t l n ( \" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \"); r e g i s t r o . r e b i n d ( m iN a n b r e , h ) ; L o c a t e R e g i s t r y . g e t R e g i s t r y ( p u e r t o R M I ) ; (continúa) www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 7 9 41 } / / f i n t r y 42 c a t c h ( R e m o te E x c e p tio n r e ) { 43 S y stem . c x it. p r i n t l n ( \" E x c e p c ió n e n e l m a in d e l S e r v i d o r : 11 44 + r e ) ; 45 } / / f i n c a t c h 46 } / / f i n m a in 47 48 / / E l m é to d o d o r m i r s u s p e n d e l a e j e c u c i ó n d e e s t e o b j e t o 49 / / u n n ú m ero d e t e r m i n a d o d e s e g u n d o s . 50 s t a t i c v o i d d o r m i r ( d o u b l e t i m e ){ 51 t r y { 52 T h r e a d . s l e e p ( ( l o n g ) ( t i m e * 1 0 0 0 . 0 ) ) ; 53 } 54 c a t c h (I n t e r r u p t e d E x c e p t i o n e ) { 55 S y s t e m . o u t . p r i n t l n ( \" e x c e p c i ó n e n d o r m i r \" ) ; 56 } 57 > / / f i n d o r m i r 58 > / / f i n c l a s s Para finalizar, se necesita un programa cliente que cree una instancia y lance al agente hacia la primera parada del itinerario. La implementación se muestra en la Fi­ gura 12.12. F ig u ra 1 2 .1 2 . C liente.java. 1 / / C l i e n t e . j a v a - p r o g r a m a c l i e n t e q u e l a n z a a l a g e n t e m ó v i l 2 / / M. L i u 3 4 i m p o r t j a v a . i o . * ; 5 i m p o r t j a v a . u t i l . * ; 6 i m p o r t j a v a . r m i . * ; 7 i m p o r t j a v a . m i . r e g i s t r y . R e g i s t r y ; 8 i m p o r t j a v a . m i . r e g i s t r y . L o c a t e R e g i s t r y ; 9 10 p u b l i c c l a s s C l i e n t e { 11 s t a t i c i n t p u e rto R M I = 1 2 3 4 5 ; 12 p u b l i c s t a t i c v o i d m a i n ( S t r i n g a r g s [ ] ) { 13 14 S y s te m . s e t S e c u r i t y M a n a g e r ( new R M IS e c u r ity M a n a g e r( ) ) ; 15 16 t r y { 17 R e g i s t r y r e g i s t r o = L o c a t e R e g i s t r y . g e t R e g i s t r y 18 ( \" l o c a l h o s t \" , p u e rto R M I) ; 19 S e r v e r I n t e r f a c e h = ( S e r v e r l n t e r f a c e ) 20 r e g i s t r o . l o o k u p ( \" s e r v i d o r 1 \" ) ; 21 S y s te m , o u t . p r i n t l n 22 (\" L o o k u p f o r s e r v i d o r 1 c o m p l e te d \" ) ; 23 S y s t e m . o u t . p r i n t l n ( \"* * * B u en v i a j e , \" + (continúa) www.FreeLibros.org 3 8 0 Computación distribuida. Fundamentos y aplicaciones 24 \" a g e n t 0 0 7 . \" ) ; 25 26 V e c t o r l i s t a N o d o s = new V e c t o r ( ) ; 27 l i s t a N o d o s . a d d E le m e n t( \" s e r v i d o r 1 \" ) ; 28 l i s t a N o d o s . a d d E le m e n t( \" s e r v i d o r 2 \" ) ; 29 l i s t a N o d o s . a d d E le m e n t ( \" s e r v i d o r 3 \" ) ; 30 A g e n t a = new A g e n t ( \" 0 0 7 \" , l i s t a N o d o s , p u e r t o R M I ) ; 31 h . r e c e i v e ( a ) ; 32 S y s t e m . o u t . p r i n t l n ( \" * * * B u e n t r a b a j o , 0 0 7 \" ) ; 33 > 34 c a t c h ( E x c e p t i o n e ) { 35 S y s t e m . o u t . p r i n t l n ( \" E x c e p c ió n e n m a i n : \" + e ) ; 36 } 37 } / / f i n m a in 38 } / / f i n c l a s s Como paradigma de computación distribuida, los agentes móviles son radicalmente diferentes al resto de paradigmas que se han visto. En otros paradigmas, procesos in­ dependientes colaboran intercambiando datos sobre sus enlaces de red. Con los agen­ tes móviles, un proceso se transmite, llevando consigo los datos a compartir y visi­ tando la lista de procesos de su itinerario. La Figura 12.13 muestra esta característica discriminatoria. El p a ra d ig m a de a g e n te s m ó v ile s P a ra d ig m a s c o n v e n c io n a le s A los d a to s se acce de localm ente y el com p ortam iento se articula en base a un agente m óvil. Los procesos intercambian d atos entre sí. F ig u ra 1 2 .1 3 . C o ntraste e n tre e l p a ra d ig m a d e a g e n te s m ó vile s y lo s p a ra d ig m a s c o n ve n cio n a le s. Ventajas de los agentes móviles El paradigma d e agentes móviles proporciona las siguientes ventajas: • Los agentes móviles permiten un uso eficiente y económico de los canales de comunicación, que pueden ser d e ancho de banda reducido, latencia elevada, y pudiendo ser proclives a errores. En contra, los paradigmas convencionales re­ www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 8 1 quieren el intercambio repetido de paquetes de datos sobre la red. Si esto afec­ ta a grandes volúmenes de datos, el consumo de ancho de banda puede ser con­ siderable, con el consecuente retardo en el tiempo de respuesta o la latencia. Por medio de agentes móviles, un único objeto se señaliza y se transmite por la red, potencialmente reduciendo el consumo de ancho de banda. Además, ya que un agente móvil sólo se necesita transportar entre dos nodos una vez, la probabilidad de fallo debido a un error de comunicación se reduce. Por estas dos razones, los agentes móviles son especialmente interesantes para enlaces de red inalámbricos. • Los agentes móviles permiten el uso d e dispositivos de comunicación portátiles y de bajo coste para realizar tareas complejas incluso cuando e l dispositivo está desconectado de la red. Un agente se puede lanzar desde cualquier dispositivo que soporte la arquitectura necesaria. Una vez lanzado, el agente se desacopla de su origen y es capaz de realizar las tareas de forma independiente de su dis­ positivo inicial. Con una implementación apropiada, un agente móvil puede te­ ner la inteligencia de saltarse nodos que fallen o de buscar refugio momentáneo en nodos fiables. • Los agentes móviles permiten operaciones asincronas y una verdadera descen­ tralización. La ejecución de un agente móvil está desacoplada de su servidor original y de los servidores participantes. Las tareas se realizan en cada uno de los nodos individuales de una manera asincrona, y no resulta necesario que nin­ guno de los participantes asuma el papel de coordinador. A pesar de las ventajas ofrecidas por los agentes móviles, e l paradigma no se ha de­ sarrollado de forma amplia en aplicaciones industriales o comerciales. Una d e las prin­ cipales pegas del paradigma es que puede suponer un riesgo de seguridad para los participantes. Existen consideraciones para ambos, servidores y agentes móviles. Desde el pun­ to de vista de los servidores que reciben un agente, agentes maliciosos o no autori­ zados pueden hacer un uso fraudulento y destruir recursos locales. Sin restricciones, un agente malicioso puede causar un caos en el servidor, de igual manera que lo ha­ cen los virus. Desde el punto de vista de un agente, servidores maliciosos pueden des­ truir o alterar los datos del agente o su lógica. Por ejemplo, el itinerario de un agen­ te móvil se podría alterar o destruir por un servidor malicioso, de forma que el agente no pudiese continuar con su viaje. O, los datos almacenados por el agente se podrí­ an alterar de forma que el agente se llevase información errónea. La seguridad en sistem as de agentes es un área de investigación m uy activa [mole.informatik.uni-stuttgart.de, 9]. Algunas de las contramedidas que se han pro­ puesto son: • Autenticación Un agente debe autentificarse ante el servidor, y un servidor de agentes debe autentificarse ante el agente. • Cifrado Un agente debe cifrar sus datos sensibles. • Acceso a recursos. Un servidor forzará un estricto control de acceso a sus re­ cursos. Sistem as basados en entornos para agentes móviles Hay disponible un gran número d e sistemas basados en entornos de desarrollo para agentes móviles. Además de proporcionar la arquitectura para transportar agentes mó- www.FreeLibros.org 3 8 2 Computación distribuida. Fundamentos y aplicaciones viles, estos sistem as tam bién tratan cuestiones relativas a la seguridad, el soporte transaccional, y la gestión d e agentes. Los lectores que estén interesados en este tem a pueden buscar en referencias como [trl.ibm.com, 6], [concordiaagents.com, 7), y [grasshopper.de, 8]. 1 2 .3 . S E R V IC IO S DE RED En e l paradigma de servicios de red [Edwards, 11], la red se ve como una infraes­ tructura para servicios, que puede incluir aplicaciones, ficheros, bases de datos, ser­ vidores, sistem as de información, y dispositivos, tales como electrodomésticos móvi­ les, alm acenam iento o impresoras. La Figura 12.14 ilustra este paradigma. Una aplicación cliente puede utilizar uno o varios de estos servicios. Los servicios se pue­ den añadir y eliminar de la red d e forma autónoma, y los clientes pueden localizar los servicios disponibles, a través de un servicio de directorio. El protocolo SOAP (Simple Object Access Protocoí), que se vio en el Capítulo 11, se basa en este paradigma. Jini, que es anterior a SOAP, es un conjunto de herra­ mientas basado en este paradigma. S e rv ic io de re d 1 S e rv ic io de re d 2 S e rv ic io de re d 3 S o lic ita n te de s e rv ic io S o lic ita n te de s e rv ic io F ig u ra 1 2 .1 4 . B p a ra d ig m a d e s e rv ic io s d e red. Las Figuras 12.15 y 12.16 muestran la sintaxis d e la implementación de un pro­ veedor de servicios en Jini, que proporciona e l método decirHolaf). La Figura 12.17 muestra la implementación de un cliente de dicho servicio. Nótese que Jini hace uso de RMI, que ya se vio en los Capítulos 7 y 8. F ig u ra 1 2 .1 5 . InterfazServidorH ola.java. 1 / / I n t e r f a z p a r a e l S e r v i d o r H o l a 2 3 i m p o r t j a v a . r m i . * ; 4 5 p u b l i c i n t e r f a c e I n t e r f a z S e r v i d o r H o l a e x t e n d s R em ó te { 6 p u b l i c S t r i n g d e c i r H o l a ( ) th r o w s R e m o te E x c e p t io n ; 7 } www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 8 3 I / / Un e je m p lo d e s e r v i d o r J i n i s e n c i l l o 2 / / M. L i u , b a s a d o e n e l e je m p lo \" N o e l 's N u g g e ts \" [ c c . g a t e c h . e d u , 1 4 ] 3 i m p o r t n e t . j i n i . c o r e . e n t r y . * ; 4 i m p o r t n e t . j i n i . c o r e . l o o k u p . * ; 5 i m p o r t n e t . j i n i . c o r e . d i s c o v e r y . * ; 6 i m p o r t n e t . j i n i . l o o k u p . e n t r y . * ; 7 i m p o r t c o m . s u n . j i n i . l o o k u p . * ; 8 i m p o r t c o m . s u n . j i n i . l e a s e . * ; 9 i m p o r t j a v a . i o . * ; 10 i m p o r t j a v a . r m i . * ; I I i m p o r t j a v a . r m i . s e r v e r . * ; 12 13 p u b l i c c l a s s S e r v i d o r H o l a e x t e n d s U n ic a s t R e m o te O b je c t 14 im p le m e n ts I n t e r f a z S e r v i d o r H o l a , S e r v i c e I D L i s t e n e r { 15 16 p u b l i c S e r v i d o r H o l a ( ) th r o w s R e m o te E x c e p tio n { 17 s u p e r ( ) ; 18 } 19 20 p u b l i c S t r i n g d e c i r H o l a ( ) th r o w s R e m o te E x c e p tio n { 21 r e t u r n ( \" ¡ H o l a M undo1 \" ) ; 22 > 23 24 / / E s t e m é to d o e s t á a l a e s c u c h a d e S e r v i c e I D d e p a r t e d e l 25 / / s e r v i c i o d e d i r e c t o r i o , c u a n d o e l ID e s t é d i s p o n i b l e . 26 p u b l i c v o i d s e r v i c e I D N o t i f y ( S e r v i c e I D i d ) { 27 S y s te m , o u t . p r i n t l n ( \" S e r v i c e I D r e c i b i d o : \" + i d ) ; 28 > 29 30 p u b l i c s t a t i c v o i d m a in ( S t r i n g [ ] a r g s ) { 31 S e r v i d o r H o l a s e r v i d o r ; 32 E n t r y [ ] a t r i b u t o s ; 33 J o i n M a n a g e r m a n a g e r ; 34 35 t r y { 36 S y s te m . s e t S e c u r i t y M a n a g e r 37 (n ew R M IS e c u r ity M a n a g e r ( ) ) ; 38 / / C r e a l o s a t r i b u t o s como u n v e c t o r d e o b j e t o s 39 / / E n t r y q u e d e s c r i b e n e s t e s e r v i c i o , y 40 / / s e r e g i s t r a e n e l s e r v i c i o d e b ú s q u e d a v í a 41 / / e l J o in M a n a g e r. E l S e r v i c e I D , c u a n d o e s t é d i s p o n i b l e , 42 / / l e s e r á in d i c a d o p o r m edio d e l l i s t e m e r d e l S e rv ic e ID . 43 44 a t r i b u t o s = new E n t r y [ l ] ; 45 a t r i b u t o s [ 0 ] = new Ñame ( \" S e r v i d o r H o l a \" ) ; 46 s e r v i d o r = new S e r v i d o r H o l a ( ) ; 47 m a n a g e r = new J o i n M a n a g e r ( 48 s e r v i d o r , a t r i b u t o s , s e r v i d o r , F ig u ra 1 2 .1 6 . S ervido rH ola.java . (continúa) www.FreeLibros.org 3 8 4 Computación distribuida. Fundamentos y aplicaciones 49 new L e a s e R e n e w a lM a n a g e r ( ) 50 ) ; 51 } 52 53 c a t c h ( E x c e p t i o n e x ) { 54 e x . p r i n t S t a c k T r a c e ( ) ; 55 } 56 } / / f i n m a in 57 } / / f i n c l a s s F ig u ra 1 2 .1 7 . C liente Jin i. 1 / / Un e je m p lo d e u n c l i e n t e J i n i 2 / / M. L i u , b a s a d o e n e l e je m p lo \" t t o e l 's N u g g e ts \" [ c c . g a t e c h . e d u , 1 4 ] 3 4 i m p o r t n e t . j i n i . c o r e . e n t r y . * ; 5 i m p o r t n e t . j i n i . c o r e . l o o k u p . * ; 6 i m p o r t n e t . j i n i . c o r e . d i s c o v e r y . * ; 7 i m p o r t n e t . j i n i . l o o k u p . e n t r y . * ; 8 i m p o r t c a n . s u n . j i n i . l o o k u p . * ; 9 i m p o r t j a v a . r m i . * ; 10 11 c l a s s C l i e n t e H o l a { 12 p u b l i c s t a t i c v o i d m a in ( S t r i n g [ ] a r g s ) { 13 14 E n t r y [ ] a t r i b u t o s ; 15 L o o k u p L o c a to r b u s c a d o r ; 16 S e r v i c e I D i d ; 17 S e r v i c e R e g i s t r a r r e g i s t r a r ; 18 S e r v i c e T e m p l a t e p l a n t i l l a ; 19 I n t e r f a z S e r v i d o r H o l a s e r v i d o r H o l a ; 20 21 t r y { 22 S y s te m . s e t S e c u r i t y M a n a g e r 23 (new R M IS e c u r ity M a n a g e r ( ) ) ; 24 25 / / L o c a l i z a r e l s e r v c i o d e b ú s q u e d a d e J i n i 26 b u s c a d o r = new L o o k u p L o c a to r ( \" j i n i : / / l o c a l h o s t \" ) ; 27 / / B u s c a r e l S e r v i c e R e g i s t r a r 28 r e g i s t r a r = b u s c a d o r . g e t R e g i s t r a r ( ) ; 29 / / B ú sq u e d a d e l s e r v i c i o 30 a t r i b u t o s = new E n t r y [ 1 ] ; 31 a t r i b u t o s ! 0 ] = new Ñame ( \" S e r v i d o r H o l a \" ) ; 32 p l a n t i l l a = new S e r v i c e T e m p l a t e 33 ( n u i l , n u i l , a t r i b u t o s ) ; 34 s e r v i d o r H o l a = ( I n t e r f a z S e r v i d o r H o l a ) 35 r e g i s t r a r . b u s c a d o r (p l a n t i l l a ) ; 36 / / I n v o c a r e l m é to d o d e l s e r v i c i o ( continúa) www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 8 5 37 S y s t e m . o u t . p r i n t l n ( s e r v i d o r H o l a . d e c i r H o l a ( ) ) ; 38 > 39 40 c a t c h ( E x c e p t i o n e x ) { 41 e x . p r i n t S t a c e T r a c e ( ) ; 42 } 43 } 44 > La introducción que se ha presentado apenas toca los aspectos fundamentales de Jini y no hace justicia a las sofisticadas capacidades proporcionadas por este conjun­ to de herramientas. Un concepto interesante en Jini es el uso de alquileres (leases) (línea 49 en la Figura 12.16). En un sistem a Jini, cada servicio se asocia a un gestor d e raw varión d e alquileres. Cuando un cliente localiza un servicio Jini a través de un servicio de búsqueda, e l propio servicio de búsqueda actúa como elem ento que concede periodos de alquiler para el servicio. El cliente puede realizar peticiones mien­ tras que su alquiler no haya expirado. El uso de alquileres permite al sistema pro­ porcionar tolerancia a fallos de una forma más eficiente. (Los fallos en sistemas dis­ tribuidos y la tolerancia a fallos se presentaron en e l Capítulo 1). 1 2 .4 . ESPA C IO S DE O B JETO S Esta sección muestra el paradigma que proporciona el mayor nivel de abstracción: los espadas de objetos El paradigma de espacios d e objetos tiene su origen en el Es­ pacio de Tupias de Linda (Linda Tuplespace) desarrollado por David Gelemter [Ahu- ja, Carrier, y Gelemter, 17] y es la base de los sistem as de Pizarras en e l campo de la Inteligencia Artificial [Corkill, 15]. En e l paradigma de espacios de objetos, un es­ p ad o es un repositorio para objetos, compartido y accesible por red. En lugar de co­ municarse entre sí, los procesos se coordinan intercambiando objetas a través de uno o varios espacios. La Figura 12.18 ilustra este concepto. Los procesos interactúan com­ partiendo los datos de estado en uno o más objetos o actualizando el estado d e los objetos según sus necesidades. F ig u ra 1 2 .1 8 . B p a ra d ig m a d e e s p a c io d e o b je to s . www.FreeLibros.org 3 8 6 Computación distribuida. Fundamentos y aplicaciones Un proceso puede depositar un objeto en un espacio. A diferencia d e los modelos de mensajes, los procesos no modifican los objetos en el espacio ni invocan los mé­ todos de los objetos directamente. Un proceso que desea acceder a un objeto utiliza­ rá un servicio d e directorio para localizar el objeto en el espacio. Para modificar el objeto, un proceso debe retirarlo explícitamente, actualizarlo y re insertarlo en e l es­ pacio. El paradigma d e espacios de objetos es un área activa de investigación. Para po­ der experimentar con este paradigma existe un conjunto de herramientas basado en Java, JavaSpaces, que proporciona un entorno d e trabajo para espacios de objetos. En el API de JavaSpaces, se proporciona una interfaz llamada Entry. Un objeto Entry puede escribirse o leerse del espacio. De la Figura 12.19 a la 12.21 se muestra un programa de ejem plo sencillo que utiliza un objeto Entry que contiene un mensa­ je \\Hola Mundo\\ y un contador. El servidor crea el objeto Entry y lo escribe en e l es­ pacio de objetos por defecto. El cliente lee (toma) el objeto del espacio e incremen­ ta el contador, antes de escribirlo de nuevo en el espacio. Nótese que JavaSpaces utiliza el A PI de Jini presentada en la sección 12.3. 1 / / U na c l a s e E n t r y d e e je m p lo p a r a u n o b j e t o d e e s p a c i o J a v a S p a c e s 2 / / M. L i u , b a s a d o e n e l e je m p lo p r o p o r c i o n a d o e n : 3 / / JAVASPACES PR IN CIPLES, PATTERNS, AND PRACTICE [1 8 ] 4 5 6 7 i m p o r t n e t . j i n i . c o r e . e n t r y . E n t r y ; 8 9 p u b l i c c l a s s O b je to D C E s p a c io im p le m e n ts E n t r y { 10 p u b l i c S t r i n g m e n s a j e ; 11 p u b l i c I n t e g e r c o n t a d o r ; / / E s n e c e s a r i o q u e s e a u n o b j e t o F ig u ra 1 2 .1 9 . Un e je m p lo d e un a c la s e E n try d e J a v a S p a c e s . 12 13 14 p u b l i c O b je to D e E s p a c io ( ) { > 15 16 17 18 19 20 21 22 p u b l i c O b j e t o D e E s p a c i o ( S t r i n g m e n s a j e ) { t h i s . m e n s a j e = m e n s a j e ; c o n t a d o r = 0 ; > p u b l i c S t r i n g t o S t r i n g ( ) { r e t u r n m e n s a je + \" l e i d o 11 + c o n t a d o r + \" v e c e s . 1' ; >23 24 25 26 27 28 p u b l i c v o i d i n c r e m e n t o ( ) { c o n t a d o r = new I n t e g e r ( c o n t a d o r . i n t V a l u e ( ) + 1 ) ; > } / / f i n c l a s s www.FreeLibros.org F ig u ra 12.20. Un p ro gra m a d e e je m p lo q u e in icia liza un o b je to J a v a S p a c e s . 1 / / Un p r o g r a m a q u e i n i c i a l i z a u n E n t r y d e J a v a S p a c e s . 2 / / M. L i u , b a s a d o e n e l e je m p lo p r o p o r c i o n a d o e n : 3 / / JAVASPACES PR IN C IPLE S, PATTERNS, AND PRACTICE [ 1 8 ] 4 5 6 7 i m p o r t n e t . j i n i . c o r e . l e a s e . L e a s e ; 8 i m p o r t n e t . j i n i . s p a c e . J a v a S p a c e ; 9 10 p u b l i c c l a s s H olaM undo { Paradigmas avanzados d e com p u ta ció n distribu ida 11 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 12 t r y { 13 S p a c e O b j e c t m ens = new S p a c e O b j e c t ( \" iH o la M u n d o !\" )? 14 15 J a v a S p a c e e s p a c i o ; 16 e s p a c i o = ( J a v a S p a c e ) s p a c e ( ) ; 17 e s p a c i o . w r i t e ( m e n s , n u i l , L e a s e . FOREVER) ; 18 19 S p a c e O b j e c t p l a n t i l l a = new S p a c e O b j e c t ( ) ? 20 w h i l e ( t r u e ) { 21 S p a c e O b je c t r e s u l t a d o = ( S p a c e O b j e c t ) 22 e s p a c i o . r e a d ( p l a n t i l l a , n u i l , L o n g . MAX_VALUE) ; 23 S y s te m , o u t . p r i n t l n ( r e s u l t a d o ) ; 24 T h r e a d . s l e e p ( 1 0 0 0 )? 25 } / / f i n w h i l e 26 } 27 c a t c h ( E x c e p t i o n e x ) { 28 e x . p r i n t S t a c k T r a c e ( ) ; 29 } 30 } 31 > / / f i n c l a s s F ig u ra 12.21. Un e je m p lo d e un c lie n te J a v a S p a c e s . 1 / / Un p r o g r a m a c l i e n t e q u e a c c e d e a un E n t r y d e J a v a S p a c e s 2 / / M. L i u , b a s a d o e n e l e je m p lo p r o p o r c i o n a d o e n : 3 / / JAVASPACES PR IN C IPLE S, PATTERNS, AND PRACTICE [1 8 ] 4 5 6 7 i m p o r t n e t . j i n i . c o r e . l e a s e . L e a s e ; 8 i m p o r t n e t . j i n i . s p a c e . J a v a S p a c e ; 9 10 p u b l i c c l a s s C lie n te H o la M u n d o { 11 p u b l i c s t a t i c v o i d m a i n ( S t r i n g [ ] a r g s ) { 12 t r y { 13 J a v a S p a c e e s p a c i o = ( J a v a S p a c e ) s p a c e ( ) ; 14 S p a c e O b je c t p l a n t i l l a = new S p a c e O b j e c t ( ) ; (continúa) 387 www.FreeLibros.org 3 8 8 Computación distribuida. Fundamentos y aplicaciones 15 / / R e t i r a e l o b j e t o d e l e s p a c i o r e p e t i d a s v e c e s , 16 / / l o m o d i f i c a , y l o d e p o s i t a d e n u e v o e n e l e s p a c i o 17 w h i l e ( t r u e ) { 18 / / L e e e l o b j e t o d e l e s p a c i o 19 S p a c e O b je c t r e s u l t = ( S p a c e O b je c t ) 20 e s p a c i o . t a k e ( p l a n t i l l a , n u i l , L o n g . MAX_VALUE) ; 21 r e s u l t . i n c r e m e n t o ( ) ; 22 / / E s c r i b e e l o b j e t o e n e l e s p a c i o 23 e s p a c i o .w r i t e ( r e s u l t , n u i l , L e a s e . FOREVER) ; 24 T h r e a d . s l e e p ( 1 0 0 0 ) ; 25 } / / f i n w h i l e 26 } 27 c a t c h ( E x c e p t i o n e x ) { 28 e x . p r i n t S t a c k T r a c e ( ) ; 29 > 30 > 31 } / / f i n c l a s s Es especialmente interesante que la exclusión mutua es una característica interna de diseño del paradigma de espacios de objetos, ya que un objeto compartido sólo puede ser accedido por un participante a la vez. La referencia [Ahuja, Carrier, y Ge- lemter, 17] proporciona excelentes ejemplos que ilustran las aplicaciones que se pue­ den construir usando este paradigma. A los lectores interesados en JavaSpaces se les recomienda consultar las referen­ cias [java.sun.com, 18], [jiniworld.net, 19], [onjava.com, 20], y [Alter, 23]. Tendencias futuras Este capítulo ha presentado un gran número de paradigmas avanzados de computa­ ción distribuida, muchos de los cuales se encuadran dentro del área de investigación. Existen verdaderamente más paradigmas y herramientas que irán surgiendo. Por ejem ­ plo, peer-to-peer es un paradigma que recientemente ha recibido m ucha atención; se han desarrollado varios sistemas y API para dar soporte a este paradigma, incluyen­ do el proyecto JX T A [jxta.org, 16]. Otro paradigma, c o n y u fc w ó n co lab o ratív a usa el concepto de canales para permitir que procesos independientes colaboren en tiem ­ po real; el entorno JSD T (Java Shared Data Toolkit) [java.sun.com, 21] se puede uti­ lizar para crear aplicaciones de red, como pizarras compartidas o entornos d e chat. También se puede utilizar para hacer presentaciones remotas, simulaciones comparti­ das, y distribuir fácilmente datos para trabajos en grupo. S e espera que usted, como lector del libro, haya adquirido los conceptos básicos y comprensión que le permitirá explorar paradigmas nuevos con los que no esté fa­ miliarizado así como nuevas A PI de computación distribuida. 1=14-41 m i Este capítulo ha proporcionado una visión general de los siguientes paradigmas avan­ zados de computación distribuida: www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 8 9 • El paradigma de Sistemas de Colas de Mensajes, que proporciona emisión y re­ cepción de mensajes de forma asincrona a través del uso de colas de mensajes. Un entorno que da soporte a este paradigma es Java M essage System (JMS). • El paradigma de agentes móviles, que da soporte al uso de programas trans­ portables. A pesar de que los agentes móviles se pueden implementar directa­ mente usando RMI, se recomienda el uso de entornos como Aglet, Concordia, y Grasshopper. • El paradigma de servicios de red, el cual muestra la red como una federación de proveedores de servicios y de consumidores de los mismos. Una aplicación puede consumir uno o más recursos, según lo requiera. El protocolo SOAP (Sim­ ple O bject Access Protocoí) se utiliza para este paradigma. Jini de Java es un conjunto de herramientas m uy sofisticado que hace uso de un concepto intere­ sante que son los alquileres de servicios. • El paradigma de espacios de objetos, el cual proporciona espacios lógicos don­ de los objetos pueden depositarse y retirarse por elementos colaboradores. Ja- vaSpaces es un conjunto de herramientas que soportan este paradigma. • H ay otros paradigmas y otras tecnologías que no se han cubierto, incluyendo peer-to-peer y computación colaborativa. E J E R C IC IO S 1. Siga las instrucciones de [java.sun.com, 1] para instalar JM S (Java Message System) en su ordenador. a. Experimente con e l ejem plo HolaMundo mostrado en las Figuras 12.4 y 12.5. — Compile los ficheros fuente. — Arranque un receptor, luego un emisor. Describa y explique el compor­ tamiento. — Arranque dos receptores, luego un emisor. Describa y explique el com­ portamiento. b. Repita parte del experimento con el ejemplo punto-a-punto proporcionado en [java.sun.com, 1]. c. Repita parte del experimento con el ejem plo publicación/suscripción pro­ porcionado en [java.sun.com, 1]. 2. Describa una aplicación que use una o más colas d e mensajes punto-a-punto. Explique cómo la aplicación saca partido del uso de cola(s) de mensajes en térm inos de facilidad d e implementación. 3. Describa una aplicación que use una o más colas de mensajes publicación/sus­ cripción. Explique cómo la aplicación saca partido del uso de colafs) de men­ sajes en términos de facilidad de implementación. 4. Siga las instrucciones del fichero README de la carpeta de ejemplos de agen­ tes móviles para ejecutar la dem o de agentes móviles mostrada en las Figuras d e la 12.8 a las 12.12. Describa y explique el comportamiento. 5. Investigue el entorno de trabajo Aglets [trl.ibm.com, 6], un entorno para agen­ tes móviles. a. ¿Cómo se proporciona transporte de código dentro del entorno Aglet? www.FreeLibros.org 3 9 0 Computación distribuida. Fundamentos y aplicaciones b. ¿Qué otros servicios proporciona e l entorno Aglet adem ás del de transpor­ te de código? c. Descargue e instale el paquete, experimente con los ejemplos proporcio­ nados. 6. Considere las siguientes aplicaciones listadas a continuación. Describa cómo cada uno de estos paradigmas (sistemas de colas de mensajes, agentes móvi­ les y espacios de objetos) pueden aplicarse para desarrollar cada aplicación. Nótese que no se le pide que realice la implementación. S u descripción debe enmarcarse en términos del paradigma genérico, no de una API específica: Las aplicaciones a considerar son: a. Monitorización d e la carga d e mercancías a transportar por un vehículo en camino entre almacenes y tiendas. b. Una sala de chat. c. Una subasta on-line. d. Un servicio que permita a su universidad proporcionar información de los cursos a los estudiantes. La información se actualiza frecuentemente. 7. Investigue sobre JXTA [jxta.org, 16] y escriba un informe del soporte para el paradigma peer-to-peer. Incluya en su informe una descripción de la arquitec­ tura, del API, y programas de ejemplo. ¿Dónde pondría este paradigma den­ tro d e la jerarquía de paradigmas distribuidos? 8. Investigue sobre JSD T (Java Shared Data Toolkit) [pandonia.canberra.edu.au, 22] y escriba un informe sobre el paradigma al que da soporte. Incluya en su informe una descripción de la arquitectura, del API, y programas de ejemplo. ¿Dónde pondría este paradigma dentro de la jerarquía de paradigmas distri­ buidos? R EFER EN C IA S 1. Ja v a M essage S e rv ic e T utorial, http://java.sun.com/products/jms/tutorial/ 2. M icrosoft M S M Q H om e Page, http://www.microsoft.com/msmq/default.htm 3. IB M ’s M Q -S eries, http://www-4.bm.com/software/ts/rnqseries/ 4. Java™ 2 P latform , E nterprise E dition, http://java.sun.com/j2ee/ 5. D. L an g e y M . O shim a. “S e v e n G ood R easons fo r M obile A gents.\" Communicatbns o f the ACM, M arch 1999. 6. IB M A glet. http://www.trl.ibm.com/aglets/ 7. C oncordia, http://www.concordiaagents.com/ 8. G rasshopper 2, http://www.grasshopper.de/index.html 9. S e c u rity in m obile a g e n t sy stem s, http://mole.informatik.uni-stuttgart.de/security.html 10. Jini™ NetW ork T echnology, http://www.sun.com/jini/ 11. K eith E dw ards. Core Jini. U p p er S a d d le R iver, NJ: P rentice H all P T R , 2000. 12. Ja n N ew m arch ’s G u id e to JIN I T echnologies, http://jan.netcomp.monash.edu.au/java/jini/ tutorial/Jini jcml 13. Jini Planet, http://www.kedwards.com/jini/ 14. N o e l’s N uggets, http://www.cc.gatech.edu/~kris/cs7470/nuggets/: Jin i tutorial, w ith exam ples a nd instructions. 15. D aniel D. C orkill. “B lackboard S y stem s,\" A I Expert 6, no. 9 (Septem ber 1991): 4 0 -4 7 . www.FreeLibros.org Paradigmas avanzados d e com p u ta ció n d istrib u id a 3 9 1 16. P roject JX T A , http://www.pita.orgl 17. S u d h ir A huja, N icholas C a rn ero , a n d D avid G elernter. “L in d a a n d F riends.\" Computer, A u ­ g u st 1986: 2 6 -3 4 . 18. E ric Freem an, S u san n e Jupfer, y K en A m o ld . JavaSpaces: Principies, Patterns, and Prac- tice. R eading, M A : A ddison-W esley, 1999. http://java.sun.com/docs/books/jini/javaspaces/ 19. T h e N u ts a n d B o lts o f C o m p ilin g a n d R u n n in g J a v a S p a c e s P ro g ra m s, http://www. jiniworld.net/document/javaspace/The Nuts and Bolts o f Compiling and Running JavaSpa- ces(TM).htm www.FreeLibros.orgwww.FreeLibros.org E p ílo g o Espero que hayas encontrado los materiales presentados en este libro tan interesantes como yo los encontré cuando, como estudiante, me introduje en el campo d e la com­ putación distribuida. Esto no significa, sin embargo, que este libro haga justicia al am ­ plio rango de tem as que existen dentro del espectro de la computación distribuida. La computación distribuida es un apasionante campo, con nuevas ideas y tecno­ logías en constante desarrollo, y viejas ideas y tecnologías siendo redescubiertas. Es cierto que cualquier persona involucrada en este campo estará siempre retada con nue­ vos modelos, teorías y herramientas. Tengo la esperanza de que este libro haya con­ tribuido a que comprendas los principios de la computación distribuida y que te haya preparado para una larga vida de aprendizaje dentro de este campo. Existen muchas áreas que necesitan más atención. La tolerancia a fallos es un tema de gran importancia para cualquier investigador o practicante de la computación dis­ tribuida. Asimismo, no se puede desestimar la importancia del área de la seguridad. También está el tem a d e los algoritmos distribuidos, que yo misma enseño a los es­ tudiantes más avanzados, muchos de los cuales lo encuentran particularmente estimu­ lante. Te invito a que estudies estos campos en mayor profundidad a fin de que am ­ plíes tus conocimientos en el campo de la computación distribuida. M. L. Liu www.FreeLibros.orgwww.FreeLibros.org I n d i c e a l f a b é t i c o A Abstracción, 47, 71-72. nivel de, frente a sobrecarga. 86. Abstract Syntax Notation Number 1 (ASN.l), 58. Abstract Window Toolkit (AWT), 72. Acceso a recursos, 381. Aceptar conexión, operación de, 47. Adaptador de Objetos Portable (POA, Portable Object Adapter), 300. Adaptadores de objetos, 300. Agencia de Proyectos de Investigación Avanzada, 164. Agentes, 373. Agentes móviles, 83, 88, 373-381. arquitectura básica, 374-380. ventajas de, 380-381. American Online (AOL), 29. American Standard Code for Information Interchange (ASCII), 56, 59. Analizador de protocolos, 117. Analógica, procesamiento de señal, 55. Apache Axis, 351. Apache SOAP, 351-352. clase Cali, 351. clase Parameter, 352. clase Response, 352. clase RPCMessage, 351. implementación de servicios web, 356. invocación de servicios web, 354-356. API de JavaSpaces, 386. API de multidifusión arquetípica, 172. API de multidifusión básica de Java, 176-184. API de multidifusión fiable, 184-185. API de sockets datagrama, 92-96. Clase DatagramSocket, 93. métodos principales del, 96. Aplicación independiente, 16. Aplicaciones colaborativas (groupware), paradigma de, 85-86. Aplicaciones conscientes de la multidifusión, 184. Aplicaciones de Internet, 245-286, 321-357. applets, 321-323. contenido web generado de forma dinámica, 257-258. Interfaz Estándar de Pasarela, 258-269. Lenguaje de Marcado de Hipertexto (HTML), 246. Lenguaje Extensible de Etiquetado, 247. Protocolo de Transferencia Hipertexto (HTTP), 248-257. Protocolo Simple de Acceso a Objetos (SOAP), 346-357. servicios web, 344-346. servlets, 323-343. sesiones web y datos de estado de la sesión, 269-285. Aplicaciones, 12. Véase también aplicaciones de Internet. consciente de la multidifusión, 184. ejemplo, 72. independiente, 16. red, 2. Aplicaciones de red, 2. distinción entre servicios de red y, 2. Applets, 12-13, 14, 232, 321-323. Archivos RFC/STD/FYI/BCP, 2. ARPANET, 2, 3, 163-164. Arquitectura arquetípica de objetos distribuidos, 193-194. Arquitectura cliente-servidor, 125. www.FreeLibros.org 3 9 6 Computación distribuida. Fundamentos y aplicaciones Arquitectura de aplicación distribuida, 35-36. capa de presentación, 36. capa de servicios, 36. capa lógica de aplicación, 36. Arquitectura de aplicaciones distribuidas, 35-36. capa de presentación, 36. capa de servicio, 36. capa lógica de aplicación, 36. Arquitectura de Java RMI, 197-199. arquitectura de la parte cliente, 197. arquitectura de la parte servidora, 198-199. registro de objetos, 199. Arquitectura de la parte cliente, RMI, 197. Capa de referencia remota, 198. Capa de resguardo, 197. Capa de transporte, 198. Arquitectura de la parte servidora, 198-199. capa de referencia remota, 199. capa de transporte, 199. capa del esqueleto, 198. Arquitectura de red, 21-23, 125. capa de aplicación, 21. capa de transporte, 21. capa física, 21. capa Internet, 21. direcciones de correo electrónico, 31. direcciones del protocolo Internet, 26-31. identificación de máquina, 26-31. identificación de procesos con puertos de protocolo, 31. protocolos, 23. recursos, 25. Uniform Resource Locators (URLs), 31-33. Arquitectura de software, 130. nivel de lógica de aplicación, 130. nivel de presentación, 130. nivel de servicios, 130. Arquitectura OSI (Open System Interconnection), 21, 125. artefactos de sistemas software, 35. ASCII (American Standard Code for Information Interchange), 56, 59. Asincronas, operaciones enviar, 51-52. Asincronas, operaciones recibir, 52-53. Asincronas, operaciones, 49, 368. Aspectos de seguridad, 9, 284. Ataques web, 10. Audio Galaxy, 39. Autenticación, 381. Autoridad de Asignación de Números de Internet (IANA), 31, 163. B Base64, 253. Berners-Lee, Tim, 245. Big endian, 55. Bloqueante 48, 97. inedefinido, 49, 54. para sincronización de eventos, 48-49. Brumley, David J., 10. Bus. Véase bus de objetos. Bus de objetos, 296. Búsqueda de nombre, 33. Bytecode (código de objeto universal), 13, 16. c Caching de Web, 232. Cadena de interrogación, 263, 264-265. codificación y decodificación, 265-268. envío a programas externos, 265. envío al servidor, 264. Cailliau, Robert, 245. Callback, 84, 220. Callback de cliente, 219,-231. en RMI, 219-231. extensión de la parte cliente, 221. extensión de la parte servidora, 221. pasos para construir una aplicación RMI, 230-231. Campos ocultos de formulario, 270, 334. para enviar datos de estado de la sesión, 271, 276. Capa de esqueleto en la arquitectura de la parte servidora, 198. Capa de mensajería en Servicios Web, 344. Capa de presentación. en arquitectura de software, 130. en una arquitectura distribuida de aplicaciones, 36. Capa de red en servicios web, 344. Capa de referencia remota. en la arquitectura de la parte cliente, 198. en la arquitectura de la parte servidora, 199. Capa de resguardo en la arquitectura de la parte cliente, 197. Capa de servicios. en arquitectura de aplicaciones distribuidas, 36. en arquitectura de software, 130. Capa de transporte. en la arquitectura de la parte cliente, 198. en la arquitectura de la parte servidora, 199. www.FreeLibros.org índice alfabético 3 9 7 en la arquitectura de red, 21. en servicios web, 344-345. Capa física en una arquitectura de red, 21. Capa Internet en una arquitectura de red, 21. Carácter de nueva línea, 260. Cerf, Vint, 162. CERN, 2, 245. CERT (Computer Emergency Response Team), 10. Cifrado, 118, 381. Clase contenedor, 306, 307. Clase DatagramPacket, 93. Clase de ayuda de Java IDL, 304-306. Clase InetAddress, 98, 176. Clase Java, 12. Clase MuíticastSocket, 177. Clientes, 125. Clientes de objeto, 193, 294, 296. Cliente-servidor Daytime. usando sockets datagrama sin conexión, 131-138. usando sockets en modo stream, 138-144. Cliente-servidor Echo. Cliente-servidor Echo orientado a conexión, 149-153. Cliente-servidor Echo sin conexión, 145. Cliente-servidor, paradigma, 74-75, 125-165. antecedentes, 125-126. cuestiones sobre el, 126. comunicaciones entre procesos y sincronización de eventos, 128-129. protocolo de servicio, 127. representación de datos, 129. sesión de servicio, 126-127. ingeniería de software de un servicio de red, 130-145. servidores con estado, 156-162. servidores iterativos, 154-156. COBOL, lenguaje, 295. Codificación de datos, 57-58. Código máquina, 13. Colalx)rativa, computación, 86,388. COM/DCOM, tecnologías, 88. Comité de Arquitectura de Internet, 163. Common Object Request Broker Architecture (CORBA), 82, 88, 194, 293-316. adaptadores de objetos, 300. arquitectura básica, 294. clientes de objetos, 296. compatible con, 294. interfaz de objeto, 295. Inter-ORB, protocolos, 295-296. Lenguaje de Definición de Interfaces (IDL), 295. JAVA, 300-316. Object Request Broker, 301. referencia a objeto, 296-297. Servicio de Nombres, 297-299. Servicio de Nombres Interoperable, 297. servicios de objetos, 299-300. servicios estándar, 301. servidores de objetos, 296. Compartición de recursos, 8. Componentes, tecnologías basadas en, 82. Compuesto, nombre, 298. Computación cooperativa, 8. Computación distribuida, 5-6. arquitectura 35-36. comunicación entre procesos en, 45-64. definido, 2. falta de vocabulario universal, 1. historia, 2-5. modelo cliente-servidor, 2, 74, 108. razones de popularidad, 8-9. virtudes y limitaciones, 8-9. Computación monolítica, 1, 5, 9. Computación monolítica monousuario, 5. Computación paralela, 6. Computación. Véase también Computación Distribuida colaborativa, 86, 388. cooperativa, 8. monolítica monousuario, 5. monolítica, 1, 5, 8-9. paralela, 6. Computadores. en la arquitectura cliente-servidor, 125. Computadores fuertemente acoplados, 1. Computadores ligeramente acoplados, 1. Computer Emergency Response Team (CERT), 10. Comunicación. Comunicación de grupo, 171-185, 369. API de multidifusión básica de Java, 176-184. API de multidifusión fiable, 184-185. Interfaz de Programación de Aplicaciones de multidifusión arquetípica, 172. multidifusión fiable frente a no fiable, 173-176. multidifusión sin conexión frente a orientada a conexión, 172. unidifusión frente a multidifusión, 171-172. Comunicación entre procesos (IPC), 45-64. evolución de los paradigmas para, 63. mecanismo de, 131. metáfora del socket en, 92. sincronización de eventos y, 128-129. comunicación orientada a conexión, 23-25, 103. www.FreeLibros.org 3 9 8 Computación distribuida. Fundamentos y aplicaciones frente a comunicación sin conexión, 23-25. Comunicación simplex, 100. Comunicación sin conexión, 23-25. frente a comunicación orientada a conexión, 23-25. Concordia, sistema, 83. Concurrencia, Servicio CORBA de, 299. Condición de carrera, 18. Conectar, operación, 47. Contenedor de servlets, 324. Contenido web generado de forma dinámica, 257-258. Content-encoding, 253. Content-length, 253. Content-type, 253. Contexto de nombrado, 298. Cookies, 270, 276, 285, 332. código de ejemplo para transmitir datos de estado, 281-284. para transmitir datos de estado de sesión, 276-277. Cookies, expiration date, 253. CORBA. Véase Common Object Request Broker Architecture (CORBA). Corporación de Internet para Nombres y Números Asignados (ICANN, Internet Corporation fo r Assigned Ñames and Numbers), 164. Correo electrónico, 2. Crocker, Stephen D., 163. D D’agent, 83. Datagrama, 92. Datos de control, 93. Datos de estado, código de ejemplo de la utilización de cookies para transmitir, 281-285. Datos de estado de la sesión, 270. campos ocultos de formulario para envío de, 271-276. cookies para envío de, 276-277. Datos de la carga, 93. De la Garza, Joel, 11. Descarga dinámica de resguardo, 232. Desconexión, 47. Descripción, Descubrimiento e Integración Universales (UDDI), 344. Diagramas. de eventos, 59-61. de secuencia, 61-62, 129, 258. Direccionamiento dinámico, 25. Direcciones de correo electrónico, 31. Direcciones de multidifusión del Protocolo de Internet, 177. Direcciones del protocolo de Internet, 26-31. Distefano, Kelly, 11. Distributed Computing Environment (DCE) de Open Group, 80, 195. Documentos hipertexto, 246. Dominio de Internet, 3. Dominio de primer, 29. Sistema Tótem, 185. Dominio de segundo nivel, 29. E E/S en modo stream de los sistemas operativos Unix, 106. eBay, proceso de oferta en, 7. EJB (Enterprise Java Bean), 36, 82. Elementos de entrada, 263. Emisor, 45, 73. Encaminador, 25. Encapsulación, 72. Engelbart, Doug, 164. Entorno, 36. Entorno de multidifusión fiable (RMF, Reliable Multicast Framework), 185. Entorno Microsoft .NET, 36. Entrada estándar, 265. Enviar, 47. Escalabilidad, 8, 87. Espacio, 385. Espacio de nombres, 32. Espacios de objetos, 72, 82-83, 87, 88, 385-388. Estación de trabajo, 4. Estrin, Jerry, 163. Estructuras, 348. Evento, 47. Eventos, diagrama de, 59-61. Eventos, Servicio CORBA de, 299. Excite@Home, 10, 11. Exclusión mutua, 18. Extensible Markup Language (XML), 58, 247. Extensión de la parte cliente para callback de cliente, RMI, 221-225. Extensión de la parte servidora para callback de cliente, 225-229. Extensión de sockets seguros de Java (JSSE, Java Se cure Socket Extensión), 118. Extensiones Multipropósito para el Correo de Internet (MIME), 253. External Data Representation (XDR), 58. www.FreeLibros.org índice alfabético 3 9 9 F Farber, Gerald,163. Fault tolerance, 9. Fichero de políticas de seguridad, 234. Ficheros de políticas de seguridad de Java, sintaxis de, 237-238. Finger, 75. Firma Java IDL, fichero de interfaz de, 303. Flujo binario, 55. Formulario web, 261-263. Función de programación procedimental, 34. G General Inter-ORB Protocol (GIOP), 295. Gestor de renovación de alquileres en Jini, 385. Gestor de seguridad, 233. en RMI avanzado, 233-241. instanciacíón de, en programas RMI, 234-237. Gopher, 75. Grupo de multidifusión, 172. abandono de un, 179. envío a un, 176-184. incorporación en un, 178. recepción de mensajes enviados a un, 179. Gusanos de Internet, 9. H Herramienta, 36. Herramientas de sockets Java, 36. Hilos, 17-20, 54 también Procesos. Java, 19-20. Hilos de ejecución Java, 19-20. Hipertexto, 3. Holder, Eric, 10. HTML. Véase Lenguaje de Marcado de Hipertexto. HTTP. Véase Protocolo de Transferencia Hipertexto (HTTP). i IBM 360 series, 5. IBM MQ*Series, 79, 369. Identificador de proceso, 31. identifying processes wíth, Puertos de protocolo, identificación de procesos con, 31. IDL-a-Java compilador, 301. IDLScript, 295. IFsec, 10. In formación de identificación de un agente móvil, 374. Indefinido, bloqueo, 49, 54. Independiente de plataforma, 16. Información de estado de sesión, 160-164. Información de estado global, 157-160. Ingeniería del software, 34-36. abstracción, 48, 73. arquitectura de las aplicaciones distribuidas, 35-36. componentes, 36. entornos, 36. herramientas, 36. lenguaje de modelado unificado (UML), 34-35. para servicios de red, 130-145. programación procedimental frente a programación orientada a objetos, 34. prototipos en, 213. Interbloqueo, 54. Intercambio de objetos, 385. interfaz cliente remota, 221. implementación, 222. Interfaz de Nombrado y Directorios Java (JNDI), 199. Interfaz de operaciones de Java, 303. Interfaz de Programación de Aplicaciones (API), 47. para Java RMI, 200-207. Interfaz de Programación de Aplicaciones (API) de sockets de Java, 93. Interfaz de programación de aplicaciones (API) de sockets en modo stream, 106-117. Interfaz de programación de aplicaciones de sockets seguros (API, Application Programming Interface), 117-118. Interfaz Estándar de Pasarela (CGI), 258-269. codificación y decodificación de la cadena de interrogación, 265-268. formulario web, 261-263. procesamiento de la cadena de interrogación, 264-269. variables de entorno usadas con, 268-269. Interfaz IPC de programa arquetípica, 47-48. Interfaz remota, 197, 200-201. implementación de, 201-202. Interfaz remota de Java, 200. Interfaz remota Java, 200. Internet Explorer, 6, 21. www.FreeLibros.org 4 0 0 Computación distribuida. Fundamentos y aplicaciones Internet Relay Chat (I.R.C.), 10. Inter-ORB Protocoí (IIOP), 295-296. Interoperable Object References (IORs), 297. Invocación a Método Remoto (RMI), 197. algoritmos para construir, 240. aplicación ejemplo, 207-210. avanzado, 219-242. callback de cliente, 219-232. descarga de resguardo, 232-233. gestor de seguridad, 233-241. instanciación del gestor de seguridad en, 234-237. pasos para construir, 210-212. con callback de cliente, 230-231. pruebas y depuración, 212-213. registro, 234. Invocación de Métodos Remoto Avanzado, 219-241. callback de cliente, 219-231. descarga de resguardo, 232-233. gestor de seguridad, 233-241. Invocación de Métodos Remotos, API, 63, 81, 84, 87. comparación del API de programación de Socket y, 213. Invocación de métodos remotos en Java (Java RMI), 63, 75, 87, 193, 195, 220, 295, 375. API de, 200-207. Iplanet, 326. Itinerario de un agente móvil, 374. J Jabber, 76, 248, 345. Jakarta Tomcat, 326. Java Bean, 82. javaio.InterruptedlOException, 97. Java Message Service (JMS), 369. Java.nio (NIO), 117. Java Server \\\\éb Development Kit (JSWDK), 326. Java Shared DataToolkít (JSDTj, 86, 388. JavaSpaces, 87. Javax, 326. K KaZaA, 39. Kit de desarrollo Java, 36. Kleinrock, Leonard, 162. Kroll-O'Gara Information Security Group, 11. L Lamport, Leslie, 9. Last-modifíed date HTTP, 253. Latencia, 173. Lenguaje ADA, 260,295. Lenguaje C, 260, 295. llamadas a procedimiento en, 79. Lenguaje C++, 260, 295. Lenguaje de Definición de Interfaces Java (Java IDL), 82, 294, 300-316. aplicación, 311. aplicación del cliente del objeto, 313-314. clase contenedor (Holder), 306-307. clase de ayuda (Helper), 304-305. clases del lado servidor, 311-313. compilación y ejecución de la aplicación, 315-316. fichero de interfaz, 302-303. fichero de intefaz de firma, 303. fichero stub, 307-309. herramientas, 301. interfaz de operaciones, 303. paquetes, 301. skeleton del servidor y adaptador portable de objetos (POA, Portable Object Adapter), 309-311. Lenguaje de Descripción de Servicios Web (WSDL), 345. Lenguaje de Marcado de Hipertexto (HTML), 58, 246, 247. Lenguaje de Marcado de Hipertexto (HTTP), 21, 23, 59, 75, 86 246, 248-257. cuerpo de la respuesta, 253. cabecera de la respuesta, 252-253. línea de estado, 251-252. petición del cliente, 249-251. cabecera de la petición, 250. cuerpo de la petición, 250-251. línea de petición, 249-250. respuesta del servidor, 251-253. servidor, 248. servlet, 323. tipo de contenido y MIME, 253. Lenguaje de Modelado Unificado (UML), 34-35. Lenguaje de programación, sintaxis de, 21. Lenguaje estandarizado de Marcado General (SGML), 246, 247. Lenguaje Lisp, 295. Lenguaje Python, 260, 295. Lenguajes. de modelado unificado (UML), 34-35. orientados a objetos, 34. Lenguajes orientados a objeto, 35. Lenguajes procedimentales, 34-35. www.FreeLibros.org índice alfabético 401 Línea de cabecera de petición HTTP Cookie, sintaxis de, 279-280. Línea de cabecera de respuesta HTTP Set- Cookie, sintaxis de, 277-279. Linux, 91. Little endian, 56. Lotus QuickPlace, 86. Llamada a procedimiento local, 195. Llamada a procedimientos remotos de Open Network Computing (ONC), 80, 195. Llamadas a procedimientos, en lenguaje C, 79. remotas, 63, 79-80, 195-197. local, 195. Llamadas a procedimientos remotos, 63, 195- 197. modelo para, 79-80. M Mac-OS, 91. Mainframe, 4, 5. Mantenimiento de la información de estado en la programación con servlets, 332-344. Máquina cliente, 125. Máquina servidora, 125. Máquina Virtual Java (JVM), 13, 16, 19, 232, 322. Máquinas. heterogéneas, 56. identificación, 26-31. Internet, 26. servidor, 125. Marca de tiempo, 128, 129. Mecanismos de transferencia de ficheros automatizados, 2 . Mecanismos del lado del cliente, 270. Mensajes, 2. Método estático, 20. Método FORM GET. envío de la cadena de interrogación al programa externo, 265. envío de la cadena de interrogación al servidor, 264. Método FORM POST. envío de la cadena de interrogación al programa externo, 265. envío de la cadena de interrogación al servidor, 264. Método POST HTTP, 281. Método SetSoTimeout, 97. Métodos estáticos sincronizadas, 20. Métodos remotos, 193, 200. Microsoft DCOM, 82. Microsoft Message Queue (MSMQ), 79, 369. Middleware, 78. Minicomputador, 4. Middleware orientado a mensajes (MOM, Message-Oriented Middleware), 79, 368. Modelo cliente-servidor de la computación distribuida, 2, 74. Modelo de Objetos de Componentes de Microsoft (COM) 36, 82. Modelo de Objetos de Componentes Distribuidos (DCOM), 194. Modelos abstractos de arquitectura de red, 125. Monoprocesador, 1. Motor de servlets, 324. MS-DOS, 91. Multidifusión, 46, 171-172, 176, 369. Multidifusión de Ethernet, 176. Multidifusión en orden atómico, 176. Multidifusión en orden causal, 175. Multidifusión en orden de envío, 175. Multidifusión fiable, 174. Multidifusión FIFO, 174. Multidifusión no fiable, 173, 184. Multidifusión orientada a conexión, 172. Multidifusión sin conexión, 172. naturaleza de uno a muchos de la, 171. Multiplataforma, soporte, 87. Múltiples puntos de fallo, 9. Multitarea, 16-17. N Napster.com, 37, 75. National Center for Supercomputing Applications (NCSA), 275. Naturaleza de uno a muchos de la multidifusión, 171. Navegadores web, 21, 60, 246. Nelson, Ted, 246. Netscape, 6, 21. Neumann, Peter, 11. Nivel de aplicación. en arquitectura de red, 21. en servicios web, 344. Nivel de descripción de servicios web, 344. Nivel de sockets seguros (SSL, Secure Sockets Layer), 117-118. Nivel lógico de aplicación. en arquitectura de aplicación, 36. en arquitectura de software, 130. No orientada a conexión, herramienta, 62-63. Nodo, red, 2. Nodos de Internet, 25. Notification Service Transfer Protocoí (NSTP), 86. www.FreeLibros.org 4 0 2 Computación distribuida. Fundamentos y aplicaciones O Object Computing, Inc., 82. Object Management Group (OMG), 35, 291. Object Request Broker (ORB), 81-82, 294. Objeto DatagramPacket, 93. Objeto DatagramSocket, 93, 94. Objeto Session, 339-343. Objetos distribuidos, 191-215, 192. API para Java RMI, 200-207. arquitectura arquetípica, 193-194. arquitectura de Java RMI, 197-199. comparación de RMI y los API de socket, 213. frente a paso de mensajes, 191-193. Invocación a método remoto (RMI), 197. aplicación de ejemplo, 207-210. pasos para construir una aplicación, 2 1 0 - 2 1 2 . llamadas a procedimiento remoto, 195-197. pruebas y depuración, 212-213. sistemas, 194. Objetos distribuidos, herramientas, 293-294. Objetos distribuidos, paradigmas, 81-82, 192. Ocultamiento de detalles, 72. oNLine System (NLS), 164, 246. Operación de Abandono en la multidifusión de Java, 172. Operación enviar, 172. Operaciones, 48. sincronización de eventos y, 108-117. Operaciones de E/S no bloqueantes, sockets con, 117. Operaciones de E/S, sockets con no- bloqueantes, 117. Operaciones no bloqueantes, 49, 97. Orbix de IONA, 82. Ordenador personal (PC), 5. Organización XNS Public Trust Organization (XNSORG), 33. Orientada a conexión, herramienta, 62-63. Orientado a datos, 192. Orientado a eventos, 192. OS/2, 91. p Páginas Java de Servidor, 343. Paquete, 92. Paradigma de espacio de objetos, 82. Paradigma de Servicios de Red, 84-85, 344. Paradigma de Sistemas de Mensajes, 76. Paradigma peer-to-peer, 75-76, 388. Paradigmas. agentes móviles, 83-84. cliente-servidor, 74-75. espacio de objetos, 82. Middlewares orientados a mensajes (MOM, Message-Oriented Middleware), 76-78. objetos ditribuidos, 8 1 -8 2 . peer-to-peer, 75-76. Paradigmas avanzados de computación distribuida, 367-389. agentes móviles, 373-381. colas de mensajes, sistemas de, 368-373. espacios de objetos, 385,388. servicios de red, 382-385. Paradigmas de computación distribuida, 71-88. abstracción, 71-72, 86. agentes móviles, 83-84, 373-382. avanzados, 367-388. cliente-servidor, 74-75. colaborativas, aplicaciones, 85-86. colas de mensajes, sistemas de, 368-373. escalabilidad, 87. espacios de objetos, 82-83, 385-388. llamada a procedimientos remotos, modelo, 79-80. multiplataforma, soporte, 87. objetos distribuidos, 8 1 -8 2 . paradigmas, 73. paso de mensajes, 73-74. peer-to-peer, 75-76. servicios de red, 84-85, 382-385. sistemas de mensajes, 76. Parámetro tiempo de vida, 179. TKL, 260. Paso de mensajes, 72, 73-74. objetos distribuidos versus, 191-193. Perl, 260. Petición del cliente, 249-251. Petición-de-conexión, operación, 47. Pizarras, 85. Política de seguridad del sistema, 234. Polly, Jean Armour, 163. Postel, Jonathan B„ 162-163. Potencia computacional, 4-5. Presencia en Jabber, 76. Privacidad de los datos, 284-285. Procedimiento, 34. Procesamiento paralelo, 6. Proceso local, 192. Proceso padre, 17. Proceso remoto, 192. Proceso servidor, 125. en un computador conectado a la red, 125. Procesos, 12. Véase también hilos. www.FreeLibros.org índice alfabético 4 0 3 cliente, 125, 193. concurrente, 16-17. hijo, 17, 54. identificación con puertos de protocolo, 31. ligeros, 17. local, 192. Navegador Web, 60. padre, 17. remoto, 192. servidor, 125. Servidor Web, 60. Procesos clientes, 125, 193. procesos hijos, 17, 54. Procesos ligeros, 17. programa de aplicación Java, 12. Programa externo, envío de la cadena de interrogación, 265. Programa transportable, 83. Programación. servlet, 327-344. Programación con hilos, 18-19. Programación concurrente, 16-20. Programación de servlets, 327-331. mantenimiento de la información de estado en, 332-344. Programación multihilo, 18-19. Programación orientada a objetos frente a programación procedimental, 35. Programación procedimental, 195. frente a programación orientada a objetos, 34. Programas y procesos de computación, 12-16. Protocolo de Control de Transmisión (TCP), 23, 24, 31, 93. Protocolo de datagrama de usuario (UDP), 23, 24, 31, 92, 176. Protocolo de descubrimiento de servicios, 344. Protocolo de Transferencia de Ficheros (FTP), 2, 23, 59, 70, 246. Protocolo de Transporte, 246. Protocolo MIME, 253. Protocolo Simple de Acceso a Objetos (SOAP), 84, 195, 248, 344, 346-357, 382. Apache, 351-352. invocación de servicios web utilizando, 354-356. cuerpo, 347. cuerpo de la petición, 348. líneas de cabecera HTTP, 347. recubrimiento, 348. respuesta, 349-351. tipos de datos, 348-349. estructuras, 348. matrices, 349. objetos, 349. Protocolo simple de transferencia de correo (SMTP, Simple Mail Transpon Protocol), 59, 345. Protocolo SNMP (Simple Network Management Protocol), 23. Protocolo TCP/IP, 23. conjunto, 24. pila, 23. Protocolos, 20-21. arquitectura de red, 23. basados en texto, 59. con estado, 161. deservicio, 127. descubrimiento de servicios, 344. MIME, 253. servicios de red, 47. sin estado, 161. solicitud-respuesta, 59, 128. transporte, 248. Protocolos con estado, 156. Protocolos de servicios de red, 47. Protocolos sin estado, 156. Prototipos, 213. Proveedores de Servicio de Internet (ISP), 28. Proxy, 193. diente, 193. servidor, 193. proxy de cliente, 194. Proxy servidor, 194. aplicación, 82. con estado, 156. concurrente, 154. envío de la cadena de interrogación a, 264. iterativo, 154. objeto, 199, 296. Servidores, 108, 125, 312. sin conexión, 143. sin estado, 156. Web, 6, 60, 246, 248, 250. Proyecto JXTA, 76. Proyecto SETI (Search fo r Extraterrestrial ¡ntelligence), 8. Publicación, operación de sistema de mensajes, 369. Publicación/suscripción, sistema de mensajes, 78, 88, 368-373. Puertos bien conocidos, 31. Punto-a-punto, modelo de mensajes, 78, 368. www.FreeLibros.org 4 0 4 Computación distribuida. Fundamentos y aplicaciones R Receptor, 45, 73. Recibir, operación, 47. Recuperación de información a través de una red, 246. Recursos de red, 25. Red, 20-34. protocolos, 2 0 -2 1 . Red de datos, 24. Referencia a un objeto distribuido, 194. región crítica, 18. Registro, 34. objeto, 193. RMI, 234. Registro de objetos, 193, 199. Relación causal, 175. Remnitz, David M., 10. Replicación, 172. Representación de datos, 55, 56. Representación externa, 56. Request fo r Comments (RFC), 2, 162. Resguardos, 145, 196, 294. descarga, 203. algoritmos para construir aplicaciones RMI para, 240. dinámica, 232. en RMI avanzado, 232-233. especificar, 238. en el software de la parte servidora, 2 0 1 - 2 0 2 . en la arquitectura de la parte cliente, 197. Resolución de nombre, 33, 297. Rodaja de tiempo, 16. Rpcgen, 196. s Script de Interfaz Estándar de Pasarela (CGI), 258, 323, 328, 332. Secuencia, digrama de, 61. Serializable, objeto, 374. Señalización de objetos, 57. Serie, transferencia de datos, 63. Series UNIVAC 1 1 0 0 , 5. Servant, CORBA, 311. Servicio CORBA de Control de Transacciones, 299. Servicio CORBA de Negociación, 299. Servicio CORBA de Notificación, 299. Servicio CORBA de Planificación, 299. Servicio CORBA de Seguridad, 299. Servicio CORBA de Tiempo, 299. Servicio de Daytime, 126. Servicio de Eventos de T em po (Timer Event Service), 299. Servicio de Logging de CORBA, 299. Servicio de multidifusión fiable de Java (Servicio JRM, Java Reliable Multicast Service), 185. Servicio de Nombres, 294, 299. Servicio de Nombres Extensible (XNS), 33. Servicio de Nombres Interoperable (INS), 298. Servicio de red Los Nettos, 163. Servicio de transferencia de ficheros, 25. Servicio, replicación de, 172. Servicios de Colas de Mensajes (MQS, Message Queue Services), 79, 368-373. Servicios de red, 2 , 25, 382-385. distinción entre aplicaciones de red y, 2 . ingeniería de software de, 130-145. Servicios web, 285, 344-346. implementación, utilizando Apache SOAP, 356. invocación, utilizando Apache SOAP, 354-355. y a implementados, 353. Servicios web y a implementados, 353. Servidor, clases en el lado, 311-313. Servidor con estado, 157. Servidor concurrente, 154-156. Servidor de aplicaciones, 82. Servidor Echo, 146-149. Servidor iterativo, 154. Servidor orientado a conexión, 143. Servidor sin conexión, 143. Servidor sin estado, 157. servidores de objeto, 193, 296. máquina, 199. Servidores Wfeb, 6 , 60, 245. Servlet persistente, 324. Servlets, 1 2 , 13, 15, 323-343. soporte arquitectónico, 324-326. Sesión, 126-127. sesión de servicio, 126-127. Sesión web y datos de estado de la sesión, 269-285. Síncronas, operaciones, 49. Síncronas, operaciones enviar, 50-52. Síncronas, operaciones recibir, 50-52. Sincronización de eventos, 48-53. bloqueo para, 48-49. comunicaciones entre procesos y, 128-129. en sockets datagrama, 97-103. enviar asíncorno y recibir asincrono, 53. enviar asíncorno y recibir síncrono, 51-52. www.FreeLibros.org índice alfabético 4 0 5 enviar síncorno y recibir asincrono, 52-53. enviar síncorno y recibir síncrono, 50-51. operaciones y, 108-117. Sintaxis. de la línea de cabecera de petición HTTP Cookie, 279-281. de la línea de cabecera de respuesta HTTP Set-Cookie, 277-279. de mensajes, 129. del fichero de políticas de seguridad Java, 237-238. del lenguaje de programación, 21. Sistema de multidifusión fiable sin orden, 174. Sistema de Nombre de Dominio (DNS), 29, 75. resolución de nombres, 30. servidores, 33. Sistemas de objetos distribuidos, 194. Sistemas distribuidos, 1-2. Sistemas operativos, 12-20. programas y procesos, 1 2 - 1 6 . programación concurrente, 16-20. Skeleton, 294. generación de, en software de la parte servidora, 202-203. Skeleton del servidor y adaptador de objetos portable (POA, Portable Object Adapter), 309-311. Smalltalk, lenguaje, 295. SMART Board, 86. smurf attack, 1 1 . SOAP. Véase Protocolo Simple de Acceso a Objetos (SOAP). Sobrecarga, nivel de abstracción versus, 86- 87. Sociedad de Internet, 162. Socket datagrama sin conexión, 93-96. cliente-servidor Daytime utilizando, 131-138. Socket Interfaz de Programación de Aplicaciones (API) de, 63, 74, 92-118. antecedentes, 91-92. con operaciones de E/S no-bloqueantes, 117. datagrama, 92-106. en modo stream, 106-117. metáfora del socket en comunicación entre procesos, 92. seguros, 117-119. Sockets, 63, 92. como metáfora en comunicación entre procesos, 92. con operaciones de E/S no-bloqueantes, 117. datagrama, 92-102. datagrama sin conexión, 93-97, 131-138. en modo stream, 138-145. Sockets datagrama, 93. Empaquetamiento de datos, 56,374. sin conexión, 93-96. sincronización de eventos en los, 97-103. Sockets de conexión, 103, 108. Sockets de datos, 108. Sockets en modo stream, cliente-servidor Daytime usando, 138-144. Sockets stream, 93. Software, 12. del lado cliente, 130, 131-132, 138-139, 205-207, 214. del lado servidor, 130, 132, 139-140, 201- 205, 214. Software del lado cliente, RMI, 130-132, 205-207. algoritmos para desarrollar, 212, 241. búsqueda de objeto remoto, 206. invocación de método remoto, 206. lógica de aplicación en el, 132, 139. lógica de presentación en el, 131, 138. lógica de servicio en el, 132,139. sentencia import, 206. Solicitud-respuesta, protocolos, 59, 128. Sondeo, 220. Soporte de tiempo real, 194. de la Interfaz de Programación de Aplicaciones (API), 93. Stub, fichero, 307-309. Sun Microsystems, Inc., 293. Suscripción, operación de sistema de mensajes, 368. SYNflood, 11. T Tacoma, proyecto, 83. TAO, 82. Tarea, datos de, 372. Telnet, 126. Temporizadores (timeouts), 54. Terminales, 5. Texto, protocolos basados en, 59. Thread-safe, 18. Tiempo compartido, 5, 16. Tipos de datos escalares del esquema XML, 348. Transferencia de datos en paralelo, 63. Transparencia de localización, 42, 84. www.FreeLibros.org 4 0 6 Computación distribuida. Fundamentos y aplicaciones u Unicode, 33, 56. Unidifusión, 46, 171. UNIX, 46, 253, 269. UNIX de Berkeley, 91. URI (Uniform Resource Identifier), 32. URL (Uniform Resource Locator), 31-33, 255. URL relativo, 32, 262. URN ( Uniform Resource Ñame), 32. Utilidades del servidor, 270. algoritmos para el desarrollo, 211, 230, 240. generación del resguardo y el esqueleto, 202-203. implementación de la interfaz remota, 2 0 1 - 2 0 2 . lógica de aplicación, 132, 139. lógica de presentación, 132, 139. lógica de servicio, 132, 140. servidor de objeto, 203-205. Software del lado servidor, 130, 132, 201-205. Uuencode, 253. v Variables de estado utilizadas con el Interfaz Estándar de Pasarela (CGI), 268-269. Variables servlet, 332. Vector Java, 229. Virus, 9. Visual Basic script, 260. w Watson, Thomas, 8. Web (World Wide Web, WWW) 2-3, 25, 245. WebLogic, 326. Websphere, 326. Windows, 46, 283. Windows NT, 91. Winsock, 92. World Wide Web (WWW) Consortium, 245. www.FreeLibros.orgwww.FreeLibros.org El objetivo p rin c ip a l de e ste m a n u a l e s d a r a c o n o c e r lo s c o n c e p t o s f u n d a m e n t a le s de la i n t e r c o m u n i c a c i ó n entre p r o c e s o s . C a r a c t e r í s t i c a s im p o rta n te s : • Está d is e ñ a d o p a ra in tro d u c ir a lo s e s t u d ia n t e s u n iv e r s it a r io s en lo s fu n d a m e n to s de la c o m p u t a c ió n d istrib u id a . • Se c e n t r a en la s c a p a s m á s a lta s de la a rq u it e c t u r a de la c o m p u t a c ió n b a s a d a en red, y m á s e s p e c íf ic a m e n t e en lo s p a r a d ig m a s y a b s t r a c c i o n e s de dich a c o m p u t a c ió n . • In c o r p o r a t e m a s c o n c e p t u a l e s y p r á c t i c o s , utilizando p r o g r a m a s de e je m p lo y e j e r c i c i o s p a ra ilu s t r a r y r e fo rz a r lo s c o n c e p t o s p r e s e n t a d o s . • C om bina la t e o ría y la p r á c t ic a de la c o m p u t a c ió n d istrib u id a . • Está d is e ñ a d o p a ra el a p re n d iz a je c o n la e x p e r im e n t a c ió n : s e p r e s e n t a n e je m p lo s de p r o g r a m a c ió n s o b re lo s t e m a s t r a t a d o s y se in c o r p o r a n a c t iv id a d e s de la b o ra to rio y e j e r c i c i o s al fin a l de c a d a c a p ítu lo . P E A R S O N Educación w w w .p e a rs o n e d u c a c io n .c o m www.FreeLibros.org","libVersion":"0.5.0","langs":""}