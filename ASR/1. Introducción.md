# 1.1 Tipos de Instalación
A la hora de instalar un sistema, tenemos que tener en cuenta el tipo de funciones que va a desempeñar. 
- **Sistema de escritorio:** usado en tareas rutinarias
- **Estación de trabajo:** sistema de alto rendimiento, generalmente orientado a una tarea específica. Por ejemplo estaciones dedicadas al cálculo o estaciones gráficas.
- **Servidores:** ofrecen servicios a otras máquinas de la red
	- **Servicios de disco:** acceso a ficheros a través de FTP, servicio de disco transparente a través de NFS o Samba
	- **Servicios de aplicaciones**, por ejemplo, terminales, conexión remota (telnet, ssh) ...
	- **Servicios de directorio**, por ejemplo, LDAP, que almacena credenciales de usuarios, directorios, etc.
	- **Servicios de bd**
	- **Servicios de impresión**
	- **Servicios de red**

# 1.2 Instalación
Seguimos con detalle los pasos sugeridos por el instalador, al llegar a la parte del particionado del disco podemos instalar todo el sistema en una sola partición, aunque no es nada recomendable. Esto se debe a motivos de **seguridad, estabilidad, mantenimiento y rendimiento**. La estructura de directorios **UNIX** sigue el estándar **FHS** (*Fylesystem Hierarchy Standard*)

### Fylesystem Hierarchy Standard
- **/ (root o raíz):**  directorio raíz del sistema, todo cuelga de aquí
- **/boot/:** ficheros usados para el arranque, incluyendo el kernel
- **/bin/ (binaries):** ejecutables esenciales de configuración y administración para el superusuario. 
- **/lib/:** librerías esenciales para los ejecutables de **/bin/** y **/sbin/**
- **/usr/ (Unix System Resources):** resto de las aplicaciones usadas por los usuarios y el superusuario. Incluye ejecutables, librerías, cabeceras para programación en C, código fuente, manuales, etc, organizados en los siguientes subdirectorios.
	- **/usr/bin/:** la mayoría de las aplicaciones de usuario
	- **/usr/sbin/:** la mayoría de las aplicaciones para el superusuario
	- **/usr/lib/:** librerías que necesitan los ejecutables de **/usr/bin/** y **/usr/sbin/**
	- **/usr/share/:** datos independientes de la arquitectura, fundamentalmente manuales
	- **/usr/include/:** ficheros de cabecera (.h) estándar
	- **/usr/src/ (opcional):** código fuente del kernel y de las aplicaciones
	- **/usr/local/:** aplicaciones que no forman parte de la distribución y que el superusuario ha instalado manualmente. Replica la estructura anterior **usr/local/bin/, /usr/local/lib/, /usr/local/share/, etc.**
- **/opt/:** aplicaciones que requieren un subdirectorio separado del resto 
- **/etc/:** ficheros y scripts de configuración, tanto del sistema como de las aplicaciones. 
- **/var/:** ficheros variables (logs, bases de datos, etc.) Por ejemplo:
	- **/var/log/:** ficheros de log
	- **/var/spool/:** ficheros temporales de impresión, e-mail y otros
- **/tmp/:** ficheros temporales que se borran durante el reinicio del sistema
- **/srv/:** datos de servicios proporcionados por el sistema (páginas web, ftp, cvs, etc.)
- **/home/ (opcional):** directorio de usuarios (directorio inicial o home)
- **/root/ (opcional):** directorio *home* del superusuario

Otros directorios:
- **/media/:** punto de montaje para medios removibles (USB, CDROM)
- **/mnt/:** punto de montaje para otros sistemas temporales (por ejemplo una partición de otro SO)
- **/dev/:** directorio que contiene *seudoficheros* de acceso a periféricos, operando sobre estos ficheros damos ordenes a los dispositivos
- **/proc/:** directorio que contiene información del sistema (CPU, memoria, buses, interrupciones, procesos en ejecución, etc.)
- **/sys/:** similar al anterior, contiene información de dispositivos (por ejemplo, el brillo de la pantalla y la carga de la batería de los **portátiles**)

### Esquemas de particionamiento
Dependiendo del tipo de sistema:
- **Máquina de escritorio** (un solo usuario trabajando a la vez).
	- **swap:** área de intercambio, es una zona del disco que en caso de emergencia puede utilizarse en sustitución de la memoria RAM. Se le suele otorgan al menos el doble del tamaño de la RAM.
	- **/home/:** cuentas de usuario, tamaño en función del número de usuarios
	- **/:** resto del disco (con el SO)

- **Sistema multiusuario**, además de las particiones anteriores crear particiones separadas para **/usr, /var y /tmp**.
	- **/usr** podría montarse en modo sólo-lectura después de que todo el sistema esté instalado
	- tener **/var** y **/tmp** en su partición evita que estos directorios crezcan hasta ocupar todo el disco 

- **Particiones adicionales:**
	- **/boot:** para tener la función de arranque separada del resto. Permite incluso evitar las incompatibilidades de las BIOS con los discos duros grandes
	- **/chroot:** para aplicaciones en un entorno *enjaulado* que requieran seguridad y aislamiento
	- **/var/lib:** partición para gestionar del servidor de bases de datos (DNS, Apache) o del proxy (MySQL, Squid).

### Sistemas de ficheros
Linux soporta varios sistemas de archivos:
- **ext4:** Fourth EXTended filesystem, es el sistema de ficheros estándar en Linux
	- Es un sistema de ficheros transaccional (como una bd)
	- Tiene características que le permiten reducir la fragmentación
	- Puede trabajar con discos y ficheros de gran tamaño.
	- Las opciones pueden configurarse con el comando `tuen2fs` 
	- Las anteriores versiones `ext3` y `ext2`  siguen estando disponibles

- **btrfs:** posible sucesor de ext4, pues presenta características avanzadas que además de mejorar el rendimiento, van dirigidas a la gestión y seguridad del almacenamiento:
	- Gestiona de manera integrada el almacenamiento, pues incluye funciones que antes formaban parte del sistema de ficheros, del controlador RAID y del gestor lógico de volúmenes LVM
	- Hace uso extensivo de *copy-on-write*, si varios recursos son idénticos se devuelve un puntero a un único recurso; en el momento en que se modifica una “copia” del recurso, se crea una copia auténtica para prevenir que los cambios sean visibles a las demás copias.
	- Permite *snapshots* de solo lectura o modificables
	- Etc

- **JFS, XFS:** otros tipos de sistemas transaccionales portados de otros sistemas Unix

- **NFTS, exFAT:** usados por Windows en ordenadores domésticos soportados también por linux
- **ReFS:** usado por windows para empresas, no disponible de forma nativa para windows

### Instalación del gestor de arranque
Podemos tener diferentes distribuciones de Linux y Windows en el mismo ordenador, cada una con sus correspondientes particiones. El gestor de arranque (cargador o *bootloader*) nos permite seleccionar el SO  a arrancar.

- Las distribuciones **Linux** usando el cargador **GRUB** (GRand Unified Bootloader)
- Cuando el sistema se inicia, la **BIOS** carga el gestor de arranque que nos permite seleccionar el SO y a continuación transfiere el control al programa de inicio del correspondiente SO (localizado en /boot)

Tenemos dos posibilidades a la hora de instalarlo:
- Instalarlo en el **MBR** o **GTP** del primer disco:
	- El MBR contiene información osbre las particiones del disco y un pequeño código del gestor de arranque. MBR se almacena solo en el primer sector del disco
	- El GTP es el nuevo estándar que sustituye al anterior, más fiable y asociado a los sistemas UEFI. GTP Crea múltiples copias redundantes a lo largo de todo el disco y su nombre hace referencia a que a cada partición se le asocia un identificador global único
- En caso de que tengamos otro cargador en el MBR o GTP, el gestor de arranque GRUB puede instalarse en el primer sector de la partición Linux que contenga /boot

Podemos configurar GRUB para evitar que sea modificado el menu de arranque. En concreto, podemos usar una contraseña para limitar:
- la modificación de los parámetros iniciales
- el acceso a determiandas imágenes
- el acceso a opciones avanzadas

### Logical Volume Management
Proporcionar una visión de alto nivel de los discos:
- permite ver varios discos como un único volumen lógico
- permite hacer cambios en las particiones sin necesidad de reiniciar el sistema
- permite gestionar los volúmenes en grupos definidos por el administrados

- **Volumen físico (PV):** discos duros, particiones de los discos y otros dispositivos
- **Grupos de volúmenes (VG):** agrupación de LV, que forman una unidad administrativa
- **Volumen lógico (LV):** particiones lógicas sobre las que se montan los sistemas de ficheros

![[Pasted image 20250917104001.png]]


# 1.3 Arranque del sistema
1. **BIOS:** el procesador se dirige a una posición de memoria específica, donde se encuentra la **BIOS**. Se ejecuta un programa que detecta los discos, carga el registro del arranque y ejecuta el gestor de arranque.
2. **Gestor de Arranque:** es un pequeño programa que usualmente muestra un menú con la lista de los SO disponibles, el usuario puede seleccionar lo que le interese y cargar el kernel.
3. **Kernel:** se localiza en **/boot/vmlinuz** y empiza a buscar y montar la partición que contiene el sistema de ficheros raiz, ejecutando el primer programa, **init**. Esto se suele hacer en 2 pasos:
	1. **initframs:** primera fase donde se carga en RAM el fichero de imagen de un pequeño disco virtual que contiene un partición raíz virtual y el programa **init**
	2. **init:** initframs cede el control al init real y la máquina inicia el proceso de arranque estándar.

**Systemd** es el sistema de inicio actualmente utilizando en Debian:
- ejecuta varios procesos encargados de la creación del sistema: teclado, controladores, sistemas de ficheros, red, servicios...
- esto hace que ofrezca una visión global del sistema tanto software como hardware
- muchos de estos procesos ofrecen servicion

Varias utilidades:
- **systemctl** es un comando de gestión de servicios específico de **systemd**. Si se ejecuta sin argumentos muestra la lista de servicios activos, mientras que si indicamos un servicio podemos realizar diferentes operaciones sobre el.
![[Pasted image 20250918112100.png]]
![[Pasted image 20250918112150.png]]

- **service:** es el comando que clásico que tiene una sintaxis similiar
![[Pasted image 20250918112233.png]]
![[Pasted image 20250918112246.png]]

**Systemd** distingue varios target. Entre ellos destacan:
- **Rescate:** que arranca lo mínimo para intentar repara un sistema dañado
- **Emergencia:** abre un único shell
- **Multisuario:** multiusuario no gráfico
- **Gráfico:** multiusuario gráfico
![[Pasted image 20250918112801.png]]

## 1.4 Verificación de la instalación
![[Pasted image 20250918112858.png]]


# 2. Instalación de software
## 2.1 Formas de instalación
Hay dos formas de instalar programas en linux:
- Instalación desde paquetes precompilados: menos optimización, más sencilla
- Compilación e instalación desde las fuentes: optimización para nuestro sistema, más compleja

### Gestores de paquetes
En la mayoría de distribuciones Linux, es posible obtener los programas precompilados en formato de paquetes
- **Ventajas:** fáciles de instalar y desinstalar, fáciles de actualizar, fácil control de los programas instalados
- **Inconvenientes:** Binarios menos optimizados, problemas de dependencias de paquetes, problemas si la base de datos de paquetes se corrompe.

Formatos de paquete más populares:
- **DEB**
- **RPM**

### Gestión de paquetes en Debian
Existen varias herramientas para instalar paquetes:
- **dkpg:** herramienta de bajo nivel, para gestionar directamente los paquetes DEB
![[Pasted image 20250918114831.png]]

- **apt:** herramientas **APT**, permiten gestionar los paquetes descargándolos de varias fuentes (CDs, http). Apt cuenta con un fichero de configuración que contiene los distintos servidores desde  los cuales se obtienen los paquetes (**/etc/apt/sources.list**)
![[Pasted image 20250918115548.png]]
![[Pasted image 20250918115625.png]]



- Muchas otras herramientas con interfaz gráfico o semigráfico, a veces con formato *store*
- **alien:** permite convertir e instalar en Debian paquetes de otro tipo como RPM
- **snap:** estos paquetes son autocontenidos por lo que funcionan en una amplia gama de distribuciones linux. Incluyen dentro del paquete todas las componentes que necesitas como las librerías. 
- **pip:** es el instalador de paquetes de Python


# 2.2 Instalación desde el código fuente
Los pasos para instalar manualmente una aplicación desde código fuente:
1. Descarga, normalmente se distribuyen en forma de *tarballs*:
	- .tar (empaquetado pero sin comprimir)
	- .tar.gz (empaquetado y comprimido, abreviado .tgz)
2. Desempaqeutado: comando tar (Tape ARchive format)
![[Pasted image 20250918124159.png]]

3. Leer el fichero INSTALL
4. Configuración, mediante el script de configure `./configure <opciones>` 
![[Pasted image 20250918124328.png]]

5. Compilación `make all`
6. Instalación `make install` 