<!-- Copyright (c) 2025 Adrián Quiroga Linares Lectura y referencia permitidas; reutilización y plagio prohibidos -->

# 3.1 Gestión de procesos
Un proceso es una instancia de un programa en ejecución. En cada momento se están ejecutando un gran número de procesos:
- procesos de sistema (kernel, servicios o daemons)
- procesos de usuario

Una CPU puede constar de varios núcleos. El planificador de procesos se encarga de asignar los procesos a los núcleos en función de su prioridad. En la planificación con asignación dinámica los procesos pueden cambiar de núcleo al pasar a estado activo si el último núcleo en el que se ejecutó está ocupado y existe otro núcleo ocioso. No obstante, la migración de un proceso de un núcleo a otro es costosa. Por tanto, siempre que sea posible se intentará evitar para no incurrir en la penalización de los fallos de caché que resultan de la migración de procesos.

Un proceso se puede componer de varios subprocesos (hilos). Tanto los procesos como los hilos son secuencias independientes de ejecución.La diferencia es que los hilos (del mismo proceso) comparten su espacio de direcciones virtuales y recursos del sistema, mientras que los procesos se ejecutan en espacios de memoria separados.

En esta sección trataremos la gestión de los procesos que se ejecutan:
- **listar procesos en ejecución**
- **detener y matar procesos**
- **controlar la prioridad de ejecución**

![[Pasted image 20251013130143.png]]

## 3.1.1 Ver los procesos en ejecución
Existen varias herramientas para ver los procesos en ejecución, la más importante es `ps` 

### ps (process status)
Lista los procesos son su **PID** (identificador de proceso), **TTY** (número de terminal), **TIME** (tiempo de cpu usado) y **CMD** (línea de comando usada).

![[Pasted image 20251013130524.png]]

Sin opciones, `ps` sólo muestra los procesos lanzados desde la terminal actual y con el mismo EUID que el usuario que lo lanzó.

Tipos de opciones:
- **Opciones UNIX:** `ps -e`
- **Opciones BSD:** `ps ax` 
- **Opciones largas GNU:** `ps --user tomas` 

- `-e`: muestra todos los procesos
- `-u`: muestra los procesos de un usuario
- `-o`: permite definir el formato de salida

![[Pasted image 20251013130913.png]]

![[Pasted image 20251013131040.png]]

En cuento al estado (código state), son posibles entre otros: 
![[Pasted image 20251013131001.png]]

### pstree
Muestra el árbol de procesos
![[Pasted image 20251013131148.png]]

### top
Nos da una lista de procesos actualizada periódicamente
![[Pasted image 20251013131300.png]]

En la cabecera nos muestra un resumen del estado del sistema:
- hora actual, tiempo que lleva el sistema encendido, el número de usuarios conectados y la carga media del sistema para los últimos 1, 5, 15 mins
- Número total de tareas y resumen por estado
- estado de ocupación de la CPU y la memoria. En un sistema $n$ núcleos el máximo uso de CPU es $n\times100$ % 
Por defecto, los procesos se muestran ordenados por porcentaje de uso de CPU. Pulsando h mientras se ejecuta top, obtenemos una lista de comandos interactivos. Los campos de las columnas tienen un significados similar a los del comando ps y se pueden seleccionar interactivamente pulsando f. Para salir, q.

### strace
Muestra las llamadas al sistema realizadas por un proceso en ejecución
![[Pasted image 20251013132152.png]]

### Ejecución en segundo plano
Por defecto, los comandos corren en primer plano (foreground): el shell espera a que termine el comando antes de aceptar uno nuevo.
- para ejecutar un comando en segundo plano se añade &
![[Pasted image 20251013132304.png]]

- para terminar un proceso en foreground Ctrl-C
- para pasar un comando en foreground usar Ctrl-Z
	- `bg` pasa el proceso a background
	- `fg` lo devuelve a foreground

![[Pasted image 20251013132449.png]]

El comando jobs permite ver la lista de comandos (jobs) en background lanzados desde el shell, así como su estado (fg y bg pueden actuar sobre uno de los jobs identificándo por su número)
![[Pasted image 20251013132516.png]]

## 3.1.2 Señalización de procesos
El comando básico para enviar señales a un proceso el `kill` 
- Si el proceso se lanzó en foreground se pueden enviar algunas señales desde teclado
- `kill -l` lista el conjunto de señales
![[Pasted image 20251013152508.png]]

- Para ver lo que hace cada señal `man 7 signal` 

La sintaxis de `kill`:
- `kill [señal] PID` 
- `kill -9` es equivalente a `kill -SIGKILL` 

Las señales más comunes son:
- `SIGTERM:` mata al proceso permitiéndole terminar correctamente
- `SIGKILL:` mata al proceso inmediatamente
- `SIGSTOP:` detiene temporalmente el proceso
- `SIGCONT:` continua si el proceso fue parado
- `SIGINT:` interrupción de teclado (Ctrl+C), mata el proceso
- `SIGTSTP:` stop de teclado (Ctrl+Z) para temporalmente el proceso

Algunas carácterísticas:
- Excepto `SIGKILL` y `SIGSTOP`, las demás señales pueden ser ignoradas o gestionadas por el proceso
- La señal que se envía por defecto es `SIGTERM` 
	- Se puede ignorar y no terminar
	- la señal equivalente de teclado es `SIGINT`
- `SIGSTOP` y `SIGTSTP` se utilizan para detener temporalmente un proceso, la primera desde un programa y la segunda desde teclado (Crtl-Z)
- Cuando cerramos un shell o un terminal en un entorno gráfico, se envía un `SIGHUP`  (hang up, cuelgue) a todos sus hijos, que suelen responder finalizando también.

### Otros comandos
`nohup` normalmente, cuando salimos de un login shell (logout) o cerramos un terminal, se envía una señal `SIGHUP` a todos los procesos hijos:
- si lanzamos un proceso en background y salimo sde la sesión el proceso se muere al morir el shell desde el que lo iniciamos
- El comando `nohup` permite lanzar un comando ignorando las señales de `SIGHUP` 
- La salida del comando se redirige al fichero nohup.out

`pgrep` busca en la lista de procesos para localizar el PID a partir del nombre:
- `pgrep sshd` devuelve el PID de `sshd` 

`pkill` permite enviar señales a otros procesos indicándolos por el nombre en vez por PID
- `pkill -KILL firefox` 
- Si hay varios procesos con el mismo nombre los mata a todos
- admite también patrones en vez de nombres

`exec` ejecuta un comando reemplazando al shell desde el que se lanza


## 3.1.3 Manejo de la prioridad y recursos de un proceso
Cuando un proceso se ejecuta, lo hace con una cierta prioridad
- Van desde -20 (más alta) a 19 (más baja)
- Por defecto, los procesos se ejecutan con prioridad 0
- Los comandos para manejo de prioridades son `nice` y `renice` 

`nice` permite lanzar un comando con una cierta prioridad.
- `nice -n ajuste comando` 
![[Pasted image 20251013160519.png]]

`renice` permite cambiar la prioridad de un proceso que está en ejecución
- `renice pri [-p pid] [-u user] [-g pgrp]`
- `-p pid` cambia la prioridad para el proceso especificado
- `-u user` cambia la prioridad para los procesos del usuario especificado
- `-g pgrp` cambia la prioridad para los procesos ejecutados por los usuarios que pertenecen al grupo de gid `pgrp` 
![[Pasted image 20251013160732.png]]

### Control de los recursos de un proceso
El comando interno `ulimit` permite controlar los recursos de los que dispone un proceso arrancado por el shell
- `ulimit [opciones] [limite]` 
- `-a` muestra los límites actuales
- `-f` máximo tamaño de los ficheros creados por el shell (opción por defecto)
- `-n` máximos número de ficheros abiertos
- `-s` tamaño máximo de pila
- `-t` máximo tiempo de cpu
- `-S/-H` usa los límites `soft` y `hard`

![[Pasted image 20251013161000.png]]

## 3.1.4 Análisis básico del rendimiento del sistema
Además de `ps` y `top` existen comandos básicos que nos pueden mostrar el rendimiento del sistema en cuento a uso de CPU y consumo de memoria

`uptime` Muestra la hora actual, el tiempo que el sistema lleva encendido, el número de usuarios conectados y la carga media del sistema para los últimos 1, 5 y 15 minutos.
![[Pasted image 20251013161919.png]]

`w` además de la información dada por uptime, el comando `w` muestra información sobre los usuarios y sus procesos
![[Pasted image 20251013161955.png]]

- `LOGIN@`  la hora a la que se conectó el usuario
- `IDLE` tiempo que lleva ocioso el terminal
- `JCPU` tiempo de CPU consumido por los procesos que se ejecutan en el TYY
- `PCPU` tiempo de CPU consumido por el proceso actual

`free` muestra la cantidad de memoria libre y usada en el sistema, tanto para la memoria física como para el swap, así como los buffers usados por el kernel
![[Pasted image 20251013162233.png]]

- La columna `shared` indica la memoria usada por tmpfs, `buffers` la memoria usada por los buffers del kernel y cache la memoria usada por los datos cacheados.

- `-b, -k, -m, -g` memoria en bytes/KBytes/MBytes/GBytes
- `-t` muestra una línea con el tatal de memoria (física+swap)
- `-s` delay muestra la memoria de forma continua, cada delay en segundos

## 3.1.5 Los directorios /proc y /sys
Son dos diectorios que guardan la información que recopila el S.O.
- /proc ofrece información sobre los procesos (de ahí su nombre). También almacena todo tipo de información sobre los componentes principales del ordenador.
- /sys ofrece información detallada sobre los dispositivos.

Se caracterizan por:
- se inicializan durante el arranque cuando el kernel configura el sistema
- son seudosistemas de ficheros que están implementados en memoria y no se guardan en disco
- los comandos que muestran información del computador y de los procesos (ps, top, etc.) obtienen la información de estos directorios. 

Algunos ficheros y directorios de /proc son:
![[Pasted image 20251013162733.png]]

Además, en el directorio /proc existe un directorio por cada proceso, que se identifica con el PID del proceso, /proc/PID/, en el que se puede encontrar información sobre cada proceso, incluidos:
![[Pasted image 20251013162755.png]]

La información detallada de cada dispositivo se ofrece en el directorio /sys. Por ejemplo, la información sobre la carga de un portátil puede encontrarse en /sys/class/power_supply/BAT1/uevent

# 3.2 Gestión del sistema de ficheros
UNIX tiene múltiples comandos para trabajar con ficheros y directorios: `ls, rm, cp, mv, mkdir, rmdir, touch, etc.`

## 3.2.1 Tipos de ficheros y operaciones
- **Ficheros regulares:** son los usuales; se crean con distintos programas (`vi, cp, touch, etc.`) y se borran con `rm` 

- **Directorios:** contiene referencias a otros ficheros y directorios, se crean con `mkdir` y se borran con `rmdir` o `rm -r` 

- **Ficheros de dispositivos de caracteres o bloques:** permiten la comunicación con el hardware y los periféricos; se crean con `mknod` y se borran con `rm` 
	- caracteres: entrada/salida byte a byte
	- bloques: entrada salida en bloques de datos

- **Tuberías con nombre (named pipes)** también llamados ficheros FIFO, permite la comunicación entre procesos; se crean con `mknod` y se borran con `rm`

- **Sockets:** comunican procesos en la red; se crean con `socket()` y se borran con `rm` o `unlink()` 

- **Enlaces simbólicos** también llamados enlaces **blandos:** apuntador a otro fichero; se crean con `ln -s` y se borran con `rm`.

El comando `file` nos permite determinar el tipo de un fichero, para ficheros normales distingue según contenido (fichero de imagen, pdf, ASCII, etc):
![[Pasted image 20251031105522.png]]

### Creación de enlaces
Los enlaces permiten referirse a un fichero con otro nombre. Dos tipos:
- **Enlaces duros:** asignan otro nombre al fichero
	- crean una entrada en el directorio apuntando al mismo nodo-i que el fichero original
	- el fichero no se borra hasta que se borran todos sus enlaces duros
	- no se pueden enlazar con ficheros de otra partición
- **Enlaces blandos:** un fichero que apunta al original
	- si el fichero se borra, el enlace permanece sin apuntar a nada
	- no tienen problema con las particiones

![[Pasted image 20251031110000.png]]

### Comando `ln`
Permite crear enlaces
- Formato
`ln [-s] [opciones] destino [enlace]`

- por defecto crea enlaces dos; con -s se crean enlaces blandos
- si no se pone nombre del enlace se usa el del `destino` 

![[Pasted image 20251031110501.png]]

### Atributos de un fichero
![[Pasted image 20251031110532.png]]

Podemos ver los atributos de un fichero con `ls -l`
![[Pasted image 20251031110608.png]]

**Indicador de tipo** el primer carácter nos indica el tipo de fichero
![[Pasted image 20251031170219.png]]

**Número de enlaces:** indica el número de nombre (enlaces duros) del fichero. En caso de un directorio, esto corresponde con el número de subdirectorios

**Tamaño:** es el tamaño en bytes. Con `ls -lh` se ve el tamaño de forma más legible. El tamaño máximo de un fichero depende del filesystem usado.

**Fecha** especifica la fecha de última modificación del fichero, podemos actualizarla con el comando `touch`. Además linux guarda para cada fichero 3 tipos de fecha:
- `mtime`, fecha de la última modificación, opción por defecto.
- `atime`, fecha del último acceso, se muestra con `ls -l --time=atime` 
- `ctime`, fecha del último cambio de estado, se muestra con `ls -l --time=ctime` 

**Nombre:** la longitud máxima del nombre es de 255 caracteres. 

### Permisos de ficheros y directorios
UNIX proporciona tres operaciones básicas para realizar sobre un fichero o directorio: lectura (`l`), escritura (`w`) y ejecución (`x`)

Efecto sobre un fichero:
- **Lectura:** permite abrir y leer el fichero
- **Escritura:** permite modificar o truncar el fichero
- **Ejecución:** permite ejecutar el archivo (binario o script)

Efecto sobre directorios:
- **Ejecución:** permite entrar al directorio (pero no listar contenido ni crear ficheros ni directorios)
- **Lectura y ejecución:** permite listar el contenido del directorio (pero no crear ficheros ni directorios) 
- **Escritura y ejecución:** permite crear, borrar o renombrar ficheros (pero no listar su contenido)
- **Acceso total**

Los permisos tienen tres categorías:
- Permisos de usuario (`u`): propietario del fichero (por defecto, usuario que lo creó)
- Permisos de grupo (`g`): grupo del fichero (por defecto, grupo principal del usuario que lo creó)
- Permisos de otros (`o`): resto de usuarios

![[Pasted image 20251031172301.png]]

### Cambios de permisos
`chmod [R] operación ficheros` 
- `-R` indica acceso recursivo
- solo el propietario del fichero (o root) puede cambiar los permisos

`operación` indica como cambiar los permisos, y puede especificarse por símbolos o números:
- Permisos simbólicos: formato `quien op permisos`
	- `quien` especificado por `u, g, o` o `a` para todos
	- `op` puede ser `+` para añadir permisos, `-` para quitar o `=` para establecer
	- `permisos` especificados por `r,w,x` 

![[Pasted image 20251031173133.png]]

- Permisos numéricos:
	- `operación` se representa por un número **octal** de tres dígitos, para `u,g y o` respectivamente. 4 para `r`, 2 para `w` y 1 para `x`, para combinaciones se suman (`rw`=7)
![[Pasted image 20251031173350.png]]

### Permisos especiales
Ademas de `rwx` existen los permisos `setuid/setgid(s)` (relacionados con los atributos de los procesos) y `sticky bit (t)`.

Cuando un proceso se crea se le asigna un UID/GID real y un UID/GID efectivo:
- **UID/GID real** (RUID/RGUI) identificadores de usuario y grupo del usuario que lanzó el proceso (y que puede matarlo)
- **UID/GID efectivos** (EUID/EGUI) determinan las operaciones que el proceso puede hacer sobre los objetos del sistema. Un proceso con UID efectivo 0 (root) puede ma- nipular todos los ficheros del sistema

Podemos usar ps para ver los RUID/RGID y EUID/EGID
![[Pasted image 20251031173736.png]]

Los permisos `setuid/setgid`D permiten que un proceso lanzado por un usua- rio se ejecute con EUID/EGID de otro usuario.
![[Pasted image 20251031174042.png]]

**sticky bit** solo se usa en directorios, permite crear ficheros en el directorio (si tiene permiso de escritura), pero solo los puede borrar:
- el propietario del fichero 
- el propietario del directorio 
- el superusuario

![[Pasted image 20251031174206.png]]

### Cambio de usuario/grupoç
Los comandos `chown` y `chgrp` permiten cambiar el propietario y grupo de un fichero. Sólo root puede cambiar el propietario y el grupo puede cambiarse a otro al que pertenezcamos

![[Pasted image 20251031174434.png]]

## 3.2.2 Localización de ficheros
### Comando `find`
Busca a través de la jerarquía de directorios ficheros que cumplan determinado criterio.

`find [directorio de búsqueda] [expresión]` 

![[Pasted image 20251031175551.png]]

La `expresión` tiene los siguientes componentes: 
- operaciones: modifican la forma de operación de `find`
- criterio de búsqueda
- acciones: especifica que hacer con los ficheros que encuentra
- operadores: permiten agrupar expresiones

### Criterios de búsqueda
**Búsqueda por nombre/path/tipo/usuario/grupo:** 

![[Pasted image 20251031175727.png]]

![[Pasted image 20251031175838.png]]

- **Búsqueda por tamaño/permiso**
![[Pasted image 20251031175918.png]]

![[Pasted image 20251031175958.png]]

### Operadores de `find`
![[Pasted image 20251031180041.png]]

### Acciones de `find` 
![[Pasted image 20251031180102.png]]


![[Pasted image 20251031180124.png]]

### Otros comandos para localizar ficheros
`which` muestra la localización de comandos buscando en `$PATH`
- `which [opciones] comando` 
- ![[Pasted image 20251031180310.png]]

`whereis` muestra la localización del binario, fuente y página del manual de un comando buscando en las localizaciones estándar
- `whereis [opciones] comando`
- ![[Pasted image 20251031180444.png]]

`locate` localiza todo tipo de ficheros rápidamente. Utiliza una bd donde guarda la localización de los ficheros. Esa base de datos la crea y actualiza el administrador con el comando `updatedb`.


# 3.3 Gestión de discos y particiones
## 3.3.1 Particiones y sistemas de ficheros
Vimos en el primer capítulo como crear particiones y sistemas de ficheros en el momento de la instalación. Si añadimos un nuevo disco al sistema ya instalado deberemos crear las particiones y los sistemas de ficheros. Esta operación implica los siguientes pasos:

- Creación de particiones (comando `fdisk`)
- Creación de los sistemas de ficheros (comando `mkfs`)
- Montado de los sistemas de ficheros (comando `mount` o `/etc/fstab`)

![[Pasted image 20251031181804.png]]

### Creación de particiones
- `fdisk [opciones] dispositivo`
- `dispositivo` es el dispositivo del disco `/dev/sdx/` para SATA o `/dev/nvmex` para NVME
- Debemos tener permiso de administrador para usarlo
- `-l` muestra la tabla de particiones del dispositivo