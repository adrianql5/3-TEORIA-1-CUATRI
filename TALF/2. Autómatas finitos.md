# 2.1 Clasificación
- **Autómatas Finitos Deterministas (AFD):** el autómata no puede estar en más de un estado simultáneamente. 
- **Autómatas Finitos No Deterministas (AFN):** puede estar en varios estados al mismo tiempo

# 2.2 Autómatas Finitos Deterministas
### Definición
Un **Autómata Finito Determinista (AFD)** es un modelo matemático que reconoce **lenguajes regulares**.

La palabra **determinista** implica que desde un estado dado y un símbolo de entrada, **solo hay una transición posible**. Nunca hay dudas ni caminos paralelos como en los AFN.

Por ejemplo una cerradura con clave de 3 dígitos.
- En cada paso, si presionamos un dígito, sabemos exactamente cómo cambia el “estado” de la cerradura.
- No hay confusión: para cada número presionado hay una única reacción.

### Definición Formal
$$A=(Q,\Sigma,\delta,q_0,F)$$
- Un conjunto de **estados** $Q$
- Un conjunto finito de **símbolos de entrada** $\Sigma$
- Una **función de transición** $\delta$: Q × Σ → Q (devuelve **un solo estado**).
- Un **estado inicial** (uno de los estados de $Q$), $q_0$
- Un conjunto de **estados finales** o de aceptación (subconjunto de $Q$) $F$

### Ejemplo
Acepta todas las cadenas de 0 y 1 que contienen la secuencia 01 en algún lugar
 $$A=(\set{q_0,q_1,q_2}, \set{0,1}, \delta, q_0,\set{q_1})$$
![[Pasted image 20250921131548.png]]

- **q₀**: estado inicial, aún no hemos visto nada interesante.
- Si leemos un `0`, pasamos a **q₁** (porque podría empezar la secuencia `01`).
- Si leemos un `1` en q₀, nos quedamos en q₀ (aún no hemos visto un `0`).
- En **q₁**, si ahora leemos un `1`, llegamos a **q₂**  ya vimos `01`
- Una vez en **q₂**, podemos seguir leyendo cualquier cosa, pero ya hemos aceptado.

 Si la cadena termina en un estado final (q₂), el AFD **acepta**.

### Representación
- **Grafo:**
	- Un nodo para estado de $Q$
	- Un arco de $q$ a $p$ etiquetado con $a$  para cada $\delta(q,a)=p$
	- Una flecha dirigida al estado inicial
	- Los estados finales están marcados por un doble círculo

![[Pasted image 20250918192641.png]]

- **Tabla de Transiciones:**
	- Filas: estados
	- Columnas: entradas
	- Estado inicial: indicado por una flecha
	- Estados finales: indicados por *

![[Pasted image 20250918192659.png]]

# 2.3 Autómatas Finitos No Deterministas (AFN)
### Definición
Un **Autómata Finito No Determinista (AFN)** es un modelo matemático que sirve para reconocer lenguajes regulares, igual que los **AFD (Autómatas Finitos Deterministas)**.

La diferencia está en la **función de transición** $\delta$:
- En un **AFD**, desde cada estado y para cada símbolo del alfabeto, existe **exactamente un estado destino**.
- En un **AFN**, desde un estado y un símbolo, pueden pasar varias cosas:
    1. Ir a **varios estados posibles**.
    2. No ir a ningún estado.
    3. Incluso tener **transiciones vacías (ε)** → moverse sin consumir ningún símbolo.

Por eso se dice que un AFN puede estar en **varios estados al mismo tiempo** (se comporta como si explorara todas las opciones en paralelo).

### Definición formal
$$A=(Q, \Sigma, \delta, q_0, F)$$
- **Q**: conjunto finito de estados.
- **Σ**: alfabeto de entrada (símbolos).
- **δ**: función de transición → δ: Q × Σ → 2^Q (devuelve un **conjunto de estados**, no solo uno).
- **q₀**: estado inicial.
- **F**: conjunto de estados finales o de aceptación.


### Ejemplo
 Acepta todas las cadenas de 0 y 1 terminan con la secuencia 01
 $$A=(\set{q_0,q_1,q_2}, \set{0,1}, \delta, q_0,\set{q_2})$$
![[Pasted image 20250921131735.png]]

El autómata “vigila” si aparece la secuencia final `01`. Cuando llega al final, si ha visto `01`, cae en el estado final `q₂`.

- Desde **q₀** con un `0` puedes ir tanto a **q₀** (reiniciando) como a **q₁** (porque puede ser el inicio de `01`).    
- Desde **q₁** con un `1` pasas a **q₂** (ya viste `01`).
- Desde **q₂** puedes seguir leyendo, pero para aceptar basta con que hayas caído ahí al final.

Este AFN tiene **varias opciones en paralelo**, por eso es más fácil de diseñar que el AFD equivalente.
### Representación
- **Grafo:**
![[Pasted image 20250921131951.png]]

	AFD equivalente:
	
![[Pasted image 20250921132029.png]]

- **Tabla de Transiciones:**
![[Pasted image 20250921132115.png]]


### AFN con transiciones ε (AFN-ε)
Un **AFN-ε** es un AFN que además permite transiciones vacías:
- **ε-transición**: pasar de un estado a otro **sin leer ningún símbolo**.
- Se usan para simplificar aún más el diseño, pero **no aumentan el poder** del autómata (siguen reconociendo solo lenguajes regulares).

Ejemplo:
- Quiero un autómata que acepte cadenas con `ab` o con `ba`.
- Con un AFN-ε puedo hacer dos ramas paralelas desde el inicio:
    - Una que espere `a` luego `b`.
    - Otra que espere `b` luego `a`.

- Gracias a la transición **ε**, el autómata se “duplica” al empezar, explorando ambas ramas.

### Clausura-ε
Cuando hay ε-transiciones, necesitamos la idea de **clausura-ε de un estado**:
- **CLAUSε(q):** todos los estados alcanzables desde `q` usando solo transiciones vacías (incluido él mismo).

Ejemplo:
- Si desde `q₀` hay una transición ε hacia `q₁`, entonces:
    - CLAUSε(q₀) = {q₀, q₁}.
    - Si además desde `q₁` hay otra ε hacia `q₂`, entonces CLAUSε(q₀) = {q₀, q₁, q₂}.


Esto sirve para “expandir” los caminos posibles antes de consumir un símbolo real.

# 2.4 Equivalencia entre AFD y AFN




Perfecto — lo desgloso paso a paso y con ejemplos claros. Primero trataremos **la conversión AFN → AFD (construcción por subconjuntos)** —incluyendo el caso con ε— y después **la minimización de un AFD**. Iré muy paso a paso para que se vea cada operación y su porqué.

---

# A) Conversión AFN → AFD (construcción por subconjuntos)

## Idea intuïtiva
Un AFN puede “estar en varios estados a la vez” (varios hilos). Un AFD **no** puede. La construcción por subconjuntos simula todos esos hilos a la vez usando **un estado del AFD que representa un conjunto de estados del AFN**.  

Cada estado del AFD = un **conjunto** de estados del AFN. Las transiciones del AFD se calculan tomando, para cada símbolo `a`, la unión de las transiciones en el AFN desde cada estado del conjunto, y aplicando la **clausura ε** si hay ε-transiciones.

---

## Definiciones clave

- **ε-clausura** de un estado `p` (CLAUSε(p)) = conjunto de estados alcanzables desde `p` usando **solo** transiciones ε (incluye `p`).
- Para un conjunto `T` de estados, CLAUSε(T) = unión de CLAUSε(p) para cada `p ∈ T`.
- `move(T, a)` = unión de `δ(p, a)` para todos `p ∈ T` (sin clausura).
- En la construcción, la nueva transición del AFD desde el estado `T` con símbolo `a` es `CLAUSε(move(T,a))`.

---

## Algoritmo paso a paso (resumido)
1. Calcular CLAUSε(p) para **cada** estado `p` del AFN.  
2. El **estado inicial** del AFD es `S0 = CLAUSε({q0_AFN})` (q0_AFN = estado inicial del AFN).  
3. Construir recursivamente: para cada nuevo estado `T` del AFD (un conjunto de estados AFN) y para cada símbolo `a ∈ Σ`:
   - calcular `U = CLAUSε(move(T, a))`.
   - `U` es un (posible nuevo) estado del AFD; añadir la transición `T --a--> U`.
   - repetir hasta que no aparezcan nuevos conjuntos.
4. Estados finales del AFD = todos los conjuntos `T` que **contienen** al menos un estado final del AFN.

---

## Ejemplo completo (con ε) — NFA que reconoce `a` **o** `bc` (expresión `a | bc`)

Construimos un AFN-ε pequeño:

- Estados AFN: `s` (inicio), `p`, `r`, `f` (final).  
- Alfabeto: `{a, b, c}`.  
- Transiciones:
  - `δ(s, ε) = {p, r}`  (desde inicio se bifurca por ε)
  - `δ(p, a) = {f}`
  - `δ(r, b) = {x}` (necesitamos un estado intermedio; llamémosle `x`)
  - `δ(x, c) = {f}`
  - `f` es final. (No más ε salvo las del inicio)

Para simplificar, renombremos estados y dejemos la lista completa:

Q = { s, p, r, x, f }  
δ:
- s —ε→ p
- s —ε→ r
- p —a→ f
- r —b→ x
- x —c→ f

No hay otras transiciones.

### 1) Calculamos las clausuras ε
- CLAUSε(s) = { s, p, r }  (s →ε p y r)
- CLAUSε(p) = { p }
- CLAUSε(r) = { r }
- CLAUSε(x) = { x }
- CLAUSε(f) = { f }

### 2) Estado inicial del DFA
S0 = CLAUSε({s}) = {s, p, r}. Lo llamamos **A**.

### 3) Construcción de transiciones (para cada símbolo a, b, c)

Partimos de A = {s,p,r}:

- Para `a`:
  - move({s,p,r}, a) = δ(s,a) ∪ δ(p,a) ∪ δ(r,a) = ∅ ∪ {f} ∪ ∅ = {f}
  - CLAUSε({f}) = {f} → nuevo estado B = {f}

- Para `b`:
  - move({s,p,r}, b) = δ(s,b) ∪ δ(p,b) ∪ δ(r,b) = ∅ ∪ ∅ ∪ {x} = {x}
  - CLAUSε({x}) = {x} → nuevo estado C = {x}

- Para `c`:
  - move(..., c) = ∅ → CLAUSε(∅) = ∅ → llamaremos al estado ∅ = D (estado muerto)

Ahora miramos los nuevos estados B, C, D:

**B = {f}:**
- `a`: move({f},a)=∅ → CLAUSε(∅)=∅ → D
- `b`: → D
- `c`: → D

**C = {x}:**
- `a`: move({x},a)=∅ → D
- `b`: move({x},b)=∅ → D
- `c`: move({x},c)={f} → CLAUSε({f})={f}=B

**D = ∅:**
- para cualquier símbolo, move(∅, a)=∅ → D (auto-loop en estado muerto)

### 4) Estados finales
Los estados del DFA que contienen `f` son finales. Solo B = {f} es final (y cualquier conjunto que contenga f sería final).

### 5) Resultado — tabla del DFA

Nombres: A={s,p,r} (inicial), B={f} (final), C={x}, D=∅ (muerto)

| Estado (DFA) | a    | b    | c    | final? |
|--------------|------|------|------|--------|
| → A = {s,p,r}| B    | C    | D    | No     |
| B = {f}      | D    | D    | D    | Sí     |
| C = {x}      | D    | D    | B    | No     |
| D = ∅        | D    | D    | D    | No     |

Dibujo (esquema):
```
A --a--> B*(final)
A --b--> C --c--> B
A --c--> D (dead)
B --a,b,c--> D
C --a,b--> D
D --a,b,c--> D
```

Observa:
- Cada estado del DFA corresponde a un conjunto de estados del AFN.
- El DFA es determinista (una transición única por símbolo).
- Si el AFN fuera más grande, aparecerían más conjuntos hasta que ya no salgan nuevos.

---

## Ejemplo breve sin ε (AFN simple: termina con `01`)
Volvemos al AFN del mensaje anterior (sin ε) que acepta cadenas que **terminan en 01**:

AFN:
- Q = { q0, q1, q2 }, Σ={0,1}
- δ(q0,0) = { q0, q1 }  (no determinista: con 0 o bien stays q0 o entra en q1)
- δ(q0,1) = { q0 }
- δ(q1,1) = { q2 }
- q2 es final (q2 acepta si leímos `01` y acabamos)

Construcción por subconjuntos (sin ε, CLAUSε es trivial cada estado a sí mismo):
- Estado inicial A = {q0}
- Desde {q0} con 0 → {q0, q1}
- Desde {q0} con 1 → {q0}
- Desde {q0,q1} con 0 → δ(q0,0) ∪ δ(q1,0) = {q0,q1} ∪ ∅ = {q0,q1}
- Desde {q0,q1} con 1 → δ(q0,1) ∪ δ(q1,1) = {q0} ∪ {q2} = {q0,q2}
- Desde {q0,q2}... etc.
- Continúas hasta cerrar el conjunto de estados nuevos; los que contienen q2 son estados finales.

(Es la misma idea: cada conjunto del DFA representa varios hilos del AFN.)

---

# B) Minimización de un AFD

## Objetivo
Reducir el número de estados del AFD **sin cambiar** el lenguaje que acepta. Al final cada clase de equivalencia de estados (states indistinguibles) se convierte en un solo estado.

Hay dos algoritmos comunes: **refinamiento por particiones** (más conceptual y eficiente — p. ej. Hopcroft) y **algoritmo de llenado de tabla** (pairwise). Te explico el de particiones (fácil de entender) y lo ejemplifico.

---

## Algoritmo por particiones (versión conceptual / simple)
1. Partición inicial `P = {F, Q\F}` (separar finales y no finales).
2. Repetir: para cada bloque `B ∈ P` y para cada símbolo `a ∈ Σ`, comprobar a qué bloque de `P` va cada estado de `B` con `a`.  
   - Si dentro del mismo bloque `B` hay estados que, tomando `a`, llevan a **bloques diferentes**, entonces `B` se divide en subbloques según la imagen por `a` (y por todos los símbolos simultáneamente: estados se agrupan por el vector de bloques destino para cada símbolo).
3. Repetir hasta que en una pasada no se realicen divisiones (estabilización).
4. Cada bloque final es un estado del autómata minimizado; las transiciones se definen de forma natural por la representante de bloque.

### Observaciones prácticas
- Si el AFD no está completo (faltan transiciones), añadir un **estado muerto** y completar las transiciones antes de minimizar.
- Complexidad: Hopcroft lo hace en O(n log n), pero la idea conceptual es la descrita.

---

## Ejemplo de minimización (ejemplo sencillo con estados equivalentes)

DFA con estados S0 (inicial), S1, S2 (final), S3 (final); Σ = {0,1}

Transiciones:

| Estado | 0    | 1    | final? |
|--------|------|------|--------|
| S0     | S1   | S2   | No     |
| S1     | S1   | S3   | No     |
| S2     | S1   | S2   | Sí     |
| S3     | S1   | S2   | Sí     |

Nota: S2 y S3 tienen **exactamente** las mismas transiciones y ambos son finales → muy probablemente sean equivalentes. Veamos el algoritmo:

### Paso 1: Partición inicial
P = { {S2, S3} (finales), {S0, S1} (no finales) }

### Paso 2: Intentamos refinar

- Consideramos bloque `{S2, S3}`: para cada símbolo su imagen es:
  - S2 con 0 → S1 (que está en bloque {S0,S1})  
    S3 con 0 → S1 (mismo bloque)  
  - S2 con 1 → S2 (bloque {S2,S3})  
    S3 con 1 → S2 (bloque {S2,S3})  
  → Ambos tienen mismo “vector de bloques destino” → **no se separan**.

- Bloque `{S0, S1}`:
  - S0 con 0 → S1 (bloque {S0,S1})
    S1 con 0 → S1 (bloque {S0,S1})
  - S0 con 1 → S2 (bloque {S2,S3})
    S1 with 1 → S3 (bloque {S2,S3})
  → Para cada símbolo, las imágenes de S0 y S1 van al **mismo bloque** (aunque sean estados distintos) → **no se separan**.

No hay más divisiones: el conjunto de particiones se estabiliza.

### Resultado
- Dos bloques finales: `B1 = {S0,S1}` y `B2 = {S2,S3}`.
- Construimos el DFA minimizado con 2 estados: `N` (no-final: B1) y `F` (final: B2):

Transiciones del minimizado (usando representante cualquiera de cada bloque):
- `N --0--> N` (porque S0 0→S1 ambos en B1)
- `N --1--> F` (S0 1→S2 ∈ B2)
- `F --0--> N` (S2 0→S1 ∈ B1)
- `F --1--> F` (S2 1→S2 ∈ B2)

¡Hemos reducido 4 estados a 2 sin cambiar el lenguaje!

---

## Alternativa: algoritmo de la tabla (pairwise)
Breve idea:
1. Hacer una tabla triangular con todas las parejas `({p,q})`.
2. Marcar inmediatamente las parejas donde uno es final y el otro no (son distinguibles).
3. Iterativamente marcar pareja (p,q) si existe un símbolo `a` tal que la pareja (δ(p,a), δ(q,a)) ya está marcada.
4. Al final, las parejas **no marcadas** son equivalentes → se pueden fusionar.

Es útil para entender por pares, mientras que el método por particiones agrupa en bloques.

---

# Consejos y errores comunes

- **Siempre** calcula la clausura-ε *antes* de empezar la construcción: es la base del estado inicial.
- En la construcción por subconjuntos, **nombrar** cada nuevo conjunto con una etiqueta (A, B, C...) ayuda mucho.
- Si trabajas en minimización y el autómata **no está completo**, añádele el estado muerto antes de comenzar.
- Comprueba que en la minimización no estés fusionando un estado final con uno no final: eso cambiaría el lenguaje.
- Cuando implementes en código (o en un examen) deja claro:
  - Cómo representas conjuntos (bitsets son muy prácticos).
  - La cola/cola de trabajo para procesar nuevos conjuntos en la construcción por subconjuntos.

---

¿Quieres que haga **un ejercicio paso a paso** partiendo de un AFN concreto **tuyo** (o del PDF) y te muestre **la construcción completa** y la **minimización final** dibujada? Puedo convertir cualquier AFN que me pegues en texto y mostrarte la tabla y el DFA resultante.