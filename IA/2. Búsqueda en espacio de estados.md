# 2.1 Introducción
La búsqueda en espacios de estados es una técnica fundamental en Inteligencia Artificial para resolver problemas. Consiste en explorar todas las posibles configuraciones (estados) que puede tener un sistema, aplicando reglas (operadores) que transforman un estado en otro, hasta encontrar uno que cumpla el objetivo (meta).

Ejemplo: En el ajedrez, los estados son las posiciones de las piezas en el tablero y las jugadas posibles son los operadores.

---

### 2. Tipos de métodos de búsqueda

| Método        | Descripción | Tipo de solución |
|---------------|-------------|------------------|
| **Preciso**   | Específico para el problema, encuentra la solución óptima. | Exacta |
| **Heurístico**| Usa conocimientos del problema para aproximar la solución o aumentar eficiencia. | Aproximada |
| **Metaheurístico** | Generaliza heurísticos para mejorar eficiencia, evitando quedarse en mínimos locales e intensificando la búsqueda en zonas prometedoras. | Aproximada |

---

### 3. Conceptos clave

- **Estado**: Representación de una configuración posible del sistema.
- **Operador**: Acción que transforma un estado en otro.
- **Secuencia de estados**: Camino desde el estado inicial hasta el estado meta.
- **Prueba de meta**: Permite saber si un estado cumple el objetivo.
- **Condición de parada**: Criterio para detener la búsqueda.

---

### 4. Ejemplos de problemas

#### a) 8-puzzle (8-quebracabezas)
- **Estados**: Distribución de las piezas.
- **Operadores**: Movimiento del espacio vacío (^, v, >, <).
- **Meta**: Alcanzar la configuración final.
- **Criterio de coste**: Número de movimientos.

#### b) Criptoaritmética
- **Estados**: Sustitución de letras por dígitos.
- **Operadores**: Cambiar una letra por un dígito sin repetición.
- **Meta**: Todas las letras convertidas y suma correcta.
- **Criterio de coste**: Generalmente cero.

#### c) Problema de bloques
- Estados y operadores según la posición y movimiento de los bloques.

---

### 5. Espacio de estados y grafos de búsqueda

- El espacio de estados es el conjunto de todos los estados que se pueden alcanzar desde el inicial, usando cualquier secuencia de operadores.
- El proceso de búsqueda consiste en encontrar una meta, y a veces la ruta seguida.
- En muchos problemas el espacio de estados puede representarse como un grafo (con nodos y aristas).

---

### 6. Imposibilidad de explorar todo

- En problemas complejos, no es posible explorar todas las alternativas.
- Si hay múltiples soluciones, suele bastar con encontrar una "suficiente".
- Las **heurísticas** ayudan a elegir el camino más prometedor.

---

### 7. Estrategias de búsqueda

#### A. Búsqueda a ciegas (sin información extra)

1. **Búsqueda en amplitud (Breadth-first search)**  
   Explora primero los nodos más cercanos al inicial (por niveles).
   - Completa y óptima (encuentra todas las soluciones y la mejor).
   - Alta complejidad espacial y temporal.

2. **Búsqueda en profundidad (Depth-first search)**  
   Explora lo más profundo posible antes de retroceder.
   - No siempre es completa ni óptima.
   - Menor uso de memoria.

3. **Búsqueda en profundidad limitada e iterativa**  
   Limita la profundidad máxima y repite aumentando el límite.

4. **Búsqueda bidireccional**  
   Busca desde el estado inicial y desde el estado meta simultáneamente.

| Estrategia        | Completa | Óptima | Tiempo | Espacio |
|-------------------|----------|--------|--------|---------|
| Amplitud          | Sí       | Sí     | O(r^p) | O(r^p)  |
| Profundidad       | No*      | No     | O(r^m) | O(r*m)  |
| Prof. limitada    | No*      | No     | O(r*l) | O(r*l)  |
| Iterativa         | Sí       | Sí     | O(r^p) | O(r^p)  |
| Bidireccional     | Sí       | Sí     | O(r^p/2)|O(r^p/2)|

\* Solo en espacios finitos y sin bucles.

- **r**: factor de ramificación (media de sucesores por nodo)
- **p**: profundidad de la solución
- **m**: profundidad máxima
- **l**: límite de profundidad

---

### 8. Búsqueda heurística (con información útil)

Se utiliza una **función de evaluación** para estimar qué tan cerca está un estado de la meta:

- **f(n) = g(n) + h(n)**
  - g(n): coste desde el inicio hasta n.
  - h(n): estimación heurística de la distancia de n a la meta.

Ejemplos:
- **Criterio de piezas mal colocadas** (en el 8-puzzle): h(n) = número de piezas fuera de lugar.
- **Algoritmo primero el mejor**: solo usa h(n).
- **Algoritmo A\***: usa g(n) + h(n).

#### Algoritmo A*
1. Inicializar origen s: f(s)=0, f(i)=∞ para el resto.
2. Calcular f(s) y ponerlo en el conjunto Q.
3. Seleccionar el nodo con menor f(n) en Q y expandir.
4. Para cada vecino, calcular nuevo f. Si mejora, actualizar y añadir a Q.
5. Repetir hasta llegar a la meta o vaciar Q.

- Si h(n) es **admisible** (nunca sobreestima), A* es óptimo.

---

### 9. Cómo inventar heurísticas

- **Relajación del problema**: simplificar restricciones para facilitar la estimación.
  - Ejemplo en 8-puzzle:
    - Relajar movimientos permitiendo que las piezas se muevan libremente, así se pueden calcular distancias mínimas.

---

### 10. Estrategias retroactivas (Backtracking)

- Solo se guarda un hijo por estado, manteniendo el camino actual.
- Se retrocede si no hay más operadores que aplicar.
- Útil para problemas como puzzles y criptoaritmética.

---

### 11. Resumen visual

- Espacio de estados = grafo de posibles configuraciones.
- La búsqueda consiste en recorrer el grafo aplicando operadores y usando criterios (a ciegas o heurísticos) hasta hallar la solución.

---

### 12. Referencias

- Senén Barro Ameneiro, CiTIUS.  
- http://elvex.ugr.es/courses.html

---

¿Necesitas ejemplos de código para alguna estrategia de búsqueda o quieres que te explique algún algoritmo concreto?  