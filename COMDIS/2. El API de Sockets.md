# 2.1 Introducción
**API de sockets:** interfaz de programación para la comunicación entre procesos (IPC) y ha sido traducido a todos los SO modernos. Es el estándar de facto para la programación IPC y es la base de interfaces IPC más sofisticados tales como Remote Procedure Call (RPC) y Remote Method Invocation (RMI).

# 2.2 Protocolo TPC/IP
El **protocolos TCP/IP** es un protocolos independiente del fabricante, que sirve para permitir que un equipo pueda comunicarse en una red. Está disponible para cualquier ordenador o supercomputador, se utiliza tanto en LANs como WANs y es el más extendido en Internet. Tiene cuatro capas y cada una se construye sobre su predecesora:
- **Capa física:** topología de la red y conexiones globales a la red
- **Capa de datos:** se ocupa del direccionamiento físico, del acceso al medio, de la detección de errores, de la distribución ordenadas de tramas y  del control de flujo. Utiliza interfaces de comunicación.
- **Capa de red:** se encarga de identificar el enrutamiento existente entre una o más redes. El objetivo de la capa de red es hacer que los datos lleguen desde el origen al destino (enrutamiento). Aparecen las dirección **IP** y cada ordenador en la red dispone de una dirección única de 32 bits.
- **Capa de transporte:** se encarga de efectuar el transporte de los datos, independizándolos del tipo de red física que esté utilizando. LOs datos a través de la red siempre se transmiten en formato Big Endian.

**Clases de redes IP:**
![[Pasted image 20250923114326.png]]

**UDP:** protocolo no orientado a conexión sino al paso de mensajes. No garantiza la correcta recepción de los datos ni el orden de los mismos. Es simple y rápido. UDP utiliza puertos para permitir la comunicación entre aplicaciones. Existen fronteras entre mensajes. Es ideal para apps que requieren alta tasa de transferencia y donde las pérdidas no son importantes. No garantiza un ancho de banda y puede haber retardos.

**TCP:** protocolo orientado a conexión que garantiza la correcta recepción de la información y el orden de los paquetes. Se usa para transmisión fiable de información.

A la hora de **encapsular un frame** para convertirlo en un Ethernet frame:
- **Puerto:** entero de 16 bits que se utiliza para identificar sin ambigüedad procesos que intervienen en un diálogo
- **Asociación:** una comunicación en Internet que consta de un protocolo, una dirección IP de la máquina local y otra de la remota de 32 bits y un puerto local y otro remoto de 16 bits
- **Fragmentación:** dividir un mensaje en paquetes porque la mayoría de capas de red tienen un tamaño máximo de paquete que pueden manejar. Los paquetes de un mensaje pueden recibirse en desorden, pero los paquetes tienen un número de orden para reconstruirlos después y detectar fallos de transmisión en el ensamblado.
- **Ensamblado:** reconstruir de nuevo el mensaje ordenando sus paquetes por el número y detección de fallos de transmisión (y solicitarlos de nuevo en caso de que sea necesario).
- **Out of Band (OOB):** mecanismo utilizado para no necesitar una memoria intermedia en la transmisión/recepción de información a través de una interfaz de comunicación. Los datos del canal OOB se envían antes que el resto.
- **IPC de UNIX BSD 4.x:** a partir de BSD 4.2 se implementa una IPC  a través de llamadas al sistema. Antes de comunicarse, cada proceso debe crear un **socket**, especificando **protocolo** y **dominio** y se devolverá un **descriptor** del socket susceptible de ser utilizado en llamadas posteriores. Debe tener un id que los demás procesos utilicen como dirección destino. El socket es el encargado del envío y recepción de mensajes que se ponen en una cola hasta que transmiten/extraen.

![[Pasted image 20250923114817.png]]
![[Pasted image 20250923114835.png]]


# 2.3 Comunicación
- **Comunicación por datagramas:**
	- Primitiva de envío de mensajes: `sendto`  (especificando mensaje, descriptor de socket propio y destino)
	- Primitiva de recepción de mensajes: `recvfrom` (epecificando socket propio, buffer de almacenamiento y remitente)

- **Comunicación cliente-servidor:** 
	- El cliente y servidor crean un socket (`socket()`), asociándole una dirección (`bind()`). El servidor la publica de algún modo y el cliente la obtiene. El cliente envía un `sento()` y el servidor lo recoge con un `recvfrom()`. Para responder sus papeles se invierten

- **Comunicación encauzada (stream):**
	- Crear e identificar el par del **sockets**
	- En este caso el servidor escucha con `listen()`
	- El cliente solicita la conexión: `connect()`, y el servidor aceptará la conexión `accept()`
	- Cuando hay una conexión (*connect-acept*), el SO  crea un nuevo socket y los conecta al del cliente de modo que el servidor sigue escuchando en el socket original.
	- Una vez conectados, la comunicación se hace a través de `read()`, `write()`, `send()`, y `recv()` 
	- Finalmente, se cierra la conexión `close()`


# 2.4 Servidor TCP vs Cliente TCP
![[Pasted image 20250923122434.png]]


# 2.5 Sockets Datagramas en Java
En Java tenemos dos clases proporcionadas por el API de sockets para datagramas:
- La clase `DatagramSocket` para especificar el **socket**
- La clase `DatagramPacket` para representar al **datagrama** intercambiado

Un proceso que desee enviar o recibir datos usando esta API debe crear una instancia de `DatagramSocket`. Cada socket está ligado a un puerto UDP de la máquina local donde reside el proceso.

Para enviar un datagrama a otro proceso, un proceso hay que crear un objeto que represente el datagrama (`DatagramPacket`) que contenga los datos y la dirección de destino . Se emite una llamada a `send()` del `DatagramSocket` cuyo argumento es el `DatagramPacket`. En el proceso receptor se debe instanciar un objeto de tipo `DatagramSocket` y  ligarlos a un puerto local. Para recibir datagramas enviados al socket, el proceso crea un objeto de tipo `DatagramPacket` que referencia a un *array de bytes* y llamar al método `receive` del objeto `DatagramSocket`, especificando como argumento una referencia al objeto `DatagramPacket`.

**Timeout:** se usa para **evitar bloqueos** indefinidos.

**Datos:**
- Tanto bajo TCP como UDP existe un rango de **puertos reservados** [1,1023]. Unicamente los procesos con permisos de root podrán generar un socket en uno de esos puertos.
- El **puerto** siempre se fija en la parte del **servidor**. El cliente genera su puerto de forma automática
- Por defecto, un socket siempre es **bloqueante**, de forma que cuando realizamos una operación de lectura sobre el mismo, se suspende la ejecución del proceso si no hay datos en el buffer.
- Suele ser preferible generar un proceso aparte para leer datos de un socket que ponerlo en modo no bloqueante y gestionar su lectura por interrupciones.

![[Pasted image 20250923130229.png]]

**Sockets no orientados a conexión:** socket con lo que es posible que múltiples procesos simultáneamente envíen datagramas al mismo socket creado por el proceso receptor.

![[Pasted image 20250923130435.png]]
![[Pasted image 20250923130531.png]]

![[Pasted image 20250923130610.png]]

# 2.6 API de Sockets en Modo Stream
**API de sockets:** en modo stream proporciona un modelo para la transmisión de datos basado en el **modo encauzado de E/S** proporcionado por los SO Unix. Da únicamente soporte a comunicación orientada o **conexión**.

![[Pasted image 20250923132032.png]]
![[Pasted image 20250923132107.png]]

Un socket en modo stream se crea para el intercambio de datos entre dos procesos específicos. Los datos se escriben en un extremo del socket y se leen en el otro extremo. Un socket stream no puede utilizarse para comunicarnos con más de un proceso. *Receive* y *accept* son bloqueantes; *send* es no bloqueante.
En Java, el API de sockets en modo stream se proporciona mediante dos clases:
- **ServerSocket:** para aceptar conexiones; llamaremos a un objeto de esta clase un socket de conexión
- **Socket:** para el intercambio de datos; llamaremos a un objeto de esta clase un socket de datos

![[Pasted image 20250923132420.png]]

