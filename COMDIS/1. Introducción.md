# 1.1 Introducción
Un **paradigma** es un patrón, ejemplo o modelo. Útil para clasificar elementos (aplicaciones) de la materia. Una aplicación puede comportarse como dos modelos diferentes.

Una **abstracción** es el proceso de encapsulación, esconder detalles. Se consigue gracias a herramientas o funcionalidades que permitan el desarrollo de software sin que el programador tenga que conocer las complejidades subyacentes.

El **middleware** es una capa de software que aumenta la abstracción, actúa como intermediario entre procesos independientes.

Lo que **distingue** a una aplicación distribuida de una convencional son las siguientes caracterísitcas:
- **Comunicación entre procesos:** necesita la participación de varias entidades (*procesos*). Los procesos necesitan comunicarse entre ellos. Los **mecanismos de comunicación** consiguen esto.
- **Sincronización de eventos:** el envío de mensajes debe ser sincronizado, es decir, si desde un proceso se envían datos tiene que haber otro proceso que esté esperando para recibirlos.


# 1.2 Paradigmas en Computación Distribuida
![[Pasted image 20250916092329.png]]


## 1.2.1 Paradigma del paso de mensajes
Es el más básico e importante. Un proceso envía un mensaje a otro proceso. El mensaje se entrega al receptor que lo procesa. Esta respuesta desencadena una serie de una serie de peticiones que darán lugar a más mensajes.

![[Pasted image 20250916092352.png]]

Las operaciones son **enviar** y **recibir**. También se necesitan **conectar** y **desconectar** para la comunicación orientada a conexión. Se realizan las operaciones como si se tratara de un fichero: las operaciones sirven para encapsular el detalle de la comunicación a nivel del SO (*el programador puede hacer uso de ellas para enviar y recibir mensajes sin preocuparse por los detalles*). 

La interfaz de programación de aplicaciones de sockets se basa en este paradigma. Los procesos intercambian información así: un emisor inserta un mensaje en el socket y el receptor extrae el mensaje del socket para leerlo.

En este modelo **no está establecido el orden** en el envío y recepción de mensajes. Además surge el paradigma **Cliente-Servidor** para resolver que ambos procesos (emisor y receptor) estén escuchando o escribiendo a la vez.

## 1.2.2 Paradigma cliente-servidor
Uno de los más conocidos. Este modelo asigna **roles** diferentes a los dos procesos que colaboran. De esta manera la sincronización de eventos se simplifica.
- **Servidor:** proveedor del servicio, espera de forma pasiva la llegada de peticiones
- **Cliente:** envía las peticiones al servidor y espera por las respuestas

Las operaciones serán aquellas necesarias para, en el servidor, esperar y aceptar peticiones y, en el cliente, emitir peticiones y aceptar respuestas.

Este modelo proporciona una abstracción eficiente para servicios de red por lo que se usan mucho en los servicios de Internet. *Ejemplos:* HTTP, FTP, DNS ...

![[Pasted image 20250916093514.png]]

**Protocolo de comunicación:** descripción detallada de las situaciones que se encuentran los procesos y se establece el orden de la transmisión de mensajes. 

Para que el protocolos sea un estándar público debe tener un *Request for comment* (*archivo*). Este será revisado muy atentamente, si lo aceptan se le asignará un número. Cualquier protocolo de cualquier aplicación tiene su RFC asociado.

**Problemas:**
- **Cuello de botella:** al tener un solo servidor y muchos clientes
- No da soporte para que el proceso **servidor inicie la comunicación**.
Estos problemas se resuelven con el paradigma peer-to-peer.


## 1.2.3 Paradigma peer-to-peer (P2P)
Los procesos participantes interpretan los **mismos papeles** (pueden actuar al mismo tiempo como clientes y servidores en función del rol más eficiente para la red). Los ordenadores que en cliente-servidor eran clientes y servicios (intercambio de información, almacenamiento, etc.) entre ellos de manera directa. Cualquier participante puede enviar una petición a otro y recibir una respuesta.

Para servicios centralizados es mejor el paradigma cliente-servidor. El paradigma P2P es más apropiado para **aplicaciones menos centralizadas** como transferencia de mensajes, transferencia de ficheros o videoconferencia. Un ejemplo muy conocido es **Napster**. A pesar de estos hay muchas aplicaciones que utilizan los dos modelos combinados, es mejor esta solución desde el punto de vista de la privacidad.

![[Pasted image 20250916095357.png]]

## 1.2.4 Paradigma de sistema de mensajes
Este paradigma es una sofisticación de paso de mensajes. Intenta resolver el problema de la sincronización del envío de mensajes. Un servidor (sistema de mensajes)  sirve de **intermediario entre procesos separados e independientes.** Este sistema tiene como funcionalidad que los procesos intercambien mensajes de forma **asíncrona** de una manera desacoplada.

El emisor deposita un mensaje en el sistema de mensajes y este lo redirige a la cola de mensajes del receptor correspondiente (cada receptor tiene asociada una cola de mensajes). Una vez enviado el mensaje el emisor queda libre para realizar cualquier otra tarea. El receptor puede consultar e cualquier momento su cola de mensajes. El problema  es que la cosa es estática por lo que si el receptor se desentiende de los mensajes. El problema es que la cosa es estática por lo que si el receptor se desentiende de los mensajes se colapsaría. Es responsabilidad del receptor leer los mensajes para evitar este caso.

Existen dos subtipos:
- **Modelo punto a punto:** el sistema de mensajes redirige el mensaje desde el emisor hasta la cola del receptor. El middelware proporciona un depósito para los mensajes de manera que permite que el envío y la recepción de mensajes estén desacoplados. Comparándolo con el paso de mensajes este paradigma proporciona una abstracción para operaciones asíncronas. Para conseguir esto con el modelo básico sería necesario utilizar hilos o procesos hijo.
- **Mododelo pública/subscribe:** cada mensaje tiene asociado un evento (información que puede ser requerida o no por los otros procesos). Las aplicaciones interesadas en la información de un evento pueden subscribirse a este. Cuando  ocurre el evento el proceso publica un mensaje anunciándolo y el middleware se encarga de distribuir los mensajes a todos los subscriptores. Las operaciones utilizadas son publicar, que permite al proceso difundir a un grupo de otros procesos y suscribir que permite a un proceso escuchar esta difusión. Este modelo aporta una gran abstracción para comunicaciones multicast.

![[Pasted image 20250920212044.png]]

# 1.2.5 Paradigma de llamadas a procedimientos remotos
Según las aplicaciones crecen en complejidad se va necesitando un nivel mayor de abstracción para la programación distribuida. Sería deseable tener un paradigma que permita que el software distribuido se programase de forma similar al convencional. Esto se consigue gracias al paradigma de llamadas a procedimientos remotos que además consigue un **alto nivel de abstracción** tanto para la comunicación de procesos como para la **sincronización** de eventos.

![[Pasted image 20250920212328.png]]

Imaginemos 2 procesos independientes $A$ y $B$. Si $A$ decide realizar una petición a $B$, invoca un procedimiento de $B$ pasando unos argumentos junto a la llamada. Una llamada a un procedimiento remoto dispara una acción predefinida en un procedimiento de $B$. AL finalizar dicho procedimiento el proceso $B$ devuelve un valor a $A$.

Hay fundamentalmente dos APIs y las dos incorporan herramientas para transformar invocaciones remotas a llamadas a **procedimientos locales**:
![[Pasted image 20250920212841.png]]

Los módulos se generan automáticamente. Se busca que el programador se abstraiga de los módulos y que para él sea como una llamada local.